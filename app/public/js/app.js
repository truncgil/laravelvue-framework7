/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Truncgil.vue?vue&type=script&lang=js&":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Truncgil.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7-vue */ "./node_modules/framework7-vue/framework7-vue.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  components: {
    f7App: framework7_vue__WEBPACK_IMPORTED_MODULE_0__.f7App,
    f7Navbar: f7Navbar
  }
});

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var framework7_lite_bundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framework7/lite-bundle */ "./node_modules/framework7/framework7-lite-bundle.esm.js");
/* harmony import */ var framework7_vue_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7-vue/bundle */ "./node_modules/framework7-vue/framework7-vue-bundle.js");
/* harmony import */ var _components_Truncgil_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Truncgil.vue */ "./resources/js/components/Truncgil.vue");
// Import Vue


// Import Framework7 Bundle


// Import Framework7-Vue with helper to register all components


// Import your main app component


// Init plugin and register all components
framework7_lite_bundle__WEBPACK_IMPORTED_MODULE_2__["default"].use(framework7_vue_bundle__WEBPACK_IMPORTED_MODULE_0__["default"]);

// create Vue app
var app = (0,vue__WEBPACK_IMPORTED_MODULE_3__.createApp)(_components_Truncgil_vue__WEBPACK_IMPORTED_MODULE_1__["default"]);

// register all Framework7 Vue components by passing Vue app instance there
(0,framework7_vue_bundle__WEBPACK_IMPORTED_MODULE_0__.registerComponents)(app);

/***/ }),

/***/ "./node_modules/framework7/node_modules/path-to-regexp/dist.es2015/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/framework7/node_modules/path-to-regexp/dist.es2015/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "compile": () => (/* binding */ compile),
/* harmony export */   "match": () => (/* binding */ match),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "pathToRegexp": () => (/* binding */ pathToRegexp),
/* harmony export */   "regexpToFunction": () => (/* binding */ regexpToFunction),
/* harmony export */   "tokensToFunction": () => (/* binding */ tokensToFunction),
/* harmony export */   "tokensToRegexp": () => (/* binding */ tokensToRegexp)
/* harmony export */ });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at ".concat(i));
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at ".concat(j));
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at ".concat(j));
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at ".concat(i));
            if (!pattern)
                throw new TypeError("Missing pattern at ".concat(i));
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
    };
    var consumeText = function () {
        var result = "";
        var value;
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || "",
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || "",
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"".concat(token.name, "\" to not repeat, but got an array"));
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"".concat(token.name, "\" to not be empty"));
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"".concat(token.name, "\" to match \"").concat(token.pattern, "\", but got \"").concat(segment, "\""));
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"".concat(token.name, "\" to match \"").concat(token.pattern, "\", but got \"").concat(segment, "\""));
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"".concat(token.name, "\" to be ").concat(typeOfMessage));
        }
        return path;
    };
}
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
    var index = 0;
    var execResult = groupsRegex.exec(path.source);
    while (execResult) {
        keys.push({
            // Use parenthesized substring match if available, index otherwise
            name: execResult[1] || index++,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: "",
        });
        execResult = groupsRegex.exec(path.source);
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
    var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
    var delimiterRe = "[".concat(escapeString(delimiter), "]");
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
                    }
                    else {
                        route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
                    }
                }
                else {
                    if (token.modifier === "+" || token.modifier === "*") {
                        route += "((?:".concat(token.pattern, ")").concat(token.modifier, ")");
                    }
                    else {
                        route += "(".concat(token.pattern, ")").concat(token.modifier);
                    }
                }
            }
            else {
                route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
            }
        }
    }
    if (end) {
        if (!strict)
            route += "".concat(delimiterRe, "?");
        route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1
            : endToken === undefined;
        if (!strict) {
            route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
        }
        if (!isEndDelimited) {
            route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
        }
    }
    return new RegExp(route, flags(options));
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./resources/js/components/Truncgil.vue":
/*!**********************************************!*\
  !*** ./resources/js/components/Truncgil.vue ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Truncgil_vue_vue_type_template_id_6d7af909___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Truncgil.vue?vue&type=template&id=6d7af909& */ "./resources/js/components/Truncgil.vue?vue&type=template&id=6d7af909&");
/* harmony import */ var _Truncgil_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Truncgil.vue?vue&type=script&lang=js& */ "./resources/js/components/Truncgil.vue?vue&type=script&lang=js&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _Truncgil_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Truncgil_vue_vue_type_template_id_6d7af909___WEBPACK_IMPORTED_MODULE_0__.render,
  _Truncgil_vue_vue_type_template_id_6d7af909___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/js/components/Truncgil.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/js/components/Truncgil.vue?vue&type=script&lang=js&":
/*!***********************************************************************!*\
  !*** ./resources/js/components/Truncgil.vue?vue&type=script&lang=js& ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Truncgil_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Truncgil.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Truncgil.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Truncgil_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./resources/js/components/Truncgil.vue?vue&type=template&id=6d7af909&":
/*!*****************************************************************************!*\
  !*** ./resources/js/components/Truncgil.vue?vue&type=template&id=6d7af909& ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Truncgil_vue_vue_type_template_id_6d7af909___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Truncgil_vue_vue_type_template_id_6d7af909___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Truncgil_vue_vue_type_template_id_6d7af909___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Truncgil.vue?vue&type=template&id=6d7af909& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Truncgil.vue?vue&type=template&id=6d7af909&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Truncgil.vue?vue&type=template&id=6d7af909&":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Truncgil.vue?vue&type=template&id=6d7af909& ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "f7-app",
    _vm._b(
      {},
      "f7-app",
      { theme: "auto", name: "My App", id: "com.demoapp.test" },
      false
    ),
    [
      _c(
        "f7-view",
        { attrs: { main: "" } },
        [
          _c(
            "f7-page",
            [
              _c("f7-navbar", { attrs: { title: "Awesome App" } }),
              _vm._v(" "),
              _c(
                "f7-toolbar",
                { attrs: { bottom: "" } },
                [
                  _c("f7-link", [_vm._v("Link 1")]),
                  _vm._v(" "),
                  _c("f7-link", [_vm._v("Link 2")]),
                ],
                1
              ),
              _vm._v(" "),
              _c("p", [_vm._v("Page content goes here")]),
              _vm._v(" "),
              _c("f7-link", { attrs: { href: "/about/" } }, [
                _vm._v("About App"),
              ]),
            ],
            1
          ),
        ],
        1
      ),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeComponent)
/* harmony export */ });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": () => (/* binding */ EffectScope),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "default": () => (/* binding */ Vue),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "del": () => (/* binding */ del),
/* harmony export */   "effectScope": () => (/* binding */ effectScope),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* binding */ getCurrentScope),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "isShallow": () => (/* binding */ isShallow),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "mergeDefaults": () => (/* binding */ mergeDefaults),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* binding */ onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref$1),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref),
/* harmony export */   "useAttrs": () => (/* binding */ useAttrs),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "useListeners": () => (/* binding */ useListeners),
/* harmony export */   "useSlots": () => (/* binding */ useSlots),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "watchPostEffect": () => (/* binding */ watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* binding */ watchSyncEffect)
/* harmony export */ });
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var emptyObject = Object.freeze({});
var isArray = Array.isArray;
// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef(v) {
    return v === undefined || v === null;
}
function isDef(v) {
    return v !== undefined && v !== null;
}
function isTrue(v) {
    return v === true;
}
function isFalse(v) {
    return v === false;
}
/**
 * Check if value is primitive.
 */
function isPrimitive(value) {
    return (typeof value === 'string' ||
        typeof value === 'number' ||
        // $flow-disable-line
        typeof value === 'symbol' ||
        typeof value === 'boolean');
}
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * Quick object check - this is primarily used to tell
 * objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;
function toRawType(value) {
    return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
}
function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
}
function isPromise(val) {
    return (isDef(val) &&
        typeof val.then === 'function' &&
        typeof val.catch === 'function');
}
/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
    return val == null
        ? ''
        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
            ? JSON.stringify(val, null, 2)
            : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };
}
/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */
function remove$2(arr, item) {
    var len = arr.length;
    if (len) {
        // fast path for the only / last item
        if (item === arr[len - 1]) {
            arr.length = len - 1;
            return;
        }
        var index = arr.indexOf(item);
        if (index > -1) {
            return arr.splice(index, 1);
        }
    }
}
/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
        var hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
}
/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });
});
/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */
/* istanbul ignore next */
function polyfillBind(fn, ctx) {
    function boundFn(a) {
        var l = arguments.length;
        return l
            ? l > 1
                ? fn.apply(ctx, arguments)
                : fn.call(ctx, a)
            : fn.call(ctx);
    }
    boundFn._length = fn.length;
    return boundFn;
}
function nativeBind(fn, ctx) {
    return fn.bind(ctx);
}
// @ts-expect-error bind cannot be `undefined`
var bind$1 = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
        ret[i] = list[i + start];
    }
    return ret;
}
/**
 * Mix properties into target object.
 */
function extend(to, _from) {
    for (var key in _from) {
        to[key] = _from[key];
    }
    return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
        if (arr[i]) {
            extend(res, arr[i]);
        }
    }
    return res;
}
/* eslint-disable no-unused-vars */
/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop(a, b, c) { }
/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };
/* eslint-enable no-unused-vars */
/**
 * Return the same value.
 */
var identity = function (_) { return _; };
/**
 * Generate a string containing static keys from compiler modules.
 */
function genStaticKeys$1(modules) {
    return modules
        .reduce(function (keys, m) {
        return keys.concat(m.staticKeys || []);
    }, [])
        .join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
    if (a === b)
        return true;
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
        try {
            var isArrayA = Array.isArray(a);
            var isArrayB = Array.isArray(b);
            if (isArrayA && isArrayB) {
                return (a.length === b.length &&
                    a.every(function (e, i) {
                        return looseEqual(e, b[i]);
                    }));
            }
            else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            else if (!isArrayA && !isArrayB) {
                var keysA = Object.keys(a);
                var keysB = Object.keys(b);
                return (keysA.length === keysB.length &&
                    keysA.every(function (key) {
                        return looseEqual(a[key], b[key]);
                    }));
            }
            else {
                /* istanbul ignore next */
                return false;
            }
        }
        catch (e) {
            /* istanbul ignore next */
            return false;
        }
    }
    else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
    }
    else {
        return false;
    }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
        if (looseEqual(arr[i], val))
            return i;
    }
    return -1;
}
/**
 * Ensure a function is called only once.
 */
function once(fn) {
    var called = false;
    return function () {
        if (!called) {
            called = true;
            fn.apply(this, arguments);
        }
    };
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill
function hasChanged(x, y) {
    if (x === y) {
        return x === 0 && 1 / x !== 1 / y;
    }
    else {
        return x === x || y === y;
    }
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch',
    'renderTracked',
    'renderTriggered'
];

var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),
    /**
     * Whether to suppress warnings.
     */
    silent: false,
    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',
    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',
    /**
     * Whether to record perf
     */
    performance: false,
    /**
     * Error handler for watcher errors
     */
    errorHandler: null,
    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,
    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],
    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),
    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,
    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,
    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,
    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,
    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,
    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,
    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,
    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
};

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5f;
}
/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
    });
}
/**
 * Parse simple path.
 */
var bailRE = new RegExp("[^".concat(unicodeRegExp.source, ".$_\\d]"));
function parsePath(path) {
    if (bailRE.test(path)) {
        return;
    }
    var segments = path.split('.');
    return function (obj) {
        for (var i = 0; i < segments.length; i++) {
            if (!obj)
                return;
            obj = obj[segments[i]];
        }
        return obj;
    };
}

// can we use __proto__?
var hasProto = '__proto__' in {};
// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
UA && /chrome\/\d+/.test(UA) && !isEdge;
UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);
// Firefox has a "watch" function on Object.prototype...
// @ts-expect-error firebox support
var nativeWatch = {}.watch;
var supportsPassive = false;
if (inBrowser) {
    try {
        var opts = {};
        Object.defineProperty(opts, 'passive', {
            get: function () {
                /* istanbul ignore next */
                supportsPassive = true;
            }
        }); // https://github.com/facebook/flow/issues/285
        window.addEventListener('test-passive', null, opts);
    }
    catch (e) { }
}
// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
    if (_isServer === undefined) {
        /* istanbul ignore if */
        if (!inBrowser && typeof __webpack_require__.g !== 'undefined') {
            // detect presence of vue-server-renderer and avoid
            // Webpack shimming the process
            _isServer =
                __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';
        }
        else {
            _isServer = false;
        }
    }
    return _isServer;
};
// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */
function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}
var hasSymbol = typeof Symbol !== 'undefined' &&
    isNative(Symbol) &&
    typeof Reflect !== 'undefined' &&
    isNative(Reflect.ownKeys);
var _Set; // $flow-disable-line
/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
}
else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = /** @class */ (function () {
        function Set() {
            this.set = Object.create(null);
        }
        Set.prototype.has = function (key) {
            return this.set[key] === true;
        };
        Set.prototype.add = function (key) {
            this.set[key] = true;
        };
        Set.prototype.clear = function () {
            this.set = Object.create(null);
        };
        return Set;
    }());
}

var currentInstance = null;
/**
 * This is exposed for compatibility with v3 (e.g. some functions in VueUse
 * relies on it). Do not use this internally, just use `currentInstance`.
 *
 * @internal this function needs manual type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function getCurrentInstance() {
    return currentInstance && { proxy: currentInstance };
}
/**
 * @internal
 */
function setCurrentInstance(vm) {
    if (vm === void 0) { vm = null; }
    if (!vm)
        currentInstance && currentInstance._scope.off();
    currentInstance = vm;
    vm && vm._scope.on();
}

/**
 * @internal
 */
var VNode = /** @class */ (function () {
    function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = undefined;
        this.context = context;
        this.fnContext = undefined;
        this.fnOptions = undefined;
        this.fnScopeId = undefined;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = undefined;
        this.parent = undefined;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = undefined;
        this.isAsyncPlaceholder = false;
    }
    Object.defineProperty(VNode.prototype, "child", {
        // DEPRECATED: alias for componentInstance for backwards compat.
        /* istanbul ignore next */
        get: function () {
            return this.componentInstance;
        },
        enumerable: false,
        configurable: true
    });
    return VNode;
}());
var createEmptyVNode = function (text) {
    if (text === void 0) { text = ''; }
    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
};
function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
}
// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data, 
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned;
}

/* not type checking this file because flow doesn't play well with Proxy */
var initProxy;
if (true) {
    var allowedGlobals_1 = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +
        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
        'require' // for Webpack/Browserify
    );
    var warnNonPresent_1 = function (target, key) {
        warn$2("Property or method \"".concat(key, "\" is not defined on the instance but ") +
            'referenced during render. Make sure that this property is reactive, ' +
            'either in the data option, or for class-based components, by ' +
            'initializing the property. ' +
            'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };
    var warnReservedPrefix_1 = function (target, key) {
        warn$2("Property \"".concat(key, "\" must be accessed with \"$data.").concat(key, "\" because ") +
            'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
            'prevent conflicts with Vue internals. ' +
            'See: https://v2.vuejs.org/v2/api/#data', target);
    };
    var hasProxy_1 = typeof Proxy !== 'undefined' && isNative(Proxy);
    if (hasProxy_1) {
        var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
        config.keyCodes = new Proxy(config.keyCodes, {
            set: function (target, key, value) {
                if (isBuiltInModifier_1(key)) {
                    warn$2("Avoid overwriting built-in modifier in config.keyCodes: .".concat(key));
                    return false;
                }
                else {
                    target[key] = value;
                    return true;
                }
            }
        });
    }
    var hasHandler_1 = {
        has: function (target, key) {
            var has = key in target;
            var isAllowed = allowedGlobals_1(key) ||
                (typeof key === 'string' &&
                    key.charAt(0) === '_' &&
                    !(key in target.$data));
            if (!has && !isAllowed) {
                if (key in target.$data)
                    warnReservedPrefix_1(target, key);
                else
                    warnNonPresent_1(target, key);
            }
            return has || !isAllowed;
        }
    };
    var getHandler_1 = {
        get: function (target, key) {
            if (typeof key === 'string' && !(key in target)) {
                if (key in target.$data)
                    warnReservedPrefix_1(target, key);
                else
                    warnNonPresent_1(target, key);
            }
            return target[key];
        }
    };
    initProxy = function initProxy(vm) {
        if (hasProxy_1) {
            // determine which proxy handler to use
            var options = vm.$options;
            var handlers = options.render && options.render._withStripped ? getHandler_1 : hasHandler_1;
            vm._renderProxy = new Proxy(vm, handlers);
        }
        else {
            vm._renderProxy = vm;
        }
    };
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var uid$2 = 0;
var pendingCleanupDeps = [];
var cleanupDeps = function () {
    for (var i = 0; i < pendingCleanupDeps.length; i++) {
        var dep = pendingCleanupDeps[i];
        dep.subs = dep.subs.filter(function (s) { return s; });
        dep._pending = false;
    }
    pendingCleanupDeps.length = 0;
};
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 * @internal
 */
var Dep = /** @class */ (function () {
    function Dep() {
        // pending subs cleanup
        this._pending = false;
        this.id = uid$2++;
        this.subs = [];
    }
    Dep.prototype.addSub = function (sub) {
        this.subs.push(sub);
    };
    Dep.prototype.removeSub = function (sub) {
        // #12696 deps with massive amount of subscribers are extremely slow to
        // clean up in Chromium
        // to workaround this, we unset the sub for now, and clear them on
        // next scheduler flush.
        this.subs[this.subs.indexOf(sub)] = null;
        if (!this._pending) {
            this._pending = true;
            pendingCleanupDeps.push(this);
        }
    };
    Dep.prototype.depend = function (info) {
        if (Dep.target) {
            Dep.target.addDep(this);
            if ( true && info && Dep.target.onTrack) {
                Dep.target.onTrack(__assign({ effect: Dep.target }, info));
            }
        }
    };
    Dep.prototype.notify = function (info) {
        // stabilize the subscriber list first
        var subs = this.subs.filter(function (s) { return s; });
        if ( true && !config.async) {
            // subs aren't sorted in scheduler if not running async
            // we need to sort them now to make sure they fire in correct
            // order
            subs.sort(function (a, b) { return a.id - b.id; });
        }
        for (var i = 0, l = subs.length; i < l; i++) {
            var sub = subs[i];
            if ( true && info) {
                sub.onTrigger &&
                    sub.onTrigger(__assign({ effect: subs[i] }, info));
            }
            sub.update();
        }
    };
    return Dep;
}());
// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];
function pushTarget(target) {
    targetStack.push(target);
    Dep.target = target;
}
function popTarget() {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */
var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                inserted = args;
                break;
            case 'splice':
                inserted = args.slice(2);
                break;
        }
        if (inserted)
            ob.observeArray(inserted);
        // notify change
        if (true) {
            ob.dep.notify({
                type: "array mutation" /* TriggerOpTypes.ARRAY_MUTATION */,
                target: this,
                key: method
            });
        }
        else {}
        return result;
    });
});

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
var NO_INIITIAL_VALUE = {};
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;
function toggleObserving(value) {
    shouldObserve = value;
}
// ssr mock dep
var mockDep = {
    notify: noop,
    depend: noop,
    addSub: noop,
    removeSub: noop
};
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = /** @class */ (function () {
    function Observer(value, shallow, mock) {
        if (shallow === void 0) { shallow = false; }
        if (mock === void 0) { mock = false; }
        this.value = value;
        this.shallow = shallow;
        this.mock = mock;
        // this.value = value
        this.dep = mock ? mockDep : new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (isArray(value)) {
            if (!mock) {
                if (hasProto) {
                    value.__proto__ = arrayMethods;
                    /* eslint-enable no-proto */
                }
                else {
                    for (var i = 0, l = arrayKeys.length; i < l; i++) {
                        var key = arrayKeys[i];
                        def(value, key, arrayMethods[key]);
                    }
                }
            }
            if (!shallow) {
                this.observeArray(value);
            }
        }
        else {
            /**
             * Walk through all properties and convert them into
             * getter/setters. This method should only be called when
             * value type is Object.
             */
            var keys = Object.keys(value);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);
            }
        }
    }
    /**
     * Observe a list of Array items.
     */
    Observer.prototype.observeArray = function (value) {
        for (var i = 0, l = value.length; i < l; i++) {
            observe(value[i], false, this.mock);
        }
    };
    return Observer;
}());
// helpers
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, shallow, ssrMockReactivity) {
    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        return value.__ob__;
    }
    if (shouldObserve &&
        (ssrMockReactivity || !isServerRendering()) &&
        (isArray(value) || isPlainObject(value)) &&
        Object.isExtensible(value) &&
        !value.__v_skip /* ReactiveFlags.SKIP */ &&
        !isRef(value) &&
        !(value instanceof VNode)) {
        return new Observer(value, shallow, ssrMockReactivity);
    }
}
/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow, mock) {
    var dep = new Dep();
    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
        return;
    }
    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) &&
        (val === NO_INIITIAL_VALUE || arguments.length === 2)) {
        val = obj[key];
    }
    var childOb = !shallow && observe(val, false, mock);
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            var value = getter ? getter.call(obj) : val;
            if (Dep.target) {
                if (true) {
                    dep.depend({
                        target: obj,
                        type: "get" /* TrackOpTypes.GET */,
                        key: key
                    });
                }
                else {}
                if (childOb) {
                    childOb.dep.depend();
                    if (isArray(value)) {
                        dependArray(value);
                    }
                }
            }
            return isRef(value) && !shallow ? value.value : value;
        },
        set: function reactiveSetter(newVal) {
            var value = getter ? getter.call(obj) : val;
            if (!hasChanged(value, newVal)) {
                return;
            }
            if ( true && customSetter) {
                customSetter();
            }
            if (setter) {
                setter.call(obj, newVal);
            }
            else if (getter) {
                // #7981: for accessor properties without setter
                return;
            }
            else if (!shallow && isRef(value) && !isRef(newVal)) {
                value.value = newVal;
                return;
            }
            else {
                val = newVal;
            }
            childOb = !shallow && observe(newVal, false, mock);
            if (true) {
                dep.notify({
                    type: "set" /* TriggerOpTypes.SET */,
                    target: obj,
                    key: key,
                    newValue: newVal,
                    oldValue: value
                });
            }
            else {}
        }
    });
    return dep;
}
function set(target, key, val) {
    if ( true && (isUndef(target) || isPrimitive(target))) {
        warn$2("Cannot set reactive property on undefined, null, or primitive value: ".concat(target));
    }
    if (isReadonly(target)) {
         true && warn$2("Set operation on key \"".concat(key, "\" failed: target is readonly."));
        return;
    }
    var ob = target.__ob__;
    if (isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        // when mocking for SSR, array methods are not hijacked
        if (ob && !ob.shallow && ob.mock) {
            observe(val, false, true);
        }
        return val;
    }
    if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val;
    }
    if (target._isVue || (ob && ob.vmCount)) {
         true &&
            warn$2('Avoid adding reactive properties to a Vue instance or its root $data ' +
                'at runtime - declare it upfront in the data option.');
        return val;
    }
    if (!ob) {
        target[key] = val;
        return val;
    }
    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);
    if (true) {
        ob.dep.notify({
            type: "add" /* TriggerOpTypes.ADD */,
            target: target,
            key: key,
            newValue: val,
            oldValue: undefined
        });
    }
    else {}
    return val;
}
function del(target, key) {
    if ( true && (isUndef(target) || isPrimitive(target))) {
        warn$2("Cannot delete reactive property on undefined, null, or primitive value: ".concat(target));
    }
    if (isArray(target) && isValidArrayIndex(key)) {
        target.splice(key, 1);
        return;
    }
    var ob = target.__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
         true &&
            warn$2('Avoid deleting properties on a Vue instance or its root $data ' +
                '- just set it to null.');
        return;
    }
    if (isReadonly(target)) {
         true &&
            warn$2("Delete operation on key \"".concat(key, "\" failed: target is readonly."));
        return;
    }
    if (!hasOwn(target, key)) {
        return;
    }
    delete target[key];
    if (!ob) {
        return;
    }
    if (true) {
        ob.dep.notify({
            type: "delete" /* TriggerOpTypes.DELETE */,
            target: target,
            key: key
        });
    }
    else {}
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
        e = value[i];
        if (e && e.__ob__) {
            e.__ob__.dep.depend();
        }
        if (isArray(e)) {
            dependArray(e);
        }
    }
}

function reactive(target) {
    makeReactive(target, false);
    return target;
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    makeReactive(target, true);
    def(target, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    return target;
}
function makeReactive(target, shallow) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (!isReadonly(target)) {
        if (true) {
            if (isArray(target)) {
                warn$2("Avoid using Array as root value for ".concat(shallow ? "shallowReactive()" : "reactive()", " as it cannot be tracked in watch() or watchEffect(). Use ").concat(shallow ? "shallowRef()" : "ref()", " instead. This is a Vue-2-only limitation."));
            }
            var existingOb = target && target.__ob__;
            if (existingOb && existingOb.shallow !== shallow) {
                warn$2("Target is already a ".concat(existingOb.shallow ? "" : "non-", "shallow reactive object, and cannot be converted to ").concat(shallow ? "" : "non-", "shallow."));
            }
        }
        var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);
        if ( true && !ob) {
            if (target == null || isPrimitive(target)) {
                warn$2("value cannot be made reactive: ".concat(String(target)));
            }
            if (isCollectionType(target)) {
                warn$2("Vue 2 does not support reactive collection types such as Map or Set.");
            }
        }
    }
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* ReactiveFlags.RAW */]);
    }
    return !!(value && value.__ob__);
}
function isShallow(value) {
    return !!(value && value.__v_isShallow);
}
function isReadonly(value) {
    return !!(value && value.__v_isReadonly);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    var raw = observed && observed["__v_raw" /* ReactiveFlags.RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    // non-extensible objects won't be observed anyway
    if (Object.isExtensible(value)) {
        def(value, "__v_skip" /* ReactiveFlags.SKIP */, true);
    }
    return value;
}
/**
 * @internal
 */
function isCollectionType(value) {
    var type = toRawType(value);
    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');
}

/**
 * @internal
 */
var RefFlag = "__v_isRef";
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref$1(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    var ref = {};
    def(ref, RefFlag, true);
    def(ref, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, shallow);
    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));
    return ref;
}
function triggerRef(ref) {
    if ( true && !ref.dep) {
        warn$2("received object is not a triggerable ref.");
    }
    if (true) {
        ref.dep &&
            ref.dep.notify({
                type: "set" /* TriggerOpTypes.SET */,
                target: ref,
                key: 'value'
            });
    }
    else {}
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
function proxyRefs(objectWithRefs) {
    if (isReactive(objectWithRefs)) {
        return objectWithRefs;
    }
    var proxy = {};
    var keys = Object.keys(objectWithRefs);
    for (var i = 0; i < keys.length; i++) {
        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);
    }
    return proxy;
}
function proxyWithRefUnwrap(target, source, key) {
    Object.defineProperty(target, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            var val = source[key];
            if (isRef(val)) {
                return val.value;
            }
            else {
                var ob = val && val.__ob__;
                if (ob)
                    ob.dep.depend();
                return val;
            }
        },
        set: function (value) {
            var oldValue = source[key];
            if (isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
            }
            else {
                source[key] = value;
            }
        }
    });
}
function customRef(factory) {
    var dep = new Dep();
    var _a = factory(function () {
        if (true) {
            dep.depend({
                target: ref,
                type: "get" /* TrackOpTypes.GET */,
                key: 'value'
            });
        }
        else {}
    }, function () {
        if (true) {
            dep.notify({
                target: ref,
                type: "set" /* TriggerOpTypes.SET */,
                key: 'value'
            });
        }
        else {}
    }), get = _a.get, set = _a.set;
    var ref = {
        get value() {
            return get();
        },
        set value(newVal) {
            set(newVal);
        }
    };
    def(ref, RefFlag, true);
    return ref;
}
function toRefs(object) {
    if ( true && !isReactive(object)) {
        warn$2("toRefs() expects a reactive object but received a plain one.");
    }
    var ret = isArray(object) ? new Array(object.length) : {};
    for (var key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
function toRef(object, key, defaultValue) {
    var val = object[key];
    if (isRef(val)) {
        return val;
    }
    var ref = {
        get value() {
            var val = object[key];
            return val === undefined ? defaultValue : val;
        },
        set value(newVal) {
            object[key] = newVal;
        }
    };
    def(ref, RefFlag, true);
    return ref;
}

var rawToReadonlyFlag = "__v_rawToReadonly";
var rawToShallowReadonlyFlag = "__v_rawToShallowReadonly";
function readonly(target) {
    return createReadonly(target, false);
}
function createReadonly(target, shallow) {
    if (!isPlainObject(target)) {
        if (true) {
            if (isArray(target)) {
                warn$2("Vue 2 does not support readonly arrays.");
            }
            else if (isCollectionType(target)) {
                warn$2("Vue 2 does not support readonly collection types such as Map or Set.");
            }
            else {
                warn$2("value cannot be made readonly: ".concat(typeof target));
            }
        }
        return target;
    }
    if ( true && !Object.isExtensible(target)) {
        warn$2("Vue 2 does not support creating readonly proxy for non-extensible object.");
    }
    // already a readonly object
    if (isReadonly(target)) {
        return target;
    }
    // already has a readonly proxy
    var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;
    var existingProxy = target[existingFlag];
    if (existingProxy) {
        return existingProxy;
    }
    var proxy = Object.create(Object.getPrototypeOf(target));
    def(target, existingFlag, proxy);
    def(proxy, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, true);
    def(proxy, "__v_raw" /* ReactiveFlags.RAW */, target);
    if (isRef(target)) {
        def(proxy, RefFlag, true);
    }
    if (shallow || isShallow(target)) {
        def(proxy, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    }
    var keys = Object.keys(target);
    for (var i = 0; i < keys.length; i++) {
        defineReadonlyProperty(proxy, target, keys[i], shallow);
    }
    return proxy;
}
function defineReadonlyProperty(proxy, target, key, shallow) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            var val = target[key];
            return shallow || !isPlainObject(val) ? val : readonly(val);
        },
        set: function () {
             true &&
                warn$2("Set operation on key \"".concat(key, "\" failed: target is readonly."));
        }
    });
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReadonly(target, true);
}

function computed(getterOrOptions, debugOptions) {
    var getter;
    var setter;
    var onlyGetter = isFunction(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter =  true
            ? function () {
                warn$2('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    var watcher = isServerRendering()
        ? null
        : new Watcher(currentInstance, getter, noop, { lazy: true });
    if ( true && watcher && debugOptions) {
        watcher.onTrack = debugOptions.onTrack;
        watcher.onTrigger = debugOptions.onTrigger;
    }
    var ref = {
        // some libs rely on the presence effect for checking computed refs
        // from normal refs, but the implementation doesn't matter
        effect: watcher,
        get value() {
            if (watcher) {
                if (watcher.dirty) {
                    watcher.evaluate();
                }
                if (Dep.target) {
                    if ( true && Dep.target.onTrack) {
                        Dep.target.onTrack({
                            effect: Dep.target,
                            target: ref,
                            type: "get" /* TrackOpTypes.GET */,
                            key: 'value'
                        });
                    }
                    watcher.depend();
                }
                return watcher.value;
            }
            else {
                return getter();
            }
        },
        set value(newVal) {
            setter(newVal);
        }
    };
    def(ref, RefFlag, true);
    def(ref, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, onlyGetter);
    return ref;
}

var mark;
var measure;
if (true) {
    var perf_1 = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf_1 &&
        // @ts-ignore
        perf_1.mark &&
        // @ts-ignore
        perf_1.measure &&
        // @ts-ignore
        perf_1.clearMarks &&
        // @ts-ignore
        perf_1.clearMeasures) {
        mark = function (tag) { return perf_1.mark(tag); };
        measure = function (name, startTag, endTag) {
            perf_1.measure(name, startTag, endTag);
            perf_1.clearMarks(startTag);
            perf_1.clearMarks(endTag);
            // perf.clearMeasures(name)
        };
    }
}

var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
        name: name,
        once: once,
        capture: capture,
        passive: passive
    };
});
function createFnInvoker(fns, vm) {
    function invoker() {
        var fns = invoker.fns;
        if (isArray(fns)) {
            var cloned = fns.slice();
            for (var i = 0; i < cloned.length; i++) {
                invokeWithErrorHandling(cloned[i], null, arguments, vm, "v-on handler");
            }
        }
        else {
            // return handler return value for single handlers
            return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
        }
    }
    invoker.fns = fns;
    return invoker;
}
function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {
    var name, cur, old, event;
    for (name in on) {
        cur = on[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) {
             true &&
                warn$2("Invalid handler for event \"".concat(event.name, "\": got ") + String(cur), vm);
        }
        else if (isUndef(old)) {
            if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur, vm);
            }
            if (isTrue(event.once)) {
                cur = on[name] = createOnceHandler(event.name, cur, event.capture);
            }
            add(event.name, cur, event.capture, event.passive, event.params);
        }
        else if (cur !== old) {
            old.fns = cur;
            on[name] = old;
        }
    }
    for (name in oldOn) {
        if (isUndef(on[name])) {
            event = normalizeEvent(name);
            remove(event.name, oldOn[name], event.capture);
        }
    }
}

function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
        def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];
    function wrappedHook() {
        hook.apply(this, arguments);
        // important: remove merged hook to ensure it's called only once
        // and prevent memory leak
        remove$2(invoker.fns, wrappedHook);
    }
    if (isUndef(oldHook)) {
        // no existing hook
        invoker = createFnInvoker([wrappedHook]);
    }
    else {
        /* istanbul ignore if */
        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
            // already a merged invoker
            invoker = oldHook;
            invoker.fns.push(wrappedHook);
        }
        else {
            // existing plain hook
            invoker = createFnInvoker([oldHook, wrappedHook]);
        }
    }
    invoker.merged = true;
    def[hookKey] = invoker;
}

function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
        return;
    }
    var res = {};
    var attrs = data.attrs, props = data.props;
    if (isDef(attrs) || isDef(props)) {
        for (var key in propOptions) {
            var altKey = hyphenate(key);
            if (true) {
                var keyInLowerCase = key.toLowerCase();
                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                    tip("Prop \"".concat(keyInLowerCase, "\" is passed to component ") +
                        "".concat(formatComponentName(
                        // @ts-expect-error tag is string
                        tag || Ctor), ", but the declared prop name is") +
                        " \"".concat(key, "\". ") +
                        "Note that HTML attributes are case-insensitive and camelCased " +
                        "props need to use their kebab-case equivalents when using in-DOM " +
                        "templates. You should probably use \"".concat(altKey, "\" instead of \"").concat(key, "\"."));
                }
            }
            checkProp(res, props, key, altKey, true) ||
                checkProp(res, attrs, key, altKey, false);
        }
    }
    return res;
}
function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
        if (hasOwn(hash, key)) {
            res[key] = hash[key];
            if (!preserve) {
                delete hash[key];
            }
            return true;
        }
        else if (hasOwn(hash, altKey)) {
            res[key] = hash[altKey];
            if (!preserve) {
                delete hash[altKey];
            }
            return true;
        }
    }
    return false;
}

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
        if (isArray(children[i])) {
            return Array.prototype.concat.apply([], children);
        }
    }
    return children;
}
// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
    return isPrimitive(children)
        ? [createTextVNode(children)]
        : isArray(children)
            ? normalizeArrayChildren(children)
            : undefined;
}
function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}
function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === 'boolean')
            continue;
        lastIndex = res.length - 1;
        last = res[lastIndex];
        //  nested
        if (isArray(c)) {
            if (c.length > 0) {
                c = normalizeArrayChildren(c, "".concat(nestedIndex || '', "_").concat(i));
                // merge adjacent text nodes
                if (isTextNode(c[0]) && isTextNode(last)) {
                    res[lastIndex] = createTextVNode(last.text + c[0].text);
                    c.shift();
                }
                res.push.apply(res, c);
            }
        }
        else if (isPrimitive(c)) {
            if (isTextNode(last)) {
                // merge adjacent text nodes
                // this is necessary for SSR hydration because text nodes are
                // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c);
            }
            else if (c !== '') {
                // convert primitive to vnode
                res.push(createTextVNode(c));
            }
        }
        else {
            if (isTextNode(c) && isTextNode(last)) {
                // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text);
            }
            else {
                // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) &&
                    isDef(c.tag) &&
                    isUndef(c.key) &&
                    isDef(nestedIndex)) {
                    c.key = "__vlist".concat(nestedIndex, "_").concat(i, "__");
                }
                res.push(c);
            }
        }
    }
    return res;
}

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;
// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (isArray(data) || isPrimitive(data)) {
        normalizationType = children;
        children = data;
        data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
}
function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
         true &&
            warn$2("Avoid using observed data object as vnode data: ".concat(JSON.stringify(data), "\n") + 'Always create fresh vnode data objects in each render!', context);
        return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
        tag = data.is;
    }
    if (!tag) {
        // in case of component :is set to falsy value
        return createEmptyVNode();
    }
    // warn against non-primitive key
    if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
        warn$2('Avoid using non-primitive value as key, ' +
            'use string/number value instead.', context);
    }
    // support single function children as default scoped slot
    if (isArray(children) && isFunction(children[0])) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children);
    }
    else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
        var Ctor = void 0;
        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
        if (config.isReservedTag(tag)) {
            // platform built-in elements
            if ( true &&
                isDef(data) &&
                isDef(data.nativeOn) &&
                data.tag !== 'component') {
                warn$2("The .native modifier for v-on is only valid on components but it was used on <".concat(tag, ">."), context);
            }
            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
        }
        else if ((!data || !data.pre) &&
            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {
            // component
            vnode = createComponent(Ctor, data, context, children, tag);
        }
        else {
            // unknown or unlisted namespaced elements
            // check at runtime because it may get assigned a namespace when its
            // parent normalizes children
            vnode = new VNode(tag, data, children, undefined, undefined, context);
        }
    }
    else {
        // direct component options / constructor
        vnode = createComponent(tag, data, context, children);
    }
    if (isArray(vnode)) {
        return vnode;
    }
    else if (isDef(vnode)) {
        if (isDef(ns))
            applyNS(vnode, ns);
        if (isDef(data))
            registerDeepBindings(data);
        return vnode;
    }
    else {
        return createEmptyVNode();
    }
}
function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
        // use default namespace inside foreignObject
        ns = undefined;
        force = true;
    }
    if (isDef(vnode.children)) {
        for (var i = 0, l = vnode.children.length; i < l; i++) {
            var child = vnode.children[i];
            if (isDef(child.tag) &&
                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
                applyNS(child, ns, force);
            }
        }
    }
}
// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings(data) {
    if (isObject(data.style)) {
        traverse(data.style);
    }
    if (isObject(data.class)) {
        traverse(data.class);
    }
}

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
    var ret = null, i, l, keys, key;
    if (isArray(val) || typeof val === 'string') {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
            ret[i] = render(val[i], i);
        }
    }
    else if (typeof val === 'number') {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
            ret[i] = render(i + 1, i);
        }
    }
    else if (isObject(val)) {
        if (hasSymbol && val[Symbol.iterator]) {
            ret = [];
            var iterator = val[Symbol.iterator]();
            var result = iterator.next();
            while (!result.done) {
                ret.push(render(result.value, ret.length));
                result = iterator.next();
            }
        }
        else {
            keys = Object.keys(val);
            ret = new Array(keys.length);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                ret[i] = render(val[key], key, i);
            }
        }
    }
    if (!isDef(ret)) {
        ret = [];
    }
    ret._isVList = true;
    return ret;
}

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallbackRender, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
        // scoped slot
        props = props || {};
        if (bindObject) {
            if ( true && !isObject(bindObject)) {
                warn$2('slot v-bind without argument expects an Object', this);
            }
            props = extend(extend({}, bindObject), props);
        }
        nodes =
            scopedSlotFn(props) ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    else {
        nodes =
            this.$slots[name] ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    var target = props && props.slot;
    if (target) {
        return this.$createElement('template', { slot: target }, nodes);
    }
    else {
        return nodes;
    }
}

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
}

function isKeyNotMatch(expect, actual) {
    if (isArray(expect)) {
        return expect.indexOf(actual) === -1;
    }
    else {
        return expect !== actual;
    }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName);
    }
    else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    }
    else if (eventKeyName) {
        return hyphenate(eventKeyName) !== key;
    }
    return eventKeyCode === undefined;
}

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
        if (!isObject(value)) {
             true &&
                warn$2('v-bind without argument expects an Object or Array value', this);
        }
        else {
            if (isArray(value)) {
                value = toObject(value);
            }
            var hash = void 0;
            var _loop_1 = function (key) {
                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
                    hash = data;
                }
                else {
                    var type = data.attrs && data.attrs.type;
                    hash =
                        asProp || config.mustUseProp(tag, type, key)
                            ? data.domProps || (data.domProps = {})
                            : data.attrs || (data.attrs = {});
                }
                var camelizedKey = camelize(key);
                var hyphenatedKey = hyphenate(key);
                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                    hash[key] = value[key];
                    if (isSync) {
                        var on = data.on || (data.on = {});
                        on["update:".concat(key)] = function ($event) {
                            value[key] = $event;
                        };
                    }
                }
            };
            for (var key in value) {
                _loop_1(key);
            }
        }
    }
    return data;
}

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
        return tree;
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates
    );
    markStatic$1(tree, "__static__".concat(index), false);
    return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
    markStatic$1(tree, "__once__".concat(index).concat(key ? "_".concat(key) : ""), true);
    return tree;
}
function markStatic$1(tree, key, isOnce) {
    if (isArray(tree)) {
        for (var i = 0; i < tree.length; i++) {
            if (tree[i] && typeof tree[i] !== 'string') {
                markStaticNode(tree[i], "".concat(key, "_").concat(i), isOnce);
            }
        }
    }
    else {
        markStaticNode(tree, key, isOnce);
    }
}
function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
}

function bindObjectListeners(data, value) {
    if (value) {
        if (!isPlainObject(value)) {
             true && warn$2('v-on without argument expects an Object value', this);
        }
        else {
            var on = (data.on = data.on ? extend({}, data.on) : {});
            for (var key in value) {
                var existing = on[key];
                var ours = value[key];
                on[key] = existing ? [].concat(existing, ours) : ours;
            }
        }
    }
    return data;
}

function resolveScopedSlots(fns, res, 
// the following are added in 2.6
hasDynamicKeys, contentHashKey) {
    res = res || { $stable: !hasDynamicKeys };
    for (var i = 0; i < fns.length; i++) {
        var slot = fns[i];
        if (isArray(slot)) {
            resolveScopedSlots(slot, res, hasDynamicKeys);
        }
        else if (slot) {
            // marker for reverse proxying v-slot without scope on this.$slots
            // @ts-expect-error
            if (slot.proxy) {
                // @ts-expect-error
                slot.fn.proxy = true;
            }
            res[slot.key] = slot.fn;
        }
    }
    if (contentHashKey) {
        res.$key = contentHashKey;
    }
    return res;
}

// helper to process dynamic keys for dynamic arguments in v-bind and v-on.
function bindDynamicKeys(baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
        var key = values[i];
        if (typeof key === 'string' && key) {
            baseObj[values[i]] = values[i + 1];
        }
        else if ( true && key !== '' && key !== null) {
            // null is a special value for explicitly removing a binding
            warn$2("Invalid value for dynamic directive argument (expected string or null): ".concat(key), this);
        }
    }
    return baseObj;
}
// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier(value, symbol) {
    return typeof value === 'string' ? symbol + value : value;
}

function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
}

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
    if (!children || !children.length) {
        return {};
    }
    var slots = {};
    for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        var data = child.data;
        // remove slot attribute if the node is resolved as a Vue slot node
        if (data && data.attrs && data.attrs.slot) {
            delete data.attrs.slot;
        }
        // named slots should only be respected if the vnode was rendered in the
        // same context.
        if ((child.context === context || child.fnContext === context) &&
            data &&
            data.slot != null) {
            var name_1 = data.slot;
            var slot = slots[name_1] || (slots[name_1] = []);
            if (child.tag === 'template') {
                slot.push.apply(slot, child.children || []);
            }
            else {
                slot.push(child);
            }
        }
        else {
            (slots.default || (slots.default = [])).push(child);
        }
    }
    // ignore slots that contains only whitespace
    for (var name_2 in slots) {
        if (slots[name_2].every(isWhitespace)) {
            delete slots[name_2];
        }
    }
    return slots;
}
function isWhitespace(node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' ';
}

function isAsyncPlaceholder(node) {
    // @ts-expect-error not really boolean type
    return node.isComment && node.asyncFactory;
}

function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
    var res;
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
    var key = scopedSlots && scopedSlots.$key;
    if (!scopedSlots) {
        res = {};
    }
    else if (scopedSlots._normalized) {
        // fast path 1: child component re-render only, parent did not change
        return scopedSlots._normalized;
    }
    else if (isStable &&
        prevScopedSlots &&
        prevScopedSlots !== emptyObject &&
        key === prevScopedSlots.$key &&
        !hasNormalSlots &&
        !prevScopedSlots.$hasNormal) {
        // fast path 2: stable scoped slots w/ no normal slots to proxy,
        // only need to normalize once
        return prevScopedSlots;
    }
    else {
        res = {};
        for (var key_1 in scopedSlots) {
            if (scopedSlots[key_1] && key_1[0] !== '$') {
                res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);
            }
        }
    }
    // expose normal slots on scopedSlots
    for (var key_2 in normalSlots) {
        if (!(key_2 in res)) {
            res[key_2] = proxyNormalSlot(normalSlots, key_2);
        }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (scopedSlots && Object.isExtensible(scopedSlots)) {
        scopedSlots._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res;
}
function normalizeScopedSlot(vm, normalSlots, key, fn) {
    var normalized = function () {
        var cur = currentInstance;
        setCurrentInstance(vm);
        var res = arguments.length ? fn.apply(null, arguments) : fn({});
        res =
            res && typeof res === 'object' && !isArray(res)
                ? [res] // single vnode
                : normalizeChildren(res);
        var vnode = res && res[0];
        setCurrentInstance(cur);
        return res &&
            (!vnode ||
                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391
            ? undefined
            : res;
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
            get: normalized,
            enumerable: true,
            configurable: true
        });
    }
    return normalized;
}
function proxyNormalSlot(slots, key) {
    return function () { return slots[key]; };
}

function initSetup(vm) {
    var options = vm.$options;
    var setup = options.setup;
    if (setup) {
        var ctx = (vm._setupContext = createSetupContext(vm));
        setCurrentInstance(vm);
        pushTarget();
        var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, "setup");
        popTarget();
        setCurrentInstance();
        if (isFunction(setupResult)) {
            // render function
            // @ts-ignore
            options.render = setupResult;
        }
        else if (isObject(setupResult)) {
            // bindings
            if ( true && setupResult instanceof VNode) {
                warn$2("setup() should not return VNodes directly - " +
                    "return a render function instead.");
            }
            vm._setupState = setupResult;
            // __sfc indicates compiled bindings from <script setup>
            if (!setupResult.__sfc) {
                for (var key in setupResult) {
                    if (!isReserved(key)) {
                        proxyWithRefUnwrap(vm, setupResult, key);
                    }
                    else if (true) {
                        warn$2("Avoid using variables that start with _ or $ in setup().");
                    }
                }
            }
            else {
                // exposed for compiled render fn
                var proxy = (vm._setupProxy = {});
                for (var key in setupResult) {
                    if (key !== '__sfc') {
                        proxyWithRefUnwrap(proxy, setupResult, key);
                    }
                }
            }
        }
        else if ( true && setupResult !== undefined) {
            warn$2("setup() should return an object. Received: ".concat(setupResult === null ? 'null' : typeof setupResult));
        }
    }
}
function createSetupContext(vm) {
    var exposeCalled = false;
    return {
        get attrs() {
            if (!vm._attrsProxy) {
                var proxy = (vm._attrsProxy = {});
                def(proxy, '_v_attr_proxy', true);
                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');
            }
            return vm._attrsProxy;
        },
        get listeners() {
            if (!vm._listenersProxy) {
                var proxy = (vm._listenersProxy = {});
                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');
            }
            return vm._listenersProxy;
        },
        get slots() {
            return initSlotsProxy(vm);
        },
        emit: bind$1(vm.$emit, vm),
        expose: function (exposed) {
            if (true) {
                if (exposeCalled) {
                    warn$2("expose() should be called only once per setup().", vm);
                }
                exposeCalled = true;
            }
            if (exposed) {
                Object.keys(exposed).forEach(function (key) {
                    return proxyWithRefUnwrap(vm, exposed, key);
                });
            }
        }
    };
}
function syncSetupProxy(to, from, prev, instance, type) {
    var changed = false;
    for (var key in from) {
        if (!(key in to)) {
            changed = true;
            defineProxyAttr(to, key, instance, type);
        }
        else if (from[key] !== prev[key]) {
            changed = true;
        }
    }
    for (var key in to) {
        if (!(key in from)) {
            changed = true;
            delete to[key];
        }
    }
    return changed;
}
function defineProxyAttr(proxy, key, instance, type) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            return instance[type][key];
        }
    });
}
function initSlotsProxy(vm) {
    if (!vm._slotsProxy) {
        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);
    }
    return vm._slotsProxy;
}
function syncSetupSlots(to, from) {
    for (var key in from) {
        to[key] = from[key];
    }
    for (var key in to) {
        if (!(key in from)) {
            delete to[key];
        }
    }
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useSlots() {
    return getContext().slots;
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useAttrs() {
    return getContext().attrs;
}
/**
 * Vue 2 only
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useListeners() {
    return getContext().listeners;
}
function getContext() {
    if ( true && !currentInstance) {
        warn$2("useContext() called without active instance.");
    }
    var vm = currentInstance;
    return vm._setupContext || (vm._setupContext = createSetupContext(vm));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    var props = isArray(raw)
        ? raw.reduce(function (normalized, p) { return ((normalized[p] = {}), normalized); }, {})
        : raw;
    for (var key in defaults) {
        var opt = props[key];
        if (opt) {
            if (isArray(opt) || isFunction(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else if (true) {
            warn$2("props default key \"".concat(key, "\" has no corresponding declaration."));
        }
    }
    return props;
}

function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = parentVnode
        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)
        : emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    // @ts-expect-error
    vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    // @ts-expect-error
    vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };
    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;
    /* istanbul ignore else */
    if (true) {
        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, function () {
            !isUpdatingChildComponent && warn$2("$attrs is readonly.", vm);
        }, true);
        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
            !isUpdatingChildComponent && warn$2("$listeners is readonly.", vm);
        }, true);
    }
    else {}
}
var currentRenderingInstance = null;
function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);
    Vue.prototype.$nextTick = function (fn) {
        return nextTick(fn, this);
    };
    Vue.prototype._render = function () {
        var vm = this;
        var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;
        if (_parentVnode && vm._isMounted) {
            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
            if (vm._slotsProxy) {
                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
            }
        }
        // set parent vnode. this allows render functions to have access
        // to the data on the placeholder node.
        vm.$vnode = _parentVnode;
        // render self
        var vnode;
        try {
            // There's no need to maintain a stack because all render fns are called
            // separately from one another. Nested component's render fns are called
            // when parent component is patched.
            setCurrentInstance(vm);
            currentRenderingInstance = vm;
            vnode = render.call(vm._renderProxy, vm.$createElement);
        }
        catch (e) {
            handleError(e, vm, "render");
            // return error render result,
            // or previous vnode to prevent render error causing blank component
            /* istanbul ignore else */
            if ( true && vm.$options.renderError) {
                try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                }
                catch (e) {
                    handleError(e, vm, "renderError");
                    vnode = vm._vnode;
                }
            }
            else {
                vnode = vm._vnode;
            }
        }
        finally {
            currentRenderingInstance = null;
            setCurrentInstance();
        }
        // if the returned array contains only a single node, allow it
        if (isArray(vnode) && vnode.length === 1) {
            vnode = vnode[0];
        }
        // return empty vnode in case the render function errored out
        if (!(vnode instanceof VNode)) {
            if ( true && isArray(vnode)) {
                warn$2('Multiple root nodes returned from render function. Render function ' +
                    'should return a single root node.', vm);
            }
            vnode = createEmptyVNode();
        }
        // set parent
        vnode.parent = _parentVnode;
        return vnode;
    };
}

function ensureCtor(comp, base) {
    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
        comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
}
function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node;
}
function resolveAsyncComponent(factory, baseCtor) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp;
    }
    if (isDef(factory.resolved)) {
        return factory.resolved;
    }
    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
        // already pending
        factory.owners.push(owner);
    }
    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp;
    }
    if (owner && !isDef(factory.owners)) {
        var owners_1 = (factory.owners = [owner]);
        var sync_1 = true;
        var timerLoading_1 = null;
        var timerTimeout_1 = null;
        owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });
        var forceRender_1 = function (renderCompleted) {
            for (var i = 0, l = owners_1.length; i < l; i++) {
                owners_1[i].$forceUpdate();
            }
            if (renderCompleted) {
                owners_1.length = 0;
                if (timerLoading_1 !== null) {
                    clearTimeout(timerLoading_1);
                    timerLoading_1 = null;
                }
                if (timerTimeout_1 !== null) {
                    clearTimeout(timerTimeout_1);
                    timerTimeout_1 = null;
                }
            }
        };
        var resolve = once(function (res) {
            // cache resolved
            factory.resolved = ensureCtor(res, baseCtor);
            // invoke callbacks only if this is not a synchronous resolve
            // (async resolves are shimmed as synchronous during SSR)
            if (!sync_1) {
                forceRender_1(true);
            }
            else {
                owners_1.length = 0;
            }
        });
        var reject_1 = once(function (reason) {
             true &&
                warn$2("Failed to resolve async component: ".concat(String(factory)) +
                    (reason ? "\nReason: ".concat(reason) : ''));
            if (isDef(factory.errorComp)) {
                factory.error = true;
                forceRender_1(true);
            }
        });
        var res_1 = factory(resolve, reject_1);
        if (isObject(res_1)) {
            if (isPromise(res_1)) {
                // () => Promise
                if (isUndef(factory.resolved)) {
                    res_1.then(resolve, reject_1);
                }
            }
            else if (isPromise(res_1.component)) {
                res_1.component.then(resolve, reject_1);
                if (isDef(res_1.error)) {
                    factory.errorComp = ensureCtor(res_1.error, baseCtor);
                }
                if (isDef(res_1.loading)) {
                    factory.loadingComp = ensureCtor(res_1.loading, baseCtor);
                    if (res_1.delay === 0) {
                        factory.loading = true;
                    }
                    else {
                        // @ts-expect-error NodeJS timeout type
                        timerLoading_1 = setTimeout(function () {
                            timerLoading_1 = null;
                            if (isUndef(factory.resolved) && isUndef(factory.error)) {
                                factory.loading = true;
                                forceRender_1(false);
                            }
                        }, res_1.delay || 200);
                    }
                }
                if (isDef(res_1.timeout)) {
                    // @ts-expect-error NodeJS timeout type
                    timerTimeout_1 = setTimeout(function () {
                        timerTimeout_1 = null;
                        if (isUndef(factory.resolved)) {
                            reject_1( true ? "timeout (".concat(res_1.timeout, "ms)") : 0);
                        }
                    }, res_1.timeout);
                }
            }
        }
        sync_1 = false;
        // return in case resolved synchronously
        return factory.loading ? factory.loadingComp : factory.resolved;
    }
}

function getFirstComponentChild(children) {
    if (isArray(children)) {
        for (var i = 0; i < children.length; i++) {
            var c = children[i];
            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c;
            }
        }
    }
}

function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
        updateComponentListeners(vm, listeners);
    }
}
var target$1;
function add$1(event, fn) {
    target$1.$on(event, fn);
}
function remove$1(event, fn) {
    target$1.$off(event, fn);
}
function createOnceHandler$1(event, fn) {
    var _target = target$1;
    return function onceHandler() {
        var res = fn.apply(null, arguments);
        if (res !== null) {
            _target.$off(event, onceHandler);
        }
    };
}
function updateComponentListeners(vm, listeners, oldListeners) {
    target$1 = vm;
    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
    target$1 = undefined;
}
function eventsMixin(Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
        var vm = this;
        if (isArray(event)) {
            for (var i = 0, l = event.length; i < l; i++) {
                vm.$on(event[i], fn);
            }
        }
        else {
            (vm._events[event] || (vm._events[event] = [])).push(fn);
            // optimize hook:event cost by using a boolean flag marked at registration
            // instead of a hash lookup
            if (hookRE.test(event)) {
                vm._hasHookEvent = true;
            }
        }
        return vm;
    };
    Vue.prototype.$once = function (event, fn) {
        var vm = this;
        function on() {
            vm.$off(event, on);
            fn.apply(vm, arguments);
        }
        on.fn = fn;
        vm.$on(event, on);
        return vm;
    };
    Vue.prototype.$off = function (event, fn) {
        var vm = this;
        // all
        if (!arguments.length) {
            vm._events = Object.create(null);
            return vm;
        }
        // array of events
        if (isArray(event)) {
            for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {
                vm.$off(event[i_1], fn);
            }
            return vm;
        }
        // specific event
        var cbs = vm._events[event];
        if (!cbs) {
            return vm;
        }
        if (!fn) {
            vm._events[event] = null;
            return vm;
        }
        // specific handler
        var cb;
        var i = cbs.length;
        while (i--) {
            cb = cbs[i];
            if (cb === fn || cb.fn === fn) {
                cbs.splice(i, 1);
                break;
            }
        }
        return vm;
    };
    Vue.prototype.$emit = function (event) {
        var vm = this;
        if (true) {
            var lowerCaseEvent = event.toLowerCase();
            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip("Event \"".concat(lowerCaseEvent, "\" is emitted in component ") +
                    "".concat(formatComponentName(vm), " but the handler is registered for \"").concat(event, "\". ") +
                    "Note that HTML attributes are case-insensitive and you cannot use " +
                    "v-on to listen to camelCase events when using in-DOM templates. " +
                    "You should probably use \"".concat(hyphenate(event), "\" instead of \"").concat(event, "\"."));
            }
        }
        var cbs = vm._events[event];
        if (cbs) {
            cbs = cbs.length > 1 ? toArray(cbs) : cbs;
            var args = toArray(arguments, 1);
            var info = "event handler for \"".concat(event, "\"");
            for (var i = 0, l = cbs.length; i < l; i++) {
                invokeWithErrorHandling(cbs[i], vm, args, vm, info);
            }
        }
        return vm;
    };
}

var activeInstance = null;
var isUpdatingChildComponent = false;
function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
        activeInstance = prevActiveInstance;
    };
}
function initLifecycle(vm) {
    var options = vm.$options;
    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
            parent = parent.$parent;
        }
        parent.$children.push(vm);
    }
    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;
    vm.$children = [];
    vm.$refs = {};
    vm._provided = parent ? parent._provided : Object.create(null);
    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
}
function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
        var vm = this;
        var prevEl = vm.$el;
        var prevVnode = vm._vnode;
        var restoreActiveInstance = setActiveInstance(vm);
        vm._vnode = vnode;
        // Vue.prototype.__patch__ is injected in entry points
        // based on the rendering backend used.
        if (!prevVnode) {
            // initial render
            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
        }
        else {
            // updates
            vm.$el = vm.__patch__(prevVnode, vnode);
        }
        restoreActiveInstance();
        // update __vue__ reference
        if (prevEl) {
            prevEl.__vue__ = null;
        }
        if (vm.$el) {
            vm.$el.__vue__ = vm;
        }
        // if parent is an HOC, update its $el as well
        var wrapper = vm;
        while (wrapper &&
            wrapper.$vnode &&
            wrapper.$parent &&
            wrapper.$vnode === wrapper.$parent._vnode) {
            wrapper.$parent.$el = wrapper.$el;
            wrapper = wrapper.$parent;
        }
        // updated hook is called by the scheduler to ensure that children are
        // updated in a parent's updated hook.
    };
    Vue.prototype.$forceUpdate = function () {
        var vm = this;
        if (vm._watcher) {
            vm._watcher.update();
        }
    };
    Vue.prototype.$destroy = function () {
        var vm = this;
        if (vm._isBeingDestroyed) {
            return;
        }
        callHook$1(vm, 'beforeDestroy');
        vm._isBeingDestroyed = true;
        // remove self from parent
        var parent = vm.$parent;
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
            remove$2(parent.$children, vm);
        }
        // teardown scope. this includes both the render watcher and other
        // watchers created
        vm._scope.stop();
        // remove reference from data ob
        // frozen object may not have observer.
        if (vm._data.__ob__) {
            vm._data.__ob__.vmCount--;
        }
        // call the last hook...
        vm._isDestroyed = true;
        // invoke destroy hooks on current rendered tree
        vm.__patch__(vm._vnode, null);
        // fire destroyed hook
        callHook$1(vm, 'destroyed');
        // turn off all instance listeners.
        vm.$off();
        // remove __vue__ reference
        if (vm.$el) {
            vm.$el.__vue__ = null;
        }
        // release circular reference (#6759)
        if (vm.$vnode) {
            vm.$vnode.parent = null;
        }
    };
}
function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
        // @ts-expect-error invalid type
        vm.$options.render = createEmptyVNode;
        if (true) {
            /* istanbul ignore if */
            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
                vm.$options.el ||
                el) {
                warn$2('You are using the runtime-only build of Vue where the template ' +
                    'compiler is not available. Either pre-compile the templates into ' +
                    'render functions, or use the compiler-included build.', vm);
            }
            else {
                warn$2('Failed to mount component: template or render function not defined.', vm);
            }
        }
    }
    callHook$1(vm, 'beforeMount');
    var updateComponent;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
        updateComponent = function () {
            var name = vm._name;
            var id = vm._uid;
            var startTag = "vue-perf-start:".concat(id);
            var endTag = "vue-perf-end:".concat(id);
            mark(startTag);
            var vnode = vm._render();
            mark(endTag);
            measure("vue ".concat(name, " render"), startTag, endTag);
            mark(startTag);
            vm._update(vnode, hydrating);
            mark(endTag);
            measure("vue ".concat(name, " patch"), startTag, endTag);
        };
    }
    else {
        updateComponent = function () {
            vm._update(vm._render(), hydrating);
        };
    }
    var watcherOptions = {
        before: function () {
            if (vm._isMounted && !vm._isDestroyed) {
                callHook$1(vm, 'beforeUpdate');
            }
        }
    };
    if (true) {
        watcherOptions.onTrack = function (e) { return callHook$1(vm, 'renderTracked', [e]); };
        watcherOptions.onTrigger = function (e) { return callHook$1(vm, 'renderTriggered', [e]); };
    }
    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);
    hydrating = false;
    // flush buffer for flush: "pre" watchers queued in setup()
    var preWatchers = vm._preWatchers;
    if (preWatchers) {
        for (var i = 0; i < preWatchers.length; i++) {
            preWatchers[i].run();
        }
    }
    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
        vm._isMounted = true;
        callHook$1(vm, 'mounted');
    }
    return vm;
}
function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    if (true) {
        isUpdatingChildComponent = true;
    }
    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.
    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||
        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
        (!newScopedSlots && vm.$scopedSlots.$key));
    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    var needsForceUpdate = !!(renderChildren || // has new static slots
        vm.$options._renderChildren || // has old static slots
        hasDynamicScopedSlot);
    var prevVNode = vm.$vnode;
    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render
    if (vm._vnode) {
        // update child tree's parent
        vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;
    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    var attrs = parentVnode.data.attrs || emptyObject;
    if (vm._attrsProxy) {
        // force update if attrs are accessed and has changed since it may be
        // passed to a child component.
        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {
            needsForceUpdate = true;
        }
    }
    vm.$attrs = attrs;
    // update listeners
    listeners = listeners || emptyObject;
    var prevListeners = vm.$options._parentListeners;
    if (vm._listenersProxy) {
        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');
    }
    vm.$listeners = vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, prevListeners);
    // update props
    if (propsData && vm.$options.props) {
        toggleObserving(false);
        var props = vm._props;
        var propKeys = vm.$options._propKeys || [];
        for (var i = 0; i < propKeys.length; i++) {
            var key = propKeys[i];
            var propOptions = vm.$options.props; // wtf flow?
            props[key] = validateProp(key, propOptions, propsData, vm);
        }
        toggleObserving(true);
        // keep a copy of raw propsData
        vm.$options.propsData = propsData;
    }
    // resolve slots + force update if has children
    if (needsForceUpdate) {
        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
        vm.$forceUpdate();
    }
    if (true) {
        isUpdatingChildComponent = false;
    }
}
function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
        if (vm._inactive)
            return true;
    }
    return false;
}
function activateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    else if (vm._directInactive) {
        return;
    }
    if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (var i = 0; i < vm.$children.length; i++) {
            activateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'activated');
    }
}
function deactivateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    if (!vm._inactive) {
        vm._inactive = true;
        for (var i = 0; i < vm.$children.length; i++) {
            deactivateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'deactivated');
    }
}
function callHook$1(vm, hook, args, setContext) {
    if (setContext === void 0) { setContext = true; }
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var prev = currentInstance;
    setContext && setCurrentInstance(vm);
    var handlers = vm.$options[hook];
    var info = "".concat(hook, " hook");
    if (handlers) {
        for (var i = 0, j = handlers.length; i < j; i++) {
            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);
        }
    }
    if (vm._hasHookEvent) {
        vm.$emit('hook:' + hook);
    }
    setContext && setCurrentInstance(prev);
    popTarget();
}

var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index$1 = 0;
/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
    index$1 = queue.length = activatedChildren.length = 0;
    has = {};
    if (true) {
        circular = {};
    }
    waiting = flushing = false;
}
// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;
// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;
// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
    var performance_1 = window.performance;
    if (performance_1 &&
        typeof performance_1.now === 'function' &&
        getNow() > document.createEvent('Event').timeStamp) {
        // if the event timestamp, although evaluated AFTER the Date.now(), is
        // smaller than it, it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listener timestamps as
        // well.
        getNow = function () { return performance_1.now(); };
    }
}
var sortCompareFn = function (a, b) {
    if (a.post) {
        if (!b.post)
            return 1;
    }
    else if (b.post) {
        return -1;
    }
    return a.id - b.id;
};
/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(sortCompareFn);
    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index$1 = 0; index$1 < queue.length; index$1++) {
        watcher = queue[index$1];
        if (watcher.before) {
            watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
        // in dev build, check and stop circular updates.
        if ( true && has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
                warn$2('You may have an infinite update loop ' +
                    (watcher.user
                        ? "in watcher with expression \"".concat(watcher.expression, "\"")
                        : "in a component render function."), watcher.vm);
                break;
            }
        }
    }
    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();
    resetSchedulerState();
    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);
    cleanupDeps();
    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
        devtools.emit('flush');
    }
}
function callUpdatedHooks(queue) {
    var i = queue.length;
    while (i--) {
        var watcher = queue[i];
        var vm = watcher.vm;
        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
            callHook$1(vm, 'updated');
        }
    }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
}
function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
        queue[i]._inactive = true;
        activateChildComponent(queue[i], true /* true */);
    }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] != null) {
        return;
    }
    if (watcher === Dep.target && watcher.noRecurse) {
        return;
    }
    has[id] = true;
    if (!flushing) {
        queue.push(watcher);
    }
    else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index$1 && queue[i].id > watcher.id) {
            i--;
        }
        queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
        waiting = true;
        if ( true && !config.async) {
            flushSchedulerQueue();
            return;
        }
        nextTick(flushSchedulerQueue);
    }
}

var WATCHER = "watcher";
var WATCHER_CB = "".concat(WATCHER, " callback");
var WATCHER_GETTER = "".concat(WATCHER, " getter");
var WATCHER_CLEANUP = "".concat(WATCHER, " cleanup");
// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, ( true
        ? __assign(__assign({}, options), { flush: 'post' }) : 0));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, ( true
        ? __assign(__assign({}, options), { flush: 'sync' }) : 0));
}
// initial value for watchers to trigger on undefined initial values
var INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if ( true && typeof cb !== 'function') {
        warn$2("`watch(fn, options?)` signature has been moved to a separate API. " +
            "Use `watchEffect(fn, options?)` instead. `watch` now only " +
            "supports `watch(source, cb, options?) signature.");
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, _a) {
    var _b = _a === void 0 ? emptyObject : _a, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? 'pre' : _c, onTrack = _b.onTrack, onTrigger = _b.onTrigger;
    if ( true && !cb) {
        if (immediate !== undefined) {
            warn$2("watch() \"immediate\" option is only respected when using the " +
                "watch(source, callback, options?) signature.");
        }
        if (deep !== undefined) {
            warn$2("watch() \"deep\" option is only respected when using the " +
                "watch(source, callback, options?) signature.");
        }
    }
    var warnInvalidSource = function (s) {
        warn$2("Invalid watch source: ".concat(s, ". A watch source can only be a getter/effect ") +
            "function, a ref, a reactive object, or an array of these types.");
    };
    var instance = currentInstance;
    var call = function (fn, type, args) {
        if (args === void 0) { args = null; }
        return invokeWithErrorHandling(fn, null, args, instance, type);
    };
    var getter;
    var forceTrigger = false;
    var isMultiSource = false;
    if (isRef(source)) {
        getter = function () { return source.value; };
        forceTrigger = isShallow(source);
    }
    else if (isReactive(source)) {
        getter = function () {
            source.__ob__.dep.depend();
            return source;
        };
        deep = true;
    }
    else if (isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });
        getter = function () {
            return source.map(function (s) {
                if (isRef(s)) {
                    return s.value;
                }
                else if (isReactive(s)) {
                    return traverse(s);
                }
                else if (isFunction(s)) {
                    return call(s, WATCHER_GETTER);
                }
                else {
                     true && warnInvalidSource(s);
                }
            });
        };
    }
    else if (isFunction(source)) {
        if (cb) {
            // getter with cb
            getter = function () { return call(source, WATCHER_GETTER); };
        }
        else {
            // no cb -> simple effect
            getter = function () {
                if (instance && instance._isDestroyed) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return call(source, WATCHER, [onCleanup]);
            };
        }
    }
    else {
        getter = noop;
         true && warnInvalidSource(source);
    }
    if (cb && deep) {
        var baseGetter_1 = getter;
        getter = function () { return traverse(baseGetter_1()); };
    }
    var cleanup;
    var onCleanup = function (fn) {
        cleanup = watcher.onStop = function () {
            call(fn, WATCHER_CLEANUP);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isServerRendering()) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = noop;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            call(cb, WATCHER_CB, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return noop;
    }
    var watcher = new Watcher(currentInstance, getter, noop, {
        lazy: true
    });
    watcher.noRecurse = !cb;
    var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    // overwrite default run
    watcher.run = function () {
        if (!watcher.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            var newValue = watcher.get();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some(function (v, i) {
                        return hasChanged(v, oldValue[i]);
                    })
                    : hasChanged(newValue, oldValue))) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                call(cb, WATCHER_CB, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            watcher.get();
        }
    };
    if (flush === 'sync') {
        watcher.update = watcher.run;
    }
    else if (flush === 'post') {
        watcher.post = true;
        watcher.update = function () { return queueWatcher(watcher); };
    }
    else {
        // pre
        watcher.update = function () {
            if (instance && instance === currentInstance && !instance._isMounted) {
                // pre-watcher triggered before
                var buffer = instance._preWatchers || (instance._preWatchers = []);
                if (buffer.indexOf(watcher) < 0)
                    buffer.push(watcher);
            }
            else {
                queueWatcher(watcher);
            }
        };
    }
    if (true) {
        watcher.onTrack = onTrack;
        watcher.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            watcher.run();
        }
        else {
            oldValue = watcher.get();
        }
    }
    else if (flush === 'post' && instance) {
        instance.$once('hook:mounted', function () { return watcher.get(); });
    }
    else {
        watcher.get();
    }
    return function () {
        watcher.teardown();
    };
}

var activeEffectScope;
var EffectScope = /** @class */ (function () {
    function EffectScope(detached) {
        if (detached === void 0) { detached = false; }
        this.detached = detached;
        /**
         * @internal
         */
        this.active = true;
        /**
         * @internal
         */
        this.effects = [];
        /**
         * @internal
         */
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    EffectScope.prototype.run = function (fn) {
        if (this.active) {
            var currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = currentEffectScope;
            }
        }
        else if (true) {
            warn$2("cannot run an inactive effect scope.");
        }
    };
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    EffectScope.prototype.on = function () {
        activeEffectScope = this;
    };
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    EffectScope.prototype.off = function () {
        activeEffectScope = this.parent;
    };
    EffectScope.prototype.stop = function (fromParent) {
        if (this.active) {
            var i = void 0, l = void 0;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].teardown();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (!this.detached && this.parent && !fromParent) {
                // optimized O(1) removal
                var last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = undefined;
            this.active = false;
        }
    };
    return EffectScope;
}());
function effectScope(detached) {
    return new EffectScope(detached);
}
/**
 * @internal
 */
function recordEffectScope(effect, scope) {
    if (scope === void 0) { scope = activeEffectScope; }
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else if (true) {
        warn$2("onScopeDispose() is called when there is no active effect scope" +
            " to be associated with.");
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if (true) {
            warn$2("provide() can only be used inside setup().");
        }
    }
    else {
        // TS doesn't allow symbol as index type
        resolveProvided(currentInstance)[key] = value;
    }
}
function resolveProvided(vm) {
    // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.
    var existing = vm._provided;
    var parentProvides = vm.$parent && vm.$parent._provided;
    if (parentProvides === existing) {
        return (vm._provided = Object.create(parentProvides));
    }
    else {
        return existing;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory) {
    if (treatDefaultAsFactory === void 0) { treatDefaultAsFactory = false; }
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    var instance = currentInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        var provides = instance.$parent && instance.$parent._provided;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction(defaultValue)
                ? defaultValue.call(instance)
                : defaultValue;
        }
        else if (true) {
            warn$2("injection \"".concat(String(key), "\" not found."));
        }
    }
    else if (true) {
        warn$2("inject() can only be used inside setup() or functional components.");
    }
}

/**
 * @internal this function needs manual public type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function h(type, props, children) {
    if (!currentInstance) {
         true &&
            warn$2("globally imported h() can only be invoked when there is an active " +
                "component instance, e.g. synchronously in a component's render or setup function.");
    }
    return createElement$1(currentInstance, type, props, children, 2, true);
}

function handleError(err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
        if (vm) {
            var cur = vm;
            while ((cur = cur.$parent)) {
                var hooks = cur.$options.errorCaptured;
                if (hooks) {
                    for (var i = 0; i < hooks.length; i++) {
                        try {
                            var capture = hooks[i].call(cur, err, vm, info) === false;
                            if (capture)
                                return;
                        }
                        catch (e) {
                            globalHandleError(e, cur, 'errorCaptured hook');
                        }
                    }
                }
            }
        }
        globalHandleError(err, vm, info);
    }
    finally {
        popTarget();
    }
}
function invokeWithErrorHandling(handler, context, args, vm, info) {
    var res;
    try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise(res) && !res._handled) {
            res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
            res._handled = true;
        }
    }
    catch (e) {
        handleError(e, vm, info);
    }
    return res;
}
function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
        try {
            return config.errorHandler.call(null, err, vm, info);
        }
        catch (e) {
            // if the user intentionally throws the original error in the handler,
            // do not log it twice
            if (e !== err) {
                logError(e, null, 'config.errorHandler');
            }
        }
    }
    logError(err, vm, info);
}
function logError(err, vm, info) {
    if (true) {
        warn$2("Error in ".concat(info, ": \"").concat(err.toString(), "\""), vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
        console.error(err);
    }
    else {
        throw err;
    }
}

/* globals MutationObserver */
var isUsingMicroTask = false;
var callbacks = [];
var pending = false;
function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
        copies[i]();
    }
}
// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;
// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p_1 = Promise.resolve();
    timerFunc = function () {
        p_1.then(flushCallbacks);
        // In problematic UIWebViews, Promise.then doesn't completely break, but
        // it can get stuck in a weird state where callbacks are pushed into the
        // microtask queue but the queue isn't being flushed, until the browser
        // needs to do some other work, e.g. handle a timer. Therefore we can
        // "force" the microtask queue to be flushed by adding an empty timer.
        if (isIOS)
            setTimeout(noop);
    };
    isUsingMicroTask = true;
}
else if (!isIE &&
    typeof MutationObserver !== 'undefined' &&
    (isNative(MutationObserver) ||
        // PhantomJS and iOS 7.x
        MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter_1 = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode_1 = document.createTextNode(String(counter_1));
    observer.observe(textNode_1, {
        characterData: true
    });
    timerFunc = function () {
        counter_1 = (counter_1 + 1) % 2;
        textNode_1.data = String(counter_1);
    };
    isUsingMicroTask = true;
}
else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Technically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
        setImmediate(flushCallbacks);
    };
}
else {
    // Fallback to setTimeout.
    timerFunc = function () {
        setTimeout(flushCallbacks, 0);
    };
}
/**
 * @internal
 */
function nextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
        if (cb) {
            try {
                cb.call(ctx);
            }
            catch (e) {
                handleError(e, ctx, 'nextTick');
            }
        }
        else if (_resolve) {
            _resolve(ctx);
        }
    });
    if (!pending) {
        pending = true;
        timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(function (resolve) {
            _resolve = resolve;
        });
    }
}

function useCssModule(name) {
    if (name === void 0) { name = '$style'; }
    /* istanbul ignore else */
    {
        if (!currentInstance) {
             true && warn$2("useCssModule must be called inside setup()");
            return emptyObject;
        }
        var mod = currentInstance[name];
        if (!mod) {
             true &&
                warn$2("Current instance does not have CSS module named \"".concat(name, "\"."));
            return emptyObject;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    if (!inBrowser && !false)
        return;
    var instance = currentInstance;
    if (!instance) {
         true &&
            warn$2("useCssVars is called without current active component instance.");
        return;
    }
    watchPostEffect(function () {
        var el = instance.$el;
        var vars = getter(instance, instance._setupProxy);
        if (el && el.nodeType === 1) {
            var style = el.style;
            for (var key in vars) {
                style.setProperty("--".concat(key), vars[key]);
            }
        }
    });
}

/**
 * v3-compatible async component API.
 * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts
 * because it relies on existing manual types
 */
function defineAsyncComponent(source) {
    if (isFunction(source)) {
        source = { loader: source };
    }
    var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, // undefined = never times out
    _b = source.suspensible, // undefined = never times out
    suspensible = _b === void 0 ? false : _b, // in Vue 3 default is true
    userOnError = source.onError;
    if ( true && suspensible) {
        warn$2("The suspensiblbe option for async components is not supported in Vue2. It is ignored.");
    }
    var pendingRequest = null;
    var retries = 0;
    var retry = function () {
        retries++;
        pendingRequest = null;
        return load();
    };
    var load = function () {
        var thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(function (err) {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise(function (resolve, reject) {
                            var userRetry = function () { return resolve(retry()); };
                            var userFail = function () { return reject(err); };
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then(function (comp) {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if ( true && !comp) {
                        warn$2("Async component loader resolved to undefined. " +
                            "If you are using retry(), make sure to return its return value.");
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if ( true && comp && !isObject(comp) && !isFunction(comp)) {
                        throw new Error("Invalid async component load result: ".concat(comp));
                    }
                    return comp;
                })));
    };
    return function () {
        var component = load();
        return {
            component: component,
            delay: delay,
            timeout: timeout,
            error: errorComponent,
            loading: loadingComponent
        };
    };
}

function createLifeCycle(hookName) {
    return function (fn, target) {
        if (target === void 0) { target = currentInstance; }
        if (!target) {
             true &&
                warn$2("".concat(formatName(hookName), " is called when there is no active component instance to be ") +
                    "associated with. " +
                    "Lifecycle injection APIs can only be used during execution of setup().");
            return;
        }
        return injectHook(target, hookName, fn);
    };
}
function formatName(name) {
    if (name === 'beforeDestroy') {
        name = 'beforeUnmount';
    }
    else if (name === 'destroyed') {
        name = 'unmounted';
    }
    return "on".concat(name[0].toUpperCase() + name.slice(1));
}
function injectHook(instance, hookName, fn) {
    var options = instance.$options;
    options[hookName] = mergeLifecycleHook(options[hookName], fn);
}
var onBeforeMount = createLifeCycle('beforeMount');
var onMounted = createLifeCycle('mounted');
var onBeforeUpdate = createLifeCycle('beforeUpdate');
var onUpdated = createLifeCycle('updated');
var onBeforeUnmount = createLifeCycle('beforeDestroy');
var onUnmounted = createLifeCycle('destroyed');
var onActivated = createLifeCycle('activated');
var onDeactivated = createLifeCycle('deactivated');
var onServerPrefetch = createLifeCycle('serverPrefetch');
var onRenderTracked = createLifeCycle('renderTracked');
var onRenderTriggered = createLifeCycle('renderTriggered');
var injectErrorCapturedHook = createLifeCycle('errorCaptured');
function onErrorCaptured(hook, target) {
    if (target === void 0) { target = currentInstance; }
    injectErrorCapturedHook(hook, target);
}

/**
 * Note: also update dist/vue.runtime.mjs when adding new exports to this file.
 */
var version = '2.7.14';
/**
 * @internal type is manually declared in <root>/types/v3-define-component.d.ts
 */
function defineComponent(options) {
    return options;
}

var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
    return val;
}
function _traverse(val, seen) {
    var i, keys;
    var isA = isArray(val);
    if ((!isA && !isObject(val)) ||
        val.__v_skip /* ReactiveFlags.SKIP */ ||
        Object.isFrozen(val) ||
        val instanceof VNode) {
        return;
    }
    if (val.__ob__) {
        var depId = val.__ob__.dep.id;
        if (seen.has(depId)) {
            return;
        }
        seen.add(depId);
    }
    if (isA) {
        i = val.length;
        while (i--)
            _traverse(val[i], seen);
    }
    else if (isRef(val)) {
        _traverse(val.value, seen);
    }
    else {
        keys = Object.keys(val);
        i = keys.length;
        while (i--)
            _traverse(val[keys[i]], seen);
    }
}

var uid$1 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 * @internal
 */
var Watcher = /** @class */ (function () {
    function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
        recordEffectScope(this, 
        // if the active effect scope is manually created (not a component scope),
        // prioritize it
        activeEffectScope && !activeEffectScope._vm
            ? activeEffectScope
            : vm
                ? vm._scope
                : undefined);
        if ((this.vm = vm) && isRenderWatcher) {
            vm._watcher = this;
        }
        // options
        if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.lazy = !!options.lazy;
            this.sync = !!options.sync;
            this.before = options.before;
            if (true) {
                this.onTrack = options.onTrack;
                this.onTrigger = options.onTrigger;
            }
        }
        else {
            this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$1; // uid for batching
        this.active = true;
        this.post = false;
        this.dirty = this.lazy; // for lazy watchers
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set();
        this.newDepIds = new _Set();
        this.expression =  true ? expOrFn.toString() : 0;
        // parse expression for getter
        if (isFunction(expOrFn)) {
            this.getter = expOrFn;
        }
        else {
            this.getter = parsePath(expOrFn);
            if (!this.getter) {
                this.getter = noop;
                 true &&
                    warn$2("Failed watching path: \"".concat(expOrFn, "\" ") +
                        'Watcher only accepts simple dot-delimited paths. ' +
                        'For full control, use a function instead.', vm);
            }
        }
        this.value = this.lazy ? undefined : this.get();
    }
    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    Watcher.prototype.get = function () {
        pushTarget(this);
        var value;
        var vm = this.vm;
        try {
            value = this.getter.call(vm, vm);
        }
        catch (e) {
            if (this.user) {
                handleError(e, vm, "getter for watcher \"".concat(this.expression, "\""));
            }
            else {
                throw e;
            }
        }
        finally {
            // "touch" every property so they are all tracked as
            // dependencies for deep watching
            if (this.deep) {
                traverse(value);
            }
            popTarget();
            this.cleanupDeps();
        }
        return value;
    };
    /**
     * Add a dependency to this directive.
     */
    Watcher.prototype.addDep = function (dep) {
        var id = dep.id;
        if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);
            if (!this.depIds.has(id)) {
                dep.addSub(this);
            }
        }
    };
    /**
     * Clean up for dependency collection.
     */
    Watcher.prototype.cleanupDeps = function () {
        var i = this.deps.length;
        while (i--) {
            var dep = this.deps[i];
            if (!this.newDepIds.has(dep.id)) {
                dep.removeSub(this);
            }
        }
        var tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
    };
    /**
     * Subscriber interface.
     * Will be called when a dependency changes.
     */
    Watcher.prototype.update = function () {
        /* istanbul ignore else */
        if (this.lazy) {
            this.dirty = true;
        }
        else if (this.sync) {
            this.run();
        }
        else {
            queueWatcher(this);
        }
    };
    /**
     * Scheduler job interface.
     * Will be called by the scheduler.
     */
    Watcher.prototype.run = function () {
        if (this.active) {
            var value = this.get();
            if (value !== this.value ||
                // Deep watchers and watchers on Object/Arrays should fire even
                // when the value is the same, because the value may
                // have mutated.
                isObject(value) ||
                this.deep) {
                // set new value
                var oldValue = this.value;
                this.value = value;
                if (this.user) {
                    var info = "callback for watcher \"".concat(this.expression, "\"");
                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
                }
                else {
                    this.cb.call(this.vm, value, oldValue);
                }
            }
        }
    };
    /**
     * Evaluate the value of the watcher.
     * This only gets called for lazy watchers.
     */
    Watcher.prototype.evaluate = function () {
        this.value = this.get();
        this.dirty = false;
    };
    /**
     * Depend on all deps collected by this watcher.
     */
    Watcher.prototype.depend = function () {
        var i = this.deps.length;
        while (i--) {
            this.deps[i].depend();
        }
    };
    /**
     * Remove self from all dependencies' subscriber list.
     */
    Watcher.prototype.teardown = function () {
        if (this.vm && !this.vm._isBeingDestroyed) {
            remove$2(this.vm._scope.effects, this);
        }
        if (this.active) {
            var i = this.deps.length;
            while (i--) {
                this.deps[i].removeSub(this);
            }
            this.active = false;
            if (this.onStop) {
                this.onStop();
            }
        }
    };
    return Watcher;
}());

var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
};
function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
        return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
        this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function initState(vm) {
    var opts = vm.$options;
    if (opts.props)
        initProps$1(vm, opts.props);
    // Composition API
    initSetup(vm);
    if (opts.methods)
        initMethods(vm, opts.methods);
    if (opts.data) {
        initData(vm);
    }
    else {
        var ob = observe((vm._data = {}));
        ob && ob.vmCount++;
    }
    if (opts.computed)
        initComputed$1(vm, opts.computed);
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
    }
}
function initProps$1(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = (vm._props = shallowReactive({}));
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = (vm.$options._propKeys = []);
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
        toggleObserving(false);
    }
    var _loop_1 = function (key) {
        keys.push(key);
        var value = validateProp(key, propsOptions, propsData, vm);
        /* istanbul ignore else */
        if (true) {
            var hyphenatedKey = hyphenate(key);
            if (isReservedAttribute(hyphenatedKey) ||
                config.isReservedAttr(hyphenatedKey)) {
                warn$2("\"".concat(hyphenatedKey, "\" is a reserved attribute and cannot be used as component prop."), vm);
            }
            defineReactive(props, key, value, function () {
                if (!isRoot && !isUpdatingChildComponent) {
                    warn$2("Avoid mutating a prop directly since the value will be " +
                        "overwritten whenever the parent component re-renders. " +
                        "Instead, use a data or computed property based on the prop's " +
                        "value. Prop being mutated: \"".concat(key, "\""), vm);
                }
            });
        }
        else {}
        // static props are already proxied on the component's prototype
        // during Vue.extend(). We only need to proxy props defined at
        // instantiation here.
        if (!(key in vm)) {
            proxy(vm, "_props", key);
        }
    };
    for (var key in propsOptions) {
        _loop_1(key);
    }
    toggleObserving(true);
}
function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
        data = {};
         true &&
            warn$2('data functions should return an object:\n' +
                'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
        var key = keys[i];
        if (true) {
            if (methods && hasOwn(methods, key)) {
                warn$2("Method \"".concat(key, "\" has already been defined as a data property."), vm);
            }
        }
        if (props && hasOwn(props, key)) {
             true &&
                warn$2("The data property \"".concat(key, "\" is already declared as a prop. ") +
                    "Use prop default value instead.", vm);
        }
        else if (!isReserved(key)) {
            proxy(vm, "_data", key);
        }
    }
    // observe data
    var ob = observe(data);
    ob && ob.vmCount++;
}
function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
        return data.call(vm, vm);
    }
    catch (e) {
        handleError(e, vm, "data()");
        return {};
    }
    finally {
        popTarget();
    }
}
var computedWatcherOptions = { lazy: true };
function initComputed$1(vm, computed) {
    // $flow-disable-line
    var watchers = (vm._computedWatchers = Object.create(null));
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();
    for (var key in computed) {
        var userDef = computed[key];
        var getter = isFunction(userDef) ? userDef : userDef.get;
        if ( true && getter == null) {
            warn$2("Getter is missing for computed property \"".concat(key, "\"."), vm);
        }
        if (!isSSR) {
            // create internal watcher for the computed property.
            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
        }
        // component-defined computed properties are already defined on the
        // component prototype. We only need to define computed properties defined
        // at instantiation here.
        if (!(key in vm)) {
            defineComputed(vm, key, userDef);
        }
        else if (true) {
            if (key in vm.$data) {
                warn$2("The computed property \"".concat(key, "\" is already defined in data."), vm);
            }
            else if (vm.$options.props && key in vm.$options.props) {
                warn$2("The computed property \"".concat(key, "\" is already defined as a prop."), vm);
            }
            else if (vm.$options.methods && key in vm.$options.methods) {
                warn$2("The computed property \"".concat(key, "\" is already defined as a method."), vm);
            }
        }
    }
}
function defineComputed(target, key, userDef) {
    var shouldCache = !isServerRendering();
    if (isFunction(userDef)) {
        sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
        sharedPropertyDefinition.set = noop;
    }
    else {
        sharedPropertyDefinition.get = userDef.get
            ? shouldCache && userDef.cache !== false
                ? createComputedGetter(key)
                : createGetterInvoker(userDef.get)
            : noop;
        sharedPropertyDefinition.set = userDef.set || noop;
    }
    if ( true && sharedPropertyDefinition.set === noop) {
        sharedPropertyDefinition.set = function () {
            warn$2("Computed property \"".concat(key, "\" was assigned to but it has no setter."), this);
        };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function createComputedGetter(key) {
    return function computedGetter() {
        var watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
            if (watcher.dirty) {
                watcher.evaluate();
            }
            if (Dep.target) {
                if ( true && Dep.target.onTrack) {
                    Dep.target.onTrack({
                        effect: Dep.target,
                        target: this,
                        type: "get" /* TrackOpTypes.GET */,
                        key: key
                    });
                }
                watcher.depend();
            }
            return watcher.value;
        }
    };
}
function createGetterInvoker(fn) {
    return function computedGetter() {
        return fn.call(this, this);
    };
}
function initMethods(vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
        if (true) {
            if (typeof methods[key] !== 'function') {
                warn$2("Method \"".concat(key, "\" has type \"").concat(typeof methods[key], "\" in the component definition. ") +
                    "Did you reference the function correctly?", vm);
            }
            if (props && hasOwn(props, key)) {
                warn$2("Method \"".concat(key, "\" has already been defined as a prop."), vm);
            }
            if (key in vm && isReserved(key)) {
                warn$2("Method \"".concat(key, "\" conflicts with an existing Vue instance method. ") +
                    "Avoid defining component methods that start with _ or $.");
            }
        }
        vm[key] = typeof methods[key] !== 'function' ? noop : bind$1(methods[key], vm);
    }
}
function initWatch(vm, watch) {
    for (var key in watch) {
        var handler = watch[key];
        if (isArray(handler)) {
            for (var i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i]);
            }
        }
        else {
            createWatcher(vm, key, handler);
        }
    }
}
function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
        options = handler;
        handler = handler.handler;
    }
    if (typeof handler === 'string') {
        handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
}
function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () {
        return this._data;
    };
    var propsDef = {};
    propsDef.get = function () {
        return this._props;
    };
    if (true) {
        dataDef.set = function () {
            warn$2('Avoid replacing instance root $data. ' +
                'Use nested data properties instead.', this);
        };
        propsDef.set = function () {
            warn$2("$props is readonly.", this);
        };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);
    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;
    Vue.prototype.$watch = function (expOrFn, cb, options) {
        var vm = this;
        if (isPlainObject(cb)) {
            return createWatcher(vm, expOrFn, cb, options);
        }
        options = options || {};
        options.user = true;
        var watcher = new Watcher(vm, expOrFn, cb, options);
        if (options.immediate) {
            var info = "callback for immediate watcher \"".concat(watcher.expression, "\"");
            pushTarget();
            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
            popTarget();
        }
        return function unwatchFn() {
            watcher.teardown();
        };
    };
}

function initProvide(vm) {
    var provideOption = vm.$options.provide;
    if (provideOption) {
        var provided = isFunction(provideOption)
            ? provideOption.call(vm)
            : provideOption;
        if (!isObject(provided)) {
            return;
        }
        var source = resolveProvided(vm);
        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to
        // iterate the keys ourselves.
        var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
        }
    }
}
function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
        toggleObserving(false);
        Object.keys(result).forEach(function (key) {
            /* istanbul ignore else */
            if (true) {
                defineReactive(vm, key, result[key], function () {
                    warn$2("Avoid mutating an injected value directly since the changes will be " +
                        "overwritten whenever the provided component re-renders. " +
                        "injection being mutated: \"".concat(key, "\""), vm);
                });
            }
            else {}
        });
        toggleObserving(true);
    }
}
function resolveInject(inject, vm) {
    if (inject) {
        // inject is :any because flow is not smart enough to figure out cached
        var result = Object.create(null);
        var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            // #6574 in case the inject object is observed...
            if (key === '__ob__')
                continue;
            var provideKey = inject[key].from;
            if (provideKey in vm._provided) {
                result[key] = vm._provided[provideKey];
            }
            else if ('default' in inject[key]) {
                var provideDefault = inject[key].default;
                result[key] = isFunction(provideDefault)
                    ? provideDefault.call(vm)
                    : provideDefault;
            }
            else if (true) {
                warn$2("Injection \"".concat(key, "\" not found"), vm);
            }
        }
        return result;
    }
}

var uid = 0;
function initMixin$1(Vue) {
    Vue.prototype._init = function (options) {
        var vm = this;
        // a uid
        vm._uid = uid++;
        var startTag, endTag;
        /* istanbul ignore if */
        if ( true && config.performance && mark) {
            startTag = "vue-perf-start:".concat(vm._uid);
            endTag = "vue-perf-end:".concat(vm._uid);
            mark(startTag);
        }
        // a flag to mark this as a Vue instance without having to do instanceof
        // check
        vm._isVue = true;
        // avoid instances from being observed
        vm.__v_skip = true;
        // effect scope
        vm._scope = new EffectScope(true /* detached */);
        vm._scope._vm = true;
        // merge options
        if (options && options._isComponent) {
            // optimize internal component instantiation
            // since dynamic options merging is pretty slow, and none of the
            // internal component options needs special treatment.
            initInternalComponent(vm, options);
        }
        else {
            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
        }
        /* istanbul ignore else */
        if (true) {
            initProxy(vm);
        }
        else {}
        // expose real self
        vm._self = vm;
        initLifecycle(vm);
        initEvents(vm);
        initRender(vm);
        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);
        initInjections(vm); // resolve injections before data/props
        initState(vm);
        initProvide(vm); // resolve provide after data/props
        callHook$1(vm, 'created');
        /* istanbul ignore if */
        if ( true && config.performance && mark) {
            vm._name = formatComponentName(vm, false);
            mark(endTag);
            measure("vue ".concat(vm._name, " init"), startTag, endTag);
        }
        if (vm.$options.el) {
            vm.$mount(vm.$options.el);
        }
    };
}
function initInternalComponent(vm, options) {
    var opts = (vm.$options = Object.create(vm.constructor.options));
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;
    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;
    if (options.render) {
        opts.render = options.render;
        opts.staticRenderFns = options.staticRenderFns;
    }
}
function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
        var superOptions = resolveConstructorOptions(Ctor.super);
        var cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
            // super option changed,
            // need to resolve new options.
            Ctor.superOptions = superOptions;
            // check if there are any late-modified/attached options (#4976)
            var modifiedOptions = resolveModifiedOptions(Ctor);
            // update base extend options
            if (modifiedOptions) {
                extend(Ctor.extendOptions, modifiedOptions);
            }
            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
            if (options.name) {
                options.components[options.name] = Ctor;
            }
        }
    }
    return options;
}
function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
        if (latest[key] !== sealed[key]) {
            if (!modified)
                modified = {};
            modified[key] = latest[key];
        }
    }
    return modified;
}

function FunctionalRenderContext(data, props, children, parent, Ctor) {
    var _this = this;
    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
        contextVm = Object.create(parent);
        contextVm._original = parent;
    }
    else {
        // the context vm passed in is a functional context as well.
        // in this case we want to make sure we are able to get a hold to the
        // real context instance.
        contextVm = parent;
        // @ts-ignore
        parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;
    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
        if (!_this.$slots) {
            normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));
        }
        return _this.$slots;
    };
    Object.defineProperty(this, 'scopedSlots', {
        enumerable: true,
        get: function () {
            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
        }
    });
    // support for compiled functional template
    if (isCompiled) {
        // exposing $options for renderStatic()
        this.$options = options;
        // pre-resolve slots for renderSlot()
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
    }
    if (options._scopeId) {
        this._c = function (a, b, c, d) {
            var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
            if (vnode && !isArray(vnode)) {
                vnode.fnScopeId = options._scopeId;
                vnode.fnContext = parent;
            }
            return vnode;
        };
    }
    else {
        this._c = function (a, b, c, d) {
            return createElement$1(contextVm, a, b, c, d, needNormalization);
        };
    }
}
installRenderHelpers(FunctionalRenderContext.prototype);
function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
        for (var key in propOptions) {
            props[key] = validateProp(key, propOptions, propsData || emptyObject);
        }
    }
    else {
        if (isDef(data.attrs))
            mergeProps(props, data.attrs);
        if (isDef(data.props))
            mergeProps(props, data.props);
    }
    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
    var vnode = options.render.call(null, renderContext._c, renderContext);
    if (vnode instanceof VNode) {
        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
    }
    else if (isArray(vnode)) {
        var vnodes = normalizeChildren(vnode) || [];
        var res = new Array(vnodes.length);
        for (var i = 0; i < vnodes.length; i++) {
            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
        }
        return res;
    }
}
function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    if (true) {
        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =
            renderContext;
    }
    if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
}
function mergeProps(to, from) {
    for (var key in from) {
        to[camelize(key)] = from[key];
    }
}

function getComponentName(options) {
    return options.name || options.__name || options._componentTag;
}
// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
    init: function (vnode, hydrating) {
        if (vnode.componentInstance &&
            !vnode.componentInstance._isDestroyed &&
            vnode.data.keepAlive) {
            // kept-alive components, treat as a patch
            var mountedNode = vnode; // work around flow
            componentVNodeHooks.prepatch(mountedNode, mountedNode);
        }
        else {
            var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));
            child.$mount(hydrating ? vnode.elm : undefined, hydrating);
        }
    },
    prepatch: function (oldVnode, vnode) {
        var options = vnode.componentOptions;
        var child = (vnode.componentInstance = oldVnode.componentInstance);
        updateChildComponent(child, options.propsData, // updated props
        options.listeners, // updated listeners
        vnode, // new parent vnode
        options.children // new children
        );
    },
    insert: function (vnode) {
        var context = vnode.context, componentInstance = vnode.componentInstance;
        if (!componentInstance._isMounted) {
            componentInstance._isMounted = true;
            callHook$1(componentInstance, 'mounted');
        }
        if (vnode.data.keepAlive) {
            if (context._isMounted) {
                // vue-router#1212
                // During updates, a kept-alive component's child components may
                // change, so directly walking the tree here may call activated hooks
                // on incorrect children. Instead we push them into a queue which will
                // be processed after the whole patch process ended.
                queueActivatedComponent(componentInstance);
            }
            else {
                activateChildComponent(componentInstance, true /* direct */);
            }
        }
    },
    destroy: function (vnode) {
        var componentInstance = vnode.componentInstance;
        if (!componentInstance._isDestroyed) {
            if (!vnode.data.keepAlive) {
                componentInstance.$destroy();
            }
            else {
                deactivateChildComponent(componentInstance, true /* direct */);
            }
        }
    }
};
var hooksToMerge = Object.keys(componentVNodeHooks);
function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
        return;
    }
    var baseCtor = context.$options._base;
    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
    }
    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
        if (true) {
            warn$2("Invalid Component definition: ".concat(String(Ctor)), context);
        }
        return;
    }
    // async component
    var asyncFactory;
    // @ts-expect-error
    if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
        if (Ctor === undefined) {
            // return a placeholder node for async component, which is rendered
            // as a comment node but preserves all the raw information for the node.
            // the information will be used for async server-rendering and hydration.
            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
        }
    }
    data = data || {};
    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);
    // transform component v-model data into props & events
    if (isDef(data.model)) {
        // @ts-expect-error
        transformModel(Ctor.options, data);
    }
    // extract props
    // @ts-expect-error
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);
    // functional component
    // @ts-expect-error
    if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children);
    }
    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;
    // @ts-expect-error
    if (isTrue(Ctor.options.abstract)) {
        // abstract components do not keep anything
        // other than props & listeners & slot
        // work around flow
        var slot = data.slot;
        data = {};
        if (slot) {
            data.slot = slot;
        }
    }
    // install component management hooks onto the placeholder node
    installComponentHooks(data);
    // return a placeholder vnode
    // @ts-expect-error
    var name = getComponentName(Ctor.options) || tag;
    var vnode = new VNode(
    // @ts-expect-error
    "vue-component-".concat(Ctor.cid).concat(name ? "-".concat(name) : ''), data, undefined, undefined, undefined, context, 
    // @ts-expect-error
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
    return vnode;
}
function createComponentInstanceForVnode(
// we know it's MountedComponentVNode but flow doesn't
vnode, 
// activeInstance in lifecycle state
parent) {
    var options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent: parent
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
}
function installComponentHooks(data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
        var key = hooksToMerge[i];
        var existing = hooks[key];
        var toMerge = componentVNodeHooks[key];
        // @ts-expect-error
        if (existing !== toMerge && !(existing && existing._merged)) {
            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;
        }
    }
}
function mergeHook(f1, f2) {
    var merged = function (a, b) {
        // flow complains about extra args which is why we use any
        f1(a, b);
        f2(a, b);
    };
    merged._merged = true;
    return merged;
}
// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
    var prop = (options.model && options.model.prop) || 'value';
    var event = (options.model && options.model.event) || 'input';
    (data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
        if (isArray(existing)
            ? existing.indexOf(callback) === -1
            : existing !== callback) {
            on[event] = [callback].concat(existing);
        }
    }
    else {
        on[event] = callback;
    }
}

var warn$2 = noop;
var tip = noop;
var generateComponentTrace; // work around flow check
var formatComponentName;
if (true) {
    var hasConsole_1 = typeof console !== 'undefined';
    var classifyRE_1 = /(?:^|[-_])(\w)/g;
    var classify_1 = function (str) {
        return str.replace(classifyRE_1, function (c) { return c.toUpperCase(); }).replace(/[-_]/g, '');
    };
    warn$2 = function (msg, vm) {
        if (vm === void 0) { vm = currentInstance; }
        var trace = vm ? generateComponentTrace(vm) : '';
        if (config.warnHandler) {
            config.warnHandler.call(null, msg, vm, trace);
        }
        else if (hasConsole_1 && !config.silent) {
            console.error("[Vue warn]: ".concat(msg).concat(trace));
        }
    };
    tip = function (msg, vm) {
        if (hasConsole_1 && !config.silent) {
            console.warn("[Vue tip]: ".concat(msg) + (vm ? generateComponentTrace(vm) : ''));
        }
    };
    formatComponentName = function (vm, includeFile) {
        if (vm.$root === vm) {
            return '<Root>';
        }
        var options = isFunction(vm) && vm.cid != null
            ? vm.options
            : vm._isVue
                ? vm.$options || vm.constructor.options
                : vm;
        var name = getComponentName(options);
        var file = options.__file;
        if (!name && file) {
            var match = file.match(/([^/\\]+)\.vue$/);
            name = match && match[1];
        }
        return ((name ? "<".concat(classify_1(name), ">") : "<Anonymous>") +
            (file && includeFile !== false ? " at ".concat(file) : ''));
    };
    var repeat_1 = function (str, n) {
        var res = '';
        while (n) {
            if (n % 2 === 1)
                res += str;
            if (n > 1)
                str += str;
            n >>= 1;
        }
        return res;
    };
    generateComponentTrace = function (vm) {
        if (vm._isVue && vm.$parent) {
            var tree = [];
            var currentRecursiveSequence = 0;
            while (vm) {
                if (tree.length > 0) {
                    var last = tree[tree.length - 1];
                    if (last.constructor === vm.constructor) {
                        currentRecursiveSequence++;
                        vm = vm.$parent;
                        continue;
                    }
                    else if (currentRecursiveSequence > 0) {
                        tree[tree.length - 1] = [last, currentRecursiveSequence];
                        currentRecursiveSequence = 0;
                    }
                }
                tree.push(vm);
                vm = vm.$parent;
            }
            return ('\n\nfound in\n\n' +
                tree
                    .map(function (vm, i) {
                    return "".concat(i === 0 ? '---> ' : repeat_1(' ', 5 + i * 2)).concat(isArray(vm)
                        ? "".concat(formatComponentName(vm[0]), "... (").concat(vm[1], " recursive calls)")
                        : formatComponentName(vm));
                })
                    .join('\n'));
        }
        else {
            return "\n\n(found in ".concat(formatComponentName(vm), ")");
        }
    };
}

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */
if (true) {
    strats.el = strats.propsData = function (parent, child, vm, key) {
        if (!vm) {
            warn$2("option \"".concat(key, "\" can only be used during instance ") +
                'creation with the `new` keyword.');
        }
        return defaultStrat(parent, child);
    };
}
/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from, recursive) {
    if (recursive === void 0) { recursive = true; }
    if (!from)
        return to;
    var key, toVal, fromVal;
    var keys = hasSymbol
        ? Reflect.ownKeys(from)
        : Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
        key = keys[i];
        // in case the object is already observed...
        if (key === '__ob__')
            continue;
        toVal = to[key];
        fromVal = from[key];
        if (!recursive || !hasOwn(to, key)) {
            set(to, key, fromVal);
        }
        else if (toVal !== fromVal &&
            isPlainObject(toVal) &&
            isPlainObject(fromVal)) {
            mergeData(toVal, fromVal);
        }
    }
    return to;
}
/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
        // in a Vue.extend merge, both should be functions
        if (!childVal) {
            return parentVal;
        }
        if (!parentVal) {
            return childVal;
        }
        // when parentVal & childVal are both present,
        // we need to return a function that returns the
        // merged result of both functions... no need to
        // check if parentVal is a function here because
        // it has to be a function to pass previous merges.
        return function mergedDataFn() {
            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);
        };
    }
    else {
        return function mergedInstanceDataFn() {
            // instance merge
            var instanceData = isFunction(childVal)
                ? childVal.call(vm, vm)
                : childVal;
            var defaultData = isFunction(parentVal)
                ? parentVal.call(vm, vm)
                : parentVal;
            if (instanceData) {
                return mergeData(instanceData, defaultData);
            }
            else {
                return defaultData;
            }
        };
    }
}
strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
        if (childVal && typeof childVal !== 'function') {
             true &&
                warn$2('The "data" option should be a function ' +
                    'that returns a per-instance value in component ' +
                    'definitions.', vm);
            return parentVal;
        }
        return mergeDataOrFn(parentVal, childVal);
    }
    return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */
function mergeLifecycleHook(parentVal, childVal) {
    var res = childVal
        ? parentVal
            ? parentVal.concat(childVal)
            : isArray(childVal)
                ? childVal
                : [childVal]
        : parentVal;
    return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
        if (res.indexOf(hooks[i]) === -1) {
            res.push(hooks[i]);
        }
    }
    return res;
}
LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeLifecycleHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);
    if (childVal) {
         true && assertObjectType(key, childVal, vm);
        return extend(res, childVal);
    }
    else {
        return res;
    }
}
ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    //@ts-expect-error work around
    if (parentVal === nativeWatch)
        parentVal = undefined;
    //@ts-expect-error work around
    if (childVal === nativeWatch)
        childVal = undefined;
    /* istanbul ignore if */
    if (!childVal)
        return Object.create(parentVal || null);
    if (true) {
        assertObjectType(key, childVal, vm);
    }
    if (!parentVal)
        return childVal;
    var ret = {};
    extend(ret, parentVal);
    for (var key_1 in childVal) {
        var parent_1 = ret[key_1];
        var child = childVal[key_1];
        if (parent_1 && !isArray(parent_1)) {
            parent_1 = [parent_1];
        }
        ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];
    }
    return ret;
};
/**
 * Other object hashes.
 */
strats.props =
    strats.methods =
        strats.inject =
            strats.computed =
                function (parentVal, childVal, vm, key) {
                    if (childVal && "development" !== 'production') {
                        assertObjectType(key, childVal, vm);
                    }
                    if (!parentVal)
                        return childVal;
                    var ret = Object.create(null);
                    extend(ret, parentVal);
                    if (childVal)
                        extend(ret, childVal);
                    return ret;
                };
strats.provide = function (parentVal, childVal) {
    if (!parentVal)
        return childVal;
    return function () {
        var ret = Object.create(null);
        mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);
        if (childVal) {
            mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive
            );
        }
        return ret;
    };
};
/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */
function checkComponents(options) {
    for (var key in options.components) {
        validateComponentName(key);
    }
}
function validateComponentName(name) {
    if (!new RegExp("^[a-zA-Z][\\-\\.0-9_".concat(unicodeRegExp.source, "]*$")).test(name)) {
        warn$2('Invalid component name: "' +
            name +
            '". Component names ' +
            'should conform to valid custom element name in html5 specification.');
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
        warn$2('Do not use built-in or reserved HTML elements as component ' +
            'id: ' +
            name);
    }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
    var props = options.props;
    if (!props)
        return;
    var res = {};
    var i, val, name;
    if (isArray(props)) {
        i = props.length;
        while (i--) {
            val = props[i];
            if (typeof val === 'string') {
                name = camelize(val);
                res[name] = { type: null };
            }
            else if (true) {
                warn$2('props must be strings when using array syntax.');
            }
        }
    }
    else if (isPlainObject(props)) {
        for (var key in props) {
            val = props[key];
            name = camelize(key);
            res[name] = isPlainObject(val) ? val : { type: val };
        }
    }
    else if (true) {
        warn$2("Invalid value for option \"props\": expected an Array or an Object, " +
            "but got ".concat(toRawType(props), "."), vm);
    }
    options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
    var inject = options.inject;
    if (!inject)
        return;
    var normalized = (options.inject = {});
    if (isArray(inject)) {
        for (var i = 0; i < inject.length; i++) {
            normalized[inject[i]] = { from: inject[i] };
        }
    }
    else if (isPlainObject(inject)) {
        for (var key in inject) {
            var val = inject[key];
            normalized[key] = isPlainObject(val)
                ? extend({ from: key }, val)
                : { from: val };
        }
    }
    else if (true) {
        warn$2("Invalid value for option \"inject\": expected an Array or an Object, " +
            "but got ".concat(toRawType(inject), "."), vm);
    }
}
/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives$1(options) {
    var dirs = options.directives;
    if (dirs) {
        for (var key in dirs) {
            var def = dirs[key];
            if (isFunction(def)) {
                dirs[key] = { bind: def, update: def };
            }
        }
    }
}
function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
        warn$2("Invalid value for option \"".concat(name, "\": expected an Object, ") +
            "but got ".concat(toRawType(value), "."), vm);
    }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
    if (true) {
        checkComponents(child);
    }
    if (isFunction(child)) {
        // @ts-expect-error
        child = child.options;
    }
    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives$1(child);
    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
        if (child.extends) {
            parent = mergeOptions(parent, child.extends, vm);
        }
        if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
                parent = mergeOptions(parent, child.mixins[i], vm);
            }
        }
    }
    var options = {};
    var key;
    for (key in parent) {
        mergeField(key);
    }
    for (key in child) {
        if (!hasOwn(parent, key)) {
            mergeField(key);
        }
    }
    function mergeField(key) {
        var strat = strats[key] || defaultStrat;
        options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
        return;
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id))
        return assets[id];
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId))
        return assets[camelizedId];
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId))
        return assets[PascalCaseId];
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if ( true && warnMissing && !res) {
        warn$2('Failed to resolve ' + type.slice(0, -1) + ': ' + id);
    }
    return res;
}

function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
        if (absent && !hasOwn(prop, 'default')) {
            value = false;
        }
        else if (value === '' || value === hyphenate(key)) {
            // only cast empty string / same name to boolean if
            // boolean has higher priority
            var stringIndex = getTypeIndex(String, prop.type);
            if (stringIndex < 0 || booleanIndex < stringIndex) {
                value = true;
            }
        }
    }
    // check default value
    if (value === undefined) {
        value = getPropDefaultValue(vm, prop, key);
        // since the default value is a fresh copy,
        // make sure to observe it.
        var prevShouldObserve = shouldObserve;
        toggleObserving(true);
        observe(value);
        toggleObserving(prevShouldObserve);
    }
    if (true) {
        assertProp(prop, key, value, vm, absent);
    }
    return value;
}
/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
        return undefined;
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if ( true && isObject(def)) {
        warn$2('Invalid default value for prop "' +
            key +
            '": ' +
            'Props with type Object/Array must use a factory function ' +
            'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm &&
        vm.$options.propsData &&
        vm.$options.propsData[key] === undefined &&
        vm._props[key] !== undefined) {
        return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return isFunction(def) && getType(prop.type) !== 'Function'
        ? def.call(vm)
        : def;
}
/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
        warn$2('Missing required prop: "' + name + '"', vm);
        return;
    }
    if (value == null && !prop.required) {
        return;
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
        if (!isArray(type)) {
            type = [type];
        }
        for (var i = 0; i < type.length && !valid; i++) {
            var assertedType = assertType(value, type[i], vm);
            expectedTypes.push(assertedType.expectedType || '');
            valid = assertedType.valid;
        }
    }
    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
    if (!valid && haveExpectedTypes) {
        warn$2(getInvalidTypeMessage(name, value, expectedTypes), vm);
        return;
    }
    var validator = prop.validator;
    if (validator) {
        if (!validator(value)) {
            warn$2('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
        }
    }
}
var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
function assertType(value, type, vm) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
        var t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = isPlainObject(value);
    }
    else if (expectedType === 'Array') {
        valid = isArray(value);
    }
    else {
        try {
            valid = value instanceof type;
        }
        catch (e) {
            warn$2('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
            valid = false;
        }
    }
    return {
        valid: valid,
        expectedType: expectedType
    };
}
var functionTypeCheckRE = /^\s*function (\w+)/;
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
    var match = fn && fn.toString().match(functionTypeCheckRE);
    return match ? match[1] : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (!isArray(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType(expectedTypes[i], type)) {
            return i;
        }
    }
    return -1;
}
function getInvalidTypeMessage(name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"".concat(name, "\".") +
        " Expected ".concat(expectedTypes.map(capitalize).join(', '));
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        isExplicable(typeof value) &&
        !isBoolean(expectedType, receivedType)) {
        message += " with value ".concat(styleValue(value, expectedType));
    }
    message += ", got ".concat(receivedType, " ");
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += "with value ".concat(styleValue(value, receivedType), ".");
    }
    return message;
}
function styleValue(value, type) {
    if (type === 'String') {
        return "\"".concat(value, "\"");
    }
    else if (type === 'Number') {
        return "".concat(Number(value));
    }
    else {
        return "".concat(value);
    }
}
var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable(value) {
    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });
}
function isBoolean() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });
}

function Vue(options) {
    if ( true && !(this instanceof Vue)) {
        warn$2('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
}
//@ts-expect-error Vue has function type
initMixin$1(Vue);
//@ts-expect-error Vue has function type
stateMixin(Vue);
//@ts-expect-error Vue has function type
eventsMixin(Vue);
//@ts-expect-error Vue has function type
lifecycleMixin(Vue);
//@ts-expect-error Vue has function type
renderMixin(Vue);

function initUse(Vue) {
    Vue.use = function (plugin) {
        var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
        if (installedPlugins.indexOf(plugin) > -1) {
            return this;
        }
        // additional parameters
        var args = toArray(arguments, 1);
        args.unshift(this);
        if (isFunction(plugin.install)) {
            plugin.install.apply(plugin, args);
        }
        else if (isFunction(plugin)) {
            plugin.apply(null, args);
        }
        installedPlugins.push(plugin);
        return this;
    };
}

function initMixin(Vue) {
    Vue.mixin = function (mixin) {
        this.options = mergeOptions(this.options, mixin);
        return this;
    };
}

function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;
    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
        extendOptions = extendOptions || {};
        var Super = this;
        var SuperId = Super.cid;
        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
        if (cachedCtors[SuperId]) {
            return cachedCtors[SuperId];
        }
        var name = getComponentName(extendOptions) || getComponentName(Super.options);
        if ( true && name) {
            validateComponentName(name);
        }
        var Sub = function VueComponent(options) {
            this._init(options);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(Super.options, extendOptions);
        Sub['super'] = Super;
        // For props and computed properties, we define the proxy getters on
        // the Vue instances at extension time, on the extended prototype. This
        // avoids Object.defineProperty calls for each instance created.
        if (Sub.options.props) {
            initProps(Sub);
        }
        if (Sub.options.computed) {
            initComputed(Sub);
        }
        // allow further extension/mixin/plugin usage
        Sub.extend = Super.extend;
        Sub.mixin = Super.mixin;
        Sub.use = Super.use;
        // create asset registers, so extended classes
        // can have their private assets too.
        ASSET_TYPES.forEach(function (type) {
            Sub[type] = Super[type];
        });
        // enable recursive self-lookup
        if (name) {
            Sub.options.components[name] = Sub;
        }
        // keep a reference to the super options at extension time.
        // later at instantiation we can check if Super's options have
        // been updated.
        Sub.superOptions = Super.options;
        Sub.extendOptions = extendOptions;
        Sub.sealedOptions = extend({}, Sub.options);
        // cache constructor
        cachedCtors[SuperId] = Sub;
        return Sub;
    };
}
function initProps(Comp) {
    var props = Comp.options.props;
    for (var key in props) {
        proxy(Comp.prototype, "_props", key);
    }
}
function initComputed(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
        defineComputed(Comp.prototype, key, computed[key]);
    }
}

function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
        // @ts-expect-error function is not exact same type
        Vue[type] = function (id, definition) {
            if (!definition) {
                return this.options[type + 's'][id];
            }
            else {
                /* istanbul ignore if */
                if ( true && type === 'component') {
                    validateComponentName(id);
                }
                if (type === 'component' && isPlainObject(definition)) {
                    // @ts-expect-error
                    definition.name = definition.name || id;
                    definition = this.options._base.extend(definition);
                }
                if (type === 'directive' && isFunction(definition)) {
                    definition = { bind: definition, update: definition };
                }
                this.options[type + 's'][id] = definition;
                return definition;
            }
        };
    });
}

function _getComponentName(opts) {
    return opts && (getComponentName(opts.Ctor.options) || opts.tag);
}
function matches(pattern, name) {
    if (isArray(pattern)) {
        return pattern.indexOf(name) > -1;
    }
    else if (typeof pattern === 'string') {
        return pattern.split(',').indexOf(name) > -1;
    }
    else if (isRegExp(pattern)) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
        var entry = cache[key];
        if (entry) {
            var name_1 = entry.name;
            if (name_1 && !filter(name_1)) {
                pruneCacheEntry(cache, key, keys, _vnode);
            }
        }
    }
}
function pruneCacheEntry(cache, key, keys, current) {
    var entry = cache[key];
    if (entry && (!current || entry.tag !== current.tag)) {
        // @ts-expect-error can be undefined
        entry.componentInstance.$destroy();
    }
    cache[key] = null;
    remove$2(keys, key);
}
var patternTypes = [String, RegExp, Array];
// TODO defineComponent
var KeepAlive = {
    name: 'keep-alive',
    abstract: true,
    props: {
        include: patternTypes,
        exclude: patternTypes,
        max: [String, Number]
    },
    methods: {
        cacheVNode: function () {
            var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;
            if (vnodeToCache) {
                var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;
                cache[keyToCache] = {
                    name: _getComponentName(componentOptions),
                    tag: tag,
                    componentInstance: componentInstance
                };
                keys.push(keyToCache);
                // prune oldest entry
                if (this.max && keys.length > parseInt(this.max)) {
                    pruneCacheEntry(cache, keys[0], keys, this._vnode);
                }
                this.vnodeToCache = null;
            }
        }
    },
    created: function () {
        this.cache = Object.create(null);
        this.keys = [];
    },
    destroyed: function () {
        for (var key in this.cache) {
            pruneCacheEntry(this.cache, key, this.keys);
        }
    },
    mounted: function () {
        var _this = this;
        this.cacheVNode();
        this.$watch('include', function (val) {
            pruneCache(_this, function (name) { return matches(val, name); });
        });
        this.$watch('exclude', function (val) {
            pruneCache(_this, function (name) { return !matches(val, name); });
        });
    },
    updated: function () {
        this.cacheVNode();
    },
    render: function () {
        var slot = this.$slots.default;
        var vnode = getFirstComponentChild(slot);
        var componentOptions = vnode && vnode.componentOptions;
        if (componentOptions) {
            // check pattern
            var name_2 = _getComponentName(componentOptions);
            var _a = this, include = _a.include, exclude = _a.exclude;
            if (
            // not included
            (include && (!name_2 || !matches(include, name_2))) ||
                // excluded
                (exclude && name_2 && matches(exclude, name_2))) {
                return vnode;
            }
            var _b = this, cache = _b.cache, keys = _b.keys;
            var key = vnode.key == null
                ? // same constructor may get registered as different local components
                    // so cid alone is not enough (#3269)
                    componentOptions.Ctor.cid +
                        (componentOptions.tag ? "::".concat(componentOptions.tag) : '')
                : vnode.key;
            if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance;
                // make current key freshest
                remove$2(keys, key);
                keys.push(key);
            }
            else {
                // delay setting the cache until update
                this.vnodeToCache = vnode;
                this.keyToCache = key;
            }
            // @ts-expect-error can vnode.data can be undefined
            vnode.data.keepAlive = true;
        }
        return vnode || (slot && slot[0]);
    }
};

var builtInComponents = {
    KeepAlive: KeepAlive
};

function initGlobalAPI(Vue) {
    // config
    var configDef = {};
    configDef.get = function () { return config; };
    if (true) {
        configDef.set = function () {
            warn$2('Do not replace the Vue.config object, set individual fields instead.');
        };
    }
    Object.defineProperty(Vue, 'config', configDef);
    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
        warn: warn$2,
        extend: extend,
        mergeOptions: mergeOptions,
        defineReactive: defineReactive
    };
    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;
    // 2.6 explicit observable API
    Vue.observable = function (obj) {
        observe(obj);
        return obj;
    };
    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
        Vue.options[type + 's'] = Object.create(null);
    });
    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;
    extend(Vue.options.components, builtInComponents);
    initUse(Vue);
    initMixin(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function () {
        /* istanbul ignore next */
        return this.$vnode && this.$vnode.ssrContext;
    }
});
// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
});
Vue.version = version;

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');
// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||
        (attr === 'selected' && tag === 'option') ||
        (attr === 'checked' && tag === 'input') ||
        (attr === 'muted' && tag === 'video'));
};
var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');
var convertEnumeratedValue = function (key, value) {
    return isFalsyAttrValue(value) || value === 'false'
        ? 'false'
        : // allow arbitrary string value for contenteditable
            key === 'contenteditable' && isValidContentEditableValue(value)
                ? value
                : 'true';
};
var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,' +
    'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';
var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};
var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
};
var isFalsyAttrValue = function (val) {
    return val == null || val === false;
};

function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data) {
            data = mergeClassData(childNode.data, data);
        }
    }
    // @ts-expect-error parentNode.parent not VNodeWithData
    while (isDef((parentNode = parentNode.parent))) {
        if (parentNode && parentNode.data) {
            data = mergeClassData(data, parentNode.data);
        }
    }
    return renderClass(data.staticClass, data.class);
}
function mergeClassData(child, parent) {
    return {
        staticClass: concat(child.staticClass, parent.staticClass),
        class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
}
function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
        return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
}
function concat(a, b) {
    return a ? (b ? a + ' ' + b : a) : b || '';
}
function stringifyClass(value) {
    if (Array.isArray(value)) {
        return stringifyArray(value);
    }
    if (isObject(value)) {
        return stringifyObject(value);
    }
    if (typeof value === 'string') {
        return value;
    }
    /* istanbul ignore next */
    return '';
}
function stringifyArray(value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {
            if (res)
                res += ' ';
            res += stringified;
        }
    }
    return res;
}
function stringifyObject(value) {
    var res = '';
    for (var key in value) {
        if (value[key]) {
            if (res)
                res += ' ';
            res += key;
        }
    }
    return res;
}

var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot');
// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
var isPreTag = function (tag) { return tag === 'pre'; };
var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag);
};
function getTagNamespace(tag) {
    if (isSVG(tag)) {
        return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
        return 'math';
    }
}
var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
        return true;
    }
    if (isReservedTag(tag)) {
        return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
        return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
        // http://stackoverflow.com/a/28210364/1070244
        return (unknownElementCache[tag] =
            el.constructor === window.HTMLUnknownElement ||
                el.constructor === window.HTMLElement);
    }
    else {
        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));
    }
}
var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
    if (typeof el === 'string') {
        var selected = document.querySelector(el);
        if (!selected) {
             true && warn$2('Cannot find element: ' + el);
            return document.createElement('div');
        }
        return selected;
    }
    else {
        return el;
    }
}

function createElement(tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
        return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data &&
        vnode.data.attrs &&
        vnode.data.attrs.multiple !== undefined) {
        elm.setAttribute('multiple', 'multiple');
    }
    return elm;
}
function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(node) {
    return node.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

var ref = {
    create: function (_, vnode) {
        registerRef(vnode);
    },
    update: function (oldVnode, vnode) {
        if (oldVnode.data.ref !== vnode.data.ref) {
            registerRef(oldVnode, true);
            registerRef(vnode);
        }
    },
    destroy: function (vnode) {
        registerRef(vnode, true);
    }
};
function registerRef(vnode, isRemoval) {
    var ref = vnode.data.ref;
    if (!isDef(ref))
        return;
    var vm = vnode.context;
    var refValue = vnode.componentInstance || vnode.elm;
    var value = isRemoval ? null : refValue;
    var $refsValue = isRemoval ? undefined : refValue;
    if (isFunction(ref)) {
        invokeWithErrorHandling(ref, vm, [value], vm, "template ref function");
        return;
    }
    var isFor = vnode.data.refInFor;
    var _isString = typeof ref === 'string' || typeof ref === 'number';
    var _isRef = isRef(ref);
    var refs = vm.$refs;
    if (_isString || _isRef) {
        if (isFor) {
            var existing = _isString ? refs[ref] : ref.value;
            if (isRemoval) {
                isArray(existing) && remove$2(existing, refValue);
            }
            else {
                if (!isArray(existing)) {
                    if (_isString) {
                        refs[ref] = [refValue];
                        setSetupRef(vm, ref, refs[ref]);
                    }
                    else {
                        ref.value = [refValue];
                    }
                }
                else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                }
            }
        }
        else if (_isString) {
            if (isRemoval && refs[ref] !== refValue) {
                return;
            }
            refs[ref] = $refsValue;
            setSetupRef(vm, ref, value);
        }
        else if (_isRef) {
            if (isRemoval && ref.value !== refValue) {
                return;
            }
            ref.value = value;
        }
        else if (true) {
            warn$2("Invalid template ref type: ".concat(typeof ref));
        }
    }
}
function setSetupRef(_a, key, val) {
    var _setupState = _a._setupState;
    if (_setupState && hasOwn(_setupState, key)) {
        if (isRef(_setupState[key])) {
            _setupState[key].value = val;
        }
        else {
            _setupState[key] = val;
        }
    }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */
var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
function sameVnode(a, b) {
    return (a.key === b.key &&
        a.asyncFactory === b.asyncFactory &&
        ((a.tag === b.tag &&
            a.isComment === b.isComment &&
            isDef(a.data) === isDef(b.data) &&
            sameInputType(a, b)) ||
            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));
}
function sameInputType(a, b) {
    if (a.tag !== 'input')
        return true;
    var i;
    var typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;
    var typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;
    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key;
        if (isDef(key))
            map[key] = i;
    }
    return map;
}
function createPatchFunction(backend) {
    var i, j;
    var cbs = {};
    var modules = backend.modules, nodeOps = backend.nodeOps;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            if (isDef(modules[j][hooks[i]])) {
                cbs[hooks[i]].push(modules[j][hooks[i]]);
            }
        }
    }
    function emptyNodeAt(elm) {
        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        function remove() {
            if (--remove.listeners === 0) {
                removeNode(childElm);
            }
        }
        remove.listeners = listeners;
        return remove;
    }
    function removeNode(el) {
        var parent = nodeOps.parentNode(el);
        // element may have already been removed due to v-html / v-text
        if (isDef(parent)) {
            nodeOps.removeChild(parent, el);
        }
    }
    function isUnknownElement(vnode, inVPre) {
        return (!inVPre &&
            !vnode.ns &&
            !(config.ignoredElements.length &&
                config.ignoredElements.some(function (ignore) {
                    return isRegExp(ignore)
                        ? ignore.test(vnode.tag)
                        : ignore === vnode.tag;
                })) &&
            config.isUnknownElement(vnode.tag));
    }
    var creatingElmInVPre = 0;
    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // This vnode was used in a previous render!
            // now it's used as a new node, overwriting its elm would cause
            // potential patch errors down the road when it's used as an insertion
            // reference node. Instead, we clone the node on-demand before creating
            // associated DOM element for it.
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        vnode.isRootInsert = !nested; // for transition enter check
        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
            return;
        }
        var data = vnode.data;
        var children = vnode.children;
        var tag = vnode.tag;
        if (isDef(tag)) {
            if (true) {
                if (data && data.pre) {
                    creatingElmInVPre++;
                }
                if (isUnknownElement(vnode, creatingElmInVPre)) {
                    warn$2('Unknown custom element: <' +
                        tag +
                        '> - did you ' +
                        'register the component correctly? For recursive components, ' +
                        'make sure to provide the "name" option.', vnode.context);
                }
            }
            vnode.elm = vnode.ns
                ? nodeOps.createElementNS(vnode.ns, tag)
                : nodeOps.createElement(tag, vnode);
            setScope(vnode);
            createChildren(vnode, children, insertedVnodeQueue);
            if (isDef(data)) {
                invokeCreateHooks(vnode, insertedVnodeQueue);
            }
            insert(parentElm, vnode.elm, refElm);
            if ( true && data && data.pre) {
                creatingElmInVPre--;
            }
        }
        else if (isTrue(vnode.isComment)) {
            vnode.elm = nodeOps.createComment(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
        else {
            vnode.elm = nodeOps.createTextNode(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
    }
    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        var i = vnode.data;
        if (isDef(i)) {
            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
            if (isDef((i = i.hook)) && isDef((i = i.init))) {
                i(vnode, false /* hydrating */);
            }
            // after calling the init hook, if the vnode is a child component
            // it should've created a child instance and mounted it. the child
            // component also has set the placeholder vnode's elm.
            // in that case we can just return the element and be done.
            if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);
                insert(parentElm, vnode.elm, refElm);
                if (isTrue(isReactivated)) {
                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                }
                return true;
            }
        }
    }
    function initComponent(vnode, insertedVnodeQueue) {
        if (isDef(vnode.data.pendingInsert)) {
            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
            vnode.data.pendingInsert = null;
        }
        vnode.elm = vnode.componentInstance.$el;
        if (isPatchable(vnode)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            setScope(vnode);
        }
        else {
            // empty component root.
            // skip all element-related modules except for ref (#3455)
            registerRef(vnode);
            // make sure to invoke the insert hook
            insertedVnodeQueue.push(vnode);
        }
    }
    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        var i;
        // hack for #4339: a reactivated component with inner transition
        // does not trigger because the inner node's created hooks are not called
        // again. It's not ideal to involve module-specific logic in here but
        // there doesn't seem to be a better way to do it.
        var innerNode = vnode;
        while (innerNode.componentInstance) {
            innerNode = innerNode.componentInstance._vnode;
            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {
                for (i = 0; i < cbs.activate.length; ++i) {
                    cbs.activate[i](emptyNode, innerNode);
                }
                insertedVnodeQueue.push(innerNode);
                break;
            }
        }
        // unlike a newly created component,
        // a reactivated keep-alive component doesn't insert itself
        insert(parentElm, vnode.elm, refElm);
    }
    function insert(parent, elm, ref) {
        if (isDef(parent)) {
            if (isDef(ref)) {
                if (nodeOps.parentNode(ref) === parent) {
                    nodeOps.insertBefore(parent, elm, ref);
                }
            }
            else {
                nodeOps.appendChild(parent, elm);
            }
        }
    }
    function createChildren(vnode, children, insertedVnodeQueue) {
        if (isArray(children)) {
            if (true) {
                checkDuplicateKeys(children);
            }
            for (var i_1 = 0; i_1 < children.length; ++i_1) {
                createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);
            }
        }
        else if (isPrimitive(vnode.text)) {
            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
        }
    }
    function isPatchable(vnode) {
        while (vnode.componentInstance) {
            vnode = vnode.componentInstance._vnode;
        }
        return isDef(vnode.tag);
    }
    function invokeCreateHooks(vnode, insertedVnodeQueue) {
        for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {
            cbs.create[i_2](emptyNode, vnode);
        }
        i = vnode.data.hook; // Reuse variable
        if (isDef(i)) {
            if (isDef(i.create))
                i.create(emptyNode, vnode);
            if (isDef(i.insert))
                insertedVnodeQueue.push(vnode);
        }
    }
    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
        var i;
        if (isDef((i = vnode.fnScopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
        else {
            var ancestor = vnode;
            while (ancestor) {
                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {
                    nodeOps.setStyleScope(vnode.elm, i);
                }
                ancestor = ancestor.parent;
            }
        }
        // for slot content they should also get the scopeId from the host instance.
        if (isDef((i = activeInstance)) &&
            i !== vnode.context &&
            i !== vnode.fnContext &&
            isDef((i = i.$options._scopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
    }
    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
        }
    }
    function invokeDestroyHook(vnode) {
        var i, j;
        var data = vnode.data;
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.destroy)))
                i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i)
                cbs.destroy[i](vnode);
        }
        if (isDef((i = vnode.children))) {
            for (j = 0; j < vnode.children.length; ++j) {
                invokeDestroyHook(vnode.children[j]);
            }
        }
    }
    function removeVnodes(vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (isDef(ch)) {
                if (isDef(ch.tag)) {
                    removeAndInvokeRemoveHook(ch);
                    invokeDestroyHook(ch);
                }
                else {
                    // Text node
                    removeNode(ch.elm);
                }
            }
        }
    }
    function removeAndInvokeRemoveHook(vnode, rm) {
        if (isDef(rm) || isDef(vnode.data)) {
            var i_3;
            var listeners = cbs.remove.length + 1;
            if (isDef(rm)) {
                // we have a recursively passed down rm callback
                // increase the listeners count
                rm.listeners += listeners;
            }
            else {
                // directly removing
                rm = createRmCb(vnode.elm, listeners);
            }
            // recursively invoke hooks on child component root node
            if (isDef((i_3 = vnode.componentInstance)) &&
                isDef((i_3 = i_3._vnode)) &&
                isDef(i_3.data)) {
                removeAndInvokeRemoveHook(i_3, rm);
            }
            for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {
                cbs.remove[i_3](vnode, rm);
            }
            if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {
                i_3(vnode, rm);
            }
            else {
                rm();
            }
        }
        else {
            removeNode(vnode.elm);
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
        var oldStartIdx = 0;
        var newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
        // removeOnly is a special flag used only by <transition-group>
        // to ensure removed elements stay in correct relative positions
        // during leaving transitions
        var canMove = !removeOnly;
        if (true) {
            checkDuplicateKeys(newCh);
        }
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (isUndef(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
            }
            else if (isUndef(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (isUndef(oldKeyToIdx))
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                idxInOld = isDef(newStartVnode.key)
                    ? oldKeyToIdx[newStartVnode.key]
                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
                if (isUndef(idxInOld)) {
                    // New element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                }
                else {
                    vnodeToMove = oldCh[idxInOld];
                    if (sameVnode(vnodeToMove, newStartVnode)) {
                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                        oldCh[idxInOld] = undefined;
                        canMove &&
                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                    }
                    else {
                        // same key but different element. treat as new element
                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                    }
                }
                newStartVnode = newCh[++newStartIdx];
            }
        }
        if (oldStartIdx > oldEndIdx) {
            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        }
        else if (newStartIdx > newEndIdx) {
            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function checkDuplicateKeys(children) {
        var seenKeys = {};
        for (var i_4 = 0; i_4 < children.length; i_4++) {
            var vnode = children[i_4];
            var key = vnode.key;
            if (isDef(key)) {
                if (seenKeys[key]) {
                    warn$2("Duplicate keys detected: '".concat(key, "'. This may cause an update error."), vnode.context);
                }
                else {
                    seenKeys[key] = true;
                }
            }
        }
    }
    function findIdxInOld(node, oldCh, start, end) {
        for (var i_5 = start; i_5 < end; i_5++) {
            var c = oldCh[i_5];
            if (isDef(c) && sameVnode(node, c))
                return i_5;
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
        if (oldVnode === vnode) {
            return;
        }
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // clone reused vnode
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        var elm = (vnode.elm = oldVnode.elm);
        if (isTrue(oldVnode.isAsyncPlaceholder)) {
            if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
            }
            else {
                vnode.isAsyncPlaceholder = true;
            }
            return;
        }
        // reuse element for static trees.
        // note we only do this if the vnode is cloned -
        // if the new node is not cloned it means the render functions have been
        // reset by the hot-reload-api and we need to do a proper re-render.
        if (isTrue(vnode.isStatic) &&
            isTrue(oldVnode.isStatic) &&
            vnode.key === oldVnode.key &&
            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
            vnode.componentInstance = oldVnode.componentInstance;
            return;
        }
        var i;
        var data = vnode.data;
        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
            i(oldVnode, vnode);
        }
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (isDef(data) && isPatchable(vnode)) {
            for (i = 0; i < cbs.update.length; ++i)
                cbs.update[i](oldVnode, vnode);
            if (isDef((i = data.hook)) && isDef((i = i.update)))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
            }
            else if (isDef(ch)) {
                if (true) {
                    checkDuplicateKeys(ch);
                }
                if (isDef(oldVnode.text))
                    nodeOps.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                nodeOps.setTextContent(elm, '');
            }
        }
        else if (oldVnode.text !== vnode.text) {
            nodeOps.setTextContent(elm, vnode.text);
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))
                i(oldVnode, vnode);
        }
    }
    function invokeInsertHook(vnode, queue, initial) {
        // delay insert hooks for component root nodes, invoke them after the
        // element is really inserted
        if (isTrue(initial) && isDef(vnode.parent)) {
            vnode.parent.data.pendingInsert = queue;
        }
        else {
            for (var i_6 = 0; i_6 < queue.length; ++i_6) {
                queue[i_6].data.hook.insert(queue[i_6]);
            }
        }
    }
    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');
    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
        var i;
        var tag = vnode.tag, data = vnode.data, children = vnode.children;
        inVPre = inVPre || (data && data.pre);
        vnode.elm = elm;
        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
            vnode.isAsyncPlaceholder = true;
            return true;
        }
        // assert node match
        if (true) {
            if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false;
            }
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.init)))
                i(vnode, true /* hydrating */);
            if (isDef((i = vnode.componentInstance))) {
                // child component. it should have hydrated its own tree.
                initComponent(vnode, insertedVnodeQueue);
                return true;
            }
        }
        if (isDef(tag)) {
            if (isDef(children)) {
                // empty element, allow client to pick up and populate children
                if (!elm.hasChildNodes()) {
                    createChildren(vnode, children, insertedVnodeQueue);
                }
                else {
                    // v-html and domProps: innerHTML
                    if (isDef((i = data)) &&
                        isDef((i = i.domProps)) &&
                        isDef((i = i.innerHTML))) {
                        if (i !== elm.innerHTML) {
                            /* istanbul ignore if */
                            if ( true &&
                                typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('server innerHTML: ', i);
                                console.warn('client innerHTML: ', elm.innerHTML);
                            }
                            return false;
                        }
                    }
                    else {
                        // iterate and compare children lists
                        var childrenMatch = true;
                        var childNode = elm.firstChild;
                        for (var i_7 = 0; i_7 < children.length; i_7++) {
                            if (!childNode ||
                                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {
                                childrenMatch = false;
                                break;
                            }
                            childNode = childNode.nextSibling;
                        }
                        // if childNode is not null, it means the actual childNodes list is
                        // longer than the virtual children list.
                        if (!childrenMatch || childNode) {
                            /* istanbul ignore if */
                            if ( true &&
                                typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                            }
                            return false;
                        }
                    }
                }
            }
            if (isDef(data)) {
                var fullInvoke = false;
                for (var key in data) {
                    if (!isRenderedModule(key)) {
                        fullInvoke = true;
                        invokeCreateHooks(vnode, insertedVnodeQueue);
                        break;
                    }
                }
                if (!fullInvoke && data['class']) {
                    // ensure collecting deps for deep class bindings for future updates
                    traverse(data['class']);
                }
            }
        }
        else if (elm.data !== vnode.text) {
            elm.data = vnode.text;
        }
        return true;
    }
    function assertNodeMatch(node, vnode, inVPre) {
        if (isDef(vnode.tag)) {
            return (vnode.tag.indexOf('vue-component') === 0 ||
                (!isUnknownElement(vnode, inVPre) &&
                    vnode.tag.toLowerCase() ===
                        (node.tagName && node.tagName.toLowerCase())));
        }
        else {
            return node.nodeType === (vnode.isComment ? 8 : 3);
        }
    }
    return function patch(oldVnode, vnode, hydrating, removeOnly) {
        if (isUndef(vnode)) {
            if (isDef(oldVnode))
                invokeDestroyHook(oldVnode);
            return;
        }
        var isInitialPatch = false;
        var insertedVnodeQueue = [];
        if (isUndef(oldVnode)) {
            // empty mount (likely as component), create new root element
            isInitialPatch = true;
            createElm(vnode, insertedVnodeQueue);
        }
        else {
            var isRealElement = isDef(oldVnode.nodeType);
            if (!isRealElement && sameVnode(oldVnode, vnode)) {
                // patch existing root node
                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
            }
            else {
                if (isRealElement) {
                    // mounting to a real element
                    // check if this is server-rendered content and if we can perform
                    // a successful hydration.
                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                        oldVnode.removeAttribute(SSR_ATTR);
                        hydrating = true;
                    }
                    if (isTrue(hydrating)) {
                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                            invokeInsertHook(vnode, insertedVnodeQueue, true);
                            return oldVnode;
                        }
                        else if (true) {
                            warn$2('The client-side rendered virtual DOM tree is not matching ' +
                                'server-rendered content. This is likely caused by incorrect ' +
                                'HTML markup, for example nesting block-level elements inside ' +
                                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                                'full client-side render.');
                        }
                    }
                    // either not server-rendered, or hydration failed.
                    // create an empty node and replace it
                    oldVnode = emptyNodeAt(oldVnode);
                }
                // replacing existing element
                var oldElm = oldVnode.elm;
                var parentElm = nodeOps.parentNode(oldElm);
                // create new node
                createElm(vnode, insertedVnodeQueue, 
                // extremely rare edge case: do not insert if old element is in a
                // leaving transition. Only happens when combining transition +
                // keep-alive + HOCs. (#4590)
                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));
                // update parent placeholder node element, recursively
                if (isDef(vnode.parent)) {
                    var ancestor = vnode.parent;
                    var patchable = isPatchable(vnode);
                    while (ancestor) {
                        for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {
                            cbs.destroy[i_8](ancestor);
                        }
                        ancestor.elm = vnode.elm;
                        if (patchable) {
                            for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {
                                cbs.create[i_9](emptyNode, ancestor);
                            }
                            // #6513
                            // invoke insert hooks that may have been merged by create hooks.
                            // e.g. for directives that uses the "inserted" hook.
                            var insert_1 = ancestor.data.hook.insert;
                            if (insert_1.merged) {
                                // start at index 1 to avoid re-invoking component mounted hook
                                for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {
                                    insert_1.fns[i_10]();
                                }
                            }
                        }
                        else {
                            registerRef(ancestor);
                        }
                        ancestor = ancestor.parent;
                    }
                }
                // destroy old node
                if (isDef(parentElm)) {
                    removeVnodes([oldVnode], 0, 0);
                }
                else if (isDef(oldVnode.tag)) {
                    invokeDestroyHook(oldVnode);
                }
            }
        }
        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
        return vnode.elm;
    };
}

var directives$1 = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
        // @ts-expect-error emptyNode is not VNodeWithData
        updateDirectives(vnode, emptyNode);
    }
};
function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
        _update(oldVnode, vnode);
    }
}
function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
    var dirsWithInsert = [];
    var dirsWithPostpatch = [];
    var key, oldDir, dir;
    for (key in newDirs) {
        oldDir = oldDirs[key];
        dir = newDirs[key];
        if (!oldDir) {
            // new directive, bind
            callHook(dir, 'bind', vnode, oldVnode);
            if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir);
            }
        }
        else {
            // existing directive, update
            dir.oldValue = oldDir.value;
            dir.oldArg = oldDir.arg;
            callHook(dir, 'update', vnode, oldVnode);
            if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir);
            }
        }
    }
    if (dirsWithInsert.length) {
        var callInsert = function () {
            for (var i = 0; i < dirsWithInsert.length; i++) {
                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
            }
        };
        if (isCreate) {
            mergeVNodeHook(vnode, 'insert', callInsert);
        }
        else {
            callInsert();
        }
    }
    if (dirsWithPostpatch.length) {
        mergeVNodeHook(vnode, 'postpatch', function () {
            for (var i = 0; i < dirsWithPostpatch.length; i++) {
                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
            }
        });
    }
    if (!isCreate) {
        for (key in oldDirs) {
            if (!newDirs[key]) {
                // no longer present, unbind
                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
            }
        }
    }
}
var emptyModifiers = Object.create(null);
function normalizeDirectives(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
        // $flow-disable-line
        return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
            // $flow-disable-line
            dir.modifiers = emptyModifiers;
        }
        res[getRawDirName(dir)] = dir;
        if (vm._setupState && vm._setupState.__sfc) {
            var setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);
            if (typeof setupDef === 'function') {
                dir.def = {
                    bind: setupDef,
                    update: setupDef,
                };
            }
            else {
                dir.def = setupDef;
            }
        }
        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res;
}
function getRawDirName(dir) {
    return (dir.rawName || "".concat(dir.name, ".").concat(Object.keys(dir.modifiers || {}).join('.')));
}
function callHook(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
        try {
            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        }
        catch (e) {
            handleError(e, vnode.context, "directive ".concat(dir.name, " ").concat(hook, " hook"));
        }
    }
}

var baseModules = [ref, directives$1];

function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
        return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
        return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {
        attrs = vnode.data.attrs = extend({}, attrs);
    }
    for (key in attrs) {
        cur = attrs[key];
        old = oldAttrs[key];
        if (old !== cur) {
            setAttr(elm, key, cur, vnode.data.pre);
        }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
        setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
        if (isUndef(attrs[key])) {
            if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
            }
            else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key);
            }
        }
    }
}
function setAttr(el, key, value, isInPre) {
    if (isInPre || el.tagName.indexOf('-') > -1) {
        baseSetAttr(el, key, value);
    }
    else if (isBooleanAttr(key)) {
        // set attribute for blank value
        // e.g. <option disabled>Select one</option>
        if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
        }
        else {
            // technically allowfullscreen is a boolean attribute for <iframe>,
            // but Flash expects a value of "true" when used on <embed> tag
            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
            el.setAttribute(key, value);
        }
    }
    else if (isEnumeratedAttr(key)) {
        el.setAttribute(key, convertEnumeratedValue(key, value));
    }
    else if (isXlink(key)) {
        if (isFalsyAttrValue(value)) {
            el.removeAttributeNS(xlinkNS, getXlinkProp(key));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        baseSetAttr(el, key, value);
    }
}
function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
    }
    else {
        // #7138: IE10 & 11 fires input event when setting placeholder on
        // <textarea>... block the first input event and remove the blocker
        // immediately.
        /* istanbul ignore if */
        if (isIE &&
            !isIE9 &&
            el.tagName === 'TEXTAREA' &&
            key === 'placeholder' &&
            value !== '' &&
            !el.__ieph) {
            var blocker_1 = function (e) {
                e.stopImmediatePropagation();
                el.removeEventListener('input', blocker_1);
            };
            el.addEventListener('input', blocker_1);
            // $flow-disable-line
            el.__ieph = true; /* IE placeholder patched */
        }
        el.setAttribute(key, value);
    }
}
var attrs = {
    create: updateAttrs,
    update: updateAttrs
};

function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) &&
        isUndef(data.class) &&
        (isUndef(oldData) ||
            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {
        return;
    }
    var cls = genClassForVnode(vnode);
    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
        cls = concat(cls, stringifyClass(transitionClass));
    }
    // set the class
    if (cls !== el._prevClass) {
        el.setAttribute('class', cls);
        el._prevClass = cls;
    }
}
var klass$1 = {
    create: updateClass,
    update: updateClass
};

var validDivisionCharRE = /[\w).+\-_$\]]/;
function parseFilters(exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;
    for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
            if (c === 0x27 && prev !== 0x5c)
                inSingle = false;
        }
        else if (inDouble) {
            if (c === 0x22 && prev !== 0x5c)
                inDouble = false;
        }
        else if (inTemplateString) {
            if (c === 0x60 && prev !== 0x5c)
                inTemplateString = false;
        }
        else if (inRegex) {
            if (c === 0x2f && prev !== 0x5c)
                inRegex = false;
        }
        else if (c === 0x7c && // pipe
            exp.charCodeAt(i + 1) !== 0x7c &&
            exp.charCodeAt(i - 1) !== 0x7c &&
            !curly &&
            !square &&
            !paren) {
            if (expression === undefined) {
                // first filter, end of expression
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
            }
            else {
                pushFilter();
            }
        }
        else {
            switch (c) {
                case 0x22:
                    inDouble = true;
                    break; // "
                case 0x27:
                    inSingle = true;
                    break; // '
                case 0x60:
                    inTemplateString = true;
                    break; // `
                case 0x28:
                    paren++;
                    break; // (
                case 0x29:
                    paren--;
                    break; // )
                case 0x5b:
                    square++;
                    break; // [
                case 0x5d:
                    square--;
                    break; // ]
                case 0x7b:
                    curly++;
                    break; // {
                case 0x7d:
                    curly--;
                    break; // }
            }
            if (c === 0x2f) {
                // /
                var j = i - 1;
                var p 
                // find first non-whitespace prev char
                = void 0;
                // find first non-whitespace prev char
                for (; j >= 0; j--) {
                    p = exp.charAt(j);
                    if (p !== ' ')
                        break;
                }
                if (!p || !validDivisionCharRE.test(p)) {
                    inRegex = true;
                }
            }
        }
    }
    if (expression === undefined) {
        expression = exp.slice(0, i).trim();
    }
    else if (lastFilterIndex !== 0) {
        pushFilter();
    }
    function pushFilter() {
        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
    }
    if (filters) {
        for (i = 0; i < filters.length; i++) {
            expression = wrapFilter(expression, filters[i]);
        }
    }
    return expression;
}
function wrapFilter(exp, filter) {
    var i = filter.indexOf('(');
    if (i < 0) {
        // _f: resolveFilter
        return "_f(\"".concat(filter, "\")(").concat(exp, ")");
    }
    else {
        var name_1 = filter.slice(0, i);
        var args = filter.slice(i + 1);
        return "_f(\"".concat(name_1, "\")(").concat(exp).concat(args !== ')' ? ',' + args : args);
    }
}

/* eslint-disable no-unused-vars */
function baseWarn(msg, range) {
    console.error("[Vue compiler]: ".concat(msg));
}
/* eslint-enable no-unused-vars */
function pluckModuleFunction(modules, key) {
    return modules ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; }) : [];
}
function addProp(el, name, value, range, dynamic) {
    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
    el.plain = false;
}
function addAttr(el, name, value, range, dynamic) {
    var attrs = dynamic
        ? el.dynamicAttrs || (el.dynamicAttrs = [])
        : el.attrs || (el.attrs = []);
    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
    el.plain = false;
}
// add a raw attr (use this in preTransforms)
function addRawAttr(el, name, value, range) {
    el.attrsMap[name] = value;
    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
}
function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
    (el.directives || (el.directives = [])).push(rangeSetItem({
        name: name,
        rawName: rawName,
        value: value,
        arg: arg,
        isDynamicArg: isDynamicArg,
        modifiers: modifiers
    }, range));
    el.plain = false;
}
function prependModifierMarker(symbol, name, dynamic) {
    return dynamic ? "_p(".concat(name, ",\"").concat(symbol, "\")") : symbol + name; // mark the event as captured
}
function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
    modifiers = modifiers || emptyObject;
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if ( true && warn && modifiers.prevent && modifiers.passive) {
        warn("passive and prevent can't be used together. " +
            "Passive handler can't prevent default event.", range);
    }
    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (modifiers.right) {
        if (dynamic) {
            name = "(".concat(name, ")==='click'?'contextmenu':(").concat(name, ")");
        }
        else if (name === 'click') {
            name = 'contextmenu';
            delete modifiers.right;
        }
    }
    else if (modifiers.middle) {
        if (dynamic) {
            name = "(".concat(name, ")==='click'?'mouseup':(").concat(name, ")");
        }
        else if (name === 'click') {
            name = 'mouseup';
        }
    }
    // check capture modifier
    if (modifiers.capture) {
        delete modifiers.capture;
        name = prependModifierMarker('!', name, dynamic);
    }
    if (modifiers.once) {
        delete modifiers.once;
        name = prependModifierMarker('~', name, dynamic);
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
        delete modifiers.passive;
        name = prependModifierMarker('&', name, dynamic);
    }
    var events;
    if (modifiers.native) {
        delete modifiers.native;
        events = el.nativeEvents || (el.nativeEvents = {});
    }
    else {
        events = el.events || (el.events = {});
    }
    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
    if (modifiers !== emptyObject) {
        newHandler.modifiers = modifiers;
    }
    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
        important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    }
    else if (handlers) {
        events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    }
    else {
        events[name] = newHandler;
    }
    el.plain = false;
}
function getRawBindingAttr(el, name) {
    return (el.rawAttrsMap[':' + name] ||
        el.rawAttrsMap['v-bind:' + name] ||
        el.rawAttrsMap[name]);
}
function getBindingAttr(el, name, getStatic) {
    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
        return parseFilters(dynamicValue);
    }
    else if (getStatic !== false) {
        var staticValue = getAndRemoveAttr(el, name);
        if (staticValue != null) {
            return JSON.stringify(staticValue);
        }
    }
}
// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr(el, name, removeFromMap) {
    var val;
    if ((val = el.attrsMap[name]) != null) {
        var list = el.attrsList;
        for (var i = 0, l = list.length; i < l; i++) {
            if (list[i].name === name) {
                list.splice(i, 1);
                break;
            }
        }
    }
    if (removeFromMap) {
        delete el.attrsMap[name];
    }
    return val;
}
function getAndRemoveAttrByRegex(el, name) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
        var attr = list[i];
        if (name.test(attr.name)) {
            list.splice(i, 1);
            return attr;
        }
    }
}
function rangeSetItem(item, range) {
    if (range) {
        if (range.start != null) {
            item.start = range.start;
        }
        if (range.end != null) {
            item.end = range.end;
        }
    }
    return item;
}

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
    var _a = modifiers || {}, number = _a.number, trim = _a.trim;
    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;
    if (trim) {
        valueExpression =
            "(typeof ".concat(baseValueExpression, " === 'string'") +
                "? ".concat(baseValueExpression, ".trim()") +
                ": ".concat(baseValueExpression, ")");
    }
    if (number) {
        valueExpression = "_n(".concat(valueExpression, ")");
    }
    var assignment = genAssignmentCode(value, valueExpression);
    el.model = {
        value: "(".concat(value, ")"),
        expression: JSON.stringify(value),
        callback: "function (".concat(baseValueExpression, ") {").concat(assignment, "}")
    };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
    var res = parseModel(value);
    if (res.key === null) {
        return "".concat(value, "=").concat(assignment);
    }
    else {
        return "$set(".concat(res.exp, ", ").concat(res.key, ", ").concat(assignment, ")");
    }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */
var len, str, chr, index, expressionPos, expressionEndPos;
function parseModel(val) {
    // Fix https://github.com/vuejs/vue/pull/7730
    // allow v-model="obj.val " (trailing whitespace)
    val = val.trim();
    len = val.length;
    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
        index = val.lastIndexOf('.');
        if (index > -1) {
            return {
                exp: val.slice(0, index),
                key: '"' + val.slice(index + 1) + '"'
            };
        }
        else {
            return {
                exp: val,
                key: null
            };
        }
    }
    str = val;
    index = expressionPos = expressionEndPos = 0;
    while (!eof()) {
        chr = next();
        /* istanbul ignore if */
        if (isStringStart(chr)) {
            parseString(chr);
        }
        else if (chr === 0x5b) {
            parseBracket(chr);
        }
    }
    return {
        exp: val.slice(0, expressionPos),
        key: val.slice(expressionPos + 1, expressionEndPos)
    };
}
function next() {
    return str.charCodeAt(++index);
}
function eof() {
    return index >= len;
}
function isStringStart(chr) {
    return chr === 0x22 || chr === 0x27;
}
function parseBracket(chr) {
    var inBracket = 1;
    expressionPos = index;
    while (!eof()) {
        chr = next();
        if (isStringStart(chr)) {
            parseString(chr);
            continue;
        }
        if (chr === 0x5b)
            inBracket++;
        if (chr === 0x5d)
            inBracket--;
        if (inBracket === 0) {
            expressionEndPos = index;
            break;
        }
    }
}
function parseString(chr) {
    var stringQuote = chr;
    while (!eof()) {
        chr = next();
        if (chr === stringQuote) {
            break;
        }
    }
}

var warn$1;
// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';
function model$1(el, dir, _warn) {
    warn$1 = _warn;
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;
    if (true) {
        // inputs with type="file" are read only and setting the input's
        // value will throw an error.
        if (tag === 'input' && type === 'file') {
            warn$1("<".concat(el.tag, " v-model=\"").concat(value, "\" type=\"file\">:\n") +
                "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
        }
    }
    if (el.component) {
        genComponentModel(el, value, modifiers);
        // component v-model doesn't need extra runtime
        return false;
    }
    else if (tag === 'select') {
        genSelect(el, value, modifiers);
    }
    else if (tag === 'input' && type === 'checkbox') {
        genCheckboxModel(el, value, modifiers);
    }
    else if (tag === 'input' && type === 'radio') {
        genRadioModel(el, value, modifiers);
    }
    else if (tag === 'input' || tag === 'textarea') {
        genDefaultModel(el, value, modifiers);
    }
    else if (!config.isReservedTag(tag)) {
        genComponentModel(el, value, modifiers);
        // component v-model doesn't need extra runtime
        return false;
    }
    else if (true) {
        warn$1("<".concat(el.tag, " v-model=\"").concat(value, "\">: ") +
            "v-model is not supported on this element type. " +
            "If you are working with contenteditable, it's recommended to " +
            'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
    }
    // ensure runtime directive metadata
    return true;
}
function genCheckboxModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked', "Array.isArray(".concat(value, ")") +
        "?_i(".concat(value, ",").concat(valueBinding, ")>-1") +
        (trueValueBinding === 'true'
            ? ":(".concat(value, ")")
            : ":_q(".concat(value, ",").concat(trueValueBinding, ")")));
    addHandler(el, 'change', "var $$a=".concat(value, ",") +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(".concat(trueValueBinding, "):(").concat(falseValueBinding, ");") +
        'if(Array.isArray($$a)){' +
        "var $$v=".concat(number ? '_n(' + valueBinding + ')' : valueBinding, ",") +
        '$$i=_i($$a,$$v);' +
        "if($$el.checked){$$i<0&&(".concat(genAssignmentCode(value, '$$a.concat([$$v])'), ")}") +
        "else{$$i>-1&&(".concat(genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))'), ")}") +
        "}else{".concat(genAssignmentCode(value, '$$c'), "}"), null, true);
}
function genRadioModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? "_n(".concat(valueBinding, ")") : valueBinding;
    addProp(el, 'checked', "_q(".concat(value, ",").concat(valueBinding, ")"));
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}
function genSelect(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" +
        ".call($event.target.options,function(o){return o.selected})" +
        ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
        "return ".concat(number ? '_n(val)' : 'val', "})");
    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = ".concat(selectedVal, ";");
    code = "".concat(code, " ").concat(genAssignmentCode(value, assignment));
    addHandler(el, 'change', code, null, true);
}
function genDefaultModel(el, value, modifiers) {
    var type = el.attrsMap.type;
    // warn if v-bind:value conflicts with v-model
    // except for inputs with v-bind:type
    if (true) {
        var value_1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
        var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
        if (value_1 && !typeBinding) {
            var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
            warn$1("".concat(binding, "=\"").concat(value_1, "\" conflicts with v-model on the same element ") +
                'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
        }
    }
    var _a = modifiers || {}, lazy = _a.lazy, number = _a.number, trim = _a.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
    var valueExpression = '$event.target.value';
    if (trim) {
        valueExpression = "$event.target.value.trim()";
    }
    if (number) {
        valueExpression = "_n(".concat(valueExpression, ")");
    }
    var code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
        code = "if($event.target.composing)return;".concat(code);
    }
    addProp(el, 'value', "(".concat(value, ")"));
    addHandler(el, event, code, null, true);
    if (trim || number) {
        addHandler(el, 'blur', '$forceUpdate()');
    }
}

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
        // IE input[type=range] only supports `change` event
        var event_1 = isIE ? 'change' : 'input';
        on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);
        delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
        delete on[CHECKBOX_RADIO_TOKEN];
    }
}
var target;
function createOnceHandler(event, handler, capture) {
    var _target = target; // save current target element in closure
    return function onceHandler() {
        var res = handler.apply(null, arguments);
        if (res !== null) {
            remove(event, onceHandler, capture, _target);
        }
    };
}
// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
function add(name, handler, capture, passive) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
        var attachedTimestamp_1 = currentFlushTimestamp;
        var original_1 = handler;
        //@ts-expect-error
        handler = original_1._wrapper = function (e) {
            if (
            // no bubbling, should always fire.
            // this is just a safety net in case event.timeStamp is unreliable in
            // certain weird environments...
            e.target === e.currentTarget ||
                // event is fired after handler attachment
                e.timeStamp >= attachedTimestamp_1 ||
                // bail for environments that have buggy event.timeStamp implementations
                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
                // #9681 QtWebEngine event.timeStamp is negative value
                e.timeStamp <= 0 ||
                // #9448 bail if event is fired in another document in a multi-page
                // electron/nw.js app, since event.timeStamp will be using a different
                // starting reference
                e.target.ownerDocument !== document) {
                return original_1.apply(this, arguments);
            }
        };
    }
    target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}
function remove(name, handler, capture, _target) {
    (_target || target).removeEventListener(name, 
    //@ts-expect-error
    handler._wrapper || handler, capture);
}
function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
        return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    // vnode is empty when removing all listeners,
    // and use old vnode dom element
    target = vnode.elm || oldVnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
    target = undefined;
}
var events = {
    create: updateDOMListeners,
    update: updateDOMListeners,
    // @ts-expect-error emptyNode has actually data
    destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }
};

var svgContainer;
function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
        return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {
        props = vnode.data.domProps = extend({}, props);
    }
    for (key in oldProps) {
        if (!(key in props)) {
            elm[key] = '';
        }
    }
    for (key in props) {
        cur = props[key];
        // ignore children if the node has textContent or innerHTML,
        // as these will throw away existing DOM nodes and cause removal errors
        // on subsequent patches (#3360)
        if (key === 'textContent' || key === 'innerHTML') {
            if (vnode.children)
                vnode.children.length = 0;
            if (cur === oldProps[key])
                continue;
            // #6601 work around Chrome version <= 55 bug where single textNode
            // replaced by innerHTML/textContent retains its parentNode property
            if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0]);
            }
        }
        if (key === 'value' && elm.tagName !== 'PROGRESS') {
            // store value as _value as well since
            // non-string values will be stringified
            elm._value = cur;
            // avoid resetting cursor position when value is the same
            var strCur = isUndef(cur) ? '' : String(cur);
            if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur;
            }
        }
        else if (key === 'innerHTML' &&
            isSVG(elm.tagName) &&
            isUndef(elm.innerHTML)) {
            // IE doesn't support innerHTML for SVG elements
            svgContainer = svgContainer || document.createElement('div');
            svgContainer.innerHTML = "<svg>".concat(cur, "</svg>");
            var svg = svgContainer.firstChild;
            while (elm.firstChild) {
                elm.removeChild(elm.firstChild);
            }
            while (svg.firstChild) {
                elm.appendChild(svg.firstChild);
            }
        }
        else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecessary `checked` update.
        cur !== oldProps[key]) {
            // some property updates can throw
            // e.g. `value` on <progress> w/ non-finite value
            try {
                elm[key] = cur;
            }
            catch (e) { }
        }
    }
}
function shouldUpdateValue(elm, checkVal) {
    return (
    //@ts-expect-error
    !elm.composing &&
        (elm.tagName === 'OPTION' ||
            isNotInFocusAndDirty(elm, checkVal) ||
            isDirtyWithModifiers(elm, checkVal)));
}
function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
        notInFocus = document.activeElement !== elm;
    }
    catch (e) { }
    return notInFocus && elm.value !== checkVal;
}
function isDirtyWithModifiers(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
        if (modifiers.number) {
            return toNumber(value) !== toNumber(newVal);
        }
        if (modifiers.trim) {
            return value.trim() !== newVal.trim();
        }
    }
    return value !== newVal;
}
var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
};

var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
        if (item) {
            var tmp = item.split(propertyDelimiter);
            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return res;
});
// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
}
// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
        return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
        return parseStyleText(bindingStyle);
    }
    return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;
    if (checkChild) {
        var childNode = vnode;
        while (childNode.componentInstance) {
            childNode = childNode.componentInstance._vnode;
            if (childNode &&
                childNode.data &&
                (styleData = normalizeStyleData(childNode.data))) {
                extend(res, styleData);
            }
        }
    }
    if ((styleData = normalizeStyleData(vnode.data))) {
        extend(res, styleData);
    }
    var parentNode = vnode;
    // @ts-expect-error parentNode.parent not VNodeWithData
    while ((parentNode = parentNode.parent)) {
        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
            extend(res, styleData);
        }
    }
    return res;
}

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
        el.style.setProperty(name, val);
    }
    else if (importantRE.test(val)) {
        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    }
    else {
        var normalizedName = normalize(name);
        if (Array.isArray(val)) {
            // Support values array created by autoprefixer, e.g.
            // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
            // Set them one by one, and the browser will only set those it can recognize
            for (var i = 0, len = val.length; i < len; i++) {
                el.style[normalizedName] = val[i];
            }
        }
        else {
            el.style[normalizedName] = val;
        }
    }
};
var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
        return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
        var name_1 = vendorNames[i] + capName;
        if (name_1 in emptyStyle) {
            return name_1;
        }
    }
});
function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticStyle) &&
        isUndef(data.style) &&
        isUndef(oldData.staticStyle) &&
        isUndef(oldData.style)) {
        return;
    }
    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;
    var style = normalizeStyleBinding(vnode.data.style) || {};
    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
    var newStyle = getStyle(vnode, true);
    for (name in oldStyle) {
        if (isUndef(newStyle[name])) {
            setProp(el, name, '');
        }
    }
    for (name in newStyle) {
        cur = newStyle[name];
        if (cur !== oldStyle[name]) {
            // ie9 setting to null has no effect, must use empty string
            setProp(el, name, cur == null ? '' : cur);
        }
    }
}
var style$1 = {
    create: updateStyle,
    update: updateStyle
};

var whitespaceRE$1 = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE$1).forEach(function (c) { return el.classList.add(c); });
        }
        else {
            el.classList.add(cls);
        }
    }
    else {
        var cur = " ".concat(el.getAttribute('class') || '', " ");
        if (cur.indexOf(' ' + cls + ' ') < 0) {
            el.setAttribute('class', (cur + cls).trim());
        }
    }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE$1).forEach(function (c) { return el.classList.remove(c); });
        }
        else {
            el.classList.remove(cls);
        }
        if (!el.classList.length) {
            el.removeAttribute('class');
        }
    }
    else {
        var cur = " ".concat(el.getAttribute('class') || '', " ");
        var tar = ' ' + cls + ' ';
        while (cur.indexOf(tar) >= 0) {
            cur = cur.replace(tar, ' ');
        }
        cur = cur.trim();
        if (cur) {
            el.setAttribute('class', cur);
        }
        else {
            el.removeAttribute('class');
        }
    }
}

function resolveTransition(def) {
    if (!def) {
        return;
    }
    /* istanbul ignore else */
    if (typeof def === 'object') {
        var res = {};
        if (def.css !== false) {
            extend(res, autoCssTransition(def.name || 'v'));
        }
        extend(res, def);
        return res;
    }
    else if (typeof def === 'string') {
        return autoCssTransition(def);
    }
}
var autoCssTransition = cached(function (name) {
    return {
        enterClass: "".concat(name, "-enter"),
        enterToClass: "".concat(name, "-enter-to"),
        enterActiveClass: "".concat(name, "-enter-active"),
        leaveClass: "".concat(name, "-leave"),
        leaveToClass: "".concat(name, "-leave-to"),
        leaveActiveClass: "".concat(name, "-leave-active")
    };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';
// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined &&
        window.onwebkittransitionend !== undefined) {
        transitionProp = 'WebkitTransition';
        transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined &&
        window.onwebkitanimationend !== undefined) {
        animationProp = 'WebkitAnimation';
        animationEndEvent = 'webkitAnimationEnd';
    }
}
// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
    ? window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : setTimeout
    : /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };
function nextFrame(fn) {
    raf(function () {
        // @ts-expect-error
        raf(fn);
    });
}
function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
        transitionClasses.push(cls);
        addClass(el, cls);
    }
}
function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
        remove$2(el._transitionClasses, cls);
    }
    removeClass(el, cls);
}
function whenTransitionEnds(el, expectedType, cb) {
    var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;
    if (!type)
        return cb();
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function () {
        el.removeEventListener(event, onEnd);
        cb();
    };
    var onEnd = function (e) {
        if (e.target === el) {
            if (++ended >= propCount) {
                end();
            }
        }
    };
    setTimeout(function () {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
}
var transformRE = /\b(transform|all)(,|$)/;
function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);
    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
        type: type,
        timeout: timeout,
        propCount: propCount,
        hasTransform: hasTransform
    };
}
function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max.apply(null, durations.map(function (d, i) {
        return toMs(d) + toMs(delays[i]);
    }));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}

function enter(vnode, toggleDisplay) {
    var el = vnode.elm;
    // call leave callback now
    if (isDef(el._leaveCb)) {
        el._leaveCb.cancelled = true;
        el._leaveCb();
    }
    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
        return;
    }
    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
        return;
    }
    var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;
    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
        context = transitionNode.context;
        transitionNode = transitionNode.parent;
    }
    var isAppear = !context._isMounted || !vnode.isRootInsert;
    if (isAppear && !appear && appear !== '') {
        return;
    }
    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear
        ? appearCancelled || enterCancelled
        : enterCancelled;
    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
    if ( true && explicitEnterDuration != null) {
        checkDuration(explicitEnterDuration, 'enter', vnode);
    }
    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);
    var cb = (el._enterCb = once(function () {
        if (expectsCSS) {
            removeTransitionClass(el, toClass);
            removeTransitionClass(el, activeClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, startClass);
            }
            enterCancelledHook && enterCancelledHook(el);
        }
        else {
            afterEnterHook && afterEnterHook(el);
        }
        el._enterCb = null;
    }));
    if (!vnode.data.show) {
        // remove pending leave element on enter by injecting an insert hook
        mergeVNodeHook(vnode, 'insert', function () {
            var parent = el.parentNode;
            var pendingNode = parent && parent._pending && parent._pending[vnode.key];
            if (pendingNode &&
                pendingNode.tag === vnode.tag &&
                pendingNode.elm._leaveCb) {
                pendingNode.elm._leaveCb();
            }
            enterHook && enterHook(el, cb);
        });
    }
    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
        addTransitionClass(el, startClass);
        addTransitionClass(el, activeClass);
        nextFrame(function () {
            removeTransitionClass(el, startClass);
            // @ts-expect-error
            if (!cb.cancelled) {
                addTransitionClass(el, toClass);
                if (!userWantsControl) {
                    if (isValidDuration(explicitEnterDuration)) {
                        setTimeout(cb, explicitEnterDuration);
                    }
                    else {
                        whenTransitionEnds(el, type, cb);
                    }
                }
            }
        });
    }
    if (vnode.data.show) {
        toggleDisplay && toggleDisplay();
        enterHook && enterHook(el, cb);
    }
    if (!expectsCSS && !userWantsControl) {
        cb();
    }
}
function leave(vnode, rm) {
    var el = vnode.elm;
    // call enter callback now
    if (isDef(el._enterCb)) {
        el._enterCb.cancelled = true;
        el._enterCb();
    }
    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
        return rm();
    }
    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
        return;
    }
    var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;
    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);
    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
    if ( true && isDef(explicitLeaveDuration)) {
        checkDuration(explicitLeaveDuration, 'leave', vnode);
    }
    var cb = (el._leaveCb = once(function () {
        if (el.parentNode && el.parentNode._pending) {
            el.parentNode._pending[vnode.key] = null;
        }
        if (expectsCSS) {
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, leaveClass);
            }
            leaveCancelled && leaveCancelled(el);
        }
        else {
            rm();
            afterLeave && afterLeave(el);
        }
        el._leaveCb = null;
    }));
    if (delayLeave) {
        delayLeave(performLeave);
    }
    else {
        performLeave();
    }
    function performLeave() {
        // the delayed leave may have already been cancelled
        // @ts-expect-error
        if (cb.cancelled) {
            return;
        }
        // record leaving element
        if (!vnode.data.show && el.parentNode) {
            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =
                vnode;
        }
        beforeLeave && beforeLeave(el);
        if (expectsCSS) {
            addTransitionClass(el, leaveClass);
            addTransitionClass(el, leaveActiveClass);
            nextFrame(function () {
                removeTransitionClass(el, leaveClass);
                // @ts-expect-error
                if (!cb.cancelled) {
                    addTransitionClass(el, leaveToClass);
                    if (!userWantsControl) {
                        if (isValidDuration(explicitLeaveDuration)) {
                            setTimeout(cb, explicitLeaveDuration);
                        }
                        else {
                            whenTransitionEnds(el, type, cb);
                        }
                    }
                }
            });
        }
        leave && leave(el, cb);
        if (!expectsCSS && !userWantsControl) {
            cb();
        }
    }
}
// only used in dev mode
function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
        warn$2("<transition> explicit ".concat(name, " duration is not a valid number - ") +
            "got ".concat(JSON.stringify(val), "."), vnode.context);
    }
    else if (isNaN(val)) {
        warn$2("<transition> explicit ".concat(name, " duration is NaN - ") +
            'the duration expression might be incorrect.', vnode.context);
    }
}
function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
        return false;
    }
    // @ts-expect-error
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
        // invoker
        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    }
    else {
        // @ts-expect-error
        return (fn._length || fn.length) > 1;
    }
}
function _enter(_, vnode) {
    if (vnode.data.show !== true) {
        enter(vnode);
    }
}
var transition = inBrowser
    ? {
        create: _enter,
        activate: _enter,
        remove: function (vnode, rm) {
            /* istanbul ignore else */
            if (vnode.data.show !== true) {
                // @ts-expect-error
                leave(vnode, rm);
            }
            else {
                rm();
            }
        }
    }
    : {};

var platformModules = [attrs, klass$1, events, domProps, style$1, transition];

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules$1 = platformModules.concat(baseModules);
var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules$1 });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */
/* istanbul ignore if */
if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
        var el = document.activeElement;
        // @ts-expect-error
        if (el && el.vmodel) {
            trigger(el, 'input');
        }
    });
}
var directive = {
    inserted: function (el, binding, vnode, oldVnode) {
        if (vnode.tag === 'select') {
            // #6903
            if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, 'postpatch', function () {
                    directive.componentUpdated(el, binding, vnode);
                });
            }
            else {
                setSelected(el, binding, vnode.context);
            }
            el._vOptions = [].map.call(el.options, getValue);
        }
        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
            el._vModifiers = binding.modifiers;
            if (!binding.modifiers.lazy) {
                el.addEventListener('compositionstart', onCompositionStart);
                el.addEventListener('compositionend', onCompositionEnd);
                // Safari < 10.2 & UIWebView doesn't fire compositionend when
                // switching focus before confirming composition choice
                // this also fixes the issue where some browsers e.g. iOS Chrome
                // fires "change" instead of "input" on autocomplete.
                el.addEventListener('change', onCompositionEnd);
                /* istanbul ignore if */
                if (isIE9) {
                    el.vmodel = true;
                }
            }
        }
    },
    componentUpdated: function (el, binding, vnode) {
        if (vnode.tag === 'select') {
            setSelected(el, binding, vnode.context);
            // in case the options rendered by v-for have changed,
            // it's possible that the value is out-of-sync with the rendered options.
            // detect such cases and filter out values that no longer has a matching
            // option in the DOM.
            var prevOptions_1 = el._vOptions;
            var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));
            if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {
                // trigger change event if
                // no matching option found for at least one value
                var needReset = el.multiple
                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })
                    : binding.value !== binding.oldValue &&
                        hasNoMatchingOption(binding.value, curOptions_1);
                if (needReset) {
                    trigger(el, 'change');
                }
            }
        }
    }
};
function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
        setTimeout(function () {
            actuallySetSelected(el, binding, vm);
        }, 0);
    }
}
function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
         true &&
            warn$2("<select multiple v-model=\"".concat(binding.expression, "\"> ") +
                "expects an Array value for its binding, but got ".concat(Object.prototype.toString
                    .call(value)
                    .slice(8, -1)), vm);
        return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
        option = el.options[i];
        if (isMultiple) {
            selected = looseIndexOf(value, getValue(option)) > -1;
            if (option.selected !== selected) {
                option.selected = selected;
            }
        }
        else {
            if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                    el.selectedIndex = i;
                }
                return;
            }
        }
    }
    if (!isMultiple) {
        el.selectedIndex = -1;
    }
}
function hasNoMatchingOption(value, options) {
    return options.every(function (o) { return !looseEqual(o, value); });
}
function getValue(option) {
    return '_value' in option ? option._value : option.value;
}
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing)
        return;
    e.target.composing = false;
    trigger(e.target, 'input');
}
function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
    // @ts-expect-error
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
        ? locateNode(vnode.componentInstance._vnode)
        : vnode;
}
var show = {
    bind: function (el, _a, vnode) {
        var value = _a.value;
        vnode = locateNode(vnode);
        var transition = vnode.data && vnode.data.transition;
        var originalDisplay = (el.__vOriginalDisplay =
            el.style.display === 'none' ? '' : el.style.display);
        if (value && transition) {
            vnode.data.show = true;
            enter(vnode, function () {
                el.style.display = originalDisplay;
            });
        }
        else {
            el.style.display = value ? originalDisplay : 'none';
        }
    },
    update: function (el, _a, vnode) {
        var value = _a.value, oldValue = _a.oldValue;
        /* istanbul ignore if */
        if (!value === !oldValue)
            return;
        vnode = locateNode(vnode);
        var transition = vnode.data && vnode.data.transition;
        if (transition) {
            vnode.data.show = true;
            if (value) {
                enter(vnode, function () {
                    el.style.display = el.__vOriginalDisplay;
                });
            }
            else {
                leave(vnode, function () {
                    el.style.display = 'none';
                });
            }
        }
        else {
            el.style.display = value ? el.__vOriginalDisplay : 'none';
        }
    },
    unbind: function (el, binding, vnode, oldVnode, isDestroy) {
        if (!isDestroy) {
            el.style.display = el.__vOriginalDisplay;
        }
    }
};

var platformDirectives = {
    model: directive,
    show: show
};

// Provides transition support for a single element/component.
var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
};
// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
        return getRealChild(getFirstComponentChild(compOptions.children));
    }
    else {
        return vnode;
    }
}
function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
        data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key in listeners) {
        data[camelize(key)] = listeners[key];
    }
    return data;
}
function placeholder(h, rawChild) {
    // @ts-expect-error
    if (/\d-keep-alive$/.test(rawChild.tag)) {
        return h('keep-alive', {
            props: rawChild.componentOptions.propsData
        });
    }
}
function hasParentTransition(vnode) {
    while ((vnode = vnode.parent)) {
        if (vnode.data.transition) {
            return true;
        }
    }
}
function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
}
var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };
var isVShowDirective = function (d) { return d.name === 'show'; };
var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,
    render: function (h) {
        var _this = this;
        var children = this.$slots.default;
        if (!children) {
            return;
        }
        // filter out text nodes (possible whitespaces)
        children = children.filter(isNotTextNode);
        /* istanbul ignore if */
        if (!children.length) {
            return;
        }
        // warn multiple elements
        if ( true && children.length > 1) {
            warn$2('<transition> can only be used on a single element. Use ' +
                '<transition-group> for lists.', this.$parent);
        }
        var mode = this.mode;
        // warn invalid mode
        if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {
            warn$2('invalid <transition> mode: ' + mode, this.$parent);
        }
        var rawChild = children[0];
        // if this is a component root node and the component's
        // parent container node also has transition, skip.
        if (hasParentTransition(this.$vnode)) {
            return rawChild;
        }
        // apply transition data to child
        // use getRealChild() to ignore abstract components e.g. keep-alive
        var child = getRealChild(rawChild);
        /* istanbul ignore if */
        if (!child) {
            return rawChild;
        }
        if (this._leaving) {
            return placeholder(h, rawChild);
        }
        // ensure a key that is unique to the vnode type and to this transition
        // component instance. This key will be used to remove pending leaving nodes
        // during entering.
        var id = "__transition-".concat(this._uid, "-");
        child.key =
            child.key == null
                ? child.isComment
                    ? id + 'comment'
                    : id + child.tag
                : isPrimitive(child.key)
                    ? String(child.key).indexOf(id) === 0
                        ? child.key
                        : id + child.key
                    : child.key;
        var data = ((child.data || (child.data = {})).transition =
            extractTransitionData(this));
        var oldRawChild = this._vnode;
        var oldChild = getRealChild(oldRawChild);
        // mark v-show
        // so that the transition module can hand over the control to the directive
        if (child.data.directives && child.data.directives.some(isVShowDirective)) {
            child.data.show = true;
        }
        if (oldChild &&
            oldChild.data &&
            !isSameChild(child, oldChild) &&
            !isAsyncPlaceholder(oldChild) &&
            // #6687 component root is a comment node
            !(oldChild.componentInstance &&
                oldChild.componentInstance._vnode.isComment)) {
            // replace old child transition data with fresh one
            // important for dynamic transitions!
            var oldData = (oldChild.data.transition = extend({}, data));
            // handle transition mode
            if (mode === 'out-in') {
                // return placeholder node and queue update when leave finishes
                this._leaving = true;
                mergeVNodeHook(oldData, 'afterLeave', function () {
                    _this._leaving = false;
                    _this.$forceUpdate();
                });
                return placeholder(h, rawChild);
            }
            else if (mode === 'in-out') {
                if (isAsyncPlaceholder(child)) {
                    return oldRawChild;
                }
                var delayedLeave_1;
                var performLeave = function () {
                    delayedLeave_1();
                };
                mergeVNodeHook(data, 'afterEnter', performLeave);
                mergeVNodeHook(data, 'enterCancelled', performLeave);
                mergeVNodeHook(oldData, 'delayLeave', function (leave) {
                    delayedLeave_1 = leave;
                });
            }
        }
        return rawChild;
    }
};

// Provides transition support for list items.
var props = extend({
    tag: String,
    moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
    props: props,
    beforeMount: function () {
        var _this = this;
        var update = this._update;
        this._update = function (vnode, hydrating) {
            var restoreActiveInstance = setActiveInstance(_this);
            // force removing pass
            _this.__patch__(_this._vnode, _this.kept, false, // hydrating
            true // removeOnly (!important, avoids unnecessary moves)
            );
            _this._vnode = _this.kept;
            restoreActiveInstance();
            update.call(_this, vnode, hydrating);
        };
    },
    render: function (h) {
        var tag = this.tag || this.$vnode.data.tag || 'span';
        var map = Object.create(null);
        var prevChildren = (this.prevChildren = this.children);
        var rawChildren = this.$slots.default || [];
        var children = (this.children = []);
        var transitionData = extractTransitionData(this);
        for (var i = 0; i < rawChildren.length; i++) {
            var c = rawChildren[i];
            if (c.tag) {
                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                    children.push(c);
                    map[c.key] = c;
                    (c.data || (c.data = {})).transition = transitionData;
                }
                else if (true) {
                    var opts = c.componentOptions;
                    var name_1 = opts
                        ? getComponentName(opts.Ctor.options) || opts.tag || ''
                        : c.tag;
                    warn$2("<transition-group> children must be keyed: <".concat(name_1, ">"));
                }
            }
        }
        if (prevChildren) {
            var kept = [];
            var removed = [];
            for (var i = 0; i < prevChildren.length; i++) {
                var c = prevChildren[i];
                c.data.transition = transitionData;
                // @ts-expect-error .getBoundingClientRect is not typed in Node
                c.data.pos = c.elm.getBoundingClientRect();
                if (map[c.key]) {
                    kept.push(c);
                }
                else {
                    removed.push(c);
                }
            }
            this.kept = h(tag, null, kept);
            this.removed = removed;
        }
        return h(tag, null, children);
    },
    updated: function () {
        var children = this.prevChildren;
        var moveClass = this.moveClass || (this.name || 'v') + '-move';
        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
            return;
        }
        // we divide the work into three loops to avoid mixing DOM reads and writes
        // in each iteration - which helps prevent layout thrashing.
        children.forEach(callPendingCbs);
        children.forEach(recordPosition);
        children.forEach(applyTranslation);
        // force reflow to put everything in position
        // assign to this to avoid being removed in tree-shaking
        // $flow-disable-line
        this._reflow = document.body.offsetHeight;
        children.forEach(function (c) {
            if (c.data.moved) {
                var el_1 = c.elm;
                var s = el_1.style;
                addTransitionClass(el_1, moveClass);
                s.transform = s.WebkitTransform = s.transitionDuration = '';
                el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {
                    if (e && e.target !== el_1) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el_1.removeEventListener(transitionEndEvent, cb);
                        el_1._moveCb = null;
                        removeTransitionClass(el_1, moveClass);
                    }
                }));
            }
        });
    },
    methods: {
        hasMove: function (el, moveClass) {
            /* istanbul ignore if */
            if (!hasTransition) {
                return false;
            }
            /* istanbul ignore if */
            if (this._hasMove) {
                return this._hasMove;
            }
            // Detect whether an element with the move class applied has
            // CSS transitions. Since the element may be inside an entering
            // transition at this very moment, we make a clone of it and remove
            // all other transition classes applied to ensure only the move class
            // is applied.
            var clone = el.cloneNode();
            if (el._transitionClasses) {
                el._transitionClasses.forEach(function (cls) {
                    removeClass(clone, cls);
                });
            }
            addClass(clone, moveClass);
            clone.style.display = 'none';
            this.$el.appendChild(clone);
            var info = getTransitionInfo(clone);
            this.$el.removeChild(clone);
            return (this._hasMove = info.hasTransform);
        }
    }
};
function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
        c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
        c.elm._enterCb();
    }
}
function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
}
function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
        c.data.moved = true;
        var s = c.elm.style;
        s.transform = s.WebkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
        s.transitionDuration = '0s';
    }
}

var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
};

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;
// public mount method
Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
};
// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
    setTimeout(function () {
        if (config.devtools) {
            if (devtools) {
                devtools.emit('init', Vue);
            }
            else if (true) {
                // @ts-expect-error
                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' +
                    'https://github.com/vuejs/vue-devtools');
            }
        }
        if ( true &&
            config.productionTip !== false &&
            typeof console !== 'undefined') {
            // @ts-expect-error
            console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" +
                "Make sure to turn on production mode when deploying for production.\n" +
                "See more tips at https://vuejs.org/guide/deployment.html");
        }
    }, 0);
}

var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});
function parseText(text, delimiters) {
    //@ts-expect-error
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
        return;
    }
    var tokens = [];
    var rawTokens = [];
    var lastIndex = (tagRE.lastIndex = 0);
    var match, index, tokenValue;
    while ((match = tagRE.exec(text))) {
        index = match.index;
        // push text token
        if (index > lastIndex) {
            rawTokens.push((tokenValue = text.slice(lastIndex, index)));
            tokens.push(JSON.stringify(tokenValue));
        }
        // tag token
        var exp = parseFilters(match[1].trim());
        tokens.push("_s(".concat(exp, ")"));
        rawTokens.push({ '@binding': exp });
        lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
        rawTokens.push((tokenValue = text.slice(lastIndex)));
        tokens.push(JSON.stringify(tokenValue));
    }
    return {
        expression: tokens.join('+'),
        tokens: rawTokens
    };
}

function transformNode$1(el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');
    if ( true && staticClass) {
        var res = parseText(staticClass, options.delimiters);
        if (res) {
            warn("class=\"".concat(staticClass, "\": ") +
                'Interpolation inside attributes has been removed. ' +
                'Use v-bind or the colon shorthand instead. For example, ' +
                'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
        }
    }
    if (staticClass) {
        el.staticClass = JSON.stringify(staticClass.replace(/\s+/g, ' ').trim());
    }
    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
        el.classBinding = classBinding;
    }
}
function genData$2(el) {
    var data = '';
    if (el.staticClass) {
        data += "staticClass:".concat(el.staticClass, ",");
    }
    if (el.classBinding) {
        data += "class:".concat(el.classBinding, ",");
    }
    return data;
}
var klass = {
    staticKeys: ['staticClass'],
    transformNode: transformNode$1,
    genData: genData$2
};

function transformNode(el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
        /* istanbul ignore if */
        if (true) {
            var res = parseText(staticStyle, options.delimiters);
            if (res) {
                warn("style=\"".concat(staticStyle, "\": ") +
                    'Interpolation inside attributes has been removed. ' +
                    'Use v-bind or the colon shorthand instead. For example, ' +
                    'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
            }
        }
        el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }
    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
        el.styleBinding = styleBinding;
    }
}
function genData$1(el) {
    var data = '';
    if (el.staticStyle) {
        data += "staticStyle:".concat(el.staticStyle, ",");
    }
    if (el.styleBinding) {
        data += "style:(".concat(el.styleBinding, "),");
    }
    return data;
}
var style = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode,
    genData: genData$1
};

var decoder;
var he = {
    decode: function (html) {
        decoder = decoder || document.createElement('div');
        decoder.innerHTML = html;
        return decoder.textContent;
    }
};

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
    'link,meta,param,source,track,wbr');
// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');
// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
    'title,tr,track');

/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(unicodeRegExp.source, "]*");
var qnameCapture = "((?:".concat(ncname, "\\:)?").concat(ncname, ")");
var startTagOpen = new RegExp("^<".concat(qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/".concat(qnameCapture, "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being passed as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;
// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t',
    '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;
// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) {
    return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};
function decodeAttr(value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) { return decodingMap[match]; });
}
function parseHTML(html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag = options.isUnaryTag || no;
    var canBeLeftOpenTag = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    var _loop_1 = function () {
        last = html;
        // Make sure we're not in a plaintext content element like script/style
        if (!lastTag || !isPlainTextElement(lastTag)) {
            var textEnd = html.indexOf('<');
            if (textEnd === 0) {
                // Comment:
                if (comment.test(html)) {
                    var commentEnd = html.indexOf('-->');
                    if (commentEnd >= 0) {
                        if (options.shouldKeepComment && options.comment) {
                            options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
                        }
                        advance(commentEnd + 3);
                        return "continue";
                    }
                }
                // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
                if (conditionalComment.test(html)) {
                    var conditionalEnd = html.indexOf(']>');
                    if (conditionalEnd >= 0) {
                        advance(conditionalEnd + 2);
                        return "continue";
                    }
                }
                // Doctype:
                var doctypeMatch = html.match(doctype);
                if (doctypeMatch) {
                    advance(doctypeMatch[0].length);
                    return "continue";
                }
                // End tag:
                var endTagMatch = html.match(endTag);
                if (endTagMatch) {
                    var curIndex = index;
                    advance(endTagMatch[0].length);
                    parseEndTag(endTagMatch[1], curIndex, index);
                    return "continue";
                }
                // Start tag:
                var startTagMatch = parseStartTag();
                if (startTagMatch) {
                    handleStartTag(startTagMatch);
                    if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
                        advance(1);
                    }
                    return "continue";
                }
            }
            var text = void 0, rest = void 0, next = void 0;
            if (textEnd >= 0) {
                rest = html.slice(textEnd);
                while (!endTag.test(rest) &&
                    !startTagOpen.test(rest) &&
                    !comment.test(rest) &&
                    !conditionalComment.test(rest)) {
                    // < in plain text, be forgiving and treat it as text
                    next = rest.indexOf('<', 1);
                    if (next < 0)
                        break;
                    textEnd += next;
                    rest = html.slice(textEnd);
                }
                text = html.substring(0, textEnd);
            }
            if (textEnd < 0) {
                text = html;
            }
            if (text) {
                advance(text.length);
            }
            if (options.chars && text) {
                options.chars(text, index - text.length, index);
            }
        }
        else {
            var endTagLength_1 = 0;
            var stackedTag_1 = lastTag.toLowerCase();
            var reStackedTag = reCache[stackedTag_1] ||
                (reCache[stackedTag_1] = new RegExp('([\\s\\S]*?)(</' + stackedTag_1 + '[^>]*>)', 'i'));
            var rest = html.replace(reStackedTag, function (all, text, endTag) {
                endTagLength_1 = endTag.length;
                if (!isPlainTextElement(stackedTag_1) && stackedTag_1 !== 'noscript') {
                    text = text
                        .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
                        .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
                }
                if (shouldIgnoreFirstNewline(stackedTag_1, text)) {
                    text = text.slice(1);
                }
                if (options.chars) {
                    options.chars(text);
                }
                return '';
            });
            index += html.length - rest.length;
            html = rest;
            parseEndTag(stackedTag_1, index - endTagLength_1, index);
        }
        if (html === last) {
            options.chars && options.chars(html);
            if ( true && !stack.length && options.warn) {
                options.warn("Mal-formatted tag at end of template: \"".concat(html, "\""), {
                    start: index + html.length
                });
            }
            return "break";
        }
    };
    while (html) {
        var state_1 = _loop_1();
        if (state_1 === "break")
            break;
    }
    // Clean up any remaining tags
    parseEndTag();
    function advance(n) {
        index += n;
        html = html.substring(n);
    }
    function parseStartTag() {
        var start = html.match(startTagOpen);
        if (start) {
            var match = {
                tagName: start[1],
                attrs: [],
                start: index
            };
            advance(start[0].length);
            var end = void 0, attr = void 0;
            while (!(end = html.match(startTagClose)) &&
                (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
                attr.start = index;
                advance(attr[0].length);
                attr.end = index;
                match.attrs.push(attr);
            }
            if (end) {
                match.unarySlash = end[1];
                advance(end[0].length);
                match.end = index;
                return match;
            }
        }
    }
    function handleStartTag(match) {
        var tagName = match.tagName;
        var unarySlash = match.unarySlash;
        if (expectHTML) {
            if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
                parseEndTag(lastTag);
            }
            if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
                parseEndTag(tagName);
            }
        }
        var unary = isUnaryTag(tagName) || !!unarySlash;
        var l = match.attrs.length;
        var attrs = new Array(l);
        for (var i = 0; i < l; i++) {
            var args = match.attrs[i];
            var value = args[3] || args[4] || args[5] || '';
            var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
                ? options.shouldDecodeNewlinesForHref
                : options.shouldDecodeNewlines;
            attrs[i] = {
                name: args[1],
                value: decodeAttr(value, shouldDecodeNewlines)
            };
            if ( true && options.outputSourceRange) {
                attrs[i].start = args.start + args[0].match(/^\s*/).length;
                attrs[i].end = args.end;
            }
        }
        if (!unary) {
            stack.push({
                tag: tagName,
                lowerCasedTag: tagName.toLowerCase(),
                attrs: attrs,
                start: match.start,
                end: match.end
            });
            lastTag = tagName;
        }
        if (options.start) {
            options.start(tagName, attrs, unary, match.start, match.end);
        }
    }
    function parseEndTag(tagName, start, end) {
        var pos, lowerCasedTagName;
        if (start == null)
            start = index;
        if (end == null)
            end = index;
        // Find the closest opened tag of the same type
        if (tagName) {
            lowerCasedTagName = tagName.toLowerCase();
            for (pos = stack.length - 1; pos >= 0; pos--) {
                if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                    break;
                }
            }
        }
        else {
            // If no tag name is provided, clean shop
            pos = 0;
        }
        if (pos >= 0) {
            // Close all the open elements, up the stack
            for (var i = stack.length - 1; i >= pos; i--) {
                if ( true && (i > pos || !tagName) && options.warn) {
                    options.warn("tag <".concat(stack[i].tag, "> has no matching end tag."), {
                        start: stack[i].start,
                        end: stack[i].end
                    });
                }
                if (options.end) {
                    options.end(stack[i].tag, start, end);
                }
            }
            // Remove the open elements from the stack
            stack.length = pos;
            lastTag = pos && stack[pos - 1].tag;
        }
        else if (lowerCasedTagName === 'br') {
            if (options.start) {
                options.start(tagName, [], true, start, end);
            }
        }
        else if (lowerCasedTagName === 'p') {
            if (options.start) {
                options.start(tagName, [], false, start, end);
            }
            if (options.end) {
                options.end(tagName, start, end);
            }
        }
    }
}

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:|^#/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE = /[ \f\t\r\n]+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_";
// configurable state
var warn;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;
function createASTElement(tag, attrs, parent) {
    return {
        type: 1,
        tag: tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        rawAttrsMap: {},
        parent: parent,
        children: []
    };
}
/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
    warn = options.warn || baseWarn;
    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;
    var isReservedTag = options.isReservedTag || no;
    maybeComponent = function (el) {
        return !!(el.component ||
            el.attrsMap[':is'] ||
            el.attrsMap['v-bind:is'] ||
            !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));
    };
    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
    delimiters = options.delimiters;
    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var whitespaceOption = options.whitespace;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;
    var warned = false;
    function warnOnce(msg, range) {
        if (!warned) {
            warned = true;
            warn(msg, range);
        }
    }
    function closeElement(element) {
        trimEndingWhitespace(element);
        if (!inVPre && !element.processed) {
            element = processElement(element, options);
        }
        // tree management
        if (!stack.length && element !== root) {
            // allow root elements with v-if, v-else-if and v-else
            if (root.if && (element.elseif || element.else)) {
                if (true) {
                    checkRootConstraints(element);
                }
                addIfCondition(root, {
                    exp: element.elseif,
                    block: element
                });
            }
            else if (true) {
                warnOnce("Component template should contain exactly one root element. " +
                    "If you are using v-if on multiple elements, " +
                    "use v-else-if to chain them instead.", { start: element.start });
            }
        }
        if (currentParent && !element.forbidden) {
            if (element.elseif || element.else) {
                processIfConditions(element, currentParent);
            }
            else {
                if (element.slotScope) {
                    // scoped slot
                    // keep it in the children list so that v-else(-if) conditions can
                    // find it as the prev node.
                    var name_1 = element.slotTarget || '"default"';
                    (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name_1] = element;
                }
                currentParent.children.push(element);
                element.parent = currentParent;
            }
        }
        // final children cleanup
        // filter out scoped slots
        element.children = element.children.filter(function (c) { return !c.slotScope; });
        // remove trailing whitespace node again
        trimEndingWhitespace(element);
        // check pre state
        if (element.pre) {
            inVPre = false;
        }
        if (platformIsPreTag(element.tag)) {
            inPre = false;
        }
        // apply post-transforms
        for (var i = 0; i < postTransforms.length; i++) {
            postTransforms[i](element, options);
        }
    }
    function trimEndingWhitespace(el) {
        // remove trailing whitespace node
        if (!inPre) {
            var lastNode = void 0;
            while ((lastNode = el.children[el.children.length - 1]) &&
                lastNode.type === 3 &&
                lastNode.text === ' ') {
                el.children.pop();
            }
        }
    }
    function checkRootConstraints(el) {
        if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce("Cannot use <".concat(el.tag, "> as component root element because it may ") +
                'contain multiple nodes.', { start: el.start });
        }
        if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' +
                'it renders multiple elements.', el.rawAttrsMap['v-for']);
        }
    }
    parseHTML(template, {
        warn: warn,
        expectHTML: options.expectHTML,
        isUnaryTag: options.isUnaryTag,
        canBeLeftOpenTag: options.canBeLeftOpenTag,
        shouldDecodeNewlines: options.shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
        shouldKeepComment: options.comments,
        outputSourceRange: options.outputSourceRange,
        start: function (tag, attrs, unary, start, end) {
            // check namespace.
            // inherit parent ns if there is one
            var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);
            // handle IE svg bug
            /* istanbul ignore if */
            if (isIE && ns === 'svg') {
                attrs = guardIESVGBug(attrs);
            }
            var element = createASTElement(tag, attrs, currentParent);
            if (ns) {
                element.ns = ns;
            }
            if (true) {
                if (options.outputSourceRange) {
                    element.start = start;
                    element.end = end;
                    element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
                        cumulated[attr.name] = attr;
                        return cumulated;
                    }, {});
                }
                attrs.forEach(function (attr) {
                    if (invalidAttributeRE.test(attr.name)) {
                        warn("Invalid dynamic argument expression: attribute names cannot contain " +
                            "spaces, quotes, <, >, / or =.", options.outputSourceRange
                            ? {
                                start: attr.start + attr.name.indexOf("["),
                                end: attr.start + attr.name.length
                            }
                            : undefined);
                    }
                });
            }
            if (isForbiddenTag(element) && !isServerRendering()) {
                element.forbidden = true;
                 true &&
                    warn('Templates should only be responsible for mapping the state to the ' +
                        'UI. Avoid placing tags with side-effects in your templates, such as ' +
                        "<".concat(tag, ">") +
                        ', as they will not be parsed.', { start: element.start });
            }
            // apply pre-transforms
            for (var i = 0; i < preTransforms.length; i++) {
                element = preTransforms[i](element, options) || element;
            }
            if (!inVPre) {
                processPre(element);
                if (element.pre) {
                    inVPre = true;
                }
            }
            if (platformIsPreTag(element.tag)) {
                inPre = true;
            }
            if (inVPre) {
                processRawAttrs(element);
            }
            else if (!element.processed) {
                // structural directives
                processFor(element);
                processIf(element);
                processOnce(element);
            }
            if (!root) {
                root = element;
                if (true) {
                    checkRootConstraints(root);
                }
            }
            if (!unary) {
                currentParent = element;
                stack.push(element);
            }
            else {
                closeElement(element);
            }
        },
        end: function (tag, start, end) {
            var element = stack[stack.length - 1];
            // pop stack
            stack.length -= 1;
            currentParent = stack[stack.length - 1];
            if ( true && options.outputSourceRange) {
                element.end = end;
            }
            closeElement(element);
        },
        chars: function (text, start, end) {
            if (!currentParent) {
                if (true) {
                    if (text === template) {
                        warnOnce('Component template requires a root element, rather than just text.', { start: start });
                    }
                    else if ((text = text.trim())) {
                        warnOnce("text \"".concat(text, "\" outside root element will be ignored."), {
                            start: start
                        });
                    }
                }
                return;
            }
            // IE textarea placeholder bug
            /* istanbul ignore if */
            if (isIE &&
                currentParent.tag === 'textarea' &&
                currentParent.attrsMap.placeholder === text) {
                return;
            }
            var children = currentParent.children;
            if (inPre || text.trim()) {
                text = isTextTag(currentParent)
                    ? text
                    : decodeHTMLCached(text);
            }
            else if (!children.length) {
                // remove the whitespace-only node right after an opening tag
                text = '';
            }
            else if (whitespaceOption) {
                if (whitespaceOption === 'condense') {
                    // in condense mode, remove the whitespace node if it contains
                    // line break, otherwise condense to a single space
                    text = lineBreakRE.test(text) ? '' : ' ';
                }
                else {
                    text = ' ';
                }
            }
            else {
                text = preserveWhitespace ? ' ' : '';
            }
            if (text) {
                if (!inPre && whitespaceOption === 'condense') {
                    // condense consecutive whitespaces into single space
                    text = text.replace(whitespaceRE, ' ');
                }
                var res = void 0;
                var child = void 0;
                if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
                    child = {
                        type: 2,
                        expression: res.expression,
                        tokens: res.tokens,
                        text: text
                    };
                }
                else if (text !== ' ' ||
                    !children.length ||
                    children[children.length - 1].text !== ' ') {
                    child = {
                        type: 3,
                        text: text
                    };
                }
                if (child) {
                    if ( true && options.outputSourceRange) {
                        child.start = start;
                        child.end = end;
                    }
                    children.push(child);
                }
            }
        },
        comment: function (text, start, end) {
            // adding anything as a sibling to the root node is forbidden
            // comments should still be allowed, but ignored
            if (currentParent) {
                var child = {
                    type: 3,
                    text: text,
                    isComment: true
                };
                if ( true && options.outputSourceRange) {
                    child.start = start;
                    child.end = end;
                }
                currentParent.children.push(child);
            }
        }
    });
    return root;
}
function processPre(el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
        el.pre = true;
    }
}
function processRawAttrs(el) {
    var list = el.attrsList;
    var len = list.length;
    if (len) {
        var attrs = (el.attrs = new Array(len));
        for (var i = 0; i < len; i++) {
            attrs[i] = {
                name: list[i].name,
                value: JSON.stringify(list[i].value)
            };
            if (list[i].start != null) {
                attrs[i].start = list[i].start;
                attrs[i].end = list[i].end;
            }
        }
    }
    else if (!el.pre) {
        // non root node in pre blocks with no attributes
        el.plain = true;
    }
}
function processElement(element, options) {
    processKey(element);
    // determine whether this is a plain element after
    // removing structural attributes
    element.plain =
        !element.key && !element.scopedSlots && !element.attrsList.length;
    processRef(element);
    processSlotContent(element);
    processSlotOutlet(element);
    processComponent(element);
    for (var i = 0; i < transforms.length; i++) {
        element = transforms[i](element, options) || element;
    }
    processAttrs(element);
    return element;
}
function processKey(el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
        if (true) {
            if (el.tag === 'template') {
                warn("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
            }
            if (el.for) {
                var iterator = el.iterator2 || el.iterator1;
                var parent_1 = el.parent;
                if (iterator &&
                    iterator === exp &&
                    parent_1 &&
                    parent_1.tag === 'transition-group') {
                    warn("Do not use v-for index as key on <transition-group> children, " +
                        "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true /* tip */);
                }
            }
        }
        el.key = exp;
    }
}
function processRef(el) {
    var ref = getBindingAttr(el, 'ref');
    if (ref) {
        el.ref = ref;
        el.refInFor = checkInFor(el);
    }
}
function processFor(el) {
    var exp;
    if ((exp = getAndRemoveAttr(el, 'v-for'))) {
        var res = parseFor(exp);
        if (res) {
            extend(el, res);
        }
        else if (true) {
            warn("Invalid v-for expression: ".concat(exp), el.rawAttrsMap['v-for']);
        }
    }
}
function parseFor(exp) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch)
        return;
    var res = {};
    res.for = inMatch[2].trim();
    var alias = inMatch[1].trim().replace(stripParensRE, '');
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
        res.alias = alias.replace(forIteratorRE, '').trim();
        res.iterator1 = iteratorMatch[1].trim();
        if (iteratorMatch[2]) {
            res.iterator2 = iteratorMatch[2].trim();
        }
    }
    else {
        res.alias = alias;
    }
    return res;
}
function processIf(el) {
    var exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
        el.if = exp;
        addIfCondition(el, {
            exp: exp,
            block: el
        });
    }
    else {
        if (getAndRemoveAttr(el, 'v-else') != null) {
            el.else = true;
        }
        var elseif = getAndRemoveAttr(el, 'v-else-if');
        if (elseif) {
            el.elseif = elseif;
        }
    }
}
function processIfConditions(el, parent) {
    var prev = findPrevElement(parent.children);
    if (prev && prev.if) {
        addIfCondition(prev, {
            exp: el.elseif,
            block: el
        });
    }
    else if (true) {
        warn("v-".concat(el.elseif ? 'else-if="' + el.elseif + '"' : 'else', " ") +
            "used on element <".concat(el.tag, "> without corresponding v-if."), el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
    }
}
function findPrevElement(children) {
    var i = children.length;
    while (i--) {
        if (children[i].type === 1) {
            return children[i];
        }
        else {
            if ( true && children[i].text !== ' ') {
                warn("text \"".concat(children[i].text.trim(), "\" between v-if and v-else(-if) ") +
                    "will be ignored.", children[i]);
            }
            children.pop();
        }
    }
}
function addIfCondition(el, condition) {
    if (!el.ifConditions) {
        el.ifConditions = [];
    }
    el.ifConditions.push(condition);
}
function processOnce(el) {
    var once = getAndRemoveAttr(el, 'v-once');
    if (once != null) {
        el.once = true;
    }
}
// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent(el) {
    var slotScope;
    if (el.tag === 'template') {
        slotScope = getAndRemoveAttr(el, 'scope');
        /* istanbul ignore if */
        if ( true && slotScope) {
            warn("the \"scope\" attribute for scoped slots have been deprecated and " +
                "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
                "can also be used on plain elements in addition to <template> to " +
                "denote scoped slots.", el.rawAttrsMap['scope'], true);
        }
        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    }
    else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
        /* istanbul ignore if */
        if ( true && el.attrsMap['v-for']) {
            warn("Ambiguous combined usage of slot-scope and v-for on <".concat(el.tag, "> ") +
                "(v-for takes higher priority). Use a wrapper <template> for the " +
                "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
        }
        el.slotScope = slotScope;
    }
    // slot="xxx"
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
        el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
        // preserve slot as an attribute for native shadow DOM compat
        // only for non-scoped slots.
        if (el.tag !== 'template' && !el.slotScope) {
            addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
        }
    }
    // 2.6 v-slot syntax
    {
        if (el.tag === 'template') {
            // v-slot on <template>
            var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
            if (slotBinding) {
                if (true) {
                    if (el.slotTarget || el.slotScope) {
                        warn("Unexpected mixed usage of different slot syntaxes.", el);
                    }
                    if (el.parent && !maybeComponent(el.parent)) {
                        warn("<template v-slot> can only appear at the root level inside " +
                            "the receiving component", el);
                    }
                }
                var _a = getSlotName(slotBinding), name_2 = _a.name, dynamic = _a.dynamic;
                el.slotTarget = name_2;
                el.slotTargetDynamic = dynamic;
                el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
            }
        }
        else {
            // v-slot on component, denotes default slot
            var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
            if (slotBinding) {
                if (true) {
                    if (!maybeComponent(el)) {
                        warn("v-slot can only be used on components or <template>.", slotBinding);
                    }
                    if (el.slotScope || el.slotTarget) {
                        warn("Unexpected mixed usage of different slot syntaxes.", el);
                    }
                    if (el.scopedSlots) {
                        warn("To avoid scope ambiguity, the default slot should also use " +
                            "<template> syntax when there are other named slots.", slotBinding);
                    }
                }
                // add the component's children to its default slot
                var slots = el.scopedSlots || (el.scopedSlots = {});
                var _b = getSlotName(slotBinding), name_3 = _b.name, dynamic = _b.dynamic;
                var slotContainer_1 = (slots[name_3] = createASTElement('template', [], el));
                slotContainer_1.slotTarget = name_3;
                slotContainer_1.slotTargetDynamic = dynamic;
                slotContainer_1.children = el.children.filter(function (c) {
                    if (!c.slotScope) {
                        c.parent = slotContainer_1;
                        return true;
                    }
                });
                slotContainer_1.slotScope = slotBinding.value || emptySlotScopeToken;
                // remove children as they are returned from scopedSlots now
                el.children = [];
                // mark el non-plain so data gets generated
                el.plain = false;
            }
        }
    }
}
function getSlotName(binding) {
    var name = binding.name.replace(slotRE, '');
    if (!name) {
        if (binding.name[0] !== '#') {
            name = 'default';
        }
        else if (true) {
            warn("v-slot shorthand syntax requires a slot name.", binding);
        }
    }
    return dynamicArgRE.test(name)
        ? // dynamic [name]
            { name: name.slice(1, -1), dynamic: true }
        : // static name
            { name: "\"".concat(name, "\""), dynamic: false };
}
// handle <slot/> outlets
function processSlotOutlet(el) {
    if (el.tag === 'slot') {
        el.slotName = getBindingAttr(el, 'name');
        if ( true && el.key) {
            warn("`key` does not work on <slot> because slots are abstract outlets " +
                "and can possibly expand into multiple elements. " +
                "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
        }
    }
}
function processComponent(el) {
    var binding;
    if ((binding = getBindingAttr(el, 'is'))) {
        el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
        el.inlineTemplate = true;
    }
}
function processAttrs(el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
    for (i = 0, l = list.length; i < l; i++) {
        name = rawName = list[i].name;
        value = list[i].value;
        if (dirRE.test(name)) {
            // mark element as dynamic
            el.hasBindings = true;
            // modifiers
            modifiers = parseModifiers(name.replace(dirRE, ''));
            // support .foo shorthand syntax for the .prop modifier
            if (modifiers) {
                name = name.replace(modifierRE, '');
            }
            if (bindRE.test(name)) {
                // v-bind
                name = name.replace(bindRE, '');
                value = parseFilters(value);
                isDynamic = dynamicArgRE.test(name);
                if (isDynamic) {
                    name = name.slice(1, -1);
                }
                if ( true && value.trim().length === 0) {
                    warn("The value for a v-bind expression cannot be empty. Found in \"v-bind:".concat(name, "\""));
                }
                if (modifiers) {
                    if (modifiers.prop && !isDynamic) {
                        name = camelize(name);
                        if (name === 'innerHtml')
                            name = 'innerHTML';
                    }
                    if (modifiers.camel && !isDynamic) {
                        name = camelize(name);
                    }
                    if (modifiers.sync) {
                        syncGen = genAssignmentCode(value, "$event");
                        if (!isDynamic) {
                            addHandler(el, "update:".concat(camelize(name)), syncGen, null, false, warn, list[i]);
                            if (hyphenate(name) !== camelize(name)) {
                                addHandler(el, "update:".concat(hyphenate(name)), syncGen, null, false, warn, list[i]);
                            }
                        }
                        else {
                            // handler w/ dynamic event name
                            addHandler(el, "\"update:\"+(".concat(name, ")"), syncGen, null, false, warn, list[i], true // dynamic
                            );
                        }
                    }
                }
                if ((modifiers && modifiers.prop) ||
                    (!el.component && platformMustUseProp(el.tag, el.attrsMap.type, name))) {
                    addProp(el, name, value, list[i], isDynamic);
                }
                else {
                    addAttr(el, name, value, list[i], isDynamic);
                }
            }
            else if (onRE.test(name)) {
                // v-on
                name = name.replace(onRE, '');
                isDynamic = dynamicArgRE.test(name);
                if (isDynamic) {
                    name = name.slice(1, -1);
                }
                addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic);
            }
            else {
                // normal directives
                name = name.replace(dirRE, '');
                // parse arg
                var argMatch = name.match(argRE);
                var arg = argMatch && argMatch[1];
                isDynamic = false;
                if (arg) {
                    name = name.slice(0, -(arg.length + 1));
                    if (dynamicArgRE.test(arg)) {
                        arg = arg.slice(1, -1);
                        isDynamic = true;
                    }
                }
                addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
                if ( true && name === 'model') {
                    checkForAliasModel(el, value);
                }
            }
        }
        else {
            // literal attribute
            if (true) {
                var res = parseText(value, delimiters);
                if (res) {
                    warn("".concat(name, "=\"").concat(value, "\": ") +
                        'Interpolation inside attributes has been removed. ' +
                        'Use v-bind or the colon shorthand instead. For example, ' +
                        'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
                }
            }
            addAttr(el, name, JSON.stringify(value), list[i]);
            // #6887 firefox doesn't update muted state if set via attribute
            // even immediately after element creation
            if (!el.component &&
                name === 'muted' &&
                platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                addProp(el, name, 'true', list[i]);
            }
        }
    }
}
function checkInFor(el) {
    var parent = el;
    while (parent) {
        if (parent.for !== undefined) {
            return true;
        }
        parent = parent.parent;
    }
    return false;
}
function parseModifiers(name) {
    var match = name.match(modifierRE);
    if (match) {
        var ret_1 = {};
        match.forEach(function (m) {
            ret_1[m.slice(1)] = true;
        });
        return ret_1;
    }
}
function makeAttrsMap(attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
        if ( true && map[attrs[i].name] && !isIE && !isEdge) {
            warn('duplicate attribute: ' + attrs[i].name, attrs[i]);
        }
        map[attrs[i].name] = attrs[i].value;
    }
    return map;
}
// for script (e.g. type="x/template") or style, do not decode content
function isTextTag(el) {
    return el.tag === 'script' || el.tag === 'style';
}
function isForbiddenTag(el) {
    return (el.tag === 'style' ||
        (el.tag === 'script' &&
            (!el.attrsMap.type || el.attrsMap.type === 'text/javascript')));
}
var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */
function guardIESVGBug(attrs) {
    var res = [];
    for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        if (!ieNSBug.test(attr.name)) {
            attr.name = attr.name.replace(ieNSPrefix, '');
            res.push(attr);
        }
    }
    return res;
}
function checkForAliasModel(el, value) {
    var _el = el;
    while (_el) {
        if (_el.for && _el.alias === value) {
            warn("<".concat(el.tag, " v-model=\"").concat(value, "\">: ") +
                "You are binding v-model directly to a v-for iteration alias. " +
                "This will not be able to modify the v-for source array because " +
                "writing to the alias is like modifying a function local variable. " +
                "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
        }
        _el = _el.parent;
    }
}

/**
 * Expand input[v-model] with dynamic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */
function preTransformNode(el, options) {
    if (el.tag === 'input') {
        var map = el.attrsMap;
        if (!map['v-model']) {
            return;
        }
        var typeBinding = void 0;
        if (map[':type'] || map['v-bind:type']) {
            typeBinding = getBindingAttr(el, 'type');
        }
        if (!map.type && !typeBinding && map['v-bind']) {
            typeBinding = "(".concat(map['v-bind'], ").type");
        }
        if (typeBinding) {
            var ifCondition = getAndRemoveAttr(el, 'v-if', true);
            var ifConditionExtra = ifCondition ? "&&(".concat(ifCondition, ")") : "";
            var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
            var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
            // 1. checkbox
            var branch0 = cloneASTElement(el);
            // process for on the main node
            processFor(branch0);
            addRawAttr(branch0, 'type', 'checkbox');
            processElement(branch0, options);
            branch0.processed = true; // prevent it from double-processed
            branch0.if = "(".concat(typeBinding, ")==='checkbox'") + ifConditionExtra;
            addIfCondition(branch0, {
                exp: branch0.if,
                block: branch0
            });
            // 2. add radio else-if condition
            var branch1 = cloneASTElement(el);
            getAndRemoveAttr(branch1, 'v-for', true);
            addRawAttr(branch1, 'type', 'radio');
            processElement(branch1, options);
            addIfCondition(branch0, {
                exp: "(".concat(typeBinding, ")==='radio'") + ifConditionExtra,
                block: branch1
            });
            // 3. other
            var branch2 = cloneASTElement(el);
            getAndRemoveAttr(branch2, 'v-for', true);
            addRawAttr(branch2, ':type', typeBinding);
            processElement(branch2, options);
            addIfCondition(branch0, {
                exp: ifCondition,
                block: branch2
            });
            if (hasElse) {
                branch0.else = true;
            }
            else if (elseIfCondition) {
                branch0.elseif = elseIfCondition;
            }
            return branch0;
        }
    }
}
function cloneASTElement(el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}
var model = {
    preTransformNode: preTransformNode
};

var modules = [klass, style, model];

function text(el, dir) {
    if (dir.value) {
        addProp(el, 'textContent', "_s(".concat(dir.value, ")"), dir);
    }
}

function html(el, dir) {
    if (dir.value) {
        addProp(el, 'innerHTML', "_s(".concat(dir.value, ")"), dir);
    }
}

var directives = {
    model: model$1,
    text: text,
    html: html
};

var baseOptions = {
    expectHTML: true,
    modules: modules,
    directives: directives,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys$1(modules)
};

var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
    if (!root)
        return;
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
}
function genStaticKeys(keys) {
    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
        (keys ? ',' + keys : ''));
}
function markStatic(node) {
    node.static = isStatic(node);
    if (node.type === 1) {
        // do not make component slot content static. this avoids
        // 1. components not able to mutate slot nodes
        // 2. static slot content fails for hot-reloading
        if (!isPlatformReservedTag(node.tag) &&
            node.tag !== 'slot' &&
            node.attrsMap['inline-template'] == null) {
            return;
        }
        for (var i = 0, l = node.children.length; i < l; i++) {
            var child = node.children[i];
            markStatic(child);
            if (!child.static) {
                node.static = false;
            }
        }
        if (node.ifConditions) {
            for (var i = 1, l = node.ifConditions.length; i < l; i++) {
                var block = node.ifConditions[i].block;
                markStatic(block);
                if (!block.static) {
                    node.static = false;
                }
            }
        }
    }
}
function markStaticRoots(node, isInFor) {
    if (node.type === 1) {
        if (node.static || node.once) {
            node.staticInFor = isInFor;
        }
        // For a node to qualify as a static root, it should have children that
        // are not just static text. Otherwise the cost of hoisting out will
        // outweigh the benefits and it's better off to just always render it fresh.
        if (node.static &&
            node.children.length &&
            !(node.children.length === 1 && node.children[0].type === 3)) {
            node.staticRoot = true;
            return;
        }
        else {
            node.staticRoot = false;
        }
        if (node.children) {
            for (var i = 0, l = node.children.length; i < l; i++) {
                markStaticRoots(node.children[i], isInFor || !!node.for);
            }
        }
        if (node.ifConditions) {
            for (var i = 1, l = node.ifConditions.length; i < l; i++) {
                markStaticRoots(node.ifConditions[i].block, isInFor);
            }
        }
    }
}
function isStatic(node) {
    if (node.type === 2) {
        // expression
        return false;
    }
    if (node.type === 3) {
        // text
        return true;
    }
    return !!(node.pre ||
        (!node.hasBindings && // no dynamic bindings
            !node.if &&
            !node.for && // not v-if or v-for or v-else
            !isBuiltInTag(node.tag) && // not a built-in
            isPlatformReservedTag(node.tag) && // not a component
            !isDirectChildOfTemplateFor(node) &&
            Object.keys(node).every(isStaticKey)));
}
function isDirectChildOfTemplateFor(node) {
    while (node.parent) {
        node = node.parent;
        if (node.tag !== 'template') {
            return false;
        }
        if (node.for) {
            return true;
        }
    }
    return false;
}

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;
// KeyboardEvent.keyCode aliases
var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    delete: [8, 46]
};
// KeyboardEvent.key aliases
var keyNames = {
    // #7880: IE11 and Edge use `Esc` for Escape key name.
    esc: ['Esc', 'Escape'],
    tab: 'Tab',
    enter: 'Enter',
    // #9112: IE11 uses `Spacebar` for Space key name.
    space: [' ', 'Spacebar'],
    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
    up: ['Up', 'ArrowUp'],
    left: ['Left', 'ArrowLeft'],
    right: ['Right', 'ArrowRight'],
    down: ['Down', 'ArrowDown'],
    // #9112: IE11 uses `Del` for Delete key name.
    delete: ['Backspace', 'Delete', 'Del']
};
// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return "if(".concat(condition, ")return null;"); };
var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
};
function genHandlers(events, isNative) {
    var prefix = isNative ? 'nativeOn:' : 'on:';
    var staticHandlers = "";
    var dynamicHandlers = "";
    for (var name_1 in events) {
        var handlerCode = genHandler(events[name_1]);
        //@ts-expect-error
        if (events[name_1] && events[name_1].dynamic) {
            dynamicHandlers += "".concat(name_1, ",").concat(handlerCode, ",");
        }
        else {
            staticHandlers += "\"".concat(name_1, "\":").concat(handlerCode, ",");
        }
    }
    staticHandlers = "{".concat(staticHandlers.slice(0, -1), "}");
    if (dynamicHandlers) {
        return prefix + "_d(".concat(staticHandlers, ",[").concat(dynamicHandlers.slice(0, -1), "])");
    }
    else {
        return prefix + staticHandlers;
    }
}
function genHandler(handler) {
    if (!handler) {
        return 'function(){}';
    }
    if (Array.isArray(handler)) {
        return "[".concat(handler.map(function (handler) { return genHandler(handler); }).join(','), "]");
    }
    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);
    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));
    if (!handler.modifiers) {
        if (isMethodPath || isFunctionExpression) {
            return handler.value;
        }
        return "function($event){".concat(isFunctionInvocation ? "return ".concat(handler.value) : handler.value, "}"); // inline statement
    }
    else {
        var code = '';
        var genModifierCode = '';
        var keys = [];
        var _loop_1 = function (key) {
            if (modifierCode[key]) {
                genModifierCode += modifierCode[key];
                // left/right
                if (keyCodes[key]) {
                    keys.push(key);
                }
            }
            else if (key === 'exact') {
                var modifiers_1 = handler.modifiers;
                genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta']
                    .filter(function (keyModifier) { return !modifiers_1[keyModifier]; })
                    .map(function (keyModifier) { return "$event.".concat(keyModifier, "Key"); })
                    .join('||'));
            }
            else {
                keys.push(key);
            }
        };
        for (var key in handler.modifiers) {
            _loop_1(key);
        }
        if (keys.length) {
            code += genKeyFilter(keys);
        }
        // Make sure modifiers like prevent and stop get executed after key filtering
        if (genModifierCode) {
            code += genModifierCode;
        }
        var handlerCode = isMethodPath
            ? "return ".concat(handler.value, ".apply(null, arguments)")
            : isFunctionExpression
                ? "return (".concat(handler.value, ").apply(null, arguments)")
                : isFunctionInvocation
                    ? "return ".concat(handler.value)
                    : handler.value;
        return "function($event){".concat(code).concat(handlerCode, "}");
    }
}
function genKeyFilter(keys) {
    return (
    // make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" +
        "".concat(keys.map(genFilterCode).join('&&'), ")return null;"));
}
function genFilterCode(key) {
    var keyVal = parseInt(key, 10);
    if (keyVal) {
        return "$event.keyCode!==".concat(keyVal);
    }
    var keyCode = keyCodes[key];
    var keyName = keyNames[key];
    return ("_k($event.keyCode," +
        "".concat(JSON.stringify(key), ",") +
        "".concat(JSON.stringify(keyCode), ",") +
        "$event.key," +
        "".concat(JSON.stringify(keyName)) +
        ")");
}

function on(el, dir) {
    if ( true && dir.modifiers) {
        warn$2("v-on without argument does not support modifiers.");
    }
    el.wrapListeners = function (code) { return "_g(".concat(code, ",").concat(dir.value, ")"); };
}

function bind(el, dir) {
    el.wrapData = function (code) {
        return "_b(".concat(code, ",'").concat(el.tag, "',").concat(dir.value, ",").concat(dir.modifiers && dir.modifiers.prop ? 'true' : 'false').concat(dir.modifiers && dir.modifiers.sync ? ',true' : '', ")");
    };
}

var baseDirectives = {
    on: on,
    bind: bind,
    cloak: noop
};

var CodegenState = /** @class */ (function () {
    function CodegenState(options) {
        this.options = options;
        this.warn = options.warn || baseWarn;
        this.transforms = pluckModuleFunction(options.modules, 'transformCode');
        this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
        this.directives = extend(extend({}, baseDirectives), options.directives);
        var isReservedTag = options.isReservedTag || no;
        this.maybeComponent = function (el) {
            return !!el.component || !isReservedTag(el.tag);
        };
        this.onceId = 0;
        this.staticRenderFns = [];
        this.pre = false;
    }
    return CodegenState;
}());
function generate(ast, options) {
    var state = new CodegenState(options);
    // fix #11483, Root level <script> tags should not be rendered.
    var code = ast
        ? ast.tag === 'script'
            ? 'null'
            : genElement(ast, state)
        : '_c("div")';
    return {
        render: "with(this){return ".concat(code, "}"),
        staticRenderFns: state.staticRenderFns
    };
}
function genElement(el, state) {
    if (el.parent) {
        el.pre = el.pre || el.parent.pre;
    }
    if (el.staticRoot && !el.staticProcessed) {
        return genStatic(el, state);
    }
    else if (el.once && !el.onceProcessed) {
        return genOnce(el, state);
    }
    else if (el.for && !el.forProcessed) {
        return genFor(el, state);
    }
    else if (el.if && !el.ifProcessed) {
        return genIf(el, state);
    }
    else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
        return genChildren(el, state) || 'void 0';
    }
    else if (el.tag === 'slot') {
        return genSlot(el, state);
    }
    else {
        // component or element
        var code = void 0;
        if (el.component) {
            code = genComponent(el.component, el, state);
        }
        else {
            var data = void 0;
            var maybeComponent = state.maybeComponent(el);
            if (!el.plain || (el.pre && maybeComponent)) {
                data = genData(el, state);
            }
            var tag 
            // check if this is a component in <script setup>
            = void 0;
            // check if this is a component in <script setup>
            var bindings = state.options.bindings;
            if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {
                tag = checkBindingType(bindings, el.tag);
            }
            if (!tag)
                tag = "'".concat(el.tag, "'");
            var children = el.inlineTemplate ? null : genChildren(el, state, true);
            code = "_c(".concat(tag).concat(data ? ",".concat(data) : '' // data
            ).concat(children ? ",".concat(children) : '' // children
            , ")");
        }
        // module transforms
        for (var i = 0; i < state.transforms.length; i++) {
            code = state.transforms[i](el, code);
        }
        return code;
    }
}
function checkBindingType(bindings, key) {
    var camelName = camelize(key);
    var PascalName = capitalize(camelName);
    var checkType = function (type) {
        if (bindings[key] === type) {
            return key;
        }
        if (bindings[camelName] === type) {
            return camelName;
        }
        if (bindings[PascalName] === type) {
            return PascalName;
        }
    };
    var fromConst = checkType("setup-const" /* BindingTypes.SETUP_CONST */) ||
        checkType("setup-reactive-const" /* BindingTypes.SETUP_REACTIVE_CONST */);
    if (fromConst) {
        return fromConst;
    }
    var fromMaybeRef = checkType("setup-let" /* BindingTypes.SETUP_LET */) ||
        checkType("setup-ref" /* BindingTypes.SETUP_REF */) ||
        checkType("setup-maybe-ref" /* BindingTypes.SETUP_MAYBE_REF */);
    if (fromMaybeRef) {
        return fromMaybeRef;
    }
}
// hoist static sub-trees out
function genStatic(el, state) {
    el.staticProcessed = true;
    // Some elements (templates) need to behave differently inside of a v-pre
    // node.  All pre nodes are static roots, so we can use this as a location to
    // wrap a state change and reset it upon exiting the pre node.
    var originalPreState = state.pre;
    if (el.pre) {
        state.pre = el.pre;
    }
    state.staticRenderFns.push("with(this){return ".concat(genElement(el, state), "}"));
    state.pre = originalPreState;
    return "_m(".concat(state.staticRenderFns.length - 1).concat(el.staticInFor ? ',true' : '', ")");
}
// v-once
function genOnce(el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
        return genIf(el, state);
    }
    else if (el.staticInFor) {
        var key = '';
        var parent_1 = el.parent;
        while (parent_1) {
            if (parent_1.for) {
                key = parent_1.key;
                break;
            }
            parent_1 = parent_1.parent;
        }
        if (!key) {
             true &&
                state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
            return genElement(el, state);
        }
        return "_o(".concat(genElement(el, state), ",").concat(state.onceId++, ",").concat(key, ")");
    }
    else {
        return genStatic(el, state);
    }
}
function genIf(el, state, altGen, altEmpty) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}
function genIfConditions(conditions, state, altGen, altEmpty) {
    if (!conditions.length) {
        return altEmpty || '_e()';
    }
    var condition = conditions.shift();
    if (condition.exp) {
        return "(".concat(condition.exp, ")?").concat(genTernaryExp(condition.block), ":").concat(genIfConditions(conditions, state, altGen, altEmpty));
    }
    else {
        return "".concat(genTernaryExp(condition.block));
    }
    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp(el) {
        return altGen
            ? altGen(el, state)
            : el.once
                ? genOnce(el, state)
                : genElement(el, state);
    }
}
function genFor(el, state, altGen, altHelper) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? ",".concat(el.iterator1) : '';
    var iterator2 = el.iterator2 ? ",".concat(el.iterator2) : '';
    if ( true &&
        state.maybeComponent(el) &&
        el.tag !== 'slot' &&
        el.tag !== 'template' &&
        !el.key) {
        state.warn("<".concat(el.tag, " v-for=\"").concat(alias, " in ").concat(exp, "\">: component lists rendered with ") +
            "v-for should have explicit keys. " +
            "See https://v2.vuejs.org/v2/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true /* tip */);
    }
    el.forProcessed = true; // avoid recursion
    return ("".concat(altHelper || '_l', "((").concat(exp, "),") +
        "function(".concat(alias).concat(iterator1).concat(iterator2, "){") +
        "return ".concat((altGen || genElement)(el, state)) +
        '})');
}
function genData(el, state) {
    var data = '{';
    // directives first.
    // directives may mutate the el's other properties before they are generated.
    var dirs = genDirectives(el, state);
    if (dirs)
        data += dirs + ',';
    // key
    if (el.key) {
        data += "key:".concat(el.key, ",");
    }
    // ref
    if (el.ref) {
        data += "ref:".concat(el.ref, ",");
    }
    if (el.refInFor) {
        data += "refInFor:true,";
    }
    // pre
    if (el.pre) {
        data += "pre:true,";
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
        data += "tag:\"".concat(el.tag, "\",");
    }
    // module data generation functions
    for (var i = 0; i < state.dataGenFns.length; i++) {
        data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
        data += "attrs:".concat(genProps(el.attrs), ",");
    }
    // DOM props
    if (el.props) {
        data += "domProps:".concat(genProps(el.props), ",");
    }
    // event handlers
    if (el.events) {
        data += "".concat(genHandlers(el.events, false), ",");
    }
    if (el.nativeEvents) {
        data += "".concat(genHandlers(el.nativeEvents, true), ",");
    }
    // slot target
    // only for non-scoped slots
    if (el.slotTarget && !el.slotScope) {
        data += "slot:".concat(el.slotTarget, ",");
    }
    // scoped slots
    if (el.scopedSlots) {
        data += "".concat(genScopedSlots(el, el.scopedSlots, state), ",");
    }
    // component v-model
    if (el.model) {
        data += "model:{value:".concat(el.model.value, ",callback:").concat(el.model.callback, ",expression:").concat(el.model.expression, "},");
    }
    // inline-template
    if (el.inlineTemplate) {
        var inlineTemplate = genInlineTemplate(el, state);
        if (inlineTemplate) {
            data += "".concat(inlineTemplate, ",");
        }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind dynamic argument wrap
    // v-bind with dynamic arguments must be applied using the same v-bind object
    // merge helper so that class/style/mustUseProp attrs are handled correctly.
    if (el.dynamicAttrs) {
        data = "_b(".concat(data, ",\"").concat(el.tag, "\",").concat(genProps(el.dynamicAttrs), ")");
    }
    // v-bind data wrap
    if (el.wrapData) {
        data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
        data = el.wrapListeners(data);
    }
    return data;
}
function genDirectives(el, state) {
    var dirs = el.directives;
    if (!dirs)
        return;
    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
        dir = dirs[i];
        needRuntime = true;
        var gen = state.directives[dir.name];
        if (gen) {
            // compile-time directive that manipulates AST.
            // returns true if it also needs a runtime counterpart.
            needRuntime = !!gen(el, dir, state.warn);
        }
        if (needRuntime) {
            hasRuntime = true;
            res += "{name:\"".concat(dir.name, "\",rawName:\"").concat(dir.rawName, "\"").concat(dir.value
                ? ",value:(".concat(dir.value, "),expression:").concat(JSON.stringify(dir.value))
                : '').concat(dir.arg ? ",arg:".concat(dir.isDynamicArg ? dir.arg : "\"".concat(dir.arg, "\"")) : '').concat(dir.modifiers ? ",modifiers:".concat(JSON.stringify(dir.modifiers)) : '', "},");
        }
    }
    if (hasRuntime) {
        return res.slice(0, -1) + ']';
    }
}
function genInlineTemplate(el, state) {
    var ast = el.children[0];
    if ( true && (el.children.length !== 1 || ast.type !== 1)) {
        state.warn('Inline-template components must have exactly one child element.', { start: el.start });
    }
    if (ast && ast.type === 1) {
        var inlineRenderFns = generate(ast, state.options);
        return "inlineTemplate:{render:function(){".concat(inlineRenderFns.render, "},staticRenderFns:[").concat(inlineRenderFns.staticRenderFns
            .map(function (code) { return "function(){".concat(code, "}"); })
            .join(','), "]}");
    }
}
function genScopedSlots(el, slots, state) {
    // by default scoped slots are considered "stable", this allows child
    // components with only scoped slots to skip forced updates from parent.
    // but in some cases we have to bail-out of this optimization
    // for example if the slot contains dynamic names, has v-if or v-for on them...
    var needsForceUpdate = el.for ||
        Object.keys(slots).some(function (key) {
            var slot = slots[key];
            return (slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
            );
        });
    // #9534: if a component with scoped slots is inside a conditional branch,
    // it's possible for the same component to be reused but with different
    // compiled slot content. To avoid that, we generate a unique key based on
    // the generated code of all the slot contents.
    var needsKey = !!el.if;
    // OR when it is inside another scoped slot or v-for (the reactivity may be
    // disconnected due to the intermediate scope variable)
    // #9438, #9506
    // TODO: this can be further optimized by properly analyzing in-scope bindings
    // and skip force updating ones that do not actually use scope variables.
    if (!needsForceUpdate) {
        var parent_2 = el.parent;
        while (parent_2) {
            if ((parent_2.slotScope && parent_2.slotScope !== emptySlotScopeToken) ||
                parent_2.for) {
                needsForceUpdate = true;
                break;
            }
            if (parent_2.if) {
                needsKey = true;
            }
            parent_2 = parent_2.parent;
        }
    }
    var generatedSlots = Object.keys(slots)
        .map(function (key) { return genScopedSlot(slots[key], state); })
        .join(',');
    return "scopedSlots:_u([".concat(generatedSlots, "]").concat(needsForceUpdate ? ",null,true" : "").concat(!needsForceUpdate && needsKey ? ",null,false,".concat(hash(generatedSlots)) : "", ")");
}
function hash(str) {
    var hash = 5381;
    var i = str.length;
    while (i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
    }
    return hash >>> 0;
}
function containsSlotChild(el) {
    if (el.type === 1) {
        if (el.tag === 'slot') {
            return true;
        }
        return el.children.some(containsSlotChild);
    }
    return false;
}
function genScopedSlot(el, state) {
    var isLegacySyntax = el.attrsMap['slot-scope'];
    if (el.if && !el.ifProcessed && !isLegacySyntax) {
        return genIf(el, state, genScopedSlot, "null");
    }
    if (el.for && !el.forProcessed) {
        return genFor(el, state, genScopedSlot);
    }
    var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
    var fn = "function(".concat(slotScope, "){") +
        "return ".concat(el.tag === 'template'
            ? el.if && isLegacySyntax
                ? "(".concat(el.if, ")?").concat(genChildren(el, state) || 'undefined', ":undefined")
                : genChildren(el, state) || 'undefined'
            : genElement(el, state), "}");
    // reverse proxy v-slot without scope on this.$slots
    var reverseProxy = slotScope ? "" : ",proxy:true";
    return "{key:".concat(el.slotTarget || "\"default\"", ",fn:").concat(fn).concat(reverseProxy, "}");
}
function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
    var children = el.children;
    if (children.length) {
        var el_1 = children[0];
        // optimize single v-for
        if (children.length === 1 &&
            el_1.for &&
            el_1.tag !== 'template' &&
            el_1.tag !== 'slot') {
            var normalizationType_1 = checkSkip
                ? state.maybeComponent(el_1)
                    ? ",1"
                    : ",0"
                : "";
            return "".concat((altGenElement || genElement)(el_1, state)).concat(normalizationType_1);
        }
        var normalizationType = checkSkip
            ? getNormalizationType(children, state.maybeComponent)
            : 0;
        var gen_1 = altGenNode || genNode;
        return "[".concat(children.map(function (c) { return gen_1(c, state); }).join(','), "]").concat(normalizationType ? ",".concat(normalizationType) : '');
    }
}
// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children, maybeComponent) {
    var res = 0;
    for (var i = 0; i < children.length; i++) {
        var el = children[i];
        if (el.type !== 1) {
            continue;
        }
        if (needsNormalization(el) ||
            (el.ifConditions &&
                el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
            res = 2;
            break;
        }
        if (maybeComponent(el) ||
            (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
            res = 1;
        }
    }
    return res;
}
function needsNormalization(el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}
function genNode(node, state) {
    if (node.type === 1) {
        return genElement(node, state);
    }
    else if (node.type === 3 && node.isComment) {
        return genComment(node);
    }
    else {
        return genText(node);
    }
}
function genText(text) {
    return "_v(".concat(text.type === 2
        ? text.expression // no need for () because already wrapped in _s()
        : transformSpecialNewlines(JSON.stringify(text.text)), ")");
}
function genComment(comment) {
    return "_e(".concat(JSON.stringify(comment.text), ")");
}
function genSlot(el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(".concat(slotName).concat(children ? ",function(){return ".concat(children, "}") : '');
    var attrs = el.attrs || el.dynamicAttrs
        ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
            // slot props are camelized
            name: camelize(attr.name),
            value: attr.value,
            dynamic: attr.dynamic
        }); }))
        : null;
    var bind = el.attrsMap['v-bind'];
    if ((attrs || bind) && !children) {
        res += ",null";
    }
    if (attrs) {
        res += ",".concat(attrs);
    }
    if (bind) {
        res += "".concat(attrs ? '' : ',null', ",").concat(bind);
    }
    return res + ')';
}
// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el, state) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return "_c(".concat(componentName, ",").concat(genData(el, state)).concat(children ? ",".concat(children) : '', ")");
}
function genProps(props) {
    var staticProps = "";
    var dynamicProps = "";
    for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var value = transformSpecialNewlines(prop.value);
        if (prop.dynamic) {
            dynamicProps += "".concat(prop.name, ",").concat(value, ",");
        }
        else {
            staticProps += "\"".concat(prop.name, "\":").concat(value, ",");
        }
    }
    staticProps = "{".concat(staticProps.slice(0, -1), "}");
    if (dynamicProps) {
        return "_d(".concat(staticProps, ",[").concat(dynamicProps.slice(0, -1), "])");
    }
    else {
        return staticProps;
    }
}
// #3895, #4268
function transformSpecialNewlines(text) {
    return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' +
    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
        'super,throw,while,yield,delete,export,import,return,switch,default,' +
        'extends,finally,continue,debugger,function,arguments')
        .split(',')
        .join('\\b|\\b') +
    '\\b');
// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' +
    'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') +
    '\\s*\\([^\\)]*\\)');
// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
// detect problematic expressions in a template
function detectErrors(ast, warn) {
    if (ast) {
        checkNode(ast, warn);
    }
}
function checkNode(node, warn) {
    if (node.type === 1) {
        for (var name_1 in node.attrsMap) {
            if (dirRE.test(name_1)) {
                var value = node.attrsMap[name_1];
                if (value) {
                    var range = node.rawAttrsMap[name_1];
                    if (name_1 === 'v-for') {
                        checkFor(node, "v-for=\"".concat(value, "\""), warn, range);
                    }
                    else if (name_1 === 'v-slot' || name_1[0] === '#') {
                        checkFunctionParameterExpression(value, "".concat(name_1, "=\"").concat(value, "\""), warn, range);
                    }
                    else if (onRE.test(name_1)) {
                        checkEvent(value, "".concat(name_1, "=\"").concat(value, "\""), warn, range);
                    }
                    else {
                        checkExpression(value, "".concat(name_1, "=\"").concat(value, "\""), warn, range);
                    }
                }
            }
        }
        if (node.children) {
            for (var i = 0; i < node.children.length; i++) {
                checkNode(node.children[i], warn);
            }
        }
    }
    else if (node.type === 2) {
        checkExpression(node.expression, node.text, warn, node);
    }
}
function checkEvent(exp, text, warn, range) {
    var stripped = exp.replace(stripStringRE, '');
    var keywordMatch = stripped.match(unaryOperatorsRE);
    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
        warn("avoid using JavaScript unary operator as property name: " +
            "\"".concat(keywordMatch[0], "\" in expression ").concat(text.trim()), range);
    }
    checkExpression(exp, text, warn, range);
}
function checkFor(node, text, warn, range) {
    checkExpression(node.for || '', text, warn, range);
    checkIdentifier(node.alias, 'v-for alias', text, warn, range);
    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}
function checkIdentifier(ident, type, text, warn, range) {
    if (typeof ident === 'string') {
        try {
            new Function("var ".concat(ident, "=_"));
        }
        catch (e) {
            warn("invalid ".concat(type, " \"").concat(ident, "\" in expression: ").concat(text.trim()), range);
        }
    }
}
function checkExpression(exp, text, warn, range) {
    try {
        new Function("return ".concat(exp));
    }
    catch (e) {
        var keywordMatch = exp
            .replace(stripStringRE, '')
            .match(prohibitedKeywordRE);
        if (keywordMatch) {
            warn("avoid using JavaScript keyword as property name: " +
                "\"".concat(keywordMatch[0], "\"\n  Raw expression: ").concat(text.trim()), range);
        }
        else {
            warn("invalid expression: ".concat(e.message, " in\n\n") +
                "    ".concat(exp, "\n\n") +
                "  Raw expression: ".concat(text.trim(), "\n"), range);
        }
    }
}
function checkFunctionParameterExpression(exp, text, warn, range) {
    try {
        new Function(exp, '');
    }
    catch (e) {
        warn("invalid function parameter expression: ".concat(e.message, " in\n\n") +
            "    ".concat(exp, "\n\n") +
            "  Raw expression: ".concat(text.trim(), "\n"), range);
    }
}

var range = 2;
function generateCodeFrame(source, start, end) {
    if (start === void 0) { start = 0; }
    if (end === void 0) { end = source.length; }
    var lines = source.split(/\r?\n/);
    var count = 0;
    var res = [];
    for (var i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (var j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                res.push("".concat(j + 1).concat(repeat(" ", 3 - String(j + 1).length), "|  ").concat(lines[j]));
                var lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    var pad = start - (count - lineLength) + 1;
                    var length_1 = end > count ? lineLength - pad : end - start;
                    res.push("   |  " + repeat(" ", pad) + repeat("^", length_1));
                }
                else if (j > i) {
                    if (end > count) {
                        var length_2 = Math.min(end - count, lineLength);
                        res.push("   |  " + repeat("^", length_2));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}
function repeat(str, n) {
    var result = '';
    if (n > 0) {
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // eslint-disable-line
            if (n & 1)
                result += str;
            n >>>= 1;
            if (n <= 0)
                break;
            str += str;
        }
    }
    return result;
}

function createFunction(code, errors) {
    try {
        return new Function(code);
    }
    catch (err) {
        errors.push({ err: err, code: code });
        return noop;
    }
}
function createCompileToFunctionFn(compile) {
    var cache = Object.create(null);
    return function compileToFunctions(template, options, vm) {
        options = extend({}, options);
        var warn = options.warn || warn$2;
        delete options.warn;
        /* istanbul ignore if */
        if (true) {
            // detect possible CSP restriction
            try {
                new Function('return 1');
            }
            catch (e) {
                if (e.toString().match(/unsafe-eval|CSP/)) {
                    warn('It seems you are using the standalone build of Vue.js in an ' +
                        'environment with Content Security Policy that prohibits unsafe-eval. ' +
                        'The template compiler cannot work in this environment. Consider ' +
                        'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
                        'templates into render functions.');
                }
            }
        }
        // check cache
        var key = options.delimiters
            ? String(options.delimiters) + template
            : template;
        if (cache[key]) {
            return cache[key];
        }
        // compile
        var compiled = compile(template, options);
        // check compilation errors/tips
        if (true) {
            if (compiled.errors && compiled.errors.length) {
                if (options.outputSourceRange) {
                    compiled.errors.forEach(function (e) {
                        warn("Error compiling template:\n\n".concat(e.msg, "\n\n") +
                            generateCodeFrame(template, e.start, e.end), vm);
                    });
                }
                else {
                    warn("Error compiling template:\n\n".concat(template, "\n\n") +
                        compiled.errors.map(function (e) { return "- ".concat(e); }).join('\n') +
                        '\n', vm);
                }
            }
            if (compiled.tips && compiled.tips.length) {
                if (options.outputSourceRange) {
                    compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
                }
                else {
                    compiled.tips.forEach(function (msg) { return tip(msg, vm); });
                }
            }
        }
        // turn code into functions
        var res = {};
        var fnGenErrors = [];
        res.render = createFunction(compiled.render, fnGenErrors);
        res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
            return createFunction(code, fnGenErrors);
        });
        // check function generation errors.
        // this should only happen if there is a bug in the compiler itself.
        // mostly for codegen development use
        /* istanbul ignore if */
        if (true) {
            if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
                warn("Failed to generate render function:\n\n" +
                    fnGenErrors
                        .map(function (_a) {
                        var err = _a.err, code = _a.code;
                        return "".concat(err.toString(), " in\n\n").concat(code, "\n");
                    })
                        .join('\n'), vm);
            }
        }
        return (cache[key] = res);
    };
}

function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
        function compile(template, options) {
            var finalOptions = Object.create(baseOptions);
            var errors = [];
            var tips = [];
            var warn = function (msg, range, tip) {
                (tip ? tips : errors).push(msg);
            };
            if (options) {
                if ( true && options.outputSourceRange) {
                    // $flow-disable-line
                    var leadingSpaceLength_1 = template.match(/^\s*/)[0].length;
                    warn = function (msg, range, tip) {
                        var data = typeof msg === 'string' ? { msg: msg } : msg;
                        if (range) {
                            if (range.start != null) {
                                data.start = range.start + leadingSpaceLength_1;
                            }
                            if (range.end != null) {
                                data.end = range.end + leadingSpaceLength_1;
                            }
                        }
                        (tip ? tips : errors).push(data);
                    };
                }
                // merge custom modules
                if (options.modules) {
                    finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
                }
                // merge custom directives
                if (options.directives) {
                    finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
                }
                // copy other options
                for (var key in options) {
                    if (key !== 'modules' && key !== 'directives') {
                        finalOptions[key] = options[key];
                    }
                }
            }
            finalOptions.warn = warn;
            var compiled = baseCompile(template.trim(), finalOptions);
            if (true) {
                detectErrors(compiled.ast, warn);
            }
            compiled.errors = errors;
            compiled.tips = tips;
            return compiled;
        }
        return {
            compile: compile,
            compileToFunctions: createCompileToFunctionFn(compile)
        };
    };
}

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile(template, options) {
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
        optimize(ast, options);
    }
    var code = generate(ast, options);
    return {
        ast: ast,
        render: code.render,
        staticRenderFns: code.staticRenderFns
    };
});

var _a = createCompiler(baseOptions), compileToFunctions = _a.compileToFunctions;

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode(href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
    return div.innerHTML.indexOf('&#10;') > 0;
}
// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser
    ? getShouldDecode(true)
    : false;

var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML;
});
var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (el, hydrating) {
    el = el && query(el);
    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
         true &&
            warn$2("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
        return this;
    }
    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
        var template = options.template;
        if (template) {
            if (typeof template === 'string') {
                if (template.charAt(0) === '#') {
                    template = idToTemplate(template);
                    /* istanbul ignore if */
                    if ( true && !template) {
                        warn$2("Template element not found or is empty: ".concat(options.template), this);
                    }
                }
            }
            else if (template.nodeType) {
                template = template.innerHTML;
            }
            else {
                if (true) {
                    warn$2('invalid template option:' + template, this);
                }
                return this;
            }
        }
        else if (el) {
            // @ts-expect-error
            template = getOuterHTML(el);
        }
        if (template) {
            /* istanbul ignore if */
            if ( true && config.performance && mark) {
                mark('compile');
            }
            var _a = compileToFunctions(template, {
                outputSourceRange: "development" !== 'production',
                shouldDecodeNewlines: shouldDecodeNewlines,
                shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
                delimiters: options.delimiters,
                comments: options.comments
            }, this), render = _a.render, staticRenderFns = _a.staticRenderFns;
            options.render = render;
            options.staticRenderFns = staticRenderFns;
            /* istanbul ignore if */
            if ( true && config.performance && mark) {
                mark('compile end');
                measure("vue ".concat(this._name, " compile"), 'compile', 'compile end');
            }
        }
    }
    return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
    if (el.outerHTML) {
        return el.outerHTML;
    }
    else {
        var container = document.createElement('div');
        container.appendChild(el.cloneNode(true));
        return container.innerHTML;
    }
}
Vue.compile = compileToFunctions;




/***/ }),

/***/ "./node_modules/dom7/dom7.esm.js":
/*!***************************************!*\
  !*** ./node_modules/dom7/dom7.esm.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ $),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "animate": () => (/* binding */ animate),
/* harmony export */   "animationEnd": () => (/* binding */ animationEnd),
/* harmony export */   "append": () => (/* binding */ append),
/* harmony export */   "appendTo": () => (/* binding */ appendTo),
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "blur": () => (/* binding */ blur),
/* harmony export */   "change": () => (/* binding */ change),
/* harmony export */   "children": () => (/* binding */ children),
/* harmony export */   "click": () => (/* binding */ click),
/* harmony export */   "closest": () => (/* binding */ closest),
/* harmony export */   "css": () => (/* binding */ css),
/* harmony export */   "data": () => (/* binding */ data),
/* harmony export */   "dataset": () => (/* binding */ dataset),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "detach": () => (/* binding */ detach),
/* harmony export */   "each": () => (/* binding */ each),
/* harmony export */   "empty": () => (/* binding */ empty),
/* harmony export */   "eq": () => (/* binding */ eq),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "focus": () => (/* binding */ focus),
/* harmony export */   "focusin": () => (/* binding */ focusin),
/* harmony export */   "focusout": () => (/* binding */ focusout),
/* harmony export */   "hasClass": () => (/* binding */ hasClass),
/* harmony export */   "height": () => (/* binding */ height),
/* harmony export */   "hide": () => (/* binding */ hide),
/* harmony export */   "html": () => (/* binding */ html),
/* harmony export */   "index": () => (/* binding */ index),
/* harmony export */   "insertAfter": () => (/* binding */ insertAfter),
/* harmony export */   "insertBefore": () => (/* binding */ insertBefore),
/* harmony export */   "is": () => (/* binding */ is),
/* harmony export */   "keydown": () => (/* binding */ keydown),
/* harmony export */   "keypress": () => (/* binding */ keypress),
/* harmony export */   "keyup": () => (/* binding */ keyup),
/* harmony export */   "mousedown": () => (/* binding */ mousedown),
/* harmony export */   "mouseenter": () => (/* binding */ mouseenter),
/* harmony export */   "mouseleave": () => (/* binding */ mouseleave),
/* harmony export */   "mousemove": () => (/* binding */ mousemove),
/* harmony export */   "mouseout": () => (/* binding */ mouseout),
/* harmony export */   "mouseover": () => (/* binding */ mouseover),
/* harmony export */   "mouseup": () => (/* binding */ mouseup),
/* harmony export */   "next": () => (/* binding */ next),
/* harmony export */   "nextAll": () => (/* binding */ nextAll),
/* harmony export */   "off": () => (/* binding */ off),
/* harmony export */   "offset": () => (/* binding */ offset),
/* harmony export */   "on": () => (/* binding */ on),
/* harmony export */   "once": () => (/* binding */ once),
/* harmony export */   "outerHeight": () => (/* binding */ outerHeight),
/* harmony export */   "outerWidth": () => (/* binding */ outerWidth),
/* harmony export */   "parent": () => (/* binding */ parent),
/* harmony export */   "parents": () => (/* binding */ parents),
/* harmony export */   "prepend": () => (/* binding */ prepend),
/* harmony export */   "prependTo": () => (/* binding */ prependTo),
/* harmony export */   "prev": () => (/* binding */ prev),
/* harmony export */   "prevAll": () => (/* binding */ prevAll),
/* harmony export */   "prop": () => (/* binding */ prop),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "removeAttr": () => (/* binding */ removeAttr),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "removeData": () => (/* binding */ removeData),
/* harmony export */   "resize": () => (/* binding */ resize),
/* harmony export */   "scroll": () => (/* binding */ scroll),
/* harmony export */   "scrollLeft": () => (/* binding */ scrollLeft),
/* harmony export */   "scrollTo": () => (/* binding */ scrollTo),
/* harmony export */   "scrollTop": () => (/* binding */ scrollTop),
/* harmony export */   "show": () => (/* binding */ show),
/* harmony export */   "siblings": () => (/* binding */ siblings),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "styles": () => (/* binding */ styles),
/* harmony export */   "submit": () => (/* binding */ submit),
/* harmony export */   "text": () => (/* binding */ text),
/* harmony export */   "toggleClass": () => (/* binding */ toggleClass),
/* harmony export */   "touchend": () => (/* binding */ touchend),
/* harmony export */   "touchmove": () => (/* binding */ touchmove),
/* harmony export */   "touchstart": () => (/* binding */ touchstart),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transition": () => (/* binding */ transition),
/* harmony export */   "transitionEnd": () => (/* binding */ transitionEnd),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "val": () => (/* binding */ val),
/* harmony export */   "value": () => (/* binding */ value),
/* harmony export */   "width": () => (/* binding */ width)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/**
 * Dom7 4.0.4
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * https://framework7.io/docs/dom7.html
 *
 * Copyright 2022, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: January 11, 2022
 */


/* eslint-disable no-proto */
function makeReactive(obj) {
  const proto = obj.__proto__;
  Object.defineProperty(obj, '__proto__', {
    get() {
      return proto;
    },

    set(value) {
      proto.__proto__ = value;
    }

  });
}

class Dom7 extends Array {
  constructor(items) {
    if (typeof items === 'number') {
      super(items);
    } else {
      super(...(items || []));
      makeReactive(this);
    }
  }

}

function arrayFlat(arr = []) {
  const res = [];
  arr.forEach(el => {
    if (Array.isArray(el)) {
      res.push(...arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  const uniqueArray = [];

  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }

  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, (match, group) => group.toUpperCase());
}

// eslint-disable-next-line

function qsa(selector, context) {
  if (typeof selector !== 'string') {
    return [selector];
  }

  const a = [];
  const res = context.querySelectorAll(selector);

  for (let i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }

  return a;
}

function $(selector, context) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  let arr = [];

  if (!context && selector instanceof Dom7) {
    return selector;
  }

  if (!selector) {
    return new Dom7(arr);
  }

  if (typeof selector === 'string') {
    const html = selector.trim();

    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
      let toCreate = 'div';
      if (html.indexOf('<li') === 0) toCreate = 'ul';
      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
      if (html.indexOf('<tbody') === 0) toCreate = 'table';
      if (html.indexOf('<option') === 0) toCreate = 'select';
      const tempParent = document.createElement(toCreate);
      tempParent.innerHTML = html;

      for (let i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document);
    } // arr = qsa(selector, document);

  } else if (selector.nodeType || selector === window || selector === document) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7) return selector;
    arr = selector;
  }

  return new Dom7(arrayUnique(arr));
}

$.fn = Dom7.prototype;

// eslint-disable-next-line

function addClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  this.forEach(el => {
    el.classList.add(...classNames);
  });
  return this;
}

function removeClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  this.forEach(el => {
    el.classList.remove(...classNames);
  });
  return this;
}

function toggleClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  this.forEach(el => {
    classNames.forEach(className => {
      el.classList.toggle(className);
    });
  });
}

function hasClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  return arrayFilter(this, el => {
    return classNames.filter(className => el.classList.contains(className)).length > 0;
  }).length > 0;
}

function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  } // Set attrs


  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }

  return this;
}

function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }

  return this;
}

function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        for (const propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }

    return this;
  }

  return this;
}

function data(key, value) {
  let el;

  if (typeof value === 'undefined') {
    el = this[0];
    if (!el) return undefined; // Get value

    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
      return el.dom7ElementDataStorage[key];
    }

    const dataKey = el.getAttribute(`data-${key}`);

    if (dataKey) {
      return dataKey;
    }

    return undefined;
  } // Set value


  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }

  return this;
}

function removeData(key) {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}

function dataset() {
  const el = this[0];
  if (!el) return undefined;
  const dataset = {}; // eslint-disable-line

  if (el.dataset) {
    for (const dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (let i = 0; i < el.attributes.length; i += 1) {
      const attr = el.attributes[i];

      if (attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
      }
    }
  }

  for (const key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }

  return dataset;
}

function val(value) {
  if (typeof value === 'undefined') {
    // get value
    const el = this[0];
    if (!el) return undefined;

    if (el.multiple && el.nodeName.toLowerCase() === 'select') {
      const values = [];

      for (let i = 0; i < el.selectedOptions.length; i += 1) {
        values.push(el.selectedOptions[i].value);
      }

      return values;
    }

    return el.value;
  } // set value


  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
      for (let j = 0; j < el.options.length; j += 1) {
        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
      }
    } else {
      el.value = value;
    }
  }

  return this;
}

function value(value) {
  return this.val(value);
}

function transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform;
  }

  return this;
}

function transition(duration) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
  }

  return this;
}

function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;

  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }

  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
      const parents = $(target).parents(); // eslint-disable-line

      for (let k = 0; k < parents.length; k += 1) {
        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }

  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    listener.apply(this, eventData);
  }

  const events = eventType.split(' ');
  let j;

  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }

  return this;
}

function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;

  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }

  if (!capture) capture = false;
  const events = eventType.split(' ');

  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];

    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;

      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }

      if (handlers && handlers.length) {
        for (let k = handlers.length - 1; k >= 0; k -= 1) {
          const handler = handlers[k];

          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }

  return this;
}

function once(...args) {
  const dom = this;
  let [eventName, targetSelector, listener, capture] = args;

  if (typeof args[1] === 'function') {
    [eventName, listener, capture] = args;
    targetSelector = undefined;
  }

  function onceHandler(...eventArgs) {
    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);

    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }

  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}

function trigger(...args) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const events = args[0].split(' ');
  const eventData = args[1];

  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];

    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];

      if (window.CustomEvent) {
        const evt = new window.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }

  return this;
}

function transitionEnd(callback) {
  const dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('transitionend', fireCallBack);
  }

  if (callback) {
    dom.on('transitionend', fireCallBack);
  }

  return this;
}

function animationEnd(callback) {
  const dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('animationend', fireCallBack);
  }

  if (callback) {
    dom.on('animationend', fireCallBack);
  }

  return this;
}

function width() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  if (this[0] === window) {
    return window.innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}

function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }

    return this[0].offsetWidth;
  }

  return null;
}

function height() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  if (this[0] === window) {
    return window.innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}

function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }

    return this[0].offsetHeight;
  }

  return null;
}

function offset() {
  if (this.length > 0) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = document.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window ? window.scrollY : el.scrollTop;
    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }

  return null;
}

function hide() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }

  return this;
}

function show() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (el.style.display === 'none') {
      el.style.display = '';
    }

    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }

  return this;
}

function styles() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  if (this[0]) return window.getComputedStyle(this[0], null);
  return {};
}

function css(props, value) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let i;

  if (arguments.length === 1) {
    if (typeof props === 'string') {
      // .css('width')
      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      // .css({ width: '100px' })
      for (i = 0; i < this.length; i += 1) {
        for (const prop in props) {
          this[i].style[prop] = props[prop];
        }
      }

      return this;
    }
  }

  if (arguments.length === 2 && typeof props === 'string') {
    // .css('width', '100px')
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }

    return this;
  }

  return this;
}

function each(callback) {
  if (!callback) return this;
  this.forEach((el, index) => {
    callback.apply(el, [el, index]);
  });
  return this;
}

function filter(callback) {
  const result = arrayFilter(this, callback);
  return $(result);
}

function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }

  return this;
}

function text(text) {
  if (typeof text === 'undefined') {
    return this[0] ? this[0].textContent.trim() : null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }

  return this;
}

function is(selector) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;

  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
    compareWith = $(selector);

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  if (selector === document) {
    return el === document;
  }

  if (selector === window) {
    return el === window;
  }

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  return false;
}

function index() {
  let child = this[0];
  let i;

  if (child) {
    i = 0; // eslint-disable-next-line

    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }

    return i;
  }

  return undefined;
}

function eq(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;

  if (index > length - 1) {
    return $([]);
  }

  if (index < 0) {
    const returnIndex = length + index;
    if (returnIndex < 0) return $([]);
    return $([this[returnIndex]]);
  }

  return $([this[index]]);
}

function append(...els) {
  let newChild;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

  for (let k = 0; k < els.length; k += 1) {
    newChild = els[k];

    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}

function appendTo(parent) {
  $(parent).append(this);
  return this;
}

function prepend(newChild) {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  let i;
  let j;

  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = newChild;

      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }

  return this;
}

function prependTo(parent) {
  $(parent).prepend(this);
  return this;
}

function insertBefore(selector) {
  const before = $(selector);

  for (let i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (let j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}

function insertAfter(selector) {
  const after = $(selector);

  for (let i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (let j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}

function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return $([this[0].nextElementSibling]);
      }

      return $([]);
    }

    if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
    return $([]);
  }

  return $([]);
}

function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return $([]);

  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line

    if (selector) {
      if ($(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);

    el = next;
  }

  return $(nextEls);
}

function prev(selector) {
  if (this.length > 0) {
    const el = this[0];

    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return $([el.previousElementSibling]);
      }

      return $([]);
    }

    if (el.previousElementSibling) return $([el.previousElementSibling]);
    return $([]);
  }

  return $([]);
}

function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return $([]);

  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line

    if (selector) {
      if ($(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);

    el = prev;
  }

  return $(prevEls);
}

function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}

function parent(selector) {
  const parents = []; // eslint-disable-line

  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }

  return $(parents);
}

function parents(selector) {
  const parents = []; // eslint-disable-line

  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line

    while (parent) {
      if (selector) {
        if ($(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }

      parent = parent.parentNode;
    }
  }

  return $(parents);
}

function closest(selector) {
  let closest = this; // eslint-disable-line

  if (typeof selector === 'undefined') {
    return $([]);
  }

  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }

  return closest;
}

function find(selector) {
  const foundElements = [];

  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);

    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }

  return $(foundElements);
}

function children(selector) {
  const children = []; // eslint-disable-line

  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].children;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector || $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }

  return $(children);
}

function remove() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }

  return this;
}

function detach() {
  return this.remove();
}

function add(...els) {
  const dom = this;
  let i;
  let j;

  for (i = 0; i < els.length; i += 1) {
    const toAdd = $(els[i]);

    for (j = 0; j < toAdd.length; j += 1) {
      dom.push(toAdd[j]);
    }
  }

  return dom;
}

function empty() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (el.nodeType === 1) {
      for (let j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }

      el.textContent = '';
    }
  }

  return this;
}

// eslint-disable-next-line

function scrollTo(...args) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let [left, top, duration, easing, callback] = args;

  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    [left, top, duration, callback, easing] = args;
  }

  if (typeof easing === 'undefined') easing = 'swing';
  return this.each(function animate() {
    const el = this;
    let currentTop;
    let currentLeft;
    let maxTop;
    let maxLeft;
    let newTop;
    let newLeft;
    let scrollTop; // eslint-disable-line

    let scrollLeft; // eslint-disable-line

    let animateTop = top > 0 || top === 0;
    let animateLeft = left > 0 || left === 0;

    if (typeof easing === 'undefined') {
      easing = 'swing';
    }

    if (animateTop) {
      currentTop = el.scrollTop;

      if (!duration) {
        el.scrollTop = top;
      }
    }

    if (animateLeft) {
      currentLeft = el.scrollLeft;

      if (!duration) {
        el.scrollLeft = left;
      }
    }

    if (!duration) return;

    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }

    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }

    let startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;

    function render(time = new Date().getTime()) {
      if (startTime === null) {
        startTime = time;
      }

      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
      let done;
      if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);
      if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);

      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }

      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      window.requestAnimationFrame(render);
    }

    window.requestAnimationFrame(render);
  });
} // scrollTop(top, duration, easing, callback) {


function scrollTop(...args) {
  let [top, duration, easing, callback] = args;

  if (args.length === 3 && typeof easing === 'function') {
    [top, duration, callback, easing] = args;
  }

  const dom = this;

  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }

  return dom.scrollTo(undefined, top, duration, easing, callback);
}

function scrollLeft(...args) {
  let [left, duration, easing, callback] = args;

  if (args.length === 3 && typeof easing === 'function') {
    [left, duration, callback, easing] = args;
  }

  const dom = this;

  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }

  return dom.scrollTo(left, undefined, duration, easing, callback);
}

// eslint-disable-next-line

function animate(initialProps, initialParams) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const els = this;
  const a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: 'swing' // or 'linear'

      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */

    }, initialParams),
    elements: els,
    animating: false,
    que: [],

    easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - Math.cos(progress * Math.PI) / 2;
      }

      if (typeof easing === 'function') {
        return easing(progress);
      }

      return progress;
    },

    stop() {
      if (a.frameId) {
        window.cancelAnimationFrame(a.frameId);
      }

      a.animating = false;
      a.elements.each(el => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },

    done(complete) {
      a.animating = false;
      a.elements.each(el => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);

      if (a.que.length > 0) {
        const que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },

    animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }

      const elements = []; // Define & Cache Initials & Units

      a.elements.each((el, index) => {
        let initialFullValue;
        let initialValue;
        let unit;
        let finalValue;
        let finalFullValue;
        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
        elements[index] = {
          container: el
        };
        Object.keys(props).forEach(prop => {
          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue,
            initialValue,
            unit,
            finalValue,
            finalFullValue,
            currentValue: initialValue
          };
        });
      });
      let startTime = null;
      let time;
      let elementsDone = 0;
      let propsDone = 0;
      let done;
      let began = false;
      a.animating = true;

      function render() {
        time = new Date().getTime();
        let progress;
        let easeProgress; // let el;

        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }

        if (startTime === null) {
          startTime = time;
        }

        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
        }

        elements.forEach(element => {
          const el = element;
          if (done || el.done) return;
          Object.keys(props).forEach(prop => {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            const {
              initialValue,
              finalValue,
              unit
            } = el[prop];
            el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);
            const currentValue = el[prop].currentValue;

            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;

              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }

              if (elementsDone === elements.length) {
                done = true;
              }
            }

            if (done) {
              a.done(params.complete);
              return;
            }

            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return; // Then call

        a.frameId = window.requestAnimationFrame(render);
      }

      a.frameId = window.requestAnimationFrame(render);
      return a;
    }

  };

  if (a.elements.length === 0) {
    return els;
  }

  let animateInstance;

  for (let i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }

  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  const els = this;

  for (let i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}

const noTrigger = 'resize scroll'.split(' ');

function shortcut(name) {
  function eventHandler(...args) {
    if (typeof args[0] === 'undefined') {
      for (let i = 0; i < this.length; i += 1) {
        if (noTrigger.indexOf(name) < 0) {
          if (name in this[i]) this[i][name]();else {
            $(this[i]).trigger(name);
          }
        }
      }

      return this;
    }

    return this.on(name, ...args);
  }

  return eventHandler;
}

const click = shortcut('click');
const blur = shortcut('blur');
const focus = shortcut('focus');
const focusin = shortcut('focusin');
const focusout = shortcut('focusout');
const keyup = shortcut('keyup');
const keydown = shortcut('keydown');
const keypress = shortcut('keypress');
const submit = shortcut('submit');
const change = shortcut('change');
const mousedown = shortcut('mousedown');
const mousemove = shortcut('mousemove');
const mouseup = shortcut('mouseup');
const mouseenter = shortcut('mouseenter');
const mouseleave = shortcut('mouseleave');
const mouseout = shortcut('mouseout');
const mouseover = shortcut('mouseover');
const touchstart = shortcut('touchstart');
const touchend = shortcut('touchend');
const touchmove = shortcut('touchmove');
const resize = shortcut('resize');
const scroll = shortcut('scroll');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ($);



/***/ }),

/***/ "./node_modules/framework7-vue/components/accordion-content.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7-vue/components/accordion-content.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-accordion-content',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('accordion-item-content', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/accordion-item.js":
/*!******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/accordion-item.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-accordion-item',
  render,
  props: {
    opened: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['accordion:beforeopen', 'accordion:open', 'accordion:opened', 'accordion:beforeclose', 'accordion:close', 'accordion:closed'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onBeforeOpen = (el, prevent) => {
      if (elRef.value !== el) return;
      emit('accordion:beforeopen', prevent);
    };

    const onOpen = el => {
      if (elRef.value !== el) return;
      emit('accordion:open');
    };

    const onOpened = el => {
      if (elRef.value !== el) return;
      emit('accordion:opened');
    };

    const onBeforeClose = (el, prevent) => {
      if (elRef.value !== el) return;
      emit('accordion:beforeclose', prevent);
    };

    const onClose = el => {
      if (elRef.value !== el) return;
      emit('accordion:close');
    };

    const onClosed = el => {
      if (elRef.value !== el) return;
      emit('accordion:closed');
    };

    const attachEvents = () => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('accordionBeforeOpen', onBeforeOpen);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('accordionOpen', onOpen);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('accordionOpened', onOpened);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('accordionBeforeClose', onBeforeClose);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('accordionClose', onClose);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('accordionClosed', onClosed);
      });
    };

    const detachEvents = () => {
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('accordionBeforeOpen', onBeforeOpen);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('accordionOpen', onOpen);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('accordionOpened', onOpened);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('accordionBeforeClose', onBeforeClose);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('accordionClose', onClose);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('accordionClosed', onClosed);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => attachEvents());
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => detachEvents());
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('accordion-item', {
      'accordion-item-opened': props.opened
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/accordion-toggle.js":
/*!********************************************************************!*\
  !*** ./node_modules/framework7-vue/components/accordion-toggle.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-accordion-toggle',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('accordion-item-toggle', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/accordion.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/accordion.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-accordion',
  render,
  props: {
    accordionOpposite: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('accordion-list', props.accordionOpposite && 'accordion-opposite', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/actions-button.js":
/*!******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/actions-button.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = {
  key: 0,
  class: "actions-button-media"
};
const _hoisted_2 = {
  class: "actions-button-text"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onClick && _ctx.onClick(...arguments);
    })
  }, [_ctx.hasMedia ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "media")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-actions-button',
  render,
  props: {
    bold: Boolean,
    close: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['click'],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onClick = e => {
      if (elRef.value && props.close && _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7) {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.actions.close(_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.$(elRef.value).parents('.actions-modal'));
      }

      emit('click', e);
    };

    const hasMedia = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => slots && !!slots.media);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
      'actions-button': true,
      'actions-button-bold': props.bold
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      elRef,
      hasMedia,
      onClick
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/actions-group.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/actions-group.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-actions-group',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('actions-group', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/actions-label.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/actions-label.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onClick && _ctx.onClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-actions-label',
  render,
  props: {
    bold: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['click'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;

    const onClick = e => {
      emit('click', e);
    };

    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('actions-label', {
      'actions-button-bold': props.bold
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      onClick
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/actions.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7-vue/components/actions.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/modal-state-classes.js */ "./node_modules/framework7-vue/shared/modal-state-classes.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-actions',
  render,
  props: {
    tabletFullscreen: Boolean,
    opened: Boolean,
    animate: {
      type: Boolean,
      default: undefined
    },
    grid: Boolean,
    target: {
      type: [String, Object],
      default: undefined
    },
    convertToPopover: {
      type: Boolean,
      default: undefined
    },
    forceToPopover: {
      type: Boolean,
      default: undefined
    },
    backdrop: {
      type: Boolean,
      default: undefined
    },
    backdropEl: {
      type: [String, Object],
      default: undefined
    },
    closeByBackdropClick: {
      type: Boolean,
      default: undefined
    },
    closeByOutsideClick: {
      type: Boolean,
      default: undefined
    },
    closeOnEscape: {
      type: Boolean,
      default: undefined
    },
    containerEl: {
      type: [String, Object],
      default: undefined
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['actions:open', 'actions:opened', 'actions:close', 'actions:closed', 'update:opened'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    // eslint-disable-next-line
    let f7Actions = null; // eslint-disable-next-line

    let isOpened = props.opened;
    let isClosing = false;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onOpen = instance => {
      isOpened = true;
      isClosing = false;
      emit('actions:open', instance);
      emit('update:opened', true);
    };

    const onOpened = instance => {
      emit('actions:opened', instance);
    };

    const onClose = instance => {
      isOpened = false;
      isClosing = true;
      emit('actions:close', instance);
    };

    const onClosed = instance => {
      isClosing = false;
      emit('actions:closed', instance);
      emit('update:opened', false);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.opened, value => {
      if (!f7Actions) return;

      if (value) {
        f7Actions.open();
      } else {
        f7Actions.close();
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!elRef.value) return;
      const {
        target,
        convertToPopover,
        forceToPopover,
        closeByBackdropClick,
        closeByOutsideClick,
        closeOnEscape,
        backdrop,
        backdropEl,
        grid,
        containerEl
      } = props;
      const params = {
        el: elRef.value,
        grid,
        on: {
          open: onOpen,
          opened: onOpened,
          close: onClose,
          closed: onClosed
        }
      };
      if (typeof target !== 'undefined') params.target = target;
      if (typeof convertToPopover !== 'undefined') params.convertToPopover = convertToPopover;
      if (typeof forceToPopover !== 'undefined') params.forceToPopover = forceToPopover;
      if (typeof closeByBackdropClick !== 'undefined') params.closeByBackdropClick = closeByBackdropClick;
      if (typeof closeByOutsideClick !== 'undefined') params.closeByOutsideClick = closeByOutsideClick;
      if (typeof closeOnEscape !== 'undefined') params.closeOnEscape = closeOnEscape;
      if (typeof backdrop !== 'undefined') params.backdrop = backdrop;
      if (typeof backdropEl !== 'undefined') params.backdropEl = backdropEl;
      if (typeof containerEl !== 'undefined') params.containerEl = containerEl;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        f7Actions = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.popup.create(params);

        if (props.opened) {
          f7Actions.open(false);
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Actions) {
        f7Actions.destroy();
      }

      f7Actions = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('actions-modal', {
      'actions-grid': props.grid
    }, (0,_shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_4__.modalStateClasses)({
      isOpened,
      isClosing
    }), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/app.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7-vue/components/app.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _routable_modals_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./routable-modals.js */ "./node_modules/framework7-vue/components/routable-modals.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");


function render(_ctx, _cache) {
  const _component_routable_modals = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("routable-modals");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    id: "framework7-root",
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_routable_modals)], 2);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-app',
  render,
  components: {
    RoutableModals: _routable_modals_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  inheritAttrs: false,
  props: {
    id: {
      type: String,
      default: undefined
    },
    name: {
      type: String,
      default: undefined
    },
    version: {
      type: String,
      default: undefined
    },
    theme: {
      type: String,
      default: undefined
    },
    language: {
      type: String,
      default: undefined
    },
    routes: {
      type: Array,
      default: () => []
    },
    store: Object,
    autoDarkMode: {
      type: Boolean,
      default: undefined
    },
    lazyModulesPath: {
      type: String,
      default: undefined
    },
    initOnDeviceReady: {
      type: Boolean,
      default: undefined
    },
    iosTranslucentBars: {
      type: Boolean,
      default: undefined
    },
    iosTranslucentModals: {
      type: Boolean,
      default: undefined
    },
    userAgent: {
      type: String,
      default: undefined
    },
    url: {
      type: String,
      default: undefined
    },
    // components
    accordion: {
      type: Object,
      default: () => undefined
    },
    actions: {
      type: Object,
      default: () => undefined
    },
    areaChart: {
      type: Object,
      default: () => undefined
    },
    autocomplete: {
      type: Object,
      default: () => undefined
    },
    calendar: {
      type: Object,
      default: () => undefined
    },
    card: {
      type: Object,
      default: () => undefined
    },
    colorPicker: {
      type: Object,
      default: () => undefined
    },
    dialog: {
      type: Object,
      default: () => undefined
    },
    form: {
      type: Object,
      default: () => undefined
    },
    gauge: {
      type: Object,
      default: () => undefined
    },
    grid: {
      type: Object,
      default: () => undefined
    },
    infiniteScroll: {
      type: Object,
      default: () => undefined
    },
    input: {
      type: Object,
      default: () => undefined
    },
    lazy: {
      type: Object,
      default: () => undefined
    },
    listIndex: {
      type: Object,
      default: () => undefined
    },
    loginScreen: {
      type: Object,
      default: () => undefined
    },
    messagebar: {
      type: Object,
      default: () => undefined
    },
    messages: {
      type: Object,
      default: () => undefined
    },
    navbar: {
      type: Object,
      default: () => undefined
    },
    notification: {
      type: Object,
      default: () => undefined
    },
    panel: {
      type: Object,
      default: () => undefined
    },
    photoBrowser: {
      type: Object,
      default: () => undefined
    },
    picker: {
      type: Object,
      default: () => undefined
    },
    pieChart: {
      type: Object,
      default: () => undefined
    },
    popover: {
      type: Object,
      default: () => undefined
    },
    popup: {
      type: Object,
      default: () => undefined
    },
    range: {
      type: Object,
      default: () => undefined
    },
    searchbar: {
      type: Object,
      default: () => undefined
    },
    sheet: {
      type: Object,
      default: () => undefined
    },
    smartSelect: {
      type: Object,
      default: () => undefined
    },
    sortable: {
      type: Object,
      default: () => undefined
    },
    statusbar: {
      type: Object,
      default: () => undefined
    },
    stepper: {
      type: Object,
      default: () => undefined
    },
    swipeout: {
      type: Object,
      default: () => undefined
    },
    textEditor: {
      type: Object,
      default: () => undefined
    },
    toast: {
      type: Object,
      default: () => undefined
    },
    toolbar: {
      type: Object,
      default: () => undefined
    },
    tooltip: {
      type: Object,
      default: () => undefined
    },
    view: {
      type: Object,
      default: () => undefined
    },
    virtualList: {
      type: Object,
      default: () => undefined
    },
    // modules
    clicks: {
      type: Object,
      default: () => undefined
    },
    serviceWorker: {
      type: Object,
      default: () => undefined
    },
    touch: {
      type: Object,
      default: () => undefined
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const routes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props.routes);

    if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7 || typeof window === 'undefined') {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7init)(elRef.value, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.noUndefinedProps)({ ...props,
        routes
      }), false);
    }

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      const parentEl = elRef.value && elRef.value.parentNode;
      /* eslint-disable no-restricted-globals */

      if (typeof document !== 'undefined' && parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
        parentEl.style.height = '100%';
      }
      /* eslint-enable no-restricted-globals */


      if (_shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7) {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7.init(elRef.value);
        return;
      }

      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7init)(elRef.value, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.noUndefinedProps)({ ...props,
        routes
      }), true);
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('framework7-root', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/appbar.js":
/*!**********************************************************!*\
  !*** ./node_modules/framework7-vue/components/appbar.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "before-inner"), _ctx.inner ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    key: 0,
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.innerClasses)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default", {
    key: 1
  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "after-inner")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-appbar',
  render,
  props: {
    noShadow: Boolean,
    noHairline: Boolean,
    inner: {
      type: Boolean,
      default: true
    },
    innerClass: String,
    innerClassName: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('appbar', {
      'no-shadow': props.noShadow,
      'no-hairline': props.noHairline
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    const innerClasses = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('appbar-inner', props.innerClass, props.innerClassName));
    return {
      classes,
      innerClasses
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/area-chart.js":
/*!**************************************************************!*\
  !*** ./node_modules/framework7-vue/components/area-chart.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = ["width", "height", "viewBox"];
const _hoisted_2 = ["data-index", "x1", "x2", "y2"];
const _hoisted_3 = {
  key: 0,
  class: "area-chart-axis"
};
const _hoisted_4 = {
  key: 0
};
const _hoisted_5 = {
  key: 1,
  class: "area-chart-legend"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("svg", {
    ref: "svgElRef",
    xmlns: "http://www.w3.org/2000/svg",
    width: _ctx.width,
    height: _ctx.height,
    viewBox: `0 0 ${_ctx.width} ${_ctx.height}`,
    preserveAspectRatio: "none"
  }, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.chartData, (data, index) => {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.ChartTag), {
      key: `${_ctx.ChartTag}-${index}`,
      fill: _ctx.lineChart ? undefined : data.color,
      stroke: _ctx.lineChart ? data.color : undefined,
      "fill-rule": "evenodd",
      points: _ctx.lineChart ? undefined : data.points,
      d: _ctx.lineChart ? data.points : undefined
    }, null, 8, ["fill", "stroke", "points", "d"]);
  }), 128)), ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.verticalLines, (line, index) => {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("line", {
      key: `line-${index}`,
      "data-index": index,
      fill: "#000",
      x1: line,
      y1: 0,
      x2: line,
      y2: _ctx.height,
      class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classNames({
        'area-chart-current-line': _ctx.currentIndex === index
      }))
    }, null, 10, _hoisted_2);
  }), 128))], 8, _hoisted_1)), _ctx.axis ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_3, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.axisLabels, (label, index) => {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", {
      key: index
    }, [_ctx.visibleLegends.includes(label) ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_4, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.formatAxisLabelMethod(label)), 1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)]);
  }), 128))])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.legend ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_5, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.datasets, (dataset, index) => {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.LegendItemTag), {
      key: index,
      class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classNames('area-chart-legend-item', {
        'area-chart-legend-item-hidden': _ctx.hiddenDatasets.includes(index),
        'area-chart-legend-button': _ctx.toggleDatasets
      })),
      type: _ctx.toggleDatasets ? 'button' : undefined,
      onClick: $event => _ctx.toggleDataset(index)
    }, {
      default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", {
        style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)({
          backgroundColor: dataset.color
        })
      }, null, 4), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(" " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.formatLegendLabelMethod(dataset.label)), 1)]),
      _: 2
    }, 1032, ["class", "type", "onClick"]);
  }), 128))])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-area-chart',
  render,
  props: {
    lineChart: Boolean,
    datasets: {
      type: Array,
      default: () => []
    },
    axis: Boolean,
    axisLabels: {
      type: Array,
      default: () => []
    },
    tooltip: Boolean,
    legend: Boolean,
    toggleDatasets: Boolean,
    width: {
      type: Number,
      default: 640
    },
    height: {
      type: Number,
      default: 320
    },
    maxAxisLabels: {
      type: Number,
      default: 8
    },
    formatAxisLabel: Function,
    formatLegendLabel: Function,
    formatTooltip: Function,
    formatTooltipAxisLabel: Function,
    formatTooltipTotal: Function,
    formatTooltipDataset: Function
  },
  emits: ['select'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    let f7Tooltip = null;
    const currentIndex = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const hiddenDatasets = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)([]);
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const svgElRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const linesOffsets = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const visibleLegends = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      if (!props.maxAxisLabels || props.axisLabels.length <= props.maxAxisLabels) return props.axisLabels;
      const skipStep = Math.ceil(props.axisLabels.length / props.maxAxisLabels);
      const filtered = props.axisLabels.filter((label, index) => index % skipStep === 0);
      return filtered;
    });
    const summValues = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const summ = [];
      props.datasets.filter((dataset, index) => !hiddenDatasets.value.includes(index)).forEach(_ref2 => {
        let {
          values
        } = _ref2;
        values.forEach((value, valueIndex) => {
          if (!summ[valueIndex]) summ[valueIndex] = 0;
          summ[valueIndex] += value;
        });
      });
      return summ;
    });
    const chartData = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        datasets,
        lineChart,
        width,
        height
      } = props;
      const data = [];

      if (!datasets.length) {
        return data;
      }

      const lastValues = datasets[0].values.map(() => 0);
      let maxValue = 0;

      if (lineChart) {
        datasets.forEach(_ref3 => {
          let {
            values
          } = _ref3;
          const datasetMaxValue = Math.max(...values);
          if (datasetMaxValue > maxValue) maxValue = datasetMaxValue;
        });
      } else {
        maxValue = Math.max(...summValues.value);
      }

      datasets.filter((dataset, index) => !hiddenDatasets.value.includes(index)).forEach(_ref4 => {
        let {
          label,
          values,
          color
        } = _ref4;
        const points = values.map((originalValue, valueIndex) => {
          lastValues[valueIndex] += originalValue;
          const value = lineChart ? originalValue : lastValues[valueIndex];
          const x = valueIndex / (values.length - 1) * width;
          const y = height - value / maxValue * height;

          if (lineChart) {
            return `${valueIndex === 0 ? 'M' : 'L'}${x},${y}`;
          }

          return `${x} ${y}`;
        });

        if (!lineChart) {
          points.push(`${width} ${height} 0 ${height}`);
        }

        data.push({
          label,
          points: points.join(' '),
          color
        });
      });
      return data.reverse();
    });
    const verticalLines = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const lines = [];

      if (!props.datasets.length) {
        return lines;
      }

      const values = props.datasets[0].values;
      values.forEach((value, valueIndex) => {
        const x = valueIndex / (values.length - 1) * props.width;
        lines.push(x);
      });
      return lines;
    });

    const toggleDataset = index => {
      if (!props.toggleDatasets) return;

      if (hiddenDatasets.value.includes(index)) {
        hiddenDatasets.value.splice(hiddenDatasets.value.indexOf(index), 1);
      } else {
        hiddenDatasets.value.push(index);
      }

      hiddenDatasets.value = [...hiddenDatasets.value];
    };

    const formatAxisLabelMethod = label => {
      if (props.formatAxisLabel) return props.formatAxisLabel(label);
      return label;
    };

    const formatLegendLabelMethod = label => {
      if (props.formatLegendLabel) return props.formatLegendLabel(label);
      return label;
    };

    const calcLinesOffsets = () => {
      const lines = svgElRef.value.querySelectorAll('line');
      linesOffsets.value = [];

      for (let i = 0; i < lines.length; i += 1) {
        linesOffsets.value.push(lines[i].getBoundingClientRect().left);
      }
    };

    const formatTooltip = () => {
      const index = currentIndex.value;
      if (index === null) return '';
      let total = 0;
      const currentValues = props.datasets.filter((dataset, i) => !hiddenDatasets.value.includes(i)).map(dataset => ({
        color: dataset.color,
        label: dataset.label,
        value: dataset.values[index]
      }));
      currentValues.forEach(dataset => {
        total += dataset.value;
      });

      if (props.formatTooltip) {
        return props.formatTooltip({
          index,
          total,
          datasets: currentValues
        });
      }

      let labelText = props.formatTooltipAxisLabel ? props.formatTooltipAxisLabel(props.axisLabels[index]) : formatAxisLabelMethod(props.axisLabels[index]);
      if (!labelText) labelText = '';
      const totalText = props.formatTooltipTotal ? props.formatTooltipTotal(total) : total; // prettier-ignore

      const datasetsText = currentValues.length > 0 ? `
      <ul class="area-chart-tooltip-list">
        ${currentValues.map(_ref5 => {
        let {
          label,
          color,
          value
        } = _ref5;
        const valueText = props.formatTooltipDataset ? props.formatTooltipDataset(label, value, color) : `${label}: ${value}`;
        return `
              <li><span style="background-color: ${color};"></span>${valueText}</li>
            `;
      }).join('')}
      </ul>` : ''; // prettier-ignore

      return `
      <div class="area-chart-tooltip-label">${labelText}</div>
      <div class="area-chart-tooltip-total">${totalText}</div>
      ${datasetsText}
    `;
    };

    const setTooltip = () => {
      const {
        tooltip,
        datasets
      } = props;
      const index = currentIndex.value;
      if (!tooltip) return;
      const hasVisibleDataSets = datasets.filter((dataset, i) => !hiddenDatasets.value.includes(i)).length > 0;

      if (!hasVisibleDataSets) {
        if (f7Tooltip && f7Tooltip.hide) f7Tooltip.hide();
        return;
      }

      if (index !== null && !f7Tooltip) {
        f7Tooltip = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.tooltip.create({
          trigger: 'manual',
          containerEl: elRef.value,
          targetEl: svgElRef.value.querySelector(`line[data-index="${index}"]`),
          text: formatTooltip(),
          cssClass: 'area-chart-tooltip'
        });

        if (f7Tooltip && f7Tooltip.show) {
          f7Tooltip.show();
        }

        return;
      }

      if (!f7Tooltip || !f7Tooltip.hide || !f7Tooltip.show) {
        return;
      }

      if (index !== null) {
        f7Tooltip.setText(formatTooltip());
        f7Tooltip.setTargetEl(svgElRef.value.querySelector(`line[data-index="${index}"]`));
        f7Tooltip.show();
      } else {
        f7Tooltip.hide();
      }
    };

    const onMouseEnter = () => {
      calcLinesOffsets();
    };

    const onMouseMove = e => {
      if (!linesOffsets.value) {
        calcLinesOffsets();
      }

      let currentLeft = e.pageX;
      if (typeof currentLeft === 'undefined') currentLeft = 0;
      const distances = linesOffsets.value.map(left => Math.abs(currentLeft - left));
      const minDistance = Math.min(...distances);
      const closestIndex = distances.indexOf(minDistance);
      currentIndex.value = closestIndex;
    };

    const onMouseLeave = () => {
      currentIndex.value = null;
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => currentIndex.value, () => {
      emit('select', currentIndex.value);
      setTooltip();
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!svgElRef.value) return;
      svgElRef.value.addEventListener('mouseenter', onMouseEnter);
      svgElRef.value.addEventListener('mousemove', onMouseMove);
      svgElRef.value.addEventListener('mouseleave', onMouseLeave);
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Tooltip && f7Tooltip.destroy) {
        f7Tooltip.destroy();
      }

      f7Tooltip = null;
      if (!svgElRef.value) return;
      svgElRef.value.removeEventListener('mouseenter', onMouseEnter);
      svgElRef.value.removeEventListener('mousemove', onMouseMove);
      svgElRef.value.removeEventListener('mouseleave', onMouseLeave);
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('area-chart'));
    const LegendItemTag = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.toggleDatasets ? 'button' : 'span');
    const ChartTag = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.lineChart ? 'path' : 'polygon');
    return {
      currentIndex,
      hiddenDatasets,
      visibleLegends,
      chartData,
      verticalLines,
      elRef,
      svgElRef,
      classes,
      toggleDataset,
      formatAxisLabelMethod,
      formatLegendLabelMethod,
      LegendItemTag,
      ChartTag,
      classNames: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/badge.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/badge.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-badge',
  render,
  props: {
    tooltip: String,
    tooltipTrigger: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__.useTooltip)(elRef, props);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('badge', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/block-footer.js":
/*!****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/block-footer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-block-footer',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('block-footer', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/block-header.js":
/*!****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/block-header.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-block-header',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('block-header', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/block-title.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7-vue/components/block-title.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = ["medium"];

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    medium: _ctx.medium
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 10, _hoisted_1);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-block-title',
  render,
  props: {
    large: Boolean,
    medium: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        large,
        medium
      } = props;
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('block-title', {
        'block-title-large': large,
        'block-title-medium': medium
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props));
    });
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/block.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/block.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_tab_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-tab.js */ "./node_modules/framework7-vue/shared/use-tab.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-block',
  render,
  props: {
    inset: Boolean,
    xsmallInset: Boolean,
    smallInset: Boolean,
    mediumInset: Boolean,
    largeInset: Boolean,
    xlargeInset: Boolean,
    strong: Boolean,
    tabs: Boolean,
    tab: Boolean,
    tabActive: Boolean,
    accordionList: Boolean,
    accordionOpposite: Boolean,
    noHairlines: Boolean,
    noHairlinesMd: Boolean,
    noHairlinesIos: Boolean,
    noHairlinesAurora: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['tab:hide', 'tab:show'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    (0,_shared_use_tab_js__WEBPACK_IMPORTED_MODULE_3__.useTab)(elRef, emit);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        inset,
        xsmallInset,
        smallInset,
        mediumInset,
        largeInset,
        xlargeInset,
        strong,
        accordionList,
        accordionOpposite,
        tabs,
        tab,
        tabActive,
        noHairlines,
        noHairlinesMd,
        noHairlinesIos,
        noHairlinesAurora
      } = props;
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('block', {
        inset,
        'xsmall-inset': xsmallInset,
        'small-inset': smallInset,
        'medium-inset': mediumInset,
        'large-inset': largeInset,
        'xlarge-inset': xlargeInset,
        'block-strong': strong,
        'accordion-list': accordionList,
        'accordion-opposite': accordionOpposite,
        tabs,
        tab,
        'tab-active': tabActive,
        'no-hairlines': noHairlines,
        'no-hairlines-md': noHairlinesMd,
        'no-hairlines-ios': noHairlinesIos,
        'no-hairlines-aurora': noHairlinesAurora
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props));
    });
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/breadcrumbs-collapsed.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7-vue/components/breadcrumbs-collapsed.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

const _hoisted_1 = {
  ref: "elRef",
  class: "breadcrumbs-collapsed"
};

const _hoisted_2 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", null, null, -1);

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [_hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 512);
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-breadcrumbs-collapsed',
  render,
  props: {},

  setup() {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    return {
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/breadcrumbs-item.js":
/*!********************************************************************!*\
  !*** ./node_modules/framework7-vue/components/breadcrumbs-item.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)({
      'breadcrumbs-item': true,
      'breadcrumbs-item-active': _ctx.active
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-breadcrumbs-item',
  render,
  props: {
    active: Boolean
  },

  setup() {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    return {
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/breadcrumbs-separator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7-vue/components/breadcrumbs-separator.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

const _hoisted_1 = {
  ref: "elRef",
  class: "breadcrumbs-separator"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, null, 512);
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-breadcrumbs-separator',
  render,
  props: {},

  setup() {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    return {
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/breadcrumbs.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7-vue/components/breadcrumbs.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

const _hoisted_1 = {
  ref: "elRef",
  class: "breadcrumbs"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 512);
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-breadcrumbs',
  render,
  props: {},

  setup() {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    return {
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/button.js":
/*!**********************************************************!*\
  !*** ./node_modules/framework7-vue/components/button.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");
/* harmony import */ var _shared_use_icon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-icon.js */ "./node_modules/framework7-vue/shared/use-icon.js");
/* harmony import */ var _shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/use-route-props.js */ "./node_modules/framework7-vue/shared/use-route-props.js");
/* harmony import */ var _preloader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./preloader.js */ "./node_modules/framework7-vue/components/preloader.js");
/* harmony import */ var _use_icon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./use-icon.js */ "./node_modules/framework7-vue/components/use-icon.js");

const _hoisted_1 = {
  key: 1
};
const _hoisted_2 = {
  key: 1
};

function render(_ctx, _cache) {
  const _component_f7_preloader = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-preloader");

  const _component_f7_use_icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-use-icon");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.tag), (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
    ref: "elRef",
    class: _ctx.classesComputed
  }, _ctx.attrs), {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [_ctx.preloader ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
      key: 0
    }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_f7_preloader, {
      size: _ctx.preloaderSize,
      color: _ctx.preloaderColor
    }, null, 8, ["size", "color"]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", null, [_ctx.icon ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_use_icon, {
      key: 0,
      icon: _ctx.icon
    }, null, 8, ["icon"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.text ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_1, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.text), 1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])], 64)) : ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
      key: 1
    }, [_ctx.icon ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_use_icon, {
      key: 0,
      icon: _ctx.icon
    }, null, 8, ["icon"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.text ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.text), 1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 64))]),
    _: 3
  }, 16, ["class"]);
}









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-button',
  render,
  components: {
    f7Preloader: _preloader_js__WEBPACK_IMPORTED_MODULE_6__["default"],
    f7UseIcon: _use_icon_js__WEBPACK_IMPORTED_MODULE_7__["default"]
  },
  props: {
    text: String,
    tabLink: [Boolean, String],
    tabLinkActive: Boolean,
    type: String,
    href: {
      type: [String, Boolean],
      default: '#'
    },
    target: String,
    round: Boolean,
    roundMd: Boolean,
    roundIos: Boolean,
    roundAurora: Boolean,
    fill: Boolean,
    fillMd: Boolean,
    fillIos: Boolean,
    fillAurora: Boolean,
    large: Boolean,
    largeMd: Boolean,
    largeIos: Boolean,
    largeAurora: Boolean,
    small: Boolean,
    smallMd: Boolean,
    smallIos: Boolean,
    smallAurora: Boolean,
    raised: Boolean,
    raisedMd: Boolean,
    raisedIos: Boolean,
    raisedAurora: Boolean,
    outline: Boolean,
    outlineMd: Boolean,
    outlineIos: Boolean,
    outlineAurora: Boolean,
    active: Boolean,
    disabled: Boolean,
    tooltip: String,
    tooltipTrigger: String,
    preloader: Boolean,
    preloaderSize: [Number, String],
    preloaderColor: String,
    loading: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.iconProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerProps
  },

  setup(props) {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__.useTooltip)(elRef, props);
    (0,_shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_5__.useRouteProps)(elRef, props);
    const icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_use_icon_js__WEBPACK_IMPORTED_MODULE_4__.useIcon)(props));
    const tag = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.type === 'submit' || props.type === 'reset' || props.type === 'button' ? 'button' : 'a');
    const attrs = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        href,
        tabLink,
        target,
        type
      } = props;
      let hrefComputed = href;
      if (href === true) hrefComputed = '#';
      if (href === false || tag.value === 'button') hrefComputed = undefined; // no href attribute

      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
        href: hrefComputed,
        target,
        type,
        'data-tab': (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStringProp)(tabLink) && tabLink || undefined
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerAttrs)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsAttrs)(props));
    });
    const classesComputed = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        tabLink,
        tabLinkActive,
        round,
        roundMd,
        roundIos,
        roundAurora,
        fill,
        fillMd,
        fillIos,
        fillAurora,
        large,
        largeMd,
        largeIos,
        largeAurora,
        small,
        smallMd,
        smallIos,
        smallAurora,
        raised,
        raisedMd,
        raisedIos,
        raisedAurora,
        outline,
        outlineMd,
        outlineIos,
        outlineAurora,
        active,
        disabled,
        preloader,
        loading
      } = props;
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('button', {
        'tab-link': tabLink || tabLink === '',
        'tab-link-active': tabLinkActive,
        'button-round': round,
        'button-round-ios': roundIos,
        'button-round-aurora': roundAurora,
        'button-round-md': roundMd,
        'button-fill': fill,
        'button-fill-ios': fillIos,
        'button-fill-aurora': fillAurora,
        'button-fill-md': fillMd,
        'button-large': large,
        'button-large-ios': largeIos,
        'button-large-aurora': largeAurora,
        'button-large-md': largeMd,
        'button-small': small,
        'button-small-ios': smallIos,
        'button-small-aurora': smallAurora,
        'button-small-md': smallMd,
        'button-raised': raised,
        'button-raised-ios': raisedIos,
        'button-raised-aurora': raisedAurora,
        'button-raised-md': raisedMd,
        'button-active': active,
        'button-outline': outline,
        'button-outline-ios': outlineIos,
        'button-outline-aurora': outlineAurora,
        'button-outline-md': outlineMd,
        'button-preloader': preloader,
        'button-loading': loading,
        disabled
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsClasses)(props));
    });
    return {
      tag,
      elRef,
      attrs,
      classesComputed,
      icon
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/card-content.js":
/*!****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/card-content.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-card-content',
  render,
  props: {
    padding: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('card-content', {
      'card-content-padding': props.padding
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/card-footer.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7-vue/components/card-footer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-card-footer',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('card-footer', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/card-header.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7-vue/components/card-header.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-card-header',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('card-header', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/card.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/components/card.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _card_header_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./card-header.js */ "./node_modules/framework7-vue/components/card-header.js");
/* harmony import */ var _card_content_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./card-content.js */ "./node_modules/framework7-vue/components/card-content.js");
/* harmony import */ var _card_footer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./card-footer.js */ "./node_modules/framework7-vue/components/card-footer.js");

const _hoisted_1 = ["data-animate", "data-hide-navbar-on-open", "data-hide-toolbar-on-open", "data-hide-statusbar-on-open", "data-scrollable-el", "data-swipe-to-close", "data-close-by-backdrop-click", "data-backdrop", "data-backdrop-el"];

function render(_ctx, _cache) {
  const _component_f7_card_header = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-card-header");

  const _component_f7_card_content = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-card-content");

  const _component_f7_card_footer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-card-footer");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    "data-animate": typeof _ctx.animate === 'undefined' ? _ctx.animate : _ctx.animate.toString(),
    "data-hide-navbar-on-open": typeof _ctx.hideNavbarOnOpen === 'undefined' ? _ctx.hideNavbarOnOpen : _ctx.hideNavbarOnOpen.toString(),
    "data-hide-toolbar-on-open": typeof _ctx.hideToolbarOnOpen === 'undefined' ? _ctx.hideToolbarOnOpen : _ctx.hideToolbarOnOpen.toString(),
    "data-hide-statusbar-on-open": typeof _ctx.hideStatusbarOnOpen === 'undefined' ? _ctx.hideStatusbarOnOpen : _ctx.hideStatusbarOnOpen.toString(),
    "data-scrollable-el": _ctx.scrollableEl,
    "data-swipe-to-close": typeof _ctx.swipeToClose === 'undefined' ? _ctx.swipeToClose : _ctx.swipeToClose.toString(),
    "data-close-by-backdrop-click": typeof _ctx.closeByBackdropClick === 'undefined' ? _ctx.closeByBackdropClick : _ctx.closeByBackdropClick.toString(),
    "data-backdrop": typeof _ctx.backdrop === 'undefined' ? _ctx.backdrop : _ctx.backdrop.toString(),
    "data-backdrop-el": _ctx.backdropEl
  }, [_ctx.hasHeader ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_card_header, {
    key: 0
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.title) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "header")]),
    _: 3
  })) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasContent ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_card_content, {
    key: 1,
    padding: _ctx.padding
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.content) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "content")]),
    _: 3
  }, 8, ["padding"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasFooter ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_card_footer, {
    key: 2
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.footer) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "footer")]),
    _: 3
  })) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 10, _hoisted_1);
}








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-card',
  render,
  components: {
    f7CardHeader: _card_header_js__WEBPACK_IMPORTED_MODULE_4__["default"],
    f7CardContent: _card_content_js__WEBPACK_IMPORTED_MODULE_5__["default"],
    f7CardFooter: _card_footer_js__WEBPACK_IMPORTED_MODULE_6__["default"]
  },
  props: {
    title: [String, Number],
    content: [String, Number],
    footer: [String, Number],
    outline: Boolean,
    expandable: Boolean,
    expandableAnimateWidth: Boolean,
    expandableOpened: Boolean,
    animate: {
      type: Boolean,
      default: undefined
    },
    hideNavbarOnOpen: {
      type: Boolean,
      default: undefined
    },
    hideToolbarOnOpen: {
      type: Boolean,
      default: undefined
    },
    hideStatusbarOnOpen: {
      type: Boolean,
      default: undefined
    },
    scrollableEl: {
      type: String,
      default: undefined
    },
    swipeToClose: {
      type: Boolean,
      default: undefined
    },
    closeByBackdropClick: {
      type: Boolean,
      default: undefined
    },
    backdrop: {
      type: Boolean,
      default: undefined
    },
    backdropEl: {
      type: String,
      default: undefined
    },
    noShadow: Boolean,
    noBorder: Boolean,
    padding: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['card:beforeopen', 'card:open', 'card:opened', 'card:close', 'card:closed', 'update:expandableOpened'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const open = () => {
      if (!elRef.value) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.card.open(elRef.value);
    };

    const close = () => {
      if (!elRef.value) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.card.close(elRef.value);
    };

    const onBeforeOpen = (el, prevent) => {
      if (elRef.value !== el) return;
      emit('card:beforeopen', el, prevent);
    };

    const onOpen = el => {
      if (elRef.value !== el) return;
      emit('card:open', el);
      emit('update:expandableOpened', true);
    };

    const onOpened = (el, pageEl) => {
      if (elRef.value !== el) return;
      emit('card:opened', el, pageEl);
    };

    const onClose = el => {
      if (elRef.value !== el) return;
      emit('card:close', el);
    };

    const onClosed = (el, pageEl) => {
      if (elRef.value !== el) return;
      emit('card:closed', el, pageEl);
      emit('update:expandableOpened', false);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!props.expandable || !elRef.value) return;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        if (props.expandable && props.expandableOpened) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.card.open(elRef.value, false);
        }

        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('cardBeforeOpen', onBeforeOpen);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('cardOpen', onOpen);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('cardOpened', onOpened);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('cardClose', onClose);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('cardClosed', onClosed);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('cardBeforeOpen', onBeforeOpen);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('cardOpen', onOpen);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('cardOpened', onOpened);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('cardClose', onClose);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('cardClosed', onClosed);
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.expandableOpened, value => {
      if (value) {
        open();
      } else {
        close();
      }
    });
    const hasHeader = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.title || slots.header);
    const hasContent = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.content || slots.content);
    const hasFooter = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.footer || slots.footer);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('card', {
      'card-outline': props.outline,
      'card-expandable': props.expandable,
      'card-expandable-animate-width': props.expandableAnimateWidth,
      'no-shadow': props.noShadow,
      'no-border': props.noBorder
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes,
      hasHeader,
      hasContent,
      hasFooter
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/checkbox.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7-vue/components/checkbox.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = ["name", "value", "disabled", "readonly", "checked"];

const _hoisted_2 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("i", {
  class: "icon-checkbox"
}, null, -1);

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("label", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("input", {
    ref: "inputElRef",
    type: "checkbox",
    name: _ctx.name,
    value: _ctx.value,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    checked: _ctx.checked,
    onChange: _cache[0] || (_cache[0] = function () {
      return _ctx.onChange && _ctx.onChange(...arguments);
    })
  }, null, 40, _hoisted_1), _hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-checkbox',
  render,
  props: {
    checked: Boolean,
    indeterminate: Boolean,
    name: [Number, String],
    value: {
      type: [Number, String, Boolean],
      default: undefined
    },
    disabled: Boolean,
    readonly: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['update:checked', 'change'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const inputElRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onChange = event => {
      emit('update:checked', event.target.checked);
      emit('change', event);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (inputElRef.value) {
        inputElRef.value.indeterminate = !!props.indeterminate;
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.indeterminate, newValue => {
      if (inputElRef.value) {
        inputElRef.value.indeterminate = !!newValue;
      }
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
      checkbox: true,
      disabled: props.disabled
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      inputElRef,
      classes,
      onChange
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/chip.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/components/chip.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");
/* harmony import */ var _shared_use_icon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-icon.js */ "./node_modules/framework7-vue/shared/use-icon.js");
/* harmony import */ var _use_icon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./use-icon.js */ "./node_modules/framework7-vue/components/use-icon.js");

const _hoisted_1 = {
  key: 1,
  class: "chip-label"
};

function render(_ctx, _cache) {
  const _component_f7_use_icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-use-icon");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [_ctx.hasMedia ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    key: 0,
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.mediaClasses)
  }, [_ctx.icon ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_use_icon, {
    key: 0,
    icon: _ctx.icon
  }, null, 8, ["icon"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(" " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.media) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "media")], 2)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasLabel ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.text) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "text"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.deleteable ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("a", {
    key: 2,
    class: "chip-delete",
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onDeleteClick && _ctx.onDeleteClick(...arguments);
    })
  })) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)], 2);
}







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-chip',
  render,
  components: {
    f7UseIcon: _use_icon_js__WEBPACK_IMPORTED_MODULE_5__["default"]
  },
  props: {
    media: String,
    text: [String, Number],
    deleteable: Boolean,
    mediaBgColor: String,
    mediaTextColor: String,
    outline: Boolean,
    tooltip: String,
    tooltipTrigger: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.iconProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['delete'],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onDeleteClick = event => {
      emit('delete', event);
    };

    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__.useTooltip)(elRef, props);
    const icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_use_icon_js__WEBPACK_IMPORTED_MODULE_4__.useIcon)(props));
    const mediaClasses = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('chip-media', props.mediaTextColor && `text-color-${props.mediaTextColor}`, props.mediaBgColor && `bg-color-${props.mediaBgColor}`));
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('chip', {
      'chip-outline': props.outline
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    const hasLabel = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return props.text || slots && (slots.text || slots.default);
    });
    const hasMedia = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return props.media || icon.value || slots && slots.media;
    });
    return {
      classes,
      icon,
      mediaClasses,
      elRef,
      hasLabel,
      hasMedia,
      onDeleteClick
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/col.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7-vue/components/col.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = {
  key: 0,
  class: "resize-handler"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.tag), {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default"), _ctx.resizable && _ctx.resizableHandler ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)]),
    _: 3
  }, 8, ["class"]);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-col',
  render,
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    width: {
      type: [Number, String],
      default: 'auto'
    },
    xsmall: {
      type: [Number, String]
    },
    small: {
      type: [Number, String]
    },
    medium: {
      type: [Number, String]
    },
    large: {
      type: [Number, String]
    },
    xlarge: {
      type: [Number, String]
    },
    resizable: Boolean,
    resizableFixed: Boolean,
    resizableAbsolute: Boolean,
    resizableHandler: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['grid:resize'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onResize = el => {
      if (el === elRef.value) {
        emit('grid:resize');
      }
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('gridResize', onResize);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('gridResize', onResize);
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
      col: props.width === 'auto',
      [`col-${props.width}`]: props.width !== 'auto',
      [`xsmall-${props.xsmall}`]: props.xsmall,
      [`small-${props.small}`]: props.small,
      [`medium-${props.medium}`]: props.medium,
      [`large-${props.large}`]: props.large,
      [`xlarge-${props.xlarge}`]: props.xlarge,
      resizable: props.resizable,
      'resizable-fixed': props.resizableFixed,
      'resizable-absolute': props.resizableAbsolute
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/fab-backdrop.js":
/*!****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/fab-backdrop.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-fab-backdrop',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('fab-backdrop', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/fab-button.js":
/*!**************************************************************!*\
  !*** ./node_modules/framework7-vue/components/fab-button.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");

const _hoisted_1 = ["target"];
const _hoisted_2 = {
  key: 0,
  class: "fab-label"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("a", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    target: _ctx.target,
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onClick && _ctx.onClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default"), _ctx.label ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.label), 1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)], 10, _hoisted_1);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-fab-button',
  render,
  props: {
    fabClose: Boolean,
    label: String,
    target: String,
    tooltip: String,
    tooltipTrigger: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['click'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onClick = e => {
      emit('click', e);
    };

    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__.useTooltip)(elRef, props);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
      'fab-close': props.fabClose,
      'fab-label-button': props.label
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      onClick,
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/fab-buttons.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7-vue/components/fab-buttons.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-fab-buttons',
  render,
  props: {
    position: {
      type: String,
      default: 'top'
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('fab-buttons', `fab-buttons-${props.position}`, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/fab.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7-vue/components/fab.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-fab',
  props: {
    morphTo: String,
    href: [Boolean, String],
    target: String,
    text: String,
    position: {
      type: String,
      default: 'right-bottom'
    },
    tooltip: String,
    tooltipTrigger: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorProps
  },
  emits: ['click'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)(null);

    const onClick = e => {
      emit('click', e);
    };

    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_2__.useTooltip)(elRef, props);
    const hrefComputed = (0,vue__WEBPACK_IMPORTED_MODULE_3__.computed)(() => {
      let href = props.href;
      if (href === true) href = '#';
      if (href === false) href = undefined; // no href attribute

      return href;
    });
    return () => {
      const linkChildren = [];
      const rootChildren = [];
      let textEl;
      let linkEl;
      const {
        link: linkSlots,
        default: defaultSlots,
        root: rootSlots,
        text: textSlots
      } = slots;

      if (defaultSlots) {
        defaultSlots().forEach(vnode => {
          if (typeof vnode === 'undefined') return;
          const tag = vnode.type && vnode.type.name ? vnode.type.name : vnode.type;
          if (tag === 'FabButtons' || tag === 'f7-fab-buttons') rootChildren.push(vnode);else linkChildren.push(vnode);
        });
      }

      if (props.text || textSlots) {
        textEl = (0,vue__WEBPACK_IMPORTED_MODULE_3__.h)('div', {
          class: 'fab-text'
        }, [props.text, textSlots && textSlots()]);
      }

      if (linkChildren.length || linkSlots || textEl) {
        linkEl = (0,vue__WEBPACK_IMPORTED_MODULE_3__.h)('a', {
          target: props.target,
          href: hrefComputed.value,
          onClick
        }, [linkChildren, textEl, linkSlots && linkSlots()]);
      }

      const classes = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('fab', `fab-${props.position}`, {
        'fab-morph': props.morphTo,
        'fab-extended': typeof textEl !== 'undefined'
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props));
      return (0,vue__WEBPACK_IMPORTED_MODULE_3__.h)('div', {
        class: classes,
        'data-morph-to': props.morphTo,
        ref: elRef
      }, [linkEl, rootChildren, rootSlots && rootSlots()]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/gauge.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/gauge.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

const _hoisted_1 = {
  class: "gauge"
};
const _hoisted_2 = ["width", "height", "viewBox"];
const _hoisted_3 = ["d", "stroke", "stroke-width", "fill"];
const _hoisted_4 = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset", "fill"];
const _hoisted_5 = ["stroke", "stroke-width", "fill", "cx", "cy", "r"];
const _hoisted_6 = ["transform", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset", "fill", "cx", "cy", "r"];
const _hoisted_7 = ["y", "font-weight", "font-size", "fill", "dy", "dominant-baseline"];
const _hoisted_8 = ["y", "font-weight", "font-size", "fill", "dy", "dominant-baseline"];

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("svg", {
    class: "gauge-svg",
    width: `${_ctx.size}px`,
    height: `${_ctx.semiCircle ? _ctx.size / 2 : _ctx.size}px`,
    viewBox: `0 0 ${_ctx.size} ${_ctx.semiCircle ? _ctx.size / 2 : _ctx.size}`
  }, [_ctx.semiCircle ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("path", {
    key: 0,
    class: "gauge-back-semi",
    d: `M${_ctx.size - _ctx.borderWidth / 2},${_ctx.size / 2} a1,1 0 0,0 -${_ctx.size - _ctx.borderWidth},0`,
    stroke: _ctx.borderBgColor,
    "stroke-width": _ctx.borderWidth,
    fill: _ctx.bgColor || 'none'
  }, null, 8, _hoisted_3)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.semiCircle ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("path", {
    key: 1,
    class: "gauge-front-semi",
    d: `M${_ctx.size - _ctx.borderWidth / 2},${_ctx.size / 2} a1,1 0 0,0 -${_ctx.size - _ctx.borderWidth},0`,
    stroke: _ctx.borderColor,
    "stroke-width": _ctx.borderWidth,
    "stroke-dasharray": _ctx.length / 2,
    "stroke-dashoffset": _ctx.length / 2 * (1 + _ctx.progress),
    fill: _ctx.borderBgColor ? 'none' : _ctx.bgColor || 'none'
  }, null, 8, _hoisted_4)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), !_ctx.semiCircle && _ctx.borderBgColor ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("circle", {
    key: 2,
    class: "gauge-back-circle",
    stroke: _ctx.borderBgColor,
    "stroke-width": _ctx.borderWidth,
    fill: _ctx.bgColor || 'none',
    cx: _ctx.size / 2,
    cy: _ctx.size / 2,
    r: _ctx.radius
  }, null, 8, _hoisted_5)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), !_ctx.semiCircle ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("circle", {
    key: 3,
    class: "gauge-front-circle",
    transform: `rotate(-90 ${_ctx.size / 2} ${_ctx.size / 2})`,
    stroke: _ctx.borderColor,
    "stroke-width": _ctx.borderWidth,
    "stroke-dasharray": _ctx.length,
    "stroke-dashoffset": _ctx.length * (1 - _ctx.progress),
    fill: _ctx.borderBgColor ? 'none' : _ctx.bgColor || 'none',
    cx: _ctx.size / 2,
    cy: _ctx.size / 2,
    r: _ctx.radius
  }, null, 8, _hoisted_6)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.valueText ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("text", {
    key: 4,
    class: "gauge-value-text",
    x: "50%",
    y: _ctx.semiCircle ? '100%' : '50%',
    "font-weight": _ctx.valueFontWeight,
    "font-size": _ctx.valueFontSize,
    fill: _ctx.valueTextColor,
    dy: _ctx.semiCircle ? _ctx.labelText ? -_ctx.labelFontSize - 15 : -5 : 0,
    "text-anchor": "middle",
    "dominant-baseline": !_ctx.semiCircle ? 'middle' : null
  }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.valueText), 9, _hoisted_7)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.labelText ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("text", {
    key: 5,
    class: "gauge-label-text",
    x: "50%",
    y: _ctx.semiCircle ? '100%' : '50%',
    "font-weight": _ctx.labelFontWeight,
    "font-size": _ctx.labelFontSize,
    fill: _ctx.labelTextColor,
    dy: _ctx.semiCircle ? -5 : _ctx.valueText ? _ctx.valueFontSize / 2 + 10 : 0,
    "text-anchor": "middle",
    "dominant-baseline": !_ctx.semiCircle ? 'middle' : null
  }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.labelText), 9, _hoisted_8)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)], 8, _hoisted_2))]);
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-gauge',
  render,
  props: {
    type: {
      type: String,
      default: 'circle'
    },
    value: {
      type: [Number, String],
      default: 0
    },
    size: {
      type: [Number, String],
      default: 200
    },
    bgColor: {
      type: String,
      default: 'transparent'
    },
    borderBgColor: {
      type: String,
      default: '#eeeeee'
    },
    borderColor: {
      type: String,
      default: '#000000'
    },
    borderWidth: {
      type: [Number, String],
      default: 10
    },
    valueText: [Number, String],
    valueTextColor: {
      type: String,
      default: '#000000'
    },
    valueFontSize: {
      type: [Number, String],
      default: 31
    },
    valueFontWeight: {
      type: [Number, String],
      default: 500
    },
    labelText: String,
    labelTextColor: {
      type: String,
      default: '#888888'
    },
    labelFontSize: {
      type: [Number, String],
      default: 14
    },
    labelFontWeight: {
      type: [Number, String],
      default: 400
    }
  },

  setup(props) {
    const semiCircle = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.type === 'semicircle');
    const radius = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.size / 2 - props.borderWidth / 2);
    const length = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => 2 * Math.PI * radius.value);
    const progress = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => Math.max(Math.min(props.value, 1), 0));
    return {
      semiCircle,
      radius,
      length,
      progress
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/icon.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/components/icon.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");
/* harmony import */ var _shared_use_theme_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-theme.js */ "./node_modules/framework7-vue/shared/use-theme.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("i", {
    ref: "elRef",
    style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)({
      fontSize: _ctx.sizeComputed,
      width: _ctx.sizeComputed,
      height: _ctx.sizeComputed
    }),
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classesComputed)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.iconText) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 6);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-icon',
  render,
  props: {
    material: String,
    f7: String,
    icon: String,
    ios: String,
    aurora: String,
    md: String,
    tooltip: String,
    tooltipTrigger: String,
    size: [String, Number],
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const theme = (0,_shared_use_theme_js__WEBPACK_IMPORTED_MODULE_4__.useTheme)();
    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__.useTooltip)(elRef, props);
    const classesComputed = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        ios,
        md,
        aurora,
        f7,
        material,
        icon
      } = props;
      let classes = {
        icon: true
      };
      let themeIcon;
      if (theme.value && theme.value.ios) themeIcon = ios;else if (theme.value && theme.value.md) themeIcon = md;else if (theme.value && theme.value.aurora) themeIcon = aurora;

      if (themeIcon) {
        const parts = themeIcon.split(':');
        const prop = parts[0];
        const value = parts[1];

        if (prop === 'material' || prop === 'f7') {
          classes['material-icons'] = prop === 'material';
          classes['f7-icons'] = prop === 'f7';
        }

        if (prop === 'icon') {
          classes[value] = true;
        }
      } else {
        classes = {
          icon: true,
          'material-icons': material,
          'f7-icons': f7
        };
        if (icon) classes[icon] = true;
      }

      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)(classes, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props));
    });
    const sizeComputed = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let size = props.size;

      if (typeof props.size === 'number' || parseFloat(props.size) === props.size * 1) {
        size = `${props.size}px`;
      }

      return size;
    });
    const iconText = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        ios,
        md,
        aurora,
        f7,
        material
      } = props;
      let text = material || f7;

      if (md && theme.value && theme.value.md && (md.indexOf('material:') >= 0 || md.indexOf('f7:') >= 0)) {
        text = md.split(':')[1];
      } else if (ios && theme.value && theme.value.ios && (ios.indexOf('material:') >= 0 || ios.indexOf('f7:') >= 0)) {
        text = ios.split(':')[1];
      } else if (aurora && theme.value && theme.value.aurora && (aurora.indexOf('material:') >= 0 || aurora.indexOf('f7:') >= 0)) {
        text = aurora.split(':')[1];
      }

      return text;
    });
    return {
      elRef,
      sizeComputed,
      classesComputed,
      iconText
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/input.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/input.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _toggle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toggle.js */ "./node_modules/framework7-vue/components/toggle.js");
/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./range.js */ "./node_modules/framework7-vue/components/range.js");
/* harmony import */ var _text_editor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./text-editor.js */ "./node_modules/framework7-vue/components/text-editor.js");







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-input',
  props: {
    type: String,
    name: String,
    value: {
      type: [String, Number, Array, Date, Object],
      default: undefined
    },
    inputmode: String,
    placeholder: String,
    inputId: [String, Number],
    size: [String, Number],
    accept: [String, Number],
    autocomplete: [String],
    autocorrect: [String],
    autocapitalize: [String],
    spellcheck: [String],
    autofocus: Boolean,
    autosave: String,
    checked: Boolean,
    disabled: Boolean,
    max: [String, Number],
    min: [String, Number],
    step: [String, Number],
    maxlength: [String, Number],
    minlength: [String, Number],
    multiple: Boolean,
    readonly: Boolean,
    required: Boolean,
    inputStyle: [String, Object],
    pattern: String,
    validate: [Boolean, String],
    validateOnBlur: Boolean,
    onValidate: Function,
    tabindex: [String, Number],
    resizable: Boolean,
    clearButton: Boolean,
    // Form
    noFormStoreData: Boolean,
    noStoreData: Boolean,
    ignoreStoreData: Boolean,
    // Error, Info
    errorMessage: String,
    errorMessageForce: Boolean,
    info: String,
    // Outline
    outline: Boolean,
    // Components
    wrap: {
      type: Boolean,
      default: true
    },
    dropdown: {
      type: [String, Boolean],
      default: 'auto'
    },
    // Datepicker
    calendarParams: Object,
    // Colorpicker
    colorPickerParams: Object,
    // Text editor
    textEditorParams: Object,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorProps
  },
  emits: ['input', 'focus', 'blur', 'change', 'textarea:resize', 'input:notempty', 'input:empty', 'input:clear', 'texteditor:change', 'calendar:change', 'colorpicker:change', 'update:value'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    let f7Calendar = null;
    let f7ColorPicker = null;
    const inputInvalid = (0,vue__WEBPACK_IMPORTED_MODULE_6__.ref)(false);
    const inputFocused = (0,vue__WEBPACK_IMPORTED_MODULE_6__.ref)(false);
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_6__.ref)(null);
    const inputElRef = (0,vue__WEBPACK_IMPORTED_MODULE_6__.ref)(null);
    let updateInputOnDidUpdate = false;

    const getDomValue = () => {
      if (!inputElRef.value) return undefined;
      return inputElRef.value.value;
    };

    const domValue = (0,vue__WEBPACK_IMPORTED_MODULE_6__.ref)(getDomValue());
    const inputHasValue = (0,vue__WEBPACK_IMPORTED_MODULE_6__.computed)(() => {
      if (props.type === 'datepicker' && Array.isArray(props.value) && props.value.length === 0) {
        return false;
      }

      return typeof props.value === 'undefined' ? domValue.value || domValue.value === 0 : props.value || props.value === 0;
    });

    const validateInput = () => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7 || !inputElRef.value) return;
      const validity = inputElRef.value.validity;
      if (!validity) return;

      if (!validity.valid) {
        if (props.onValidate) props.onValidate(false);

        if (inputInvalid.value !== true) {
          inputInvalid.value = true;
        }
      } else {
        if (props.onValidate) props.onValidate(true);

        if (inputInvalid.value !== false) {
          inputInvalid.value = false;
        }
      }
    };

    const onTextareaResize = event => {
      emit('textarea:resize', event);
    };

    const onInputNotEmpty = event => {
      emit('input:notempty', event);
    };

    const onInputEmpty = event => {
      emit('input:empty', event);
    };

    const onInputClear = event => {
      emit('input:clear', event);
    };

    const onInput = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      emit('input', ...args);

      if (inputElRef.value) {
        domValue.value = inputElRef.value.value;
      }

      if (!(props.validateOnBlur || props.validateOnBlur === '') && (props.validate || props.validate === '') && inputElRef.value) {
        validateInput();
      }

      if (inputElRef.value && props.type !== 'texteditor' && props.type !== 'colorpicker' && props.type !== 'datepicker') {
        emit('update:value', inputElRef.value.value);
      }
    };

    const onFocus = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      emit('focus', ...args);
      inputFocused.value = true;
    };

    const onBlur = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      emit('blur', ...args);

      if ((props.validate || props.validate === '' || props.validateOnBlur || props.validateOnBlur === '') && inputElRef.value) {
        validateInput();
      }

      inputFocused.value = false;
    };

    const onChange = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      emit('change', ...args);

      if (props.type === 'texteditor') {
        emit('texteditor:change', args[1]);
        emit('update:value', args[1]);
      }
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_6__.onMounted)(() => {
      const {
        type,
        resizable,
        clearButton,
        value,
        calendarParams,
        colorPickerParams,
        validate,
        validateOnBlur
      } = props;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7ready)(() => {
        if (type === 'range' || type === 'toggle') return;
        if (!inputElRef.value) return;
        inputElRef.value.addEventListener('input:notempty', onInputNotEmpty, false);

        if (type === 'textarea' && resizable) {
          inputElRef.value.addEventListener('textarea:resize', onTextareaResize, false);
        }

        if (clearButton) {
          inputElRef.value.addEventListener('input:empty', onInputEmpty, false);
          inputElRef.value.addEventListener('input:clear', onInputClear, false);
        }

        if (type === 'datepicker') {
          f7Calendar = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.calendar.create({
            inputEl: inputElRef.value,
            value,
            on: {
              change(calendar, calendarValue) {
                emit('calendar:change', calendarValue);
                emit('update:value', calendarValue);
              }

            },
            ...(calendarParams || {})
          });
        }

        if (type === 'colorpicker') {
          f7ColorPicker = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.colorPicker.create({
            inputEl: inputElRef.value,
            value,
            on: {
              change(colorPicker, colorPickerValue) {
                emit('colorpicker:change', colorPickerValue);
                emit('update:value', colorPickerValue);
              }

            },
            ...(colorPickerParams || {})
          });
        }

        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.input.checkEmptyState(inputElRef.value);

        if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && typeof value !== 'undefined' && value !== null && value !== '') {
          setTimeout(() => {
            validateInput();
          }, 0);
        }

        if (resizable) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.input.resizeTextarea(inputElRef.value);
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_6__.onBeforeUnmount)(() => {
      if (props.type === 'range' || props.type === 'toggle') return;
      if (!inputElRef.value) return;
      inputElRef.value.removeEventListener('input:notempty', onInputNotEmpty, false);

      if (props.type === 'textarea' && props.resizable) {
        inputElRef.value.removeEventListener('textarea:resize', onTextareaResize, false);
      }

      if (props.clearButton) {
        inputElRef.value.removeEventListener('input:empty', onInputEmpty, false);
        inputElRef.value.removeEventListener('input:clear', onInputClear, false);
      }

      if (f7Calendar && f7Calendar.destroy) {
        f7Calendar.destroy();
        f7Calendar = null;
      }

      if (f7ColorPicker && f7ColorPicker.destroy) {
        f7ColorPicker.destroy();
        f7ColorPicker = null;
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_6__.onUpdated)(() => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7) return;

      if (updateInputOnDidUpdate) {
        if (!inputElRef.value) return;
        updateInputOnDidUpdate = false;
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.input.checkEmptyState(inputElRef.value);

        if (props.validate && !props.validateOnBlur) {
          validateInput();
        }

        if (props.resizable) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.input.resizeTextarea(inputElRef.value);
        }
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_6__.watch)(() => props.colorPickerParams, newValue => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7 || !f7ColorPicker) return;
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(f7ColorPicker.params, newValue || {});
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_6__.watch)(() => props.calendarParams, newValue => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7 || !f7Calendar) return;
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(f7Calendar.params, newValue || {});
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_6__.watch)(() => props.value, newValue => {
      if (props.type === 'range' || props.type === 'toggle' || !_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7) return;
      updateInputOnDidUpdate = true;

      if (f7Calendar) {
        f7Calendar.setValue(newValue);
      }

      if (f7ColorPicker) {
        f7ColorPicker.setValue(newValue);
      }
    });

    const createInput = (InputTag, children) => {
      const needsValue = props.type !== 'file' && props.type !== 'datepicker' && props.type !== 'colorpicker';
      const needsType = InputTag === 'input';
      let inputType = props.type;

      if (inputType === 'datepicker' || inputType === 'colorpicker') {
        inputType = 'text';
      }

      const inputClassName = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)({
        resizable: inputType === 'textarea' && props.resizable,
        'no-store-data': props.noFormStoreData || props.noStoreData || props.ignoreStoreData,
        'input-invalid': props.errorMessage && props.errorMessageForce || inputInvalid.value,
        'input-with-value': inputHasValue.value,
        'input-focused': inputFocused.value
      });
      let inputValue;

      if (needsValue) {
        if (typeof props.value !== 'undefined') inputValue = props.value;else inputValue = domValue.value;
      }

      const valueProps = {};

      if (props.type !== 'datepicker' && props.type !== 'colorpicker') {
        if ('value' in props) valueProps.value = inputValue;
      }

      const inputProps = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.noUndefinedProps)({
        name: props.name,
        type: needsType ? inputType : undefined,
        placeholder: props.placeholder,
        inputmode: props.inputmode,
        id: props.inputId,
        size: props.size,
        accept: props.accept,
        autocomplete: props.autocomplete,
        autoCorrect: props.autocorrect,
        autocapitalize: props.autocapitalize,
        spellcheck: props.spellcheck,
        autofocus: props.autofocus,
        autoSave: props.autosave,
        checked: props.checked,
        disabled: props.disabled,
        max: props.max,
        maxlength: props.maxlength,
        min: props.min,
        minlength: props.minlength,
        step: props.step,
        multiple: props.multiple,
        readonly: props.readonly,
        required: props.required,
        pattern: props.pattern,
        validate: typeof props.validate === 'string' && props.validate.length ? props.validate : undefined,
        tabindex: props.tabindex
      });
      return (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(InputTag, {
        ref: inputElRef,
        style: props.inputStyle,
        ...inputProps,
        'data-validate': props.validate === true || props.validate === '' || props.validateOnBlur === true || props.validateOnBlur === '' ? true : undefined,
        'data-validate-on-blur': props.validateOnBlur === true || props.validateOnBlur === '' ? true : undefined,
        'data-error-message': props.errorMessageForce ? undefined : props.errorMessage,
        class: inputClassName,
        onFocus,
        onBlur,
        onInput,
        onChange,
        ...valueProps
      }, [children]);
    };

    const wrapClasses = (0,vue__WEBPACK_IMPORTED_MODULE_6__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('input', {
      'input-outline': props.outline,
      'input-dropdown': props.dropdown === 'auto' ? props.type === 'select' : props.dropdown,
      'input-invalid': props.errorMessage && props.errorMessageForce || inputInvalid.value
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props)));
    return () => {
      let inputEl;

      if (props.type === 'select' || props.type === 'textarea' || props.type === 'file') {
        if (props.type === 'select') {
          inputEl = createInput('select', slots.default && slots.default());
        } else if (props.type === 'file') {
          inputEl = createInput('input');
        } else {
          inputEl = createInput('textarea');
        }
      } else if (slots.default || !props.type) {
        inputEl = slots.default();
      } else if (props.type === 'toggle') {
        inputEl = (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_toggle_js__WEBPACK_IMPORTED_MODULE_3__["default"], {
          checked: props.checked,
          readonly: props.readonly,
          name: props.name,
          value: props.value,
          disabled: props.disabled,
          id: props.inputId,
          onChange
        });
      } else if (props.type === 'range') {
        inputEl = (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_range_js__WEBPACK_IMPORTED_MODULE_4__["default"], {
          value: props.value,
          disabled: props.disabled,
          min: props.min,
          max: props.max,
          step: props.step,
          name: props.name,
          id: props.inputId,
          input: true,
          onRangeChange: onChange
        });
      } else if (props.type === 'texteditor') {
        inputEl = (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_text_editor_js__WEBPACK_IMPORTED_MODULE_5__["default"], {
          value: props.value,
          resizable: props.resizable,
          placeholder: props.placeholder,
          onTextEditorFocus: onFocus,
          onTextEditorBlur: onBlur,
          onTextEditorInput: onInput,
          onTextEditorChange: onChange,
          ...(props.textEditorParams || {})
        });
      } else {
        inputEl = createInput('input');
      }

      if (!props.wrap) return inputEl;
      return (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)('div', {
        class: wrapClasses.value,
        ref: elRef
      }, [inputEl, (props.errorMessage || slots['error-message']) && props.errorMessageForce && (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)('div', {
        class: 'input-error-message'
      }, [props.errorMessage, slots['error-message'] && slots['error-message']()]), props.clearButton && (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)('span', {
        class: 'input-clear-button'
      }), (props.info || slots.info) && (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)('div', {
        class: 'input-info'
      }, [props.info, slots.info && slots.info()])]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/link.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/components/link.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-icon.js */ "./node_modules/framework7-vue/shared/use-icon.js");
/* harmony import */ var _shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-route-props.js */ "./node_modules/framework7-vue/shared/use-route-props.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");
/* harmony import */ var _shared_use_smart_select_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shared/use-smart-select.js */ "./node_modules/framework7-vue/shared/use-smart-select.js");
/* harmony import */ var _badge_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./badge.js */ "./node_modules/framework7-vue/components/badge.js");
/* harmony import */ var _use_icon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./use-icon.js */ "./node_modules/framework7-vue/components/use-icon.js");


function render(_ctx, _cache) {
  const _component_f7_use_icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-use-icon");

  const _component_f7_badge = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-badge");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("a", (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
    ref: "elRef",
    class: _ctx.classes
  }, _ctx.attrs), [_ctx.icon ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_use_icon, {
    key: 0,
    icon: _ctx.icon
  }, null, 8, ["icon"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.text ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", {
    key: 1,
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.isTabbarLabel ? 'tabbar-label' : '')
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.text) + " ", 1), _ctx.badge ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_badge, {
    key: 0,
    color: _ctx.badgeColor
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.badge), 1)]),
    _: 1
  }, 8, ["color"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)], 2)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 16);
}










/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-link',
  render,
  components: {
    f7Badge: _badge_js__WEBPACK_IMPORTED_MODULE_7__["default"],
    f7UseIcon: _use_icon_js__WEBPACK_IMPORTED_MODULE_8__["default"]
  },
  props: {
    noLinkClass: Boolean,
    text: String,
    tabLink: [Boolean, String],
    tabLinkActive: Boolean,
    tabbarLabel: Boolean,
    iconOnly: Boolean,
    badge: [String, Number],
    badgeColor: [String],
    href: {
      type: [String, Boolean],
      default: '#'
    },
    target: String,
    tooltip: String,
    tooltipTrigger: String,
    smartSelect: Boolean,
    smartSelectParams: Object,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.iconProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerProps
  },

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    let f7SmartSelect = null;
    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_5__.useTooltip)(elRef, props);
    (0,_shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_4__.useRouteProps)(elRef, props);
    (0,_shared_use_smart_select_js__WEBPACK_IMPORTED_MODULE_6__.useSmartSelect)(props, instance => {
      f7SmartSelect = instance;
    }, () => {
      return elRef.value;
    });
    const TabbarContext = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)('TabbarContext', {
      value: {}
    });
    const isTabbarLabel = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.tabbarLabel || TabbarContext.value.tabbarHasLabels);
    const attrs = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        href,
        tabLink,
        target
      } = props;
      let hrefComputed = href;
      if (href === true) hrefComputed = '#';
      if (href === false) hrefComputed = undefined; // no href attribute

      return {
        href: hrefComputed,
        target,
        'data-tab': (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStringProp)(tabLink) && tabLink || undefined,
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerAttrs)(props),
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsAttrs)(props)
      };
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        iconOnly,
        text,
        noLinkClass,
        tabLink,
        tabLinkActive,
        smartSelect
      } = props;
      let iconOnlyComputed;
      const hasChildren = slots && slots.default;

      if (iconOnly || !text && !hasChildren) {
        iconOnlyComputed = true;
      } else {
        iconOnlyComputed = false;
      }

      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
        link: !(noLinkClass || isTabbarLabel.value),
        'icon-only': iconOnlyComputed,
        'tab-link': tabLink || tabLink === '',
        'tab-link-active': tabLinkActive,
        'smart-select': smartSelect
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsClasses)(props));
    });
    const icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_use_icon_js__WEBPACK_IMPORTED_MODULE_3__.useIcon)(props));
    return {
      elRef,
      icon,
      isTabbarLabel,
      attrs,
      classes,
      f7SmartSelect
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/list-button.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7-vue/components/list-button.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");
/* harmony import */ var _shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-route-props.js */ "./node_modules/framework7-vue/shared/use-route-props.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("li", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("a", (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
    ref: "linkElRef",
    class: _ctx.linkClasses
  }, _ctx.linkAttrs, {
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onClick && _ctx.onClick(...arguments);
    })
  }), [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.title) + " " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.text) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 16)]);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-list-button',
  render,
  props: {
    title: [String, Number],
    text: [String, Number],
    tabLink: [Boolean, String],
    tabLinkActive: Boolean,
    link: [Boolean, String],
    href: [Boolean, String],
    target: String,
    tooltip: String,
    tooltipTrigger: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerProps
  },
  emits: ['click'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const linkElRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onClick = e => {
      emit('click', e);
    };

    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_3__.useTooltip)(linkElRef, props);
    (0,_shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_4__.useRouteProps)(linkElRef, props);
    const linkAttrs = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return {
        href: typeof props.link === 'boolean' && typeof props.href === 'boolean' ? '#' : props.link || props.href,
        target: props.target,
        'data-tab': (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStringProp)(props.tabLink) && props.tabLink,
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerAttrs)(props),
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsAttrs)(props)
      };
    });
    const linkClasses = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
        'list-button': true,
        'tab-link': props.tabLink || props.tabLink === '',
        'tab-link-active': props.tabLinkActive,
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props),
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerClasses)(props),
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsClasses)(props)
      });
    });
    return {
      linkAttrs,
      linkClasses,
      onClick,
      linkElRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/list-group.js":
/*!**************************************************************!*\
  !*** ./node_modules/framework7-vue/components/list-group.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = ["data-sortable-move-elements"];

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    "data-sortable-move-elements": typeof _ctx.sortableMoveElements !== 'undefined' ? _ctx.sortableMoveElements.toString() : undefined
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("ul", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])], 10, _hoisted_1);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-list-group',
  render,
  props: {
    mediaList: Boolean,
    simpleList: Boolean,
    sortable: Boolean,
    sortableOpposite: Boolean,
    sortableTapHold: Boolean,
    sortableMoveElements: {
      type: Boolean,
      default: undefined
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const ListContextParent = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)('ListContext', {
      value: {
        listIsMedia: props.mediaList,
        listIsSimple: props.simpleList,
        listIsSortable: props.sortable,
        listIsSortableOpposite: props.sortableOpposite
      }
    });
    const ListContext = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ({
      listIsMedia: props.mediaList || ListContextParent.value.listIsMedia,
      listIsSimple: props.simpleList || ListContextParent.value.listIsSimple,
      listIsSortable: props.sortable || ListContextParent.value.listIsSortable,
      listIsSortableOpposite: props.sortableOpposite || ListContextParent.value.listIsSortableOpposite
    }));
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)('ListContext', ListContext);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('list-group', {
      'media-list': props.mediaList,
      sortable: props.sortable,
      'sortable-tap-hold': props.sortableTapHold,
      'sortable-opposite': props.sortableOpposite
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/list-index.js":
/*!**************************************************************!*\
  !*** ./node_modules/framework7-vue/components/list-index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-list-index',
  render,
  props: {
    init: {
      type: Boolean,
      default: true
    },
    listEl: [String, Object],
    indexes: {
      type: [String, Array],
      default: 'auto'
    },
    scrollList: {
      type: Boolean,
      default: true
    },
    label: {
      type: Boolean,
      default: false
    },
    iosItemHeight: {
      type: Number,
      default: 14
    },
    mdItemHeight: {
      type: Number,
      default: 14
    },
    auroraItemHeight: {
      type: Number,
      default: 14
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['listindex:select'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    let f7ListIndex = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const update = () => {
      if (!f7ListIndex) return;
      f7ListIndex.update();
    };

    const scrollListToIndex = indexContent => {
      if (!f7ListIndex) return;
      f7ListIndex.scrollListToIndex(indexContent);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.indexes, newValue => {
      if (!f7ListIndex) return;
      f7ListIndex.params.indexes = newValue;
      update();
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!props.init) return;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        f7ListIndex = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.listIndex.create({
          el: elRef.value,
          listEl: props.listEl,
          indexes: props.indexes,
          iosItemHeight: props.iosItemHeight,
          mdItemHeight: props.mdItemHeight,
          auroraItemHeight: props.auroraItemHeight,
          scrollList: props.scrollList,
          label: props.label,
          on: {
            select(index, itemContent, itemIndex) {
              emit('listindex:select', itemContent, itemIndex);
            }

          }
        });
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7ListIndex && f7ListIndex.destroy) {
        f7ListIndex.destroy();
      }

      f7ListIndex = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('list-index', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes,
      update,
      scrollListToIndex
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/list-input.js":
/*!**************************************************************!*\
  !*** ./node_modules/framework7-vue/components/list-input.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _text_editor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./text-editor.js */ "./node_modules/framework7-vue/components/text-editor.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-list-input',
  props: {
    sortable: {
      type: Boolean,
      default: undefined
    },
    media: String,
    dropdown: {
      type: [String, Boolean],
      default: 'auto'
    },
    wrap: {
      type: Boolean,
      default: true
    },
    // Inputs
    input: {
      type: Boolean,
      default: true
    },
    type: {
      type: String,
      default: 'text'
    },
    name: String,
    value: {
      type: [String, Number, Array, Date, Object],
      default: undefined
    },
    inputmode: String,
    readonly: Boolean,
    required: Boolean,
    disabled: Boolean,
    placeholder: String,
    inputId: [String, Number],
    size: [String, Number],
    accept: [String, Number],
    autocomplete: [String],
    autocorrect: [String],
    autocapitalize: [String],
    spellcheck: [String],
    autofocus: Boolean,
    autosave: String,
    max: [String, Number],
    min: [String, Number],
    step: [String, Number],
    maxlength: [String, Number],
    minlength: [String, Number],
    multiple: Boolean,
    inputStyle: [String, Object],
    pattern: String,
    validate: [Boolean, String],
    validateOnBlur: Boolean,
    onValidate: Function,
    tabindex: [String, Number],
    resizable: Boolean,
    clearButton: Boolean,
    // Form
    noFormStoreData: Boolean,
    noStoreData: Boolean,
    ignoreStoreData: Boolean,
    // Error, Info
    errorMessage: String,
    errorMessageForce: Boolean,
    info: String,
    // Outline
    outline: Boolean,
    // Label
    label: [String, Number],
    inlineLabel: Boolean,
    floatingLabel: Boolean,
    // Datepicker
    calendarParams: Object,
    // Colorpicker
    colorPickerParams: Object,
    // Text editor
    textEditorParams: Object,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorProps
  },
  emits: ['textarea:resize', 'input:notempty', 'input:empty', 'input:clear', 'texteditor:change', 'calendar:change', 'colorpicker:change', 'change', 'focus', 'blur', 'input', 'update:value'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const inputInvalid = (0,vue__WEBPACK_IMPORTED_MODULE_4__.ref)(false);
    const inputFocused = (0,vue__WEBPACK_IMPORTED_MODULE_4__.ref)(false);
    const ListContext = (0,vue__WEBPACK_IMPORTED_MODULE_4__.inject)('ListContext', {
      value: {
        listIsMedia: false,
        listIsSortable: false,
        listIsSortableOpposite: false,
        listIsSimple: false
      }
    });
    let f7Calendar = null;
    let f7ColorPicker = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_4__.ref)(null);
    const inputElRef = (0,vue__WEBPACK_IMPORTED_MODULE_4__.ref)(null);
    const itemContentElRef = (0,vue__WEBPACK_IMPORTED_MODULE_4__.ref)(null);
    let updateInputOnDidUpdate = false;

    const getDomValue = () => {
      if (!inputElRef.value) return undefined;
      return inputElRef.value.value;
    };

    const domValue = (0,vue__WEBPACK_IMPORTED_MODULE_4__.ref)(getDomValue());
    const inputHasValue = (0,vue__WEBPACK_IMPORTED_MODULE_4__.computed)(() => {
      if (props.type === 'datepicker' && Array.isArray(props.value) && props.value.length === 0) {
        return false;
      }

      return typeof props.value === 'undefined' ? domValue.value || domValue.value === 0 : props.value || props.value === 0;
    });

    const validateInput = () => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7 || !inputElRef.value) return;
      const validity = inputElRef.value.validity;
      if (!validity) return;

      if (!validity.valid) {
        if (props.onValidate) props.onValidate(false);

        if (inputInvalid.value !== true) {
          inputInvalid.value = true;
        }
      } else {
        if (props.onValidate) props.onValidate(true);

        if (inputInvalid.value !== false) {
          inputInvalid.value = false;
        }
      }
    };

    const onTextareaResize = event => {
      emit('textarea:resize', event);
    };

    const onInputNotEmpty = event => {
      emit('input:notempty', event);
    };

    const onInputEmpty = event => {
      emit('input:empty', event);
    };

    const onInputClear = event => {
      emit('input:clear', event);
    };

    const onInput = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      emit('input', ...args);

      if (inputElRef.value) {
        domValue.value = inputElRef.value.value;
      }

      if (!(props.validateOnBlur || props.validateOnBlur === '') && (props.validate || props.validate === '') && inputElRef.value) {
        validateInput(inputElRef.value);
      }

      if (inputElRef.value && props.type !== 'texteditor' && props.type !== 'colorpicker' && props.type !== 'datepicker') {
        emit('update:value', inputElRef.value.value);
      }
    };

    const onFocus = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      emit('focus', ...args);
      inputFocused.value = true;
    };

    const onBlur = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      emit('blur', ...args);

      if ((props.validate || props.validate === '' || props.validateOnBlur || props.validateOnBlur === '') && inputElRef.value) {
        validateInput(inputElRef.value);
      }

      inputFocused.value = false;
    };

    const onChange = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      emit('change', ...args);

      if (props.type === 'texteditor') {
        emit('texteditor:change', args[0]);
        emit('update:value', args[0]);
      }
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_4__.onMounted)(() => {
      if (!elRef.value && !itemContentElRef.value) return;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7ready)(() => {
        if (!inputElRef.value) return;
        inputElRef.value.addEventListener('input:notempty', onInputNotEmpty, false);
        inputElRef.value.addEventListener('textarea:resize', onTextareaResize, false);
        inputElRef.value.addEventListener('input:empty', onInputEmpty, false);
        inputElRef.value.addEventListener('input:clear', onInputClear, false);

        if (props.type === 'datepicker') {
          f7Calendar = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.calendar.create({
            inputEl: inputElRef.value,
            value: props.value,
            on: {
              change(calendar, calendarValue) {
                emit('update:value', calendarValue);
                emit('calendar:change', calendarValue);
              }

            },
            ...(props.calendarParams || {})
          });
        }

        if (props.type === 'colorpicker') {
          f7ColorPicker = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.colorPicker.create({
            inputEl: inputElRef.value,
            value: props.value,
            on: {
              change(colorPicker, colorPickerValue) {
                emit('update:value', colorPickerValue);
                emit('colorpicker:change', colorPickerValue);
              }

            },
            ...(props.colorPickerParams || {})
          });
        }

        if (!(props.validateOnBlur || props.validateOnBlur === '') && (props.validate || props.validate === '') && typeof props.value !== 'undefined' && props.value !== null && props.value !== '') {
          setTimeout(() => {
            validateInput();
          }, 0);
        }

        if (props.type === 'textarea' && props.resizable) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.input.resizeTextarea(inputElRef.value);
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.onBeforeUnmount)(() => {
      if (inputElRef.value) {
        inputElRef.value.removeEventListener('input:notempty', onInputNotEmpty, false);
        inputElRef.value.removeEventListener('textarea:resize', onTextareaResize, false);
        inputElRef.value.removeEventListener('input:empty', onInputEmpty, false);
        inputElRef.value.removeEventListener('input:clear', onInputClear, false);
      }

      if (f7Calendar && f7Calendar.destroy) {
        f7Calendar.destroy();
        f7Calendar = null;
      }

      if (f7ColorPicker && f7ColorPicker.destroy) {
        f7ColorPicker.destroy();
        f7ColorPicker = null;
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.onUpdated)(() => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7) return;

      if (updateInputOnDidUpdate) {
        if (!inputElRef.value) return;
        updateInputOnDidUpdate = false;

        if (props.validate && !props.validateOnBlur) {
          validateInput();
        }

        if (props.type === 'textarea' && props.resizable) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.input.resizeTextarea(inputElRef.value);
        }
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.watch)(() => props.colorPickerParams, newValue => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7 || !f7ColorPicker) return;
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(f7ColorPicker.params, newValue || {});
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.watch)(() => props.calendarParams, newValue => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7 || !f7Calendar) return;
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(f7Calendar.params, newValue || {});
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.watch)(() => props.value, newValue => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7) return;
      updateInputOnDidUpdate = true;

      if (f7Calendar) {
        f7Calendar.setValue(newValue);
      }

      if (f7ColorPicker) {
        f7ColorPicker.setValue(newValue);
      }
    });
    const isSortableComputed = (0,vue__WEBPACK_IMPORTED_MODULE_4__.computed)(() => props.sortable === true || props.sortable === false ? props.sortable : ListContext.value.listIsSortable || false);

    const createInput = (InputTag, children) => {
      const needsValue = props.type !== 'file' && props.type !== 'datepicker' && props.type !== 'colorpicker';
      const needsType = InputTag === 'input';
      let inputType = props.type;

      if (inputType === 'datepicker' || inputType === 'colorpicker') {
        inputType = 'text';
      }

      const inputClassName = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)({
        resizable: inputType === 'textarea' && props.resizable,
        'no-store-data': props.noFormStoreData || props.noStoreData || props.ignoreStoreData,
        'input-invalid': props.errorMessage && props.errorMessageForce || inputInvalid.value,
        'input-with-value': inputHasValue.value,
        'input-focused': inputFocused.value
      });
      let inputValue;

      if (needsValue) {
        if (typeof props.value !== 'undefined') inputValue = props.value;else inputValue = domValue.value;
      }

      const valueProps = {};

      if (props.type !== 'datepicker' && props.type !== 'colorpicker') {
        if ('value' in props) valueProps.value = inputValue;
      }

      const inputProps = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.noUndefinedProps)({
        name: props.name,
        type: needsType ? inputType : undefined,
        placeholder: props.placeholder,
        inputmode: props.inputmode,
        id: props.inputId,
        size: props.size,
        accept: props.accept,
        autocomplete: props.autocomplete,
        autocorrect: props.autocorrect,
        autocapitalize: props.autocapitalize,
        spellcheck: props.spellcheck,
        autofocus: props.autofocus,
        autosave: props.autosave,
        disabled: props.disabled,
        max: props.max,
        maxlength: props.maxlength,
        min: props.min,
        minlength: props.minlength,
        step: props.step,
        multiple: props.multiple,
        readonly: props.readonly,
        required: props.required,
        pattern: props.pattern,
        validate: typeof props.validate === 'string' && props.validate.length ? props.validate : undefined,
        tabindex: props.tabindex
      });
      return (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)(InputTag, {
        ref: inputElRef,
        style: props.inputStyle,
        ...inputProps,
        'data-validate': props.validate === true || props.validate === '' || props.validateOnBlur === true || props.validateOnBlur === '' ? true : undefined,
        'data-validate-on-blur': props.validateOnBlur === true || props.validateOnBlur === '' ? true : undefined,
        'data-error-message': props.errorMessageForce ? undefined : props.errorMessage,
        class: inputClassName,
        onFocus,
        onBlur,
        onInput,
        onChange,
        ...valueProps
      }, [children]);
    };

    return () => {
      let inputEl;

      if (props.input) {
        if (props.type === 'select' || props.type === 'textarea' || props.type === 'file') {
          if (props.type === 'select') {
            inputEl = createInput('select', slots.default && slots.default());
          } else if (props.type === 'file') {
            inputEl = createInput('input');
          } else {
            inputEl = createInput('textarea');
          }
        } else if (props.type === 'texteditor') {
          inputEl = (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)(_text_editor_js__WEBPACK_IMPORTED_MODULE_3__["default"], {
            value: props.value,
            resizable: props.resizable,
            placeholder: props.placeholder,
            onTexteditorFocus: onFocus,
            onTexteditorBlur: onBlur,
            onTexteditorInput: onInput,
            onTexteditorChange: onChange,
            ...(props.textEditorParams || {})
          });
        } else {
          inputEl = createInput('input');
        }
      }

      const hasErrorMessage = !!props.errorMessage || slots['error-message'];
      const ItemContent = (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        ref: itemContentElRef,
        class: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('item-content item-input', !props.wrap && {
          disabled: props.disabled
        }, !props.wrap && (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props), {
          'inline-label': props.inlineLabel,
          'item-input-outline': props.outline,
          'item-input-focused': inputFocused.value,
          'item-input-with-info': !!props.info || slots.info,
          'item-input-with-value': inputHasValue.value,
          'item-input-with-error-message': hasErrorMessage && props.errorMessageForce || inputInvalid.value,
          'item-input-invalid': hasErrorMessage && props.errorMessageForce || inputInvalid.value
        })
      }, [slots['content-start'] && slots['content-start'](), (props.media || slots.media) && (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: 'item-media'
      }, [props.media && (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('img', {
        src: props.media
      }), slots.media && slots.media()]), (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: 'item-inner'
      }, [slots['inner-start'] && slots['inner-start'](), (props.label || slots.label) && (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('item-title item-label', {
          'item-floating-label': props.floatingLabel
        })
      }, [props.label, slots.label && slots.label()]), (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('item-input-wrap', {
          'input-dropdown': props.dropdown === 'auto' ? props.type === 'select' : props.dropdown
        })
      }, [inputEl, slots.input && slots.input(), hasErrorMessage && props.errorMessageForce && (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: 'item-input-error-message'
      }, [props.errorMessage, slots['error-message'] && slots['error-message']()]), props.clearButton && (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('span', {
        class: 'input-clear-button'
      }), (props.info || slots.info) && (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: 'item-input-info'
      }, [props.info, slots.info && slots.info()])]), slots.inner && slots.inner(), slots['inner-end'] && slots['inner-end']()]), slots.content && slots.content(), slots['content-end'] && slots['content-end']()]);
      if (!props.wrap) return ItemContent;
      return (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('li', {
        ref: elRef,
        class: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)({
          disabled: props.disabled
        }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props))
      }, [slots['root-start'] && slots['root-start'](), ItemContent, isSortableComputed.value && (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: 'sortable-handler'
      }), slots.root && slots.root(), slots['root-end'] && slots['root-end']()]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/list-item-cell.js":
/*!******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/list-item-cell.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-list-item-cell',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('item-cell', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/list-item-row.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/list-item-row.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-list-item-row',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('item-row', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/list-item.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/list-item.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/use-route-props.js */ "./node_modules/framework7-vue/shared/use-route-props.js");
/* harmony import */ var _shared_use_smart_select_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-smart-select.js */ "./node_modules/framework7-vue/shared/use-smart-select.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _badge_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./badge.js */ "./node_modules/framework7-vue/components/badge.js");









const ListItemContent = function (_temp) {
  let {
    props,
    slots,
    inputElRef,
    onChange,
    onClick,
    isMediaComputed,
    isSortableComputed,
    isSortableOppositeComputed,
    itemContentClasses
  } = _temp === void 0 ? {} : _temp;
  const {
    radio,
    checkbox,
    value,
    name,
    readonly,
    disabled,
    checked,
    required,
    media,
    header,
    footer,
    title,
    subtitle,
    text,
    after,
    badge,
    badgeColor,
    swipeout,
    sortable,
    accordionItem
  } = props;
  let titleEl;
  let afterWrapEl;
  let afterEl;
  let badgeEl;
  let innerEl;
  let titleRowEl;
  let subtitleEl;
  let textEl;
  let mediaEl;
  let inputEl;
  let inputIconEl;
  let headerEl;
  let footerEl; // Input

  if (radio || checkbox) {
    inputEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('input', {
      ref: inputElRef,
      value,
      name,
      checked,
      readonly,
      disabled,
      required,
      type: radio ? 'radio' : 'checkbox',
      onChange
    });
    inputIconEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('i', {
      class: `icon icon-${radio ? 'radio' : 'checkbox'}`
    });
  } // Media


  if (media || slots.media) {
    let mediaImgEl;

    if (media) {
      mediaImgEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('img', {
        src: media
      });
    }

    mediaEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-media'
    }, [mediaImgEl, slots.media && slots.media()]);
  } // Inner Elements


  if (header || slots.header) {
    headerEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-header'
    }, [header, slots.header && slots.header()]);
  }

  if (footer || slots.footer) {
    footerEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-footer'
    }, [footer, slots.footer && slots.footer()]);
  }

  if (title || slots.title || !isMediaComputed.value && headerEl || !isMediaComputed.value && footerEl) {
    titleEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-title'
    }, [!isMediaComputed.value && headerEl, title, slots.title && slots.title(), !isMediaComputed.value && footerEl]);
  }

  if (subtitle || slots.subtitle) {
    subtitleEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-subtitle'
    }, [subtitle, slots.subtitle && slots.subtitle()]);
  }

  if (text || slots.text) {
    textEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-text'
    }, [text, slots.text && slots.text()]);
  }

  if (after || badge || slots.after) {
    if (after) {
      afterEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('span', [after]);
    }

    if (badge) {
      badgeEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)(_badge_js__WEBPACK_IMPORTED_MODULE_6__["default"], {
        color: badgeColor
      }, () => badge);
    }

    afterWrapEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-after'
    }, [slots['after-start'] && slots['after-start'](), afterEl, badgeEl, slots.after && slots.after(), slots['after-end'] && slots['after-end']()]);
  }

  if (isMediaComputed.value) {
    titleRowEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-title-row'
    }, [slots['before-title'] && slots['before-title'](), titleEl, slots['after-title'] && slots['after-title'](), afterWrapEl]);
    innerEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-inner'
    }, [slots['inner-start'] && slots['inner-start'], headerEl, titleRowEl, subtitleEl, textEl, swipeout || accordionItem ? null : slots.default && slots.default(), slots.inner && slots.inner(), footerEl, slots['inner-end'] && slots['inner-end']]);
  } else {
    innerEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
      class: 'item-inner'
    }, [slots['inner-start'] && slots['inner-start'](), slots['before-title'] && slots['before-title'](), titleEl, slots['after-title'] && slots['after-title'](), afterWrapEl, swipeout || accordionItem ? null : slots.default && slots.default(), slots.inner && slots.inner(), slots['inner-end'] && slots['inner-end']()]);
  }

  const ItemContentTag = checkbox || radio ? 'label' : 'div';
  return (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)(ItemContentTag, {
    class: itemContentClasses.value,
    onClick
  }, [isSortableComputed.value && sortable !== false && isSortableOppositeComputed.value && (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
    class: 'sortable-handler'
  }), slots['content-start'] && slots['content-start'](), inputEl, inputIconEl, mediaEl, innerEl, slots.content && slots.content(), slots['content-end'] && slots['content-end']()]);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-list-item',
  props: {
    title: [String, Number],
    text: [String, Number],
    media: String,
    subtitle: [String, Number],
    header: [String, Number],
    footer: [String, Number],
    // Tooltip
    tooltip: String,
    tooltipTrigger: String,
    // Link Props
    link: [Boolean, String],
    target: String,
    tabLink: [Boolean, String],
    tabLinkActive: Boolean,
    selected: Boolean,
    after: [String, Number],
    badge: [String, Number],
    badgeColor: String,
    mediaItem: Boolean,
    mediaList: Boolean,
    divider: Boolean,
    groupTitle: Boolean,
    swipeout: Boolean,
    swipeoutOpened: Boolean,
    sortable: {
      type: Boolean,
      default: undefined
    },
    sortableOpposite: {
      type: Boolean,
      default: undefined
    },
    accordionItem: Boolean,
    accordionItemOpened: Boolean,
    // Smart Select
    smartSelect: Boolean,
    smartSelectParams: Object,
    // Links Chevron (Arrow) Icon
    noChevron: Boolean,
    chevronCenter: Boolean,
    // Inputs
    checkbox: Boolean,
    radio: Boolean,
    radioIcon: String,
    checked: Boolean,
    indeterminate: Boolean,
    name: String,
    value: {
      type: [String, Number, Array],
      default: undefined
    },
    readonly: Boolean,
    required: Boolean,
    disabled: Boolean,
    virtualListIndex: Number,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.actionsProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.routerProps
  },
  emits: ['click', 'swipeout', 'swipeout:overswipeenter', 'swipeout:overswipeexit', 'swipeout:deleted', 'swipeout:delete', 'swipeout:close', 'swipeout:closed', 'swipeout:open', 'swipeout:opened', 'accordion:beforeclose', 'accordion:close', 'accordion:closed', 'accordion:beforeopen', 'accordion:open', 'accordion:opened', 'change', 'update:checked'],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const ListContext = (0,vue__WEBPACK_IMPORTED_MODULE_7__.inject)('ListContext', {
      value: {
        listIsMedia: false,
        listIsSortable: false,
        listIsSortableOpposite: false,
        listIsSimple: false
      }
    });
    const listIsMedia = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => ListContext.value.listIsMedia || false);
    const listIsSortable = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => ListContext.value.listIsSortable || false);
    const listIsSortableOpposite = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => ListContext.value.listIsSortableOpposite || false);
    const listIsSimple = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => ListContext.value.listIsSimple || false);
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_7__.ref)(null);
    const linkElRef = (0,vue__WEBPACK_IMPORTED_MODULE_7__.ref)(null);
    const inputElRef = (0,vue__WEBPACK_IMPORTED_MODULE_7__.ref)(null);

    const onClick = event => {
      if (event.target.tagName.toLowerCase() !== 'input') {
        emit('click', event);
      }
    };

    const onSwipeoutOverswipeEnter = el => {
      if (elRef.value !== el) return;
      emit('swipeout:overswipeenter');
    };

    const onSwipeoutOverswipeExit = el => {
      if (elRef.value !== el) return;
      emit('swipeout:overswipeexit');
    };

    const onSwipeoutDeleted = el => {
      if (elRef.value !== el) return;
      emit('swipeout:deleted');
    };

    const onSwipeoutDelete = el => {
      if (elRef.value !== el) return;
      emit('swipeout:delete');
    };

    const onSwipeoutClose = el => {
      if (elRef.value !== el) return;
      emit('swipeout:close');
    };

    const onSwipeoutClosed = el => {
      if (elRef.value !== el) return;
      emit('swipeout:closed');
    };

    const onSwipeoutOpen = el => {
      if (elRef.value !== el) return;
      emit('swipeout:open');
    };

    const onSwipeoutOpened = el => {
      if (elRef.value !== el) return;
      emit('swipeout:opened');
    };

    const onSwipeout = (el, progress) => {
      if (elRef.value !== el) return;
      emit('swipeout', progress);
    };

    const onAccBeforeClose = (el, prevent) => {
      if (elRef.value !== el) return;
      emit('accordion:beforeclose', prevent);
    };

    const onAccClose = el => {
      if (elRef.value !== el) return;
      emit('accordion:close');
    };

    const onAccClosed = el => {
      if (elRef.value !== el) return;
      emit('accordion:closed');
    };

    const onAccBeforeOpen = (el, prevent) => {
      if (elRef.value !== el) return;
      emit('accordion:beforeopen', prevent);
    };

    const onAccOpen = el => {
      if (elRef.value !== el) return;
      emit('accordion:open');
    };

    const onAccOpened = el => {
      if (elRef.value !== el) return;
      emit('accordion:opened');
    };

    const onChange = event => {
      emit('change', event);
      emit('update:checked', event.target.checked);
    };

    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_4__.useTooltip)(elRef, props);
    (0,_shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_2__.useRouteProps)(linkElRef, props);
    (0,_shared_use_smart_select_js__WEBPACK_IMPORTED_MODULE_3__.useSmartSelect)(props, () => {}, () => elRef.value.querySelector('a.smart-select'));
    (0,vue__WEBPACK_IMPORTED_MODULE_7__.watch)(() => props.swipeoutOpened, newValue => {
      if (!props.swipeout || !elRef.value || !_shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7) return;

      if (newValue) {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.swipeout.open(elRef.value);
      } else {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.swipeout.close(elRef.value);
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_7__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7ready)(() => {
        if (props.swipeout) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('swipeoutOpen', onSwipeoutOpen);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('swipeoutOpened', onSwipeoutOpened);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('swipeoutClose', onSwipeoutClose);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('swipeoutClosed', onSwipeoutClosed);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('swipeoutDelete', onSwipeoutDelete);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('swipeoutDeleted', onSwipeoutDeleted);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('swipeout', onSwipeout);
        }

        if (props.accordionItem) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('accordionBeforeOpen', onAccBeforeOpen);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('accordionOpen', onAccOpen);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('accordionOpened', onAccOpened);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('accordionBeforeClose', onAccBeforeClose);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('accordionClose', onAccClose);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('accordionClosed', onAccClosed);
        }

        if (props.swipeout && props.swipeoutOpened) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.swipeout.open(elRef.value);
        }
      });

      if (props.checkbox && inputElRef.value) {
        inputElRef.value.indeterminate = !!props.indeterminate;
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_7__.onBeforeUnmount)(() => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('swipeoutOpen', onSwipeoutOpen);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('swipeoutOpened', onSwipeoutOpened);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('swipeoutClose', onSwipeoutClose);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('swipeoutClosed', onSwipeoutClosed);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('swipeoutDelete', onSwipeoutDelete);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('swipeoutDeleted', onSwipeoutDeleted);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('swipeout', onSwipeout);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('accordionBeforeOpen', onAccBeforeOpen);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('accordionOpen', onAccOpen);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('accordionOpened', onAccOpened);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('accordionBeforeClose', onAccBeforeClose);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('accordionClose', onAccClose);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('accordionClosed', onAccClosed);
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_7__.watch)(() => props.indeterminate, newValue => {
      if (inputElRef.value) {
        inputElRef.value.indeterminate = !!newValue;
      }
    });
    const isMediaComputed = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => props.mediaItem || props.mediaList || listIsMedia.value);
    const isSortableComputed = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => props.sortable === true || props.sortable === false ? props.sortable : listIsSortable.value);
    const isSortableOppositeComputed = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => isSortableComputed.value && (props.sortableOpposite || listIsSortableOpposite.value));
    const linkAttrs = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => ({
      href: props.link === true ? '' : props.link || props.href,
      target: props.target,
      'data-tab': (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(props.tabLink) && props.tabLink || undefined,
      ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.routerAttrs)(props),
      ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.actionsAttrs)(props)
    }));
    const linkClasses = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)({
      'item-link': true,
      'smart-select': props.smartSelect,
      'tab-link': props.tabLink || props.tabLink === '',
      'tab-link-active': props.tabLinkActive,
      'item-selected': props.selected
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.routerClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.actionsClasses)(props)));
    const itemContentClasses = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('item-content', {
      'item-checkbox': props.checkbox,
      'item-radio': props.radio,
      'item-radio-icon-start': props.radio && props.radioIcon === 'start',
      'item-radio-icon-end': props.radio && props.radioIcon === 'end'
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props)));
    const liClasses = (0,vue__WEBPACK_IMPORTED_MODULE_7__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)({
      'item-divider': props.divider,
      'list-group-title': props.groupTitle,
      'media-item': isMediaComputed.value,
      swipeout: props.swipeout,
      'accordion-item': props.accordionItem,
      'accordion-item-opened': props.accordionItemOpened,
      disabled: props.disabled && !(props.radio || props.checkbox),
      'no-chevron': props.noChevron,
      'chevron-center': props.chevronCenter,
      'disallow-sorting': props.sortable === false
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props)));
    return () => {
      let linkEl;
      let itemContentEl;

      if (!listIsSimple.value) {
        // Item Content
        itemContentEl = ListItemContent({
          props,
          slots,
          inputElRef,
          onChange,
          onClick: props.link || props.href || props.accordionItem || props.smartSelect ? undefined : onClick,
          isMediaComputed,
          isSortableComputed,
          isSortableOppositeComputed,
          itemContentClasses
        }); // Link

        if (props.link || props.href || props.accordionItem || props.smartSelect) {
          linkEl = (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('a', {
            ref: linkElRef,
            class: linkClasses.value,
            ...linkAttrs.value,
            onClick
          }, [itemContentEl]);
        }
      }

      if (props.divider || props.groupTitle) {
        return (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('li', {
          ref: elRef,
          class: liClasses.value,
          'data-virtual-list-index': props.virtualListIndex,
          onClick
        }, [props.title, slots.default && slots.default()]);
      }

      if (listIsSimple.value) {
        return (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('li', {
          ref: elRef,
          class: liClasses.value,
          onClick,
          'data-virtual-list-index': props.virtualListIndex
        }, [props.title, slots.default && slots.default()]);
      }

      const linkItemEl = props.link || props.href || props.smartSelect || props.accordionItem ? linkEl : itemContentEl;
      return (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('li', {
        ref: elRef,
        class: liClasses.value,
        'data-virtual-list-index': props.virtualListIndex
      }, [slots['root-start'] && slots['root-start'](), props.swipeout ? (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
        class: 'swipeout-content'
      }, [linkItemEl]) : linkItemEl, isSortableComputed.value && props.sortable !== false && !isSortableOppositeComputed.value && (0,vue__WEBPACK_IMPORTED_MODULE_7__.h)('div', {
        class: 'sortable-handler'
      }), (props.swipeout || props.accordionItem) && slots.default(), slots.root && slots.root(), slots['root-end'] && slots['root-end']()]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/list.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/components/list.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_use_tab_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-tab.js */ "./node_modules/framework7-vue/shared/use-tab.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-list',
  props: {
    inset: Boolean,
    xsmallInset: Boolean,
    smallInset: Boolean,
    mediumInset: Boolean,
    largeInset: Boolean,
    xlargeInset: Boolean,
    mediaList: Boolean,
    sortable: Boolean,
    sortableTapHold: Boolean,
    sortableEnabled: Boolean,
    sortableMoveElements: {
      type: Boolean,
      default: undefined
    },
    sortableOpposite: Boolean,
    accordionList: Boolean,
    accordionOpposite: Boolean,
    contactsList: Boolean,
    simpleList: Boolean,
    linksList: Boolean,
    menuList: Boolean,
    noHairlines: Boolean,
    noHairlinesBetween: Boolean,
    noHairlinesMd: Boolean,
    noHairlinesBetweenMd: Boolean,
    noHairlinesIos: Boolean,
    noHairlinesBetweenIos: Boolean,
    noHairlinesAurora: Boolean,
    noHairlinesBetweenAurora: Boolean,
    // Links Chevron (Arrow) Icon
    noChevron: Boolean,
    chevronCenter: Boolean,
    // Tab
    tab: Boolean,
    tabActive: Boolean,
    // Form
    form: Boolean,
    formStoreData: Boolean,
    inlineLabels: Boolean,
    // Virtual List
    virtualList: Boolean,
    virtualListParams: Object,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorProps
  },
  emits: ['submit', 'sortable:enable', 'sortable:disable', 'sortable:sort', 'sortable:move', 'virtual:itembeforeinsert', 'virtual:beforeclear', 'virtual:itemsbeforeinsert', 'virtual:itemsafterinsert', 'tab:hide', 'tab:show'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    let f7VirtualList = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_4__.ref)(null);

    const onSubmit = event => {
      emit('submit', event);
    };

    const onSortableEnable = el => {
      if (elRef.value !== el) return;
      emit('sortable:enable');
    };

    const onSortableDisable = el => {
      if (elRef.value !== el) return;
      emit('sortable:disable');
    };

    const onSortableSort = (el, sortData, listEl) => {
      if (elRef.value !== listEl) return;
      emit('sortable:sort', sortData);
    };

    const onSortableMove = (el, listEl) => {
      if (elRef.value !== listEl) return;
      emit('sortable:move', el, listEl);
    };

    (0,_shared_use_tab_js__WEBPACK_IMPORTED_MODULE_3__.useTab)(elRef, emit);
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7ready)(() => {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('sortableEnable', onSortableEnable);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('sortableDisable', onSortableDisable);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('sortableSort', onSortableSort);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('sortableMove', onSortableMove);
        if (!props.virtualList) return;
        const vlParams = props.virtualListParams || {};
        if (!vlParams.renderItem && !vlParams.renderExternal) return;
        if (vlParams.items) vlParams.items = (0,vue__WEBPACK_IMPORTED_MODULE_4__.toRaw)(vlParams.items);
        f7VirtualList = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.virtualList.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)({
          el: elRef.value,
          on: {
            itemBeforeInsert(itemEl, item) {
              const vl = this;
              emit('virtual:itembeforeinsert', vl, itemEl, item);
            },

            beforeClear(fragment) {
              const vl = this;
              emit('virtual:beforeclear', vl, fragment);
            },

            itemsBeforeInsert(fragment) {
              const vl = this;
              emit('virtual:itemsbeforeinsert', vl, fragment);
            },

            itemsAfterInsert(fragment) {
              const vl = this;
              emit('virtual:itemsafterinsert', vl, fragment);
            }

          }
        }, vlParams));
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.onBeforeUnmount)(() => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('sortableEnable', onSortableEnable);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('sortableDisable', onSortableDisable);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('sortableSort', onSortableSort);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('sortableMove', onSortableMove);
      if (!(props.virtualList && f7VirtualList)) return;
      if (f7VirtualList.destroy) f7VirtualList.destroy();
      f7VirtualList = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_4__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('list', {
      inset: props.inset,
      'xsmall-inset': props.xsmallInset,
      'small-inset': props.smallInset,
      'medium-inset': props.mediumInset,
      'large-inset': props.largeInset,
      'xlarge-inset': props.xlargeInset,
      'media-list': props.mediaList,
      'simple-list': props.simpleList,
      'links-list': props.linksList,
      'menu-list': props.menuList,
      sortable: props.sortable,
      'sortable-tap-hold': props.sortableTapHold,
      'sortable-enabled': props.sortableEnabled,
      'sortable-opposite': props.sortableOpposite,
      'accordion-list': props.accordionList,
      'accordion-opposite': props.accordionOpposite,
      'contacts-list': props.contactsList,
      'virtual-list': props.virtualList,
      tab: props.tab,
      'tab-active': props.tabActive,
      'no-hairlines': props.noHairlines,
      'no-hairlines-md': props.noHairlinesMd,
      'no-hairlines-ios': props.noHairlinesIos,
      'no-hairlines-aurora': props.noHairlinesAurora,
      'no-hairlines-between': props.noHairlinesBetween,
      'no-hairlines-between-md': props.noHairlinesBetweenMd,
      'no-hairlines-between-ios': props.noHairlinesBetweenIos,
      'no-hairlines-between-aurora': props.noHairlinesBetweenAurora,
      'form-store-data': props.formStoreData,
      'inline-labels': props.inlineLabels,
      'no-chevron': props.noChevron,
      'chevron-center': props.chevronCenter
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props)));
    const ListTag = (0,vue__WEBPACK_IMPORTED_MODULE_4__.computed)(() => props.form ? 'form' : 'div');
    const ListContext = (0,vue__WEBPACK_IMPORTED_MODULE_4__.computed)(() => ({
      listIsMedia: props.mediaList,
      listIsSimple: props.simpleList,
      listIsSortable: props.sortable,
      listIsSortableOpposite: props.sortableOpposite
    }));
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.provide)('ListContext', ListContext);
    return () => {
      const {
        list: slotsList,
        default: slotsDefault
      } = slots;
      const rootChildrenBeforeList = [];
      const rootChildrenAfterList = [];
      const ulChildren = slotsList || [];
      let wasUlChild = false;

      if (slotsDefault) {
        slotsDefault().forEach(vnode => {
          if (typeof vnode === 'undefined') return;
          const tag = vnode.type && vnode.type.name ? vnode.type.name : vnode.type;

          if (tag && typeof tag === 'symbol') {
            wasUlChild = true;
            ulChildren.push(vnode);
          } else if (!tag || tag && !(tag === 'li' || tag.indexOf('f7-list-item') >= 0 || tag.indexOf('f7-list-button') >= 0 || tag.indexOf('f7-list-input') >= 0)) {
            if (wasUlChild) rootChildrenAfterList.push(vnode);else rootChildrenBeforeList.push(vnode);
          } else if (tag) {
            wasUlChild = true;
            ulChildren.push(vnode);
          }
        });
      }

      return (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)(ListTag.value, {
        ref: elRef,
        class: classes.value,
        'data-sortable-move-elements': typeof props.sortableMoveElements !== 'undefined' ? props.sortableMoveElements.toString() : undefined,
        onSubmit
      }, [slots['before-list'] && slots['before-list'](), rootChildrenBeforeList, ulChildren.length > 0 && (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('ul', ulChildren), slots['after-list'] && slots['after-list'](), rootChildrenAfterList]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/login-screen-title.js":
/*!**********************************************************************!*\
  !*** ./node_modules/framework7-vue/components/login-screen-title.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-login-screen-title',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('login-screen-title', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/login-screen.js":
/*!****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/login-screen.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/modal-state-classes.js */ "./node_modules/framework7-vue/shared/modal-state-classes.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-login-screen',
  render,
  props: {
    opened: Boolean,
    animate: {
      type: Boolean,
      default: undefined
    },
    containerEl: {
      type: [String, Object],
      default: undefined
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['loginscreen:open', 'loginscreen:opened', 'loginscreen:close', 'loginscreen:closed', 'update:opened'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const f7LoginScreen = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null); // eslint-disable-next-line

    let isOpened = props.opened;
    let isClosing = false;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onOpen = instance => {
      isOpened = true;
      isClosing = false;
      emit('loginscreen:open', instance);
      emit('update:opened', true);
    };

    const onOpened = instance => {
      emit('loginscreen:opened', instance);
    };

    const onClose = instance => {
      isOpened = false;
      isClosing = true;
      emit('loginscreen:close', instance);
    };

    const onClosed = instance => {
      isClosing = false;
      emit('loginscreen:closed', instance);
      emit('update:opened', false);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.opened, value => {
      if (!f7LoginScreen.value) return;

      if (value) {
        f7LoginScreen.value.open();
      } else {
        f7LoginScreen.value.close();
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!elRef.value) return;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        const loginScreenParams = {
          el: elRef.value,
          on: {
            open: onOpen,
            opened: onOpened,
            close: onClose,
            closed: onClosed
          }
        };

        if (typeof props.animate !== 'undefined') {
          loginScreenParams.animate = props.animate;
        }

        if (typeof props.containerEl !== 'undefined') {
          loginScreenParams.containerEl = props.containerEl;
        }

        f7LoginScreen.value = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.loginScreen.create(loginScreenParams);

        if (props.opened) {
          f7LoginScreen.value.open(false);
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7LoginScreen.value) {
        f7LoginScreen.value.destroy();
      }

      f7LoginScreen.value = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('login-screen', (0,_shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_4__.modalStateClasses)({
      isOpened,
      isClosing
    }), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/menu-dropdown-item.js":
/*!**********************************************************************!*\
  !*** ./node_modules/framework7-vue/components/menu-dropdown-item.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-route-props.js */ "./node_modules/framework7-vue/shared/use-route-props.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
    ref: "elRef",
    class: _ctx.classes
  }, _ctx.attrs, {
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onClick && _ctx.onClick(...arguments);
    })
  }), [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.text) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 16);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-menu-dropdown-item',
  render,
  props: {
    text: String,
    link: Boolean,
    href: String,
    target: String,
    divider: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsProps
  },
  emits: ['click'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onClick = e => {
      emit('click', e);
    };

    (0,_shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_3__.useRouteProps)(elRef, props);
    const isLink = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.link || props.href || props.href === '');
    const tag = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => isLink.value ? 'a' : 'div');
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
        'menu-dropdown-link': isLink.value && !props.divider,
        'menu-dropdown-item': !isLink.value && !props.divider,
        'menu-dropdown-divider': props.divider
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsClasses)(props), {
        'menu-close': typeof props.menuClose === 'undefined'
      });
    });
    const attrs = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let hrefComputed = props.href;
      if (typeof hrefComputed === 'undefined' && props.link) hrefComputed = '#';
      return {
        href: hrefComputed,
        target: props.target,
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerAttrs)(props),
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsAttrs)(props)
      };
    });
    return {
      classes,
      attrs,
      tag,
      onClick,
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/menu-dropdown.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/menu-dropdown.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    class: "menu-dropdown-content",
    style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)({
      height: _ctx.contentHeight
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 4)], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-menu-dropdown',
  render,
  props: {
    contentHeight: String,
    position: String,
    left: Boolean,
    center: Boolean,
    right: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let positionComputed = props.position || 'left';
      if (props.left) positionComputed = 'left';
      if (props.center) positionComputed = 'center';
      if (props.right) positionComputed = 'right';
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('menu-dropdown', `menu-dropdown-${positionComputed}`, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props));
    });
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/menu-item.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/menu-item.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-route-props.js */ "./node_modules/framework7-vue/shared/use-route-props.js");
/* harmony import */ var _shared_use_icon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-icon.js */ "./node_modules/framework7-vue/shared/use-icon.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");
/* harmony import */ var _use_icon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./use-icon.js */ "./node_modules/framework7-vue/components/use-icon.js");

const _hoisted_1 = {
  key: 0,
  class: "menu-item-content"
};

function render(_ctx, _cache) {
  const _component_f7_use_icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-use-icon");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.tag), (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
    ref: "elRef",
    class: _ctx.classes
  }, _ctx.attrs, {
    onClick: _ctx.onClick
  }), {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [_ctx.text || _ctx.$slots.text || _ctx.icon ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.text) + " ", 1), _ctx.icon ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_use_icon, {
      key: 0,
      icon: _ctx.icon
    }, null, 8, ["icon"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "text")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")]),
    _: 3
  }, 16, ["class", "onClick"]);
}









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-menu-item',
  render,
  components: {
    f7UseIcon: _use_icon_js__WEBPACK_IMPORTED_MODULE_7__["default"]
  },
  props: {
    text: String,
    iconOnly: Boolean,
    href: String,
    link: Boolean,
    target: String,
    dropdown: Boolean,
    tooltip: String,
    tooltipTrigger: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.iconProps
  },
  emits: ['click', 'menu:opened', 'menu:closed'],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_6__.useTooltip)(elRef, props);

    const onClick = e => {
      emit('click', e);
    };

    const onOpened = el => {
      if (elRef.value !== el) return;
      emit('menu:opened', el);
    };

    const onClosed = el => {
      if (elRef.value !== el) return;
      emit('menu:closed', el);
    };

    (0,_shared_use_route_props_js__WEBPACK_IMPORTED_MODULE_3__.useRouteProps)(elRef, props);

    const attachEvents = () => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7ready)(() => {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('menuOpened', onOpened);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('menuClosed', onClosed);
      });
    };

    const detachEvents = () => {
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('menuOpened', onOpened);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('menuClosed', onOpened);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => attachEvents());
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => detachEvents());
    const icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_use_icon_js__WEBPACK_IMPORTED_MODULE_4__.useIcon)(props));
    const tag = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const isLink = props.link || props.href || props.href === '';
      return isLink ? 'a' : 'div';
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let iconOnlyComputed;

      if (props.iconOnly || !props.text && !slots.text) {
        iconOnlyComputed = true;
      } else {
        iconOnlyComputed = false;
      }

      const isDropdown = props.dropdown || props.dropdown === '';
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
        'menu-item': true,
        'menu-item-dropdown': isDropdown,
        'icon-only': iconOnlyComputed
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsClasses)(props));
    });
    const attrs = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let hrefComputed = props.href;
      if (typeof hrefComputed === 'undefined' && props.link) hrefComputed = '#';
      return {
        href: hrefComputed,
        target: props.target,
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerAttrs)(props),
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsAttrs)(props)
      };
    });
    return {
      tag,
      classes,
      attrs,
      icon,
      onClick,
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/menu.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/components/menu.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = {
  class: "menu-inner"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-menu',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('menu', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/message.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7-vue/components/message.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = {
  class: "message-content"
};
const _hoisted_2 = {
  key: 0,
  class: "message-image"
};
const _hoisted_3 = ["src"];
const _hoisted_4 = {
  key: 1,
  class: "message-text-header"
};
const _hoisted_5 = {
  key: 0,
  class: "message-typing-indicator"
};

const _hoisted_6 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", null, null, -1);

const _hoisted_7 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", null, null, -1);

const _hoisted_8 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", null, null, -1);

const _hoisted_9 = [_hoisted_6, _hoisted_7, _hoisted_8];
const _hoisted_10 = {
  key: 3,
  class: "message-text-footer"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    onClick: _cache[6] || (_cache[6] = function () {
      return _ctx.onClick && _ctx.onClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "start"), _ctx.hasAvatar ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    key: 0,
    class: "message-avatar",
    style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)({
      backgroundImage: _ctx.avatar && `url(${_ctx.avatar})`
    }),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onAvatarClick && _ctx.onAvatarClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "avatar")], 4)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "content-start"), _ctx.hasName ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    key: 0,
    class: "message-name",
    onClick: _cache[1] || (_cache[1] = function () {
      return _ctx.onNameClick && _ctx.onNameClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.name) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "name")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasHeader ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    key: 1,
    class: "message-header",
    onClick: _cache[2] || (_cache[2] = function () {
      return _ctx.onHeaderClick && _ctx.onHeaderClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.header) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "header")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    class: "message-bubble",
    onClick: _cache[4] || (_cache[4] = function () {
      return _ctx.onBubbleClick && _ctx.onBubbleClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "bubble-start"), _ctx.hasImage ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "image", {}, () => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("img", {
    src: _ctx.image
  }, null, 8, _hoisted_3)])])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasTextHeader ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.textHeader) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "text-header")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasText ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    key: 2,
    class: "message-text",
    onClick: _cache[3] || (_cache[3] = function () {
      return _ctx.onTextClick && _ctx.onTextClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.text) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "text"), _ctx.typing ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_5, _hoisted_9)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasTextFooter ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_10, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.textFooter) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "text-footer")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "bubble-end"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")]), _ctx.hasFooter ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    key: 2,
    class: "message-footer",
    onClick: _cache[5] || (_cache[5] = function () {
      return _ctx.onFooterClick && _ctx.onFooterClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.footer) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "footer")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "content-end")]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "end")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-message',
  render,
  props: {
    text: String,
    name: String,
    avatar: String,
    type: {
      type: String,
      default: 'sent'
    },
    image: String,
    header: String,
    footer: String,
    textHeader: String,
    textFooter: String,
    first: Boolean,
    last: Boolean,
    tail: Boolean,
    sameName: Boolean,
    sameHeader: Boolean,
    sameFooter: Boolean,
    sameAvatar: Boolean,
    typing: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['click', 'click:name', 'click:text', 'click:avatar', 'click:header', 'click:footer', 'click:bubble'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;

    const onClick = event => {
      emit('click', event);
    };

    const onNameClick = event => {
      emit('click:name', event);
    };

    const onTextClick = event => {
      emit('click:text', event);
    };

    const onAvatarClick = event => {
      emit('click:avatar', event);
    };

    const onHeaderClick = event => {
      emit('click:header', event);
    };

    const onFooterClick = event => {
      emit('click:footer', event);
    };

    const onBubbleClick = event => {
      emit('click:bubble', event);
    };

    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('message', {
      'message-sent': props.type === 'sent',
      'message-received': props.type === 'received',
      'message-typing': props.typing,
      'message-first': props.first,
      'message-last': props.last,
      'message-tail': props.tail,
      'message-same-name': props.sameName,
      'message-same-header': props.sameHeader,
      'message-same-footer': props.sameFooter,
      'message-same-avatar': props.sameAvatar
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    const hasAvatar = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => slots.avatar || props.avatar);
    const hasName = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => slots.name || props.name);
    const hasHeader = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => slots.header || props.header);
    const hasImage = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => slots.image || props.image);
    const hasTextHeader = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => slots['text-header'] || props.textHeader);
    const hasText = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => slots.text || props.text || props.typing);
    const hasTextFooter = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => slots['text-footer'] || props.textFooter);
    const hasFooter = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => slots.footer || props.footer);
    return {
      classes,
      onClick,
      onNameClick,
      onTextClick,
      onAvatarClick,
      onHeaderClick,
      onFooterClick,
      onBubbleClick,
      hasAvatar,
      hasName,
      hasHeader,
      hasImage,
      hasTextHeader,
      hasText,
      hasTextFooter,
      hasFooter
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/messagebar-attachment.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7-vue/components/messagebar-attachment.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = ["src"];

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    onClick: _cache[1] || (_cache[1] = function () {
      return _ctx.onClick && _ctx.onClick(...arguments);
    })
  }, [_ctx.image ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("img", {
    key: 0,
    src: _ctx.image
  }, null, 8, _hoisted_1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.deletable ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", {
    key: 1,
    class: "messagebar-attachment-delete",
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onDeleteClick && _ctx.onDeleteClick(...arguments);
    })
  })) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-messagebar-attachment',
  render,
  props: {
    image: String,
    deletable: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['attachment:click', 'attachment:delete'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;

    const onClick = event => {
      emit('attachment:click', event);
    };

    const onDeleteClick = event => {
      emit('attachment:delete', event);
    };

    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('messagebar-attachment', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      onClick,
      onDeleteClick
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/messagebar-attachments.js":
/*!**************************************************************************!*\
  !*** ./node_modules/framework7-vue/components/messagebar-attachments.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-messagebar-attachments',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('messagebar-attachments', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/messagebar-sheet-image.js":
/*!**************************************************************************!*\
  !*** ./node_modules/framework7-vue/components/messagebar-sheet-image.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = ["checked"];

const _hoisted_2 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("i", {
  class: "icon icon-checkbox"
}, null, -1);

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("label", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)(_ctx.styles)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("input", {
    type: "checkbox",
    checked: _ctx.checked,
    onChange: _cache[0] || (_cache[0] = function () {
      return _ctx.onChange && _ctx.onChange(...arguments);
    })
  }, null, 40, _hoisted_1), _hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 6);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-messagebar-sheet-image',
  render,
  props: {
    image: String,
    checked: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['checked', 'unchecked', 'change', 'update:checked'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;

    const onChange = event => {
      if (event.target.checked) emit('checked', event);else emit('unchecked', event);
      emit('update:checked', event.target.checked);
      emit('change', event);
    };

    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('messagebar-sheet-image', 'checkbox', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    const styles = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ({
      backgroundImage: props.image && `url(${props.image})`
    }));
    return {
      classes,
      styles,
      onChange
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/messagebar-sheet-item.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7-vue/components/messagebar-sheet-item.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-messagebar-sheet-item',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('messagebar-sheet-item', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/messagebar-sheet.js":
/*!********************************************************************!*\
  !*** ./node_modules/framework7-vue/components/messagebar-sheet.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-messagebar-sheet',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('messagebar-sheet', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/messagebar.js":
/*!**************************************************************!*\
  !*** ./node_modules/framework7-vue/components/messagebar.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./link.js */ "./node_modules/framework7-vue/components/link.js");
/* harmony import */ var _input_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./input.js */ "./node_modules/framework7-vue/components/input.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-messagebar',
  props: {
    sheetVisible: Boolean,
    attachmentsVisible: Boolean,
    top: Boolean,
    resizable: {
      type: Boolean,
      default: true
    },
    bottomOffset: {
      type: Number,
      default: 0
    },
    topOffset: {
      type: Number,
      default: 0
    },
    maxHeight: Number,
    resizePage: {
      type: Boolean,
      default: true
    },
    sendLink: String,
    value: [String, Number, Array],
    disabled: Boolean,
    readonly: Boolean,
    textareaId: [Number, String],
    name: String,
    placeholder: {
      type: String,
      default: 'Message'
    },
    init: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorProps
  },
  emits: ['change', 'input', 'focus', 'blur', 'submit', 'send', 'click', 'messagebar:attachmentdelete', 'messagebar:attachmentclick', 'messagebar:resizepage', 'update:value'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_5__.ref)(null);
    const areaElRef = (0,vue__WEBPACK_IMPORTED_MODULE_5__.ref)(null);
    let f7Messagebar = null;
    let updateSheetVisible = false;
    let updateAttachmentsVisible = false;

    const onChange = event => {
      emit('change', event);
    };

    const onInput = event => {
      emit('input', event);
      emit('update:value', event.target.value);
    };

    const onFocus = event => {
      emit('focus', event);
    };

    const onBlur = event => {
      emit('blur', event);
    };

    const onClick = event => {
      const inputValue = areaElRef.value.$el;
      const clear = f7Messagebar ? () => {
        f7Messagebar.clear();
      } : () => {};
      emit('submit', inputValue, clear);
      emit('send', inputValue, clear);
      emit('click', event);
    };

    const onAttachmentDelete = (instance, attachmentEl, attachmentElIndex) => {
      emit('messagebar:attachmentdelete', instance, attachmentEl, attachmentElIndex);
    };

    const onAttachmentClick = (instance, attachmentEl, attachmentElIndex) => {
      emit('messagebar:attachmentclick', instance, attachmentEl, attachmentElIndex);
    };

    const onResizePage = instance => {
      emit('messagebar:resizepage', instance);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_5__.watch)(() => props.sheetVisible, () => {
      if (!props.resizable || !f7Messagebar) return;
      updateSheetVisible = true;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_5__.watch)(() => props.attachmentsVisible, () => {
      if (!props.resizable || !f7Messagebar) return;
      updateAttachmentsVisible = true;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_5__.onMounted)(() => {
      if (!props.init) return;
      if (!elRef.value) return;
      const params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.noUndefinedProps)({
        el: elRef.value,
        top: props.top,
        resizePage: props.resizePage,
        bottomOffset: props.bottomOffset,
        topOffset: props.topOffset,
        maxHeight: props.maxHeight,
        on: {
          attachmentDelete: onAttachmentDelete,
          attachmentClick: onAttachmentClick,
          resizePage: onResizePage
        }
      });
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7ready)(() => {
        f7Messagebar = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.messagebar.create(params);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_5__.onUpdated)(() => {
      if (!f7Messagebar) return;

      if (updateSheetVisible) {
        updateSheetVisible = false;
        f7Messagebar.sheetVisible = props.sheetVisible;
        f7Messagebar.resizePage();
      }

      if (updateAttachmentsVisible) {
        updateAttachmentsVisible = false;
        f7Messagebar.attachmentsVisible = props.attachmentsVisible;
        f7Messagebar.resizePage();
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_5__.onBeforeUnmount)(() => {
      if (f7Messagebar && f7Messagebar.destroy) f7Messagebar.destroy();
      f7Messagebar = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_5__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('toolbar', 'messagebar', {
      'messagebar-attachments-visible': props.attachmentsVisible,
      'messagebar-sheet-visible': props.sheetVisible
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props)));
    return () => {
      const valueProps = {};
      if ('value' in props) valueProps.value = props.value;
      const {
        default: slotsDefault,
        'before-inner': slotsBeforeInner,
        'after-inner': slotsAfterInner,
        'send-link': slotsSendLink,
        'inner-start': slotsInnerStart,
        'inner-end': slotsInnerEnd,
        'before-area': slotsBeforeArea,
        'after-area': slotsAfterArea
      } = slots;
      const innerEndEls = [];
      let messagebarAttachmentsEl;
      let messagebarSheetEl;

      if (slotsDefault) {
        slotsDefault().forEach(vnode => {
          if (typeof vnode === 'undefined') return;
          const tag = vnode.type && vnode.type.name ? vnode.type.name : vnode.type;

          if (tag && (tag.indexOf('messagebar-attachments') >= 0 || tag === 'F7MessagebarAttachments' || tag === 'f7-messagebar-attachments')) {
            messagebarAttachmentsEl = vnode;
          } else if (tag && (tag.indexOf('messagebar-sheet') >= 0 || tag === 'F7MessagebarSheet' || tag === 'f7-messagebar-sheet')) {
            messagebarSheetEl = vnode;
          } else {
            innerEndEls.push(vnode);
          }
        });
      }

      return (0,vue__WEBPACK_IMPORTED_MODULE_5__.h)('div', {
        class: classes.value,
        ref: elRef
      }, [slotsBeforeInner && slotsBeforeInner(), (0,vue__WEBPACK_IMPORTED_MODULE_5__.h)('div', {
        class: 'toolbar-inner'
      }, [slotsInnerStart && slotsInnerStart(), (0,vue__WEBPACK_IMPORTED_MODULE_5__.h)('div', {
        class: 'messagebar-area'
      }, [slotsBeforeArea && slotsBeforeArea(), messagebarAttachmentsEl, (0,vue__WEBPACK_IMPORTED_MODULE_5__.h)(_input_js__WEBPACK_IMPORTED_MODULE_4__["default"], {
        id: props.textareaId,
        ref: areaElRef,
        type: 'textarea',
        wrap: false,
        placeholder: props.placeholder,
        disabled: props.disabled,
        name: props.name,
        readonly: props.readonly,
        resizable: props.resizable,
        onInput,
        onChange,
        onFocus,
        onBlur,
        ...valueProps
      }), slotsAfterArea && slotsAfterArea()]), (props.sendLink && props.sendLink.length > 0 || slotsSendLink) && (0,vue__WEBPACK_IMPORTED_MODULE_5__.h)(_link_js__WEBPACK_IMPORTED_MODULE_3__["default"], {
        onClick
      }, [slotsSendLink ? slotsSendLink() : props.sendLink]), slotsInnerEnd && slotsInnerEnd(), innerEndEls]), slotsAfterInner && slotsAfterInner(), messagebarSheetEl]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/messages-title.js":
/*!******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/messages-title.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-messages-title',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('messages-title', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/messages.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7-vue/components/messages.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-messages',
  render,
  props: {
    autoLayout: {
      type: Boolean,
      default: false
    },
    messages: {
      type: Array,

      default() {
        return [];
      }

    },
    newMessagesFirst: {
      type: Boolean,
      default: false
    },
    scrollMessages: {
      type: Boolean,
      default: true
    },
    scrollMessagesOnEdge: {
      type: Boolean,
      default: true
    },
    typing: {
      type: Boolean,
      default: false
    },
    firstMessageRule: Function,
    lastMessageRule: Function,
    tailMessageRule: Function,
    sameNameMessageRule: Function,
    sameHeaderMessageRule: Function,
    sameFooterMessageRule: Function,
    sameAvatarMessageRule: Function,
    customClassMessageRule: Function,
    renderMessage: Function,
    init: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    let f7Messages = null;
    let childrenBeforeUpdated = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!props.init) return;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        f7Messages = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.messages.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.noUndefinedProps)({
          el: elRef.value,
          autoLayout: props.autoLayout,
          messages: props.messages,
          newMessagesFirst: props.newMessagesFirst,
          scrollMessages: props.scrollMessages,
          scrollMessagesOnEdge: props.scrollMessagesOnEdge,
          firstMessageRule: props.firstMessageRule,
          lastMessageRule: props.lastMessageRule,
          tailMessageRule: props.tailMessageRule,
          sameNameMessageRule: props.sameNameMessageRule,
          sameHeaderMessageRule: props.sameHeaderMessageRule,
          sameFooterMessageRule: props.sameFooterMessageRule,
          sameAvatarMessageRule: props.sameAvatarMessageRule,
          customClassMessageRule: props.customClassMessageRule,
          renderMessage: props.renderMessage
        }));

        if (f7Messages && props.typing) {
          f7Messages.showTyping();
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate)(() => {
      if (!props.init || !elRef.value) return;
      const children = elRef.value.children;
      if (!children) return;
      childrenBeforeUpdated = children.length;

      for (let i = 0; i < children.length; i += 1) {
        children[i].classList.add('message-appeared');
      }

      const childrenAfterUpdate = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.getChildren)(slots);

      if (f7Messages && props.scrollMessages && childrenBeforeUpdated !== childrenAfterUpdate) {
        f7Messages.setScrollData();
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
      if (!props.init) return;
      if (!elRef.value) return;
      const children = elRef.value.children;
      if (!children) return;
      const childerAftterUpdated = children.length;

      for (let i = 0; i < children.length; i += 1) {
        if (!children[i].classList.contains('message-appeared')) {
          children[i].classList.add('message-appear-from-bottom');
        }
      }

      if (f7Messages && f7Messages.layout && props.autoLayout) {
        f7Messages.layout();
      }

      if (childerAftterUpdated !== childrenBeforeUpdated && f7Messages && f7Messages.scroll && f7Messages.scrollData && props.scrollMessages) {
        f7Messages.scrollWithEdgeCheck(true);
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Messages && f7Messages.destroy) f7Messages.destroy();
      f7Messages = null;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.typing, newValue => {
      if (!f7Messages) return;
      if (newValue) f7Messages.showTyping();else f7Messages.hideTyping();
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('messages', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/nav-left.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7-vue/components/nav-left.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_theme_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-theme.js */ "./node_modules/framework7-vue/shared/use-theme.js");
/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./link.js */ "./node_modules/framework7-vue/components/link.js");


function render(_ctx, _cache) {
  const _component_f7_link = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-link");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [_ctx.backLink ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_link, {
    key: 0,
    href: _ctx.backLinkUrl || '#',
    back: "",
    icon: "icon-back",
    force: _ctx.backLinkForce || undefined,
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(!_ctx.text ? 'icon-only' : undefined),
    text: _ctx.text,
    onClick: _ctx.onBackClick
  }, null, 8, ["href", "force", "class", "text", "onClick"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-nav-left',
  render,
  components: {
    f7Link: _link_js__WEBPACK_IMPORTED_MODULE_4__["default"]
  },
  props: {
    backLink: [Boolean, String],
    backLinkUrl: String,
    backLinkForce: Boolean,
    backLinkShowText: {
      type: Boolean,
      default: undefined
    },
    sliding: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['back:click', 'click:back'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;

    const onBackClick = event => {
      emit('back:click', event);
      emit('click:back', event);
    };

    const theme = (0,_shared_use_theme_js__WEBPACK_IMPORTED_MODULE_3__.useTheme)();
    const text = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let needBackLinkText = props.backLinkShowText;
      if (typeof needBackLinkText === 'undefined') needBackLinkText = !theme.value.md;

      if (props.backLink) {
        return props.backLink !== true && needBackLinkText ? props.backLink : undefined;
      }

      return undefined;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('left', {
      sliding: props.sliding
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      onBackClick,
      text
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/nav-right.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/nav-right.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-nav-right',
  render,
  props: {
    sliding: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('right', {
      sliding: props.sliding
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/nav-title-large.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/nav-title-large.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = {
  class: "title-large-text"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-nav-title-large',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('title-large', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/nav-title.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/nav-title.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = {
  key: 0,
  class: "subtitle"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(" " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.title) + " ", 1), _ctx.subtitle ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_1, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.subtitle), 1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-nav-title',
  render,
  props: {
    title: String,
    subtitle: String,
    sliding: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('title', {
      sliding: props.sliding
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/navbar.js":
/*!**********************************************************!*\
  !*** ./node_modules/framework7-vue/components/navbar.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_use_theme_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-theme.js */ "./node_modules/framework7-vue/shared/use-theme.js");
/* harmony import */ var _nav_left_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nav-left.js */ "./node_modules/framework7-vue/components/nav-left.js");
/* harmony import */ var _nav_title_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nav-title.js */ "./node_modules/framework7-vue/components/nav-title.js");
/* harmony import */ var _nav_right_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./nav-right.js */ "./node_modules/framework7-vue/components/nav-right.js");


const _hoisted_1 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
  class: "navbar-bg"
}, null, -1);

const _hoisted_2 = {
  key: 3,
  className: "title-large"
};
const _hoisted_3 = {
  className: "title-large-text"
};

function render(_ctx, _cache) {
  const _component_f7_nav_left = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-nav-left");

  const _component_f7_nav_title = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-nav-title");

  const _component_f7_nav_right = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-nav-right");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [_hoisted_1, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "before-inner"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.innerClasses)
  }, [_ctx.hasLeft ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_nav_left, {
    key: 0,
    "back-link": _ctx.backLink,
    "back-link-url": _ctx.backLinkUrl,
    "back-link-force": _ctx.backLinkForce,
    "back-link-show-text": _ctx.backLinkShowText,
    "onBack:click": _ctx.onBackClick
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "nav-left"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "left")]),
    _: 3
  }, 8, ["back-link", "back-link-url", "back-link-force", "back-link-show-text", "onBack:click"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasTitle ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_nav_title, {
    key: 1,
    title: _ctx.title,
    subtitle: _ctx.subtitle
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "title")]),
    _: 3
  }, 8, ["title", "subtitle"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasRight ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_nav_right, {
    key: 2
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "nav-right"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "right")]),
    _: 3
  })) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.hasLargeTitle ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_3, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.largeTitle) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "title-large")])])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "after-inner")], 2);
}









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-navbar',
  render,
  components: {
    f7NavLeft: _nav_left_js__WEBPACK_IMPORTED_MODULE_5__["default"],
    f7NavTitle: _nav_title_js__WEBPACK_IMPORTED_MODULE_6__["default"],
    f7NavRight: _nav_right_js__WEBPACK_IMPORTED_MODULE_7__["default"]
  },
  props: {
    backLink: [Boolean, String],
    backLinkUrl: String,
    backLinkForce: Boolean,
    backLinkShowText: {
      type: Boolean,
      default: undefined
    },
    sliding: {
      type: Boolean,
      default: true
    },
    title: String,
    subtitle: String,
    hidden: Boolean,
    noShadow: Boolean,
    noHairline: Boolean,
    innerClass: String,
    innerClassName: String,
    large: Boolean,
    largeTransparent: Boolean,
    transparent: Boolean,
    titleLarge: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['navbar:hide', 'navbar:show', 'navbar:expand', 'navbar:collapse', 'navbar:transparentshow', 'navbar:transparenthide', 'click:back', 'back:click'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    let routerPositionClass = '';
    let largeCollapsed = false;
    let routerNavbarRole = null;
    let routerNavbarRoleDetailRoot = false;
    let routerNavbarMasterStack = false;
    let transparentVisible = false;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const theme = (0,_shared_use_theme_js__WEBPACK_IMPORTED_MODULE_4__.useTheme)();

    const onHide = navbarEl => {
      if (elRef.value !== navbarEl) return;
      emit('navbar:hide');
    };

    const onShow = navbarEl => {
      if (elRef.value !== navbarEl) return;
      emit('navbar:show');
    };

    const onExpand = navbarEl => {
      if (elRef.value !== navbarEl) return;
      largeCollapsed = false;
      emit('navbar:expand');
    };

    const onCollapse = navbarEl => {
      if (elRef.value !== navbarEl) return;
      largeCollapsed = true;
      emit('navbar:collapse');
    };

    const onNavbarTransparentShow = navbarEl => {
      if (elRef.value !== navbarEl) return;
      transparentVisible = true;
      emit('navbar:transparentshow');
    };

    const onNavbarTransparentHide = navbarEl => {
      if (elRef.value !== navbarEl) return;
      transparentVisible = false;
      emit('navbar:transparenthide');
    };

    const onNavbarPosition = (navbarEl, position) => {
      if (elRef.value !== navbarEl) return;
      routerPositionClass = position ? `navbar-${position}` : '';
    };

    const onNavbarRole = (navbarEl, rolesData) => {
      if (elRef.value !== navbarEl) return;
      routerNavbarRole = rolesData.role;
      routerNavbarRoleDetailRoot = rolesData.detailRoot;
    };

    const onNavbarMasterStack = navbarEl => {
      if (elRef.value !== navbarEl) return;
      routerNavbarMasterStack = true;
    };

    const onNavbarMasterUnstack = navbarEl => {
      if (elRef.value !== navbarEl) return;
      routerNavbarMasterStack = false;
    };

    const hide = animate => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.navbar.hide(elRef.value, animate);
    };

    const show = animate => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.navbar.show(elRef.value, animate);
    };

    const size = () => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.navbar.size(elRef.value);
    };

    const onBackClick = event => {
      emit('back:click', event);
      emit('click:back', event);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!elRef.value) return;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.navbar.size(elRef.value);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarShow', onShow);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarHide', onHide);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarCollapse', onCollapse);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarExpand', onExpand);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarPosition', onNavbarPosition);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarRole', onNavbarRole);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarMasterStack', onNavbarMasterStack);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarMasterUnstack', onNavbarMasterUnstack);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarTransparentShow', onNavbarTransparentShow);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('navbarTransparentHide', onNavbarTransparentHide);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarShow', onShow);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarHide', onHide);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarCollapse', onCollapse);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarExpand', onExpand);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarPosition', onNavbarPosition);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarRole', onNavbarRole);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarMasterStack', onNavbarMasterStack);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarMasterUnstack', onNavbarMasterUnstack);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarTransparentShow', onNavbarTransparentShow);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('navbarTransparentHide', onNavbarTransparentHide);
    });
    const addLeftTitleClass = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => theme.value && theme.value.ios && _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7 && !_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.params.navbar.iosCenterTitle);
    const addCenterTitleClass = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => theme.value && theme.value.md && _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7 && _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.params.navbar.mdCenterTitle || theme.value && theme.value.aurora && _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7 && _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.params.navbar.auroraCenterTitle);
    const isLarge = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.large || props.largeTransparent);
    const isTransparent = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.transparent || isLarge.value && props.largeTransparent);
    const isTransparentVisible = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => isTransparent.value && transparentVisible);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('navbar', routerPositionClass, {
      'navbar-hidden': props.hidden,
      'navbar-large': isLarge.value,
      'navbar-large-collapsed': isLarge.value && largeCollapsed,
      'navbar-transparent': isTransparent.value,
      'navbar-transparent-visible': isTransparentVisible.value,
      'navbar-master': routerNavbarRole === 'master',
      'navbar-master-detail': routerNavbarRole === 'detail',
      'navbar-master-detail-root': routerNavbarRoleDetailRoot === true,
      'navbar-master-stacked': routerNavbarMasterStack === true,
      'no-shadow': props.noShadow,
      'no-hairline': props.noHairline
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    const largeTitle = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let largeTitleText = props.titleLarge;
      if (!largeTitleText && props.large && props.title) largeTitleText = props.title;
      return largeTitleText;
    });
    const hasLeft = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return props.backLink || slots['nav-left'] || slots.left;
    });
    const hasTitle = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return props.title || props.subtitle || slots.title;
    });
    const hasRight = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return slots['nav-right'] || slots.right;
    });
    const hasLargeTitle = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return largeTitle.value || slots['title-large'];
    });
    const innerClasses = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('navbar-inner', props.innerClass, props.innerClassName, {
        sliding: props.sliding,
        'navbar-inner-left-title': addLeftTitleClass.value,
        'navbar-inner-centered-title': addCenterTitleClass.value
      });
    });
    return {
      elRef,
      classes,
      innerClasses,
      hide,
      show,
      size,
      largeTitle,
      hasLeft,
      hasTitle,
      hasRight,
      hasLargeTitle,
      onBackClick
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/page-content.js":
/*!****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/page-content.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _preloader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./preloader.js */ "./node_modules/framework7-vue/components/preloader.js");
/* harmony import */ var _shared_use_tab_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-tab.js */ "./node_modules/framework7-vue/shared/use-tab.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = ["data-ptr-distance", "data-ptr-mousewheel", "data-infinite-distance"];
const _hoisted_2 = {
  key: 0,
  class: "ptr-preloader"
};

const _hoisted_3 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
  class: "ptr-arrow"
}, null, -1);

const _hoisted_4 = {
  key: 3,
  class: "ptr-preloader"
};

const _hoisted_5 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
  class: "ptr-arrow"
}, null, -1);

function render(_ctx, _cache) {
  const _component_f7_preloader = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-preloader");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    "data-ptr-distance": _ctx.ptrDistance || undefined,
    "data-ptr-mousewheel": _ctx.ptrMousewheel || undefined,
    "data-infinite-distance": _ctx.infiniteDistance || undefined
  }, [_ctx.ptr && _ctx.ptrPreloader && !_ctx.ptrBottom ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_f7_preloader), _hoisted_3])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.infinite && _ctx.infinitePreloader && _ctx.infiniteTop ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_preloader, {
    key: 1,
    class: "infinite-scroll-preloader"
  })) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default"), _ctx.infinite && _ctx.infinitePreloader && !_ctx.infiniteTop ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_preloader, {
    key: 2,
    class: "infinite-scroll-preloader"
  })) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), _ctx.ptr && _ctx.ptrPreloader && _ctx.ptrBottom ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_f7_preloader), _hoisted_5])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)], 10, _hoisted_1);
}







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-page-content',
  render,
  components: {
    f7Preloader: _preloader_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  props: {
    tab: Boolean,
    tabActive: Boolean,
    ptr: Boolean,
    ptrDistance: Number,
    ptrPreloader: {
      type: Boolean,
      default: true
    },
    ptrBottom: Boolean,
    ptrMousewheel: Boolean,
    infinite: Boolean,
    infiniteTop: Boolean,
    infiniteDistance: Number,
    infinitePreloader: {
      type: Boolean,
      default: true
    },
    hideBarsOnScroll: Boolean,
    hideNavbarOnScroll: Boolean,
    hideToolbarOnScroll: Boolean,
    messagesContent: Boolean,
    loginScreen: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['ptr:pullstart', 'ptr:pullmove', 'ptr:pullend', 'ptr:refresh', 'ptr:done', 'infinite', 'ptrPullStart', 'ptrPullMove', 'ptrPullEnd', 'ptrRefresh', 'ptrDone', 'tab:hide', 'tab:show'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onPtrPullStart = el => {
      if (elRef.value !== el) return;
      emit('ptr:pullstart');
      emit('ptrPullStart');
    };

    const onPtrPullMove = el => {
      if (elRef.value !== el) return;
      emit('ptr:pullmove');
      emit('ptrPullMove');
    };

    const onPtrPullEnd = el => {
      if (elRef.value !== el) return;
      emit('ptr:pullend');
      emit('ptrPullEnd');
    };

    const onPtrRefresh = (el, done) => {
      if (elRef.value !== el) return;
      emit('ptr:refresh', done);
      emit('ptrRefresh', done);
    };

    const onPtrDone = el => {
      if (elRef.value !== el) return;
      emit('ptr:done');
      emit('ptrDone');
    };

    const onInfinite = el => {
      if (elRef.value !== el) return;
      emit('infinite');
    };

    (0,_shared_use_tab_js__WEBPACK_IMPORTED_MODULE_4__.useTab)(elRef, emit);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7ready)(() => {
        if (props.ptr) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('ptrPullStart', onPtrPullStart);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('ptrPullMove', onPtrPullMove);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('ptrPullEnd', onPtrPullEnd);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('ptrRefresh', onPtrRefresh);
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('ptrDone', onPtrDone);
        }

        if (props.infinite) {
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.on('infinite', onInfinite);
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('ptrPullStart', onPtrPullStart);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('ptrPullMove', onPtrPullMove);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('ptrPullEnd', onPtrPullEnd);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('ptrRefresh', onPtrRefresh);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('ptrDone', onPtrDone);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_5__.f7.off('infinite', onInfinite);
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('page-content', {
      tab: props.tab,
      'tab-active': props.tabActive,
      'ptr-content': props.ptr,
      'ptr-bottom': props.ptrBottom,
      'infinite-scroll-content': props.infinite,
      'infinite-scroll-top': props.infiniteTop,
      'hide-bars-on-scroll': props.hideBarsOnScroll,
      'hide-navbar-on-scroll': props.hideNavbarOnScroll,
      'hide-toolbar-on-scroll': props.hideToolbarOnScroll,
      'messages-content': props.messagesContent,
      'login-screen-content': props.loginScreen
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/page.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/components/page.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _page_content_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./page-content.js */ "./node_modules/framework7-vue/components/page-content.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-page',
  props: {
    name: String,
    stacked: Boolean,
    withSubnavbar: {
      type: Boolean,
      default: undefined
    },
    subnavbar: {
      type: Boolean,
      default: undefined
    },
    withNavbarLarge: {
      type: Boolean,
      default: undefined
    },
    navbarLarge: {
      type: Boolean,
      default: undefined
    },
    noNavbar: Boolean,
    noToolbar: Boolean,
    tabs: Boolean,
    pageContent: {
      type: Boolean,
      default: true
    },
    noSwipeback: Boolean,
    // Page Content Props
    ptr: Boolean,
    ptrDistance: Number,
    ptrPreloader: {
      type: Boolean,
      default: true
    },
    ptrBottom: Boolean,
    ptrMousewheel: Boolean,
    infinite: Boolean,
    infiniteTop: Boolean,
    infiniteDistance: Number,
    infinitePreloader: {
      type: Boolean,
      default: true
    },
    hideBarsOnScroll: Boolean,
    hideNavbarOnScroll: Boolean,
    hideToolbarOnScroll: Boolean,
    messagesContent: Boolean,
    loginScreen: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorProps
  },
  emits: ['page:mounted', 'page:init', 'page:reinit', 'page:beforein', 'page:beforeout', 'page:afterout', 'page:afterin', 'page:beforeremove', 'page:beforeunmount', 'page:tabshow', 'page:tabhide', 'ptr:pullstart', 'ptr:pullmove', 'ptr:pullend', 'ptr:refresh', 'ptr:done', 'infinite'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    let hasSubnavbar = false;
    let hasNavbarLarge = false;
    let hasNavbarLargeCollapsed = false;
    let hasCardExpandableOpened = false;
    let routerPositionClass = '';
    let routerForceUnstack = false;
    let routerPageRole = null;
    let routerPageRoleDetailRoot = false;
    let routerPageMasterStack = false;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_4__.ref)(null); // Main Page Events

    const onPageMounted = page => {
      if (elRef.value !== page.el) return;
      emit('page:mounted', page);
    };

    const onPageInit = page => {
      if (elRef.value !== page.el) return;

      if (typeof props.withSubnavbar === 'undefined' && typeof props.subnavbar === 'undefined') {
        if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length || page.$el.children('.navbar').find('.subnavbar').length) {
          hasSubnavbar = true;
        }
      }

      if (typeof props.withNavbarLarge === 'undefined' && typeof props.navbarLarge === 'undefined') {
        if (page.$navbarEl && page.$navbarEl.hasClass('navbar-large')) {
          hasNavbarLarge = true;
        }
      }

      emit('page:init', page);
    };

    const onPageReinit = page => {
      if (elRef.value !== page.el) return;
      emit('page:reinit', page);
    };

    const onPageBeforeIn = page => {
      if (elRef.value !== page.el) return;

      if (!page.swipeBack) {
        if (page.from === 'next') {
          routerPositionClass = 'page-next';
        }

        if (page.from === 'previous') {
          routerPositionClass = 'page-previous';
        }
      }

      emit('page:beforein', page);
    };

    const onPageBeforeOut = page => {
      if (elRef.value !== page.el) return;
      emit('page:beforeout', page);
    };

    const onPageAfterOut = page => {
      if (elRef.value !== page.el) return;

      if (page.to === 'next') {
        routerPositionClass = 'page-next';
      }

      if (page.to === 'previous') {
        routerPositionClass = 'page-previous';
      }

      emit('page:afterout', page);
    };

    const onPageAfterIn = page => {
      if (elRef.value !== page.el) return;
      routerPositionClass = 'page-current';
      emit('page:afterin', page);
    };

    const onPageBeforeRemove = page => {
      if (elRef.value !== page.el) return;
      emit('page:beforeremove', page);
    };

    const onPageBeforeUnmount = page => {
      if (elRef.value !== page.el) return;
      emit('page:beforeunmount', page);
    }; // Helper events


    const onPageStack = pageEl => {
      if (elRef.value !== pageEl) return;
      routerForceUnstack = false;
    };

    const onPageUnstack = pageEl => {
      if (elRef.value !== pageEl) return;
      routerForceUnstack = true;
    };

    const onPagePosition = (pageEl, position) => {
      if (elRef.value !== pageEl) return;
      routerPositionClass = `page-${position}`;
    };

    const onPageRole = (pageEl, rolesData) => {
      if (elRef.value !== pageEl) return;
      routerPageRole = rolesData.role;
      routerPageRoleDetailRoot = rolesData.detailRoot;
    };

    const onPageMasterStack = pageEl => {
      if (elRef.value !== pageEl) return;
      routerPageMasterStack = true;
    };

    const onPageMasterUnstack = pageEl => {
      if (elRef.value !== pageEl) return;
      routerPageMasterStack = false;
    };

    const onPageNavbarLargeCollapsed = pageEl => {
      if (elRef.value !== pageEl) return;
      hasNavbarLargeCollapsed = true;
    };

    const onPageNavbarLargeExpanded = pageEl => {
      if (elRef.value !== pageEl) return;
      hasNavbarLargeCollapsed = false;
    };

    const onCardOpened = (cardEl, pageEl) => {
      if (elRef.value !== pageEl) return;
      hasCardExpandableOpened = true;
    };

    const onCardClose = (cardEl, pageEl) => {
      if (elRef.value !== pageEl) return;
      hasCardExpandableOpened = false;
    };

    const onPageTabShow = pageEl => {
      if (elRef.value !== pageEl) return;
      emit('page:tabshow');
    };

    const onPageTabHide = pageEl => {
      if (elRef.value !== pageEl) return;
      emit('page:tabhide');
    };

    const onPtrPullStart = () => {
      emit('ptr:pullstart');
    };

    const onPtrPullMove = () => {
      emit('ptr:pullmove');
    };

    const onPtrPullEnd = () => {
      emit('ptr:pullend');
    };

    const onPtrRefresh = done => {
      emit('ptr:refresh', done);
    };

    const onPtrDone = () => {
      emit('ptr:done');
    };

    const onInfinite = () => {
      emit('infinite');
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_4__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7ready)(() => {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageMounted', onPageMounted);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageInit', onPageInit);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageReinit', onPageReinit);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageBeforeIn', onPageBeforeIn);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageBeforeOut', onPageBeforeOut);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageAfterOut', onPageAfterOut);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageAfterIn', onPageAfterIn);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageBeforeRemove', onPageBeforeRemove);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageBeforeUnmount', onPageBeforeUnmount);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageStack', onPageStack);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageUnstack', onPageUnstack);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pagePosition', onPagePosition);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageRole', onPageRole);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageMasterStack', onPageMasterStack);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageMasterUnstack', onPageMasterUnstack);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageNavbarLargeCollapsed', onPageNavbarLargeCollapsed);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageNavbarLargeExpanded', onPageNavbarLargeExpanded);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('cardOpened', onCardOpened);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('cardClose', onCardClose);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageTabShow', onPageTabShow);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.on('pageTabHide', onPageTabHide);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.onBeforeUnmount)(() => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageMounted', onPageMounted);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageInit', onPageInit);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageReinit', onPageReinit);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageBeforeIn', onPageBeforeIn);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageBeforeOut', onPageBeforeOut);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageAfterOut', onPageAfterOut);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageAfterIn', onPageAfterIn);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageBeforeRemove', onPageBeforeRemove);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageBeforeUnmount', onPageBeforeUnmount);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageStack', onPageStack);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageUnstack', onPageUnstack);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pagePosition', onPagePosition);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageRole', onPageRole);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageMasterStack', onPageMasterStack);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageMasterUnstack', onPageMasterUnstack);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageNavbarLargeCollapsed', onPageNavbarLargeCollapsed);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageNavbarLargeExpanded', onPageNavbarLargeExpanded);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('cardOpened', onCardOpened);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('cardClose', onCardClose);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageTabShow', onPageTabShow);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.off('pageTabHide', onPageTabHide);
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_4__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('page', routerPositionClass, {
      stacked: props.stacked && !routerForceUnstack,
      tabs: props.tabs,
      'page-with-subnavbar': props.subnavbar || props.withSubnavbar,
      'page-with-navbar-large': props.navbarLarge || props.withNavbarLarge,
      'no-navbar': props.noNavbar,
      'no-toolbar': props.noToolbar,
      'no-swipeback': props.noSwipeback,
      'page-master': routerPageRole === 'master',
      'page-master-detail': routerPageRole === 'detail',
      'page-master-detail-root': routerPageRoleDetailRoot === true,
      'page-master-stacked': routerPageMasterStack === true,
      'page-with-navbar-large-collapsed': hasNavbarLargeCollapsed === true,
      'page-with-card-opened': hasCardExpandableOpened === true,
      'login-screen-page': props.loginScreen
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props)));
    const fixedTags = 'navbar toolbar tabbar subnavbar searchbar messagebar fab list-index panel'.split(' ').map(tagName => `f7-${tagName}`);
    return () => {
      const fixedList = [];
      const staticList = [];
      const {
        static: slotsStatic,
        fixed: slotsFixed,
        default: slotsDefault
      } = slots;
      let hasSubnavbarComputed = false;
      let hasNavbarLargeComputed = false;
      let hasMessages = props.messagesContent;
      const slotsDefaultRendered = slotsDefault && slotsDefault();

      if (slotsDefaultRendered) {
        slotsDefaultRendered.forEach(vnode => {
          if (typeof vnode === 'undefined') return;
          const tag = vnode.type && vnode.type.name ? vnode.type.name : vnode.type;
          let isFixedTag = false;

          if (!tag) {
            if (props.pageContent || props.pageContent === '') staticList.push(vnode);
            return;
          }

          if (tag === 'f7-subnavbar') hasSubnavbarComputed = true;

          if (tag === 'f7-navbar') {
            if (vnode.props && (vnode.props.large || vnode.props.large === '')) hasNavbarLargeComputed = true;
          }

          if (typeof hasMessages === 'undefined' && tag === 'f7-messages') hasMessages = true;

          if (fixedTags.indexOf(tag) >= 0) {
            isFixedTag = true;
          }

          if (props.pageContent) {
            if (isFixedTag) fixedList.push(vnode);else staticList.push(vnode);
          }
        });
      }

      let classesValue = classes.value;

      if ((hasSubnavbarComputed || hasSubnavbar) && typeof props.subnavbar === 'undefined' && typeof props.withSubnavbar === 'undefined' && classesValue.indexOf('page-with-subnavbar') < 0) {
        classesValue += ' page-with-subnavbar';
      }

      if ((hasNavbarLargeComputed || hasNavbarLarge) && typeof props.navbarLarge === 'undefined' && typeof props.withNavbarLarge === 'undefined' && classesValue.indexOf('page-with-navbar-large') < 0) {
        classesValue += ' page-with-navbar-large';
      }

      if (!props.pageContent) {
        return (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
          class: classesValue,
          ref: elRef,
          'data-name': props.name
        }, [slotsFixed && slotsFixed(), slotsStatic && slotsStatic(), slotsDefault && slotsDefaultRendered]);
      }

      return (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: classesValue,
        ref: elRef,
        'data-name': props.name
      }, [fixedList, slotsFixed && slotsFixed(), (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)(_page_content_js__WEBPACK_IMPORTED_MODULE_3__["default"], {
        ptr: props.ptr,
        ptrDistance: props.ptrDistance,
        ptrPreloader: props.ptrPreloader,
        ptrBottom: props.ptrBottom,
        ptrMousewheel: props.ptrMousewheel,
        infinite: props.infinite,
        infiniteTop: props.infiniteTop,
        infiniteDistance: props.infiniteDistance,
        infinitePreloader: props.infinitePreloader,
        hideBarsOnScroll: props.hideBarsOnScroll,
        hideNavbarOnScroll: props.hideNavbarOnScroll,
        hideToolbarOnScroll: props.hideToolbarOnScroll,
        messagesContent: props.messagesContent || hasMessages,
        loginScreen: props.loginScreen,
        onPtrPullStart,
        onPtrPullMove,
        onPtrPullEnd,
        onPtrRefresh,
        onPtrDone,
        onInfinite
      }, () => [slotsStatic && slotsStatic(), staticList])]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/panel.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/panel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = {
  key: 0,
  class: "panel-resize-handler"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default"), _ctx.resizable ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-panel',
  render,
  props: {
    side: String,
    effect: String,
    cover: Boolean,
    reveal: Boolean,
    push: Boolean,
    left: Boolean,
    right: Boolean,
    opened: Boolean,
    resizable: Boolean,
    backdrop: {
      type: Boolean,
      default: true
    },
    backdropEl: {
      type: String,
      default: undefined
    },
    containerEl: {
      type: String,
      default: undefined
    },
    closeByBackdropClick: {
      type: Boolean,
      default: undefined
    },
    visibleBreakpoint: {
      type: Number,
      default: undefined
    },
    collapsedBreakpoint: {
      type: Number,
      default: undefined
    },
    swipe: Boolean,
    swipeNoFollow: Boolean,
    swipeOnlyClose: Boolean,
    swipeActiveArea: {
      type: Number,
      default: 0
    },
    swipeThreshold: {
      type: Number,
      default: 0
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['panel:open', 'panel:opened', 'panel:close', 'panel:closed', 'click', 'panel:backdropclick', 'panel:swipe', 'panel:swipeopen', 'panel:breakpoint', 'panel:collapsedbreakpoint', 'panel:resize', 'update:opened'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    let f7Panel = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    let isOpened = false;
    let isClosing = false;
    let isCollapsed = false;
    let isBreakpoint = false;

    const onOpen = event => {
      isOpened = true;
      isClosing = false;
      emit('panel:open', event);
      emit('update:opened', true);
    };

    const onOpened = event => {
      emit('panel:opened', event);
    };

    const onClose = event => {
      isOpened = false;
      isClosing = true;
      emit('panel:close', event);
    };

    const onClosed = event => {
      isClosing = false;
      emit('panel:closed', event);
      emit('update:opened', false);
    };

    const onBackdropClick = event => {
      emit('click', event);
      emit('panel:backdropclick', event);
    };

    const onSwipe = event => {
      emit('panel:swipe', event);
    };

    const onSwipeOpen = event => {
      emit('panel:swipeopen', event);
    };

    const onBreakpoint = event => {
      isBreakpoint = true;
      isCollapsed = false;
      emit('panel:breakpoint', event);
    };

    const onCollapsedBreakpoint = event => {
      isBreakpoint = false;
      isCollapsed = true;
      emit('panel:collapsedbreakpoint', event);
    };

    const onResize = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      emit('panel:resize', ...args);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.resizable, newValue => {
      if (!f7Panel) return;
      if (newValue) f7Panel.enableResizable();else f7Panel.disableResizable();
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.opened, newValue => {
      if (!f7Panel) return;

      if (newValue) {
        f7Panel.open();
      } else {
        f7Panel.close();
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        const $ = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.$;
        if (!$) return;

        if ($('.panel-backdrop').length === 0) {
          $('<div class="panel-backdrop"></div>').insertBefore(elRef.value);
        }

        const params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.noUndefinedProps)({
          el: elRef.value,
          resizable: props.resizable,
          backdrop: props.backdrop,
          backdropEl: props.backdropEl,
          containerEl: props.containerEl,
          closeByBackdropClick: props.containerEl,
          visibleBreakpoint: props.visibleBreakpoint,
          collapsedBreakpoint: props.collapsedBreakpoint,
          swipe: props.swipe,
          swipeNoFollow: props.swipeNoFollow,
          swipeOnlyClose: props.swipeOnlyClose,
          swipeActiveArea: props.swipeActiveArea,
          swipeThreshold: props.swipeThreshold,
          on: {
            open: onOpen,
            opened: onOpened,
            close: onClose,
            closed: onClosed,
            backdropClick: onBackdropClick,
            swipe: onSwipe,
            swipeOpen: onSwipeOpen,
            collapsedBreakpoint: onCollapsedBreakpoint,
            breakpoint: onBreakpoint,
            resize: onResize
          }
        });
        f7Panel = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.panel.create(params);

        if (props.opened) {
          f7Panel.open(false);
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Panel && f7Panel.destroy) {
        f7Panel.destroy();
      }

      f7Panel = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const sideComputed = props.side || (props.left ? 'left' : 'right');
      const effectComputed = props.effect || (props.reveal ? 'reveal' : props.push ? 'push' : 'cover'); // eslint-disable-line

      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('panel', {
        'panel-in': isOpened && !isClosing && !isBreakpoint,
        'panel-in-breakpoint': isBreakpoint,
        'panel-in-collapsed': isCollapsed,
        'panel-resizable': props.resizable,
        [`panel-${sideComputed}`]: sideComputed,
        [`panel-${effectComputed}`]: effectComputed
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props));
    });
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/photo-browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/photo-browser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-photo-browser',
  props: {
    init: {
      type: Boolean,
      default: true
    },
    params: Object,
    photos: Array,
    exposition: {
      type: Boolean,
      default: true
    },
    expositionHideCaptions: {
      type: Boolean,
      default: false
    },
    type: {
      type: String
    },
    navbar: {
      type: Boolean,
      default: true
    },
    toolbar: {
      type: Boolean,
      default: true
    },
    theme: {
      type: String
    },
    captionsTheme: {
      type: String
    },
    iconsColor: {
      type: String
    },
    swipeToClose: {
      type: Boolean,
      default: true
    },
    pageBackLinkText: {
      type: String,
      default: undefined
    },
    popupCloseLinkText: {
      type: String,
      default: undefined
    },
    navbarOfText: {
      type: String,
      default: undefined
    },
    navbarShowCount: {
      type: Boolean,
      default: undefined
    },
    swiper: {
      type: Object
    },
    url: {
      type: String
    },
    routableModals: {
      type: Boolean,
      default: false
    },
    virtualSlides: {
      type: Boolean,
      default: true
    },
    view: [String, Object],
    renderNavbar: Function,
    renderToolbar: Function,
    renderCaption: Function,
    renderObject: Function,
    renderLazyPhoto: Function,
    renderPhoto: Function,
    renderPage: Function,
    renderPopup: Function,
    renderStandalone: Function
  },
  emits: ['photobrowser:open', 'photobrowser:close', 'photobrowser:opened', 'photobrowser:closed', 'photobrowser:swipetoclose'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    let f7PhotoBrowser = null;

    const open = index => {
      return f7PhotoBrowser.open(index);
    };

    const close = () => {
      return f7PhotoBrowser.close();
    };

    const expositionToggle = () => {
      return f7PhotoBrowser.expositionToggle();
    };

    const expositionEnable = () => {
      return f7PhotoBrowser.expositionEnable();
    };

    const expositionDisable = () => {
      return f7PhotoBrowser.expositionDisable();
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_2__.watch)(() => props.photos, value => {
      const pb = f7PhotoBrowser;
      if (!pb) return;
      pb.params.photos = value;

      if (pb.opened && pb.swiper) {
        pb.swiper.update();
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_2__.onMounted)(() => {
      if (!props.init) return;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_1__.f7ready)(() => {
        let paramsComputed;

        if (typeof props.params !== 'undefined') {
          paramsComputed = props.params;
        } else {
          paramsComputed = { ...props
          };
          delete paramsComputed.params;
        }

        Object.keys(paramsComputed).forEach(param => {
          if (typeof paramsComputed[param] === 'undefined' || paramsComputed[param] === '') delete paramsComputed[param];
        });
        paramsComputed = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, paramsComputed, {
          on: {
            open() {
              emit('photobrowser:open');
            },

            close() {
              emit('photobrowser:close');
            },

            opened() {
              emit('photobrowser:opened');
            },

            closed() {
              emit('photobrowser:closed');
            },

            swipeToClose() {
              emit('photobrowser:swipetoclose');
            }

          }
        });
        f7PhotoBrowser = _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__.f7.photoBrowser.create(paramsComputed);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_2__.onBeforeUnmount)(() => {
      if (f7PhotoBrowser && f7PhotoBrowser.destroy) f7PhotoBrowser.destroy();
      f7PhotoBrowser = null;
    });
    return {
      open,
      close,
      expositionToggle,
      expositionEnable,
      expositionDisable
    };
  },

  render() {
    return null;
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/pie-chart.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/pie-chart.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = ["width", "height", "viewBox"];
const _hoisted_2 = ["d", "fill", "data-index", "onClick", "onMouseenter"];

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: _ctx.size,
    height: _ctx.size,
    viewBox: `-${_ctx.size / 3} -${_ctx.size / 3} ${_ctx.size * 2 / 3} ${_ctx.size * 2 / 3}`,
    style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)({
      transform: 'rotate(-90deg)'
    })
  }, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.paths, (path, index) => {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("path", {
      key: path.label || index,
      d: path.points,
      fill: path.color,
      "data-index": index,
      class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classNames({
        'pie-chart-hidden': _ctx.currentIndex !== null && _ctx.currentIndex !== index
      })),
      onClick: $event => _ctx.setCurrentIndex(index),
      onMouseenter: $event => _ctx.setCurrentIndex(index),
      onMouseleave: _cache[0] || (_cache[0] = $event => _ctx.setCurrentIndex(null))
    }, null, 42, _hoisted_2);
  }), 128))], 12, _hoisted_1)), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-pie-chart',
  render,
  props: {
    size: {
      type: Number,
      default: 320
    },
    tooltip: Boolean,
    datasets: {
      type: Array,
      default: () => []
    },
    formatTooltip: Function
  },
  emits: ['select'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    let f7Tooltip = null;
    const currentIndex = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const setCurrentIndex = index => {
      currentIndex.value = index;
    };

    const summValue = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let summ = 0;
      props.datasets.map(d => d.value || 0).forEach(value => {
        summ += value;
      });
      return summ;
    });
    const paths = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const p = [];
      let cumulativePercentage = 0;

      function getCoordinatesForPercentage(percentage) {
        const x = Math.cos(2 * Math.PI * percentage) * (props.size / 3);
        const y = Math.sin(2 * Math.PI * percentage) * (props.size / 3);
        return [x, y];
      }

      props.datasets.forEach(_ref2 => {
        let {
          value,
          label,
          color
        } = _ref2;
        const percentage = value / summValue.value;
        const [startX, startY] = getCoordinatesForPercentage(cumulativePercentage);
        cumulativePercentage += percentage;
        const [endX, endY] = getCoordinatesForPercentage(cumulativePercentage);
        const largeArcFlag = percentage > 0.5 ? 1 : 0;
        const points = [`M ${startX} ${startY}`, // Move
        `A ${props.size / 3} ${props.size / 3} 0 ${largeArcFlag} 1 ${endX} ${endY}`, // Arc
        'L 0 0' // Line
        ].join(' ');
        p.push({
          points,
          label,
          color
        });
      });
      return p;
    });

    const formatTooltipText = () => {
      if (currentIndex.value === null) return '';
      const {
        value,
        label,
        color
      } = props.datasets[currentIndex.value];
      const percentage = value / summValue.value * 100;

      const round = v => {
        if (parseInt(v, 10) === v) return v;
        return Math.round(v * 100) / 100;
      };

      if (props.formatTooltip) {
        return props.formatTooltip({
          index: currentIndex.value,
          value,
          label,
          color,
          percentage
        });
      }

      const tooltipText = `${label ? `${label}: ` : ''}${round(value)} (${round(percentage)}%)`;
      return `
      <div class="pie-chart-tooltip-label">
        <span class="pie-chart-tooltip-color" style="background-color: ${color};"></span> ${tooltipText}
      </div>
    `;
    };

    const setTooltip = () => {
      const index = currentIndex.value;
      if (index === null && !f7Tooltip) return;
      if (!props.tooltip || !elRef.value || !_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7) return;

      if (index !== null && !f7Tooltip) {
        f7Tooltip = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.tooltip.create({
          trigger: 'manual',
          containerEl: elRef.value,
          targetEl: elRef.value.querySelector(`path[data-index="${index}"]`),
          text: formatTooltipText(),
          cssClass: 'pie-chart-tooltip'
        });
        f7Tooltip.show();
        return;
      }

      if (!f7Tooltip) return;

      if (index !== null) {
        f7Tooltip.setText(formatTooltipText());
        f7Tooltip.setTargetEl(elRef.value.querySelector(`path[data-index="${index}"]`));
        f7Tooltip.show();
      } else {
        f7Tooltip.hide();
      }
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => currentIndex.value, () => {
      emit('select', currentIndex.value, props.datasets[currentIndex.value]);
      setTooltip();
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Tooltip && f7Tooltip.destroy) {
        f7Tooltip.destroy();
      }

      f7Tooltip = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('pie-chart'));
    return {
      elRef,
      currentIndex,
      classes,
      paths,
      classNames: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames,
      setCurrentIndex
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/popover.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7-vue/components/popover.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/modal-state-classes.js */ "./node_modules/framework7-vue/shared/modal-state-classes.js");


const _hoisted_1 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
  class: "popover-angle"
}, null, -1);

const _hoisted_2 = {
  class: "popover-inner"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [_hoisted_1, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])], 2);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-popover',
  render,
  props: {
    opened: Boolean,
    animate: {
      type: Boolean,
      default: undefined
    },
    targetEl: {
      type: [String, Object],
      default: undefined
    },
    backdrop: {
      type: Boolean,
      default: undefined
    },
    backdropEl: {
      type: [String, Object],
      default: undefined
    },
    closeByBackdropClick: {
      type: Boolean,
      default: undefined
    },
    closeByOutsideClick: {
      type: Boolean,
      default: undefined
    },
    closeOnEscape: {
      type: Boolean,
      default: undefined
    },
    containerEl: {
      type: [String, Object],
      default: undefined
    },
    verticalPosition: {
      type: String,
      default: undefined
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['popover:open', 'popover:opened', 'popover:close', 'popover:closed', 'update:opened'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const f7Popover = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null); // eslint-disable-next-line

    let isOpened = props.opened;
    let isClosing = false;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onOpen = instance => {
      isOpened = true;
      isClosing = false;
      emit('popover:open', instance);
      emit('update:opened', true);
    };

    const onOpened = instance => {
      emit('popover:opened', instance);
    };

    const onClose = instance => {
      isOpened = false;
      isClosing = true;
      emit('popover:close', instance);
    };

    const onClosed = instance => {
      isClosing = false;
      emit('popover:closed', instance);
      emit('update:opened', false);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.opened, value => {
      if (!f7Popover.value) return;

      if (value) {
        f7Popover.value.open();
      } else {
        f7Popover.value.close();
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!elRef.value) return;
      const popoverParams = {
        el: elRef.value,
        on: {
          open: onOpen,
          opened: onOpened,
          close: onClose,
          closed: onClosed
        }
      };
      const {
        targetEl,
        closeByBackdropClick,
        closeByOutsideClick,
        closeOnEscape,
        backdrop,
        backdropEl,
        containerEl,
        verticalPosition
      } = props;
      if (typeof targetEl !== 'undefined') popoverParams.targetEl = targetEl;
      if (typeof closeByBackdropClick !== 'undefined') popoverParams.closeByBackdropClick = closeByBackdropClick;
      if (typeof closeByOutsideClick !== 'undefined') popoverParams.closeByOutsideClick = closeByOutsideClick;
      if (typeof closeOnEscape !== 'undefined') popoverParams.closeOnEscape = closeOnEscape;
      if (typeof backdrop !== 'undefined') popoverParams.backdrop = backdrop;
      if (typeof backdropEl !== 'undefined') popoverParams.backdropEl = backdropEl;
      if (typeof containerEl !== 'undefined') popoverParams.containerEl = containerEl;
      if (typeof verticalPosition !== 'undefined') popoverParams.verticalPosition = verticalPosition;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        f7Popover.value = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.popover.create(popoverParams);

        if (props.opened) {
          f7Popover.value.open(targetEl, false);
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Popover.value) {
        f7Popover.value.destroy();
      }

      f7Popover.value = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('popover', (0,_shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_4__.modalStateClasses)({
      isOpened,
      isClosing
    }), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/popup.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/popup.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/modal-state-classes.js */ "./node_modules/framework7-vue/shared/modal-state-classes.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-popup',
  render,
  props: {
    tabletFullscreen: Boolean,
    opened: Boolean,
    animate: {
      type: Boolean,
      default: undefined
    },
    backdrop: {
      type: Boolean,
      default: undefined
    },
    backdropEl: {
      type: [String, Object],
      default: undefined
    },
    closeByBackdropClick: {
      type: Boolean,
      default: undefined
    },
    closeOnEscape: {
      type: Boolean,
      default: undefined
    },
    swipeToClose: {
      type: [Boolean, String],
      default: false
    },
    swipeHandler: {
      type: [String, Object],
      default: undefined
    },
    push: Boolean,
    containerEl: {
      type: [String, Object],
      default: undefined
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['popup:swipestart', 'popup:swipemove', 'popup:swipeend', 'popup:swipeclose', 'popup:open', 'popup:opened', 'popup:close', 'popup:closed', 'update:opened'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const f7Popup = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null); // eslint-disable-next-line

    let isOpened = props.opened;
    let isClosing = false;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onSwipeStart = instance => {
      emit('popup:swipestart', instance);
    };

    const onSwipeMove = instance => {
      emit('popup:swipemove', instance);
    };

    const onSwipeEnd = instance => {
      emit('popup:swipeend', instance);
    };

    const onSwipeClose = instance => {
      emit('popup:swipeclose', instance);
    };

    const onOpen = instance => {
      isOpened = true;
      isClosing = false;
      emit('popup:open', instance);
      emit('update:opened', true);
    };

    const onOpened = instance => {
      emit('popup:opened', instance);
    };

    const onClose = instance => {
      isOpened = false;
      isClosing = true;
      emit('popup:close', instance);
    };

    const onClosed = instance => {
      isClosing = false;
      emit('popup:closed', instance);
      emit('update:opened', false);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.opened, value => {
      if (!f7Popup.value) return;

      if (value) {
        f7Popup.value.open();
      } else {
        f7Popup.value.close();
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!elRef.value) return;
      const popupParams = {
        el: elRef.value,
        on: {
          swipeStart: onSwipeStart,
          swipeMove: onSwipeMove,
          swipeEnd: onSwipeEnd,
          swipeClose: onSwipeClose,
          open: onOpen,
          opened: onOpened,
          close: onClose,
          closed: onClosed
        }
      };
      const {
        closeByBackdropClick,
        closeOnEscape,
        animate,
        backdrop,
        backdropEl,
        swipeToClose,
        swipeHandler,
        containerEl
      } = props;
      if (typeof closeByBackdropClick !== 'undefined') popupParams.closeByBackdropClick = closeByBackdropClick;
      if (typeof closeOnEscape !== 'undefined') popupParams.closeOnEscape = closeOnEscape;
      if (typeof animate !== 'undefined') popupParams.animate = animate;
      if (typeof backdrop !== 'undefined') popupParams.backdrop = backdrop;
      if (typeof backdropEl !== 'undefined') popupParams.backdropEl = backdropEl;
      if (typeof swipeToClose !== 'undefined') popupParams.swipeToClose = swipeToClose;
      if (typeof swipeHandler !== 'undefined') popupParams.swipeHandler = swipeHandler;
      if (typeof containerEl !== 'undefined') popupParams.containerEl = containerEl;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        f7Popup.value = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.popup.create(popupParams);

        if (props.opened) {
          f7Popup.value.open(false);
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Popup.value) {
        f7Popup.value.destroy();
      }

      f7Popup.value = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('popup', {
      'popup-tablet-fullscreen': props.tabletFullscreen,
      'popup-push': props.push
    }, (0,_shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_4__.modalStateClasses)({
      isOpened,
      isClosing
    }), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/preloader.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/preloader.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_theme_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-theme.js */ "./node_modules/framework7-vue/shared/use-theme.js");

const _hoisted_1 = {
  key: 0,
  class: "preloader-inner"
};

const _hoisted_2 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("svg", {
  viewBox: "0 0 36 36"
}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("circle", {
  cx: "18",
  cy: "18",
  r: "16"
})], -1);

const _hoisted_3 = [_hoisted_2];
const _hoisted_4 = {
  key: 1,
  class: "preloader-inner"
};

const _hoisted_5 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode)("<span class=\"preloader-inner-line\"></span><span class=\"preloader-inner-line\"></span><span class=\"preloader-inner-line\"></span><span class=\"preloader-inner-line\"></span><span class=\"preloader-inner-line\"></span><span class=\"preloader-inner-line\"></span><span class=\"preloader-inner-line\"></span><span class=\"preloader-inner-line\"></span>", 8);

const _hoisted_13 = [_hoisted_5];
const _hoisted_14 = {
  key: 2,
  class: "preloader-inner"
};

const _hoisted_15 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", {
  class: "preloader-inner-circle"
}, null, -1);

const _hoisted_16 = [_hoisted_15];
const _hoisted_17 = {
  key: 3,
  class: "preloader-inner"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)(_ctx.style)
  }, [_ctx.theme && _ctx.theme.md ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_1, _hoisted_3)) : _ctx.theme && _ctx.theme.ios ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_4, _hoisted_13)) : _ctx.theme && _ctx.theme.aurora ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_14, _hoisted_16)) : !_ctx.theme ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_17)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)], 6);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-preloader',
  render,
  props: {
    size: [Number, String],
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const theme = (0,_shared_use_theme_js__WEBPACK_IMPORTED_MODULE_3__.useTheme)();
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('preloader', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    const style = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const preloaderStyle = {};
      let sizeComputed = props.size;

      if (sizeComputed && typeof sizeComputed === 'string' && sizeComputed.indexOf('px') >= 0) {
        sizeComputed = sizeComputed.replace('px', '');
      }

      if (sizeComputed) {
        preloaderStyle.width = `${sizeComputed}px`;
        preloaderStyle.height = `${sizeComputed}px`;
        preloaderStyle['--f7-preloader-size'] = `${sizeComputed}px`;
      }

      return preloaderStyle;
    });
    return {
      classes,
      style,
      theme
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/progressbar.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7-vue/components/progressbar.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = ["data-progress"];

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    "data-progress": _ctx.progress
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", {
    style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)(_ctx.transformStyle)
  }, null, 4)], 10, _hoisted_1);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-progressbar',
  render,
  props: {
    progress: Number,
    infinite: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const set = (newProgress, speed) => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.progressbar.set(elRef.value, newProgress, speed);
    };

    const transformStyle = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ({
      transform: props.progress ? `translate3d(${-100 + props.progress}%, 0, 0)` : '',
      WebkitTransform: props.progress ? `translate3d(${-100 + props.progress}%, 0, 0)` : ''
    }));
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('progressbar', {
      'progressbar-infinite': props.infinite
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      set,
      transformStyle,
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/radio.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/radio.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = ["name", "value", "disabled", "readonly", "checked"];

const _hoisted_2 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("i", {
  class: "icon-radio"
}, null, -1);

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("label", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("input", {
    ref: "inputElRef",
    type: "radio",
    name: _ctx.name,
    value: _ctx.value,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    checked: _ctx.checked,
    onChange: _cache[0] || (_cache[0] = function () {
      return _ctx.onChange && _ctx.onChange(...arguments);
    })
  }, null, 40, _hoisted_1), _hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-radio',
  render,
  props: {
    checked: Boolean,
    name: [Number, String],
    value: {
      type: [Number, String, Boolean],
      default: undefined
    },
    disabled: Boolean,
    readonly: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['update:checked', 'change'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const inputElRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onChange = event => {
      emit('update:checked', event.target.checked);
      emit('change', event);
    };

    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
      radio: true,
      disabled: props.disabled
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      inputElRef,
      classes,
      onChange
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/range.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/range.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = ["name"];

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [_ctx.input ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("input", {
    key: 0,
    id: "inputId",
    type: "range",
    name: _ctx.name
  }, null, 8, _hoisted_1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-range',
  render,
  props: {
    init: {
      type: Boolean,
      default: true
    },
    value: {
      type: [Number, Array, String],
      default: 0
    },
    min: {
      type: [Number, String],
      default: 0
    },
    max: {
      type: [Number, String],
      default: 100
    },
    step: {
      type: [Number, String],
      default: 1
    },
    label: {
      type: Boolean,
      default: false
    },
    dual: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    verticalReversed: {
      type: Boolean,
      default: false
    },
    draggableBar: {
      type: Boolean,
      default: true
    },
    formatLabel: Function,
    scale: {
      type: Boolean,
      default: false
    },
    scaleSteps: {
      type: Number,
      default: 5
    },
    scaleSubSteps: {
      type: Number,
      default: 0
    },
    formatScaleLabel: Function,
    limitKnobPosition: {
      type: Boolean,
      default: undefined
    },
    name: String,
    input: Boolean,
    inputId: String,
    disabled: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['range:change', 'range:changed', 'rangeChange', 'rangeChanged', 'update:value'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    let f7Range = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.value, newValue => {
      if (!f7Range) return;
      const rangeValue = f7Range.value;

      if (Array.isArray(newValue) && Array.isArray(rangeValue)) {
        if (rangeValue[0] !== newValue[0] || rangeValue[1] !== newValue[1]) {
          f7Range.setValue(newValue);
        }
      } else {
        f7Range.setValue(newValue);
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        if (!props.init || !elRef.value) return;
        f7Range = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.range.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.noUndefinedProps)({
          el: elRef.value,
          ...props,
          on: {
            change(range, val) {
              emit('range:change', val);
              emit('rangeChange', val);
            },

            changed(range, val) {
              emit('range:changed', val);
              emit('rangeChanged', val);
              emit('update:value', val);
            }

          }
        }));
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Range && f7Range.destroy) f7Range.destroy();
      f7Range = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('range-slider', {
      'range-slider-horizontal': !props.vertical,
      'range-slider-vertical': props.vertical,
      'range-slider-vertical-reversed': props.vertical && props.verticalReversed,
      disabled: props.disabled
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/routable-modals.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/routable-modals.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-routable-modals',

  setup() {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);
    const modals = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)([]);
    const routerData = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);
    (0,vue__WEBPACK_IMPORTED_MODULE_1__.onMounted)(() => {
      routerData.value = {
        modals,
        el: elRef.value,

        setModals(newModals) {
          newModals.forEach(modal => {
            // eslint-disable-next-line
            modal.component = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRaw)(modal.component);
          });
          modals.value = [...newModals];
        }

      };
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7routers.modals = routerData.value;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_1__.onUpdated)(() => {
      if (!routerData.value || !_shared_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7events.emit('modalsRouterDidUpdate', routerData.value);
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_1__.onBeforeUnmount)(() => {
      if (!routerData.value) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7routers.modals = null;
      routerData.value = null;
    });

    const getComponent = modal => (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRaw)(modal.component);

    const getProps = modal => {
      const {
        component: modalComponent,
        props: modalProps
      } = modal;
      let keys = [];
      const passProps = {};
      if (modalComponent && modalComponent.props) keys = Object.keys(modalComponent.props);
      keys.forEach(key => {
        if (key in modalProps) passProps[key] = modalProps[key];
      });
      return passProps;
    };

    return () => {
      return (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('div', {
        ref: elRef,
        class: 'framework7-modals'
      }, [...modals.value.map(modal => {
        return (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)(getComponent(modal), {
          key: modal.id,
          ...getProps(modal)
        });
      })]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/row.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7-vue/components/row.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = {
  key: 0,
  class: "resize-handler"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.tag), {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default"), _ctx.resizable && _ctx.resizableHandler ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)]),
    _: 3
  }, 8, ["class"]);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-row',
  render,
  props: {
    noGap: Boolean,
    tag: {
      type: String,
      default: 'div'
    },
    resizable: Boolean,
    resizableFixed: Boolean,
    resizableAbsolute: Boolean,
    resizableHandler: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['grid:resize'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onResize = el => {
      if (el === elRef.value) {
        emit('grid:resize');
      }
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('gridResize', onResize);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('gridResize', onResize);
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('row', {
      'no-gap': props.noGap,
      resizable: props.resizable,
      'resizable-fixed': props.resizableFixed,
      'resizable-absolute': props.resizableAbsolute
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/searchbar.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/searchbar.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = {
  class: "searchbar-inner"
};
const _hoisted_2 = {
  class: "searchbar-input-wrap"
};
const _hoisted_3 = ["value", "placeholder", "spellcheck"];

const _hoisted_4 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("i", {
  class: "searchbar-icon"
}, null, -1);

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.tag), {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    onSubmit: _ctx.onSubmit
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "before-inner"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "inner-start"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "input-wrap-start"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("input", {
      value: _ctx.value,
      placeholder: _ctx.placeholder,
      spellcheck: _ctx.spellcheck,
      type: "search",
      onInput: _cache[0] || (_cache[0] = function () {
        return _ctx.onInput && _ctx.onInput(...arguments);
      }),
      onChange: _cache[1] || (_cache[1] = function () {
        return _ctx.onChange && _ctx.onChange(...arguments);
      }),
      onFocus: _cache[2] || (_cache[2] = function () {
        return _ctx.onFocus && _ctx.onFocus(...arguments);
      }),
      onBlur: _cache[3] || (_cache[3] = function () {
        return _ctx.onBlur && _ctx.onBlur(...arguments);
      })
    }, null, 40, _hoisted_3), _hoisted_4, _ctx.clearButton ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", {
      key: 0,
      class: "input-clear-button",
      onClick: _cache[4] || (_cache[4] = function () {
        return _ctx.onClearButtonClick && _ctx.onClearButtonClick(...arguments);
      })
    })) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "input-wrap-end")]), _ctx.disableButton ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", {
      key: 0,
      class: "searchbar-disable-button",
      onClick: _cache[5] || (_cache[5] = function () {
        return _ctx.onDisableButtonClick && _ctx.onDisableButtonClick(...arguments);
      })
    }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.disableButtonText), 1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "inner-end"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "after-inner")]),
    _: 3
  }, 8, ["class", "onSubmit"]);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-searchbar',
  render,
  props: {
    noShadow: Boolean,
    noHairline: Boolean,
    form: {
      type: Boolean,
      default: true
    },
    placeholder: {
      type: String,
      default: 'Search'
    },
    spellcheck: {
      type: Boolean,
      default: undefined
    },
    disableButton: {
      type: Boolean,
      default: true
    },
    disableButtonText: {
      type: String,
      default: 'Cancel'
    },
    clearButton: {
      type: Boolean,
      default: true
    },
    // Input Value
    value: [String, Number, Array],
    // SB Params
    inputEvents: {
      type: String,
      default: 'change input compositionend'
    },
    expandable: Boolean,
    inline: Boolean,
    searchContainer: [String, Object],
    searchIn: {
      type: String,
      default: '.item-title'
    },
    searchItem: {
      type: String,
      default: 'li'
    },
    searchGroup: {
      type: String,
      default: '.list-group'
    },
    searchGroupTitle: {
      type: String,
      default: '.item-divider, .list-group-title'
    },
    foundEl: {
      type: [String, Object],
      default: '.searchbar-found'
    },
    notFoundEl: {
      type: [String, Object],
      default: '.searchbar-not-found'
    },
    backdrop: {
      type: Boolean,
      default: undefined
    },
    backdropEl: [String, Object],
    hideOnEnableEl: {
      type: [String, Object],
      default: '.searchbar-hide-on-enable'
    },
    hideOnSearchEl: {
      type: [String, Object],
      default: '.searchbar-hide-on-search'
    },
    ignore: {
      type: String,
      default: '.searchbar-ignore'
    },
    customSearch: {
      type: Boolean,
      default: false
    },
    removeDiacritics: {
      type: Boolean,
      default: false
    },
    hideDividers: {
      type: Boolean,
      default: true
    },
    hideGroups: {
      type: Boolean,
      default: true
    },
    init: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['change', 'input', 'focus', 'blur', 'submit', 'click:clear', 'click:disable', 'searchbar:search', 'searchbar:clear', 'searchbar:enable', 'searchbar:disable', 'update:value'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    let f7Searchbar = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const search = query => {
      if (!f7Searchbar) return undefined;
      return f7Searchbar.search(query);
    };

    const enable = () => {
      if (!f7Searchbar) return undefined;
      return f7Searchbar.enable();
    };

    const disable = () => {
      if (!f7Searchbar) return undefined;
      return f7Searchbar.disable();
    };

    const toggle = () => {
      if (!f7Searchbar) return undefined;
      return f7Searchbar.toggle();
    };

    const clear = () => {
      if (!f7Searchbar) return undefined;
      return f7Searchbar.clear();
    };

    const onChange = event => {
      emit('change', event);
    };

    const onInput = event => {
      emit('input', event);
      emit('update:value', event.target.value);
    };

    const onFocus = event => {
      emit('focus', event);
    };

    const onBlur = event => {
      emit('blur', event);
    };

    const onSubmit = event => {
      emit('submit', event);
    };

    const onClearButtonClick = event => {
      emit('click:clear', event);
    };

    const onDisableButtonClick = event => {
      emit('click:disable', event);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!props.init) return;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        const params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.noUndefinedProps)({
          el: elRef.value,
          inputEvents: props.inputEvents,
          searchContainer: props.searchContainer,
          searchIn: props.searchIn,
          searchItem: props.searchItem,
          searchGroup: props.searchGroup,
          searchGroupTitle: props.searchGroupTitle,
          hideOnEnableEl: props.hideOnEnableEl,
          hideOnSearchEl: props.hideOnSearchEl,
          foundEl: props.foundEl,
          notFoundEl: props.notFoundEl,
          backdrop: props.backdrop,
          backdropEl: props.backdropEl,
          disableButton: props.disableButton,
          ignore: props.ignore,
          customSearch: props.customSearch,
          removeDiacritics: props.removeDiacritics,
          hideDividers: props.hideDividers,
          hideGroups: props.hideGroups,
          expandable: props.expandable,
          inline: props.inline,
          on: {
            search(searchbar, query, previousQuery) {
              emit('searchbar:search', searchbar, query, previousQuery);
            },

            clear(searchbar, previousQuery) {
              emit('searchbar:clear', searchbar, previousQuery);
            },

            enable(searchbar) {
              emit('searchbar:enable', searchbar);
            },

            disable(searchbar) {
              emit('searchbar:disable', searchbar);
            }

          }
        });
        Object.keys(params).forEach(key => {
          if (params[key] === '') {
            delete params[key];
          }
        });
        f7Searchbar = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.searchbar.create(params);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Searchbar && f7Searchbar.destroy) f7Searchbar.destroy();
      f7Searchbar = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('searchbar', {
      'searchbar-inline': props.inline,
      'no-shadow': props.noShadow,
      'no-hairline': props.noHairline,
      'searchbar-expandable': props.expandable
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    const tag = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.form ? 'form' : 'div');
    return {
      elRef,
      tag,
      classes,
      search,
      enable,
      disable,
      toggle,
      clear,
      onChange,
      onInput,
      onFocus,
      onBlur,
      onSubmit,
      onClearButtonClick,
      onDisableButtonClick
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/segmented.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/segmented.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = {
  key: 0,
  class: "segmented-highlight"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.tag), {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default"), _ctx.strong || _ctx.strongIos || _ctx.strongMd || _ctx.strongAurora ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("span", _hoisted_1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)]),
    _: 3
  }, 8, ["class"]);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-segmented',
  render,
  props: {
    raised: Boolean,
    raisedIos: Boolean,
    raisedMd: Boolean,
    raisedAurora: Boolean,
    round: Boolean,
    roundIos: Boolean,
    roundMd: Boolean,
    roundAurora: Boolean,
    strong: Boolean,
    strongIos: Boolean,
    strongMd: Boolean,
    strongAurora: Boolean,
    tag: {
      type: String,
      default: 'div'
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
      segmented: true,
      'segmented-raised': props.raised,
      'segmented-raised-ios': props.raisedIos,
      'segmented-raised-aurora': props.raisedAurora,
      'segmented-raised-md': props.raisedMd,
      'segmented-round': props.round,
      'segmented-round-ios': props.roundIos,
      'segmented-round-aurora': props.roundAurora,
      'segmented-round-md': props.roundMd,
      'segmented-strong': props.strong,
      'segmented-strong-ios': props.strongIos,
      'segmented-strong-md': props.strongMd,
      'segmented-strong-aurora': props.strongAurora
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/sheet.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/sheet.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/modal-state-classes.js */ "./node_modules/framework7-vue/shared/modal-state-classes.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-sheet',
  props: {
    opened: Boolean,
    animate: {
      type: Boolean,
      default: undefined
    },
    top: Boolean,
    bottom: Boolean,
    position: String,
    backdrop: {
      type: Boolean,
      default: undefined
    },
    backdropEl: {
      type: [String, Object],
      default: undefined
    },
    closeByBackdropClick: {
      type: Boolean,
      default: undefined
    },
    closeByOutsideClick: {
      type: Boolean,
      default: undefined
    },
    closeOnEscape: {
      type: Boolean,
      default: undefined
    },
    push: Boolean,
    swipeToClose: {
      type: Boolean,
      default: undefined
    },
    swipeToStep: {
      type: Boolean,
      default: undefined
    },
    swipeHandler: {
      type: [String, Object],
      default: undefined
    },
    containerEl: {
      type: [String, Object],
      default: undefined
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorProps
  },
  emits: ['sheet:stepprogress', 'sheet:stepopen', 'sheet:stepclose', 'sheet:open', 'sheet:opened', 'sheet:close', 'sheet:closed', 'update:opened'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    let f7Sheet = null; // eslint-disable-next-line

    let isOpened = props.opened;
    let isClosing = false;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_4__.ref)(null);

    const onStepProgress = (instance, progress) => {
      emit('sheet:stepprogress', instance, progress);
    };

    const onStepOpen = instance => {
      emit('sheet:stepopen', instance);
    };

    const onStepClose = instance => {
      emit('sheet:stepclose', instance);
    };

    const onOpen = instance => {
      isOpened = true;
      isClosing = false;
      emit('sheet:open', instance);
      emit('update:opened', true);
    };

    const onOpened = instance => {
      emit('sheet:opened', instance);
    };

    const onClose = instance => {
      isOpened = false;
      isClosing = true;
      emit('sheet:close', instance);
    };

    const onClosed = instance => {
      isClosing = false;
      emit('sheet:closed', instance);
      emit('update:opened', false);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_4__.onMounted)(() => {
      if (!elRef.value) return;
      const sheetParams = {
        el: elRef.value,
        on: {
          open: onOpen,
          opened: onOpened,
          close: onClose,
          closed: onClosed,
          stepOpen: onStepOpen,
          stepClose: onStepClose,
          stepProgress: onStepProgress
        }
      };
      const {
        animate,
        backdrop,
        backdropEl,
        closeByBackdropClick,
        closeByOutsideClick,
        closeOnEscape,
        swipeToClose,
        swipeToStep,
        swipeHandler,
        containerEl
      } = props;
      if (typeof animate !== 'undefined') sheetParams.animate = animate;
      if (typeof backdrop !== 'undefined') sheetParams.backdrop = backdrop;
      if (typeof backdropEl !== 'undefined') sheetParams.backdropEl = backdropEl;
      if (typeof closeByBackdropClick !== 'undefined') sheetParams.closeByBackdropClick = closeByBackdropClick;
      if (typeof closeByOutsideClick !== 'undefined') sheetParams.closeByOutsideClick = closeByOutsideClick;
      if (typeof closeOnEscape !== 'undefined') sheetParams.closeOnEscape = closeOnEscape;
      if (typeof swipeToClose !== 'undefined') sheetParams.swipeToClose = swipeToClose;
      if (typeof swipeToStep !== 'undefined') sheetParams.swipeToStep = swipeToStep;
      if (typeof swipeHandler !== 'undefined') sheetParams.swipeHandler = swipeHandler;
      if (typeof containerEl !== 'undefined') sheetParams.containerEl = containerEl;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7ready)(() => {
        f7Sheet = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.sheet.create(sheetParams);

        if (props.opened) {
          f7Sheet.open(false);
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.onBeforeUnmount)(() => {
      if (f7Sheet) {
        f7Sheet.destroy();
      }

      f7Sheet = null;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_4__.watch)(() => props.opened, value => {
      if (!f7Sheet) return;

      if (value) {
        f7Sheet.open();
      } else {
        f7Sheet.close();
      }
    });
    ['closeByBackdropClick', 'closeByOutsideClick', 'closeOnEscape', 'swipeToClose'].forEach(propName => {
      (0,vue__WEBPACK_IMPORTED_MODULE_4__.watch)(() => props[propName], propValue => {
        if (!f7Sheet) return;
        f7Sheet.params[propName] = propValue;
      });
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_4__.computed)(() => {
      let positionComputed = 'bottom';
      if (props.position) positionComputed = props.position;else if (props.top) positionComputed = 'top';else if (props.bottom) positionComputed = 'bottom';
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('sheet-modal', `sheet-modal-${positionComputed}`, {
        'sheet-modal-push': props.push
      }, (0,_shared_modal_state_classes_js__WEBPACK_IMPORTED_MODULE_3__.modalStateClasses)({
        isOpened,
        isClosing
      }), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props));
    });
    const fixedTags = 'navbar toolbar tabbar subnavbar searchbar messagebar fab list-index panel'.split(' ').map(tagName => `f7-${tagName}`);
    return () => {
      const fixedList = [];
      const staticList = [];

      if (slots.default) {
        slots.default().forEach(vnode => {
          if (typeof vnode === 'undefined') return;
          const tag = vnode.type && vnode.type.name ? vnode.type.name : vnode.type;

          if (fixedTags.indexOf(tag) >= 0) {
            fixedList.push(vnode);
          } else {
            staticList.push(vnode);
          }
        });
      }

      return (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: classes.value,
        ref: elRef
      }, [fixedList, slots.fixed && slots.fixed(), (0,vue__WEBPACK_IMPORTED_MODULE_4__.h)('div', {
        class: 'sheet-modal-inner'
      }, [staticList, slots.static && slots.static()])]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/skeleton-avatar.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/skeleton-avatar.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var skeleton_elements_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! skeleton-elements/vue */ "./node_modules/skeleton-elements/vue/index.js");
// eslint-disable-next-line

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (skeleton_elements_vue__WEBPACK_IMPORTED_MODULE_0__.SkeletonAvatar);

/***/ }),

/***/ "./node_modules/framework7-vue/components/skeleton-block.js":
/*!******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/skeleton-block.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var skeleton_elements_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! skeleton-elements/vue */ "./node_modules/skeleton-elements/vue/index.js");
// eslint-disable-next-line

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (skeleton_elements_vue__WEBPACK_IMPORTED_MODULE_0__.SkeletonBlock);

/***/ }),

/***/ "./node_modules/framework7-vue/components/skeleton-image.js":
/*!******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/skeleton-image.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var skeleton_elements_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! skeleton-elements/vue */ "./node_modules/skeleton-elements/vue/index.js");
// eslint-disable-next-line

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (skeleton_elements_vue__WEBPACK_IMPORTED_MODULE_0__.SkeletonImage);

/***/ }),

/***/ "./node_modules/framework7-vue/components/skeleton-text.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/skeleton-text.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var skeleton_elements_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! skeleton-elements/vue */ "./node_modules/skeleton-elements/vue/index.js");
// eslint-disable-next-line

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (skeleton_elements_vue__WEBPACK_IMPORTED_MODULE_0__.SkeletonText);

/***/ }),

/***/ "./node_modules/framework7-vue/components/stepper.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7-vue/components/stepper.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = {
  key: 0,
  class: "stepper-input-wrap"
};
const _hoisted_2 = ["id", "name", "type", "min", "max", "step", "value", "readonly"];
const _hoisted_3 = {
  key: 1,
  class: "stepper-value"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    class: "stepper-button-minus",
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onMinusClick && _ctx.onMinusClick(...arguments);
    })
  }), _ctx.input && !_ctx.buttonsOnly ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("input", {
    id: _ctx.inputId,
    name: _ctx.name,
    type: _ctx.inputType,
    min: _ctx.inputType === 'number' ? _ctx.min : undefined,
    max: _ctx.inputType === 'number' ? _ctx.max : undefined,
    step: _ctx.inputType === 'number' ? _ctx.step : undefined,
    value: _ctx.value,
    readonly: _ctx.inputReadonly,
    onInput: _cache[1] || (_cache[1] = function () {
      return _ctx.onInput && _ctx.onInput(...arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function () {
      return _ctx.onChange && _ctx.onChange(...arguments);
    })
  }, null, 40, _hoisted_2)])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), !_ctx.input && !_ctx.buttonsOnly ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_3, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.value), 1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    class: "stepper-button-plus",
    onClick: _cache[3] || (_cache[3] = function () {
      return _ctx.onPlusClick && _ctx.onPlusClick(...arguments);
    })
  })], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-stepper',
  render,
  props: {
    init: {
      type: Boolean,
      default: true
    },
    value: {
      type: Number,
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    formatValue: Function,
    name: String,
    inputId: String,
    input: {
      type: Boolean,
      default: true
    },
    inputType: {
      type: String,
      default: 'text'
    },
    inputReadonly: {
      type: Boolean,
      default: false
    },
    autorepeat: {
      type: Boolean,
      default: false
    },
    autorepeatDynamic: {
      type: Boolean,
      default: false
    },
    wraps: {
      type: Boolean,
      default: false
    },
    manualInputMode: {
      type: Boolean,
      default: false
    },
    decimalPoint: {
      type: Number,
      default: 4
    },
    buttonsEndInputMode: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    buttonsOnly: Boolean,
    round: Boolean,
    roundMd: Boolean,
    roundIos: Boolean,
    roundAurora: Boolean,
    fill: Boolean,
    fillMd: Boolean,
    fillIos: Boolean,
    fillAurora: Boolean,
    large: Boolean,
    largeMd: Boolean,
    largeIos: Boolean,
    largeAurora: Boolean,
    small: Boolean,
    smallMd: Boolean,
    smallIos: Boolean,
    smallAurora: Boolean,
    raised: Boolean,
    raisedMd: Boolean,
    raisedIos: Boolean,
    raisedAurora: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['input', 'change', 'stepper:minusclick', 'stepper:plusclick', 'stepper:change', 'update:value'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    let f7Stepper = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const increment = () => {
      if (!f7Stepper) return;
      f7Stepper.increment();
    };

    const decrement = () => {
      if (!f7Stepper) return;
      f7Stepper.decrement();
    };

    const setValue = newValue => {
      if (f7Stepper && f7Stepper.setValue) f7Stepper.setValue(newValue);
    };

    const getValue = () => {
      if (f7Stepper && f7Stepper.getValue) {
        return f7Stepper.getValue();
      }

      return undefined;
    };

    const onInput = event => {
      emit('input', event, f7Stepper);
    };

    const onChange = event => {
      emit('change', event, f7Stepper);
    };

    const onMinusClick = event => {
      emit('stepper:minusclick', event, f7Stepper);
    };

    const onPlusClick = event => {
      emit('stepper:plusclick', event, f7Stepper);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.value, newValue => {
      if (!f7Stepper) return;
      f7Stepper.setValue(newValue);
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        if (!props.init || !elRef.value) return;
        f7Stepper = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.stepper.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.noUndefinedProps)({
          el: elRef.value,
          min: props.min,
          max: props.max,
          value: props.value,
          step: props.step,
          formatValue: props.formatValue,
          autorepeat: props.autorepeat,
          autorepeatDynamic: props.autorepeatDynamic,
          wraps: props.wraps,
          manualInputMode: props.manualInputMode,
          decimalPoint: props.decimalPoint,
          buttonsEndInputMode: props.buttonsEndInputMode,
          on: {
            change(stepper, newValue) {
              emit('stepper:change', newValue);
              emit('update:value', newValue);
            }

          }
        }));
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Stepper && f7Stepper.destroy) {
        f7Stepper.destroy();
      }

      f7Stepper = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('stepper', {
      disabled: props.disabled,
      'stepper-round': props.round,
      'stepper-round-ios': props.roundIos,
      'stepper-round-md': props.roundMd,
      'stepper-round-aurora': props.roundAurora,
      'stepper-fill': props.fill,
      'stepper-fill-ios': props.fillIos,
      'stepper-fill-md': props.fillMd,
      'stepper-fill-aurora': props.fillAurora,
      'stepper-large': props.large,
      'stepper-large-ios': props.largeIos,
      'stepper-large-md': props.largeMd,
      'stepper-large-aurora': props.largeAurora,
      'stepper-small': props.small,
      'stepper-small-ios': props.smallIos,
      'stepper-small-md': props.smallMd,
      'stepper-small-aurora': props.smallAurora,
      'stepper-raised': props.raised,
      'stepper-raised-ios': props.raisedIos,
      'stepper-raised-md': props.raisedMd,
      'stepper-raised-aurora': props.raisedAurora
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes,
      increment,
      decrement,
      setValue,
      getValue,
      onInput,
      onChange,
      onMinusClick,
      onPlusClick
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/subnavbar.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7-vue/components/subnavbar.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = {
  key: 0,
  class: "subnavbar-inner"
};
const _hoisted_2 = {
  key: 0,
  class: "subnavbar-title"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [_ctx.inner ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [_ctx.title ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.title), 1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default", {
    key: 1
  })], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-subnavbar',
  render,
  props: {
    sliding: Boolean,
    title: String,
    inner: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('subnavbar', {
      sliding: props.sliding
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/swipeout-actions.js":
/*!********************************************************************!*\
  !*** ./node_modules/framework7-vue/components/swipeout-actions.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-swipeout-actions',
  render,
  props: {
    left: Boolean,
    right: Boolean,
    side: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const side = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let sideComputed = props.side;

      if (!sideComputed) {
        if (props.left) sideComputed = 'left';
        if (props.right) sideComputed = 'right';
      }

      return sideComputed;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)(`swipeout-actions-${side.value}`, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/swipeout-button.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7-vue/components/swipeout-button.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");

const _hoisted_1 = ["href", "data-confirm", "data-confirm-title"];

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("a", {
    href: _ctx.href || '#',
    "data-confirm": _ctx.confirmText || undefined,
    "data-confirm-title": _ctx.confirmTitle || undefined,
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onClick && _ctx.onClick(...arguments);
    })
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.text) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 10, _hoisted_1);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-swipeout-button',
  render,
  props: {
    text: String,
    confirmTitle: String,
    confirmText: String,
    overswipe: Boolean,
    close: Boolean,
    delete: Boolean,
    href: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['click'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;

    const onClick = e => {
      emit('click', e);
    };

    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
      'swipeout-overswipe': props.overswipe,
      'swipeout-delete': props.delete,
      'swipeout-close': props.close
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      onClick
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/swiper-slide.js":
/*!****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/swiper-slide.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var swiper_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper/vue */ "./node_modules/swiper/vue/swiper-vue.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (swiper_vue__WEBPACK_IMPORTED_MODULE_0__.SwiperSlide);

/***/ }),

/***/ "./node_modules/framework7-vue/components/swiper.js":
/*!**********************************************************!*\
  !*** ./node_modules/framework7-vue/components/swiper.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var swiper_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper/vue */ "./node_modules/swiper/vue/swiper-vue.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (swiper_vue__WEBPACK_IMPORTED_MODULE_0__.Swiper);

/***/ }),

/***/ "./node_modules/framework7-vue/components/tab.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7-vue/components/tab.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_use_tab_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-tab.js */ "./node_modules/framework7-vue/shared/use-tab.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [_ctx.tabContent ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.getComponent(_ctx.tabContent)), (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
    key: 0,
    key: _ctx.tabContent.id
  }, _ctx.getProps(_ctx.tabContent)), null, 16)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default", {
    key: 1
  })], 2);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-tab',
  render,
  props: {
    tabActive: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['tab:show', 'tab:hide'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const routerData = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const route = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)('f7route', null);
    const router = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)('f7route', null);
    let initialTabContent = null;

    if (!routerData.value && route && route.route && route.route.tab && route.route.tab.id === props.id) {
      const {
        component,
        asyncComponent,
        options: tabRouteOptions
      } = route.route.tab;

      if (component || asyncComponent) {
        const parentProps = route.route.options && route.route.options.props;
        initialTabContent = {
          id: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.getComponentId)(),
          component: component || asyncComponent,
          isAsync: !!asyncComponent,
          props: { ...(parentProps || {}),
            ...(tabRouteOptions && tabRouteOptions.props || {}),
            f7router: router,
            f7route: route,
            ...route.params
          }
        };
      }
    }

    const tabContent = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(initialTabContent || null);

    const setTabContent = newContent => {
      tabContent.value = newContent;
    };

    if (_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7 && !routerData.value) {
      routerData.value = {
        setTabContent
      };
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7routers.tabs.push(routerData.value);
    }

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (elRef.value && initialTabContent) {
        elRef.value.f7RouterTabLoaded = true;
      }

      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        if (!routerData.value) {
          routerData.value = {
            el: elRef.value,
            setTabContent
          };
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7routers.tabs.push(routerData.value);
        } else {
          routerData.value.el = elRef.value;
        }
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (!routerData.value) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7routers.tabs.splice(_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7routers.tabs.indexOf(routerData.value), 1);
      routerData.value = null;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
      if (!routerData.value || !_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7events.emit('tabRouterDidUpdate', routerData.value);
    });
    (0,_shared_use_tab_js__WEBPACK_IMPORTED_MODULE_4__.useTab)(elRef, emit);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('tab', {
      'tab-active': props.tabActive
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));

    const getComponent = content => (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRaw)(content.component);

    const getProps = content => {
      const {
        component: tabComponent,
        props: tabProps
      } = content;
      let keys = [];
      const passProps = {};
      if (tabComponent && tabComponent.props) keys = Object.keys(tabComponent.props);
      keys.forEach(key => {
        if (key in tabProps) passProps[key] = tabProps[key];
      });
      return passProps;
    };

    return {
      elRef,
      classes,
      tabContent,
      getComponent,
      getProps
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/tabs.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/components/tabs.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return _ctx.animated || _ctx.swipeable ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    key: 0,
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classNames(_ctx.wrapClasses, _ctx.classes))
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.tabsClasses)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2)], 2)) : ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    key: 1,
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classNames(_ctx.tabsClasses, _ctx.classes))
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2));
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-tabs',
  render,
  props: {
    animated: Boolean,
    swipeable: Boolean,
    routable: Boolean,
    swiperParams: {
      type: Object,
      default: undefined
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (!props.swipeable || !props.swiperParams) return;
      if (!elRef.value) return;
      elRef.value.f7SwiperParams = props.swiperParams;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)((0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    const wrapClasses = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
      'tabs-animated-wrap': props.animated,
      'tabs-swipeable-wrap': props.swipeable
    }));
    const tabsClasses = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)({
      tabs: true,
      'tabs-routable': props.routable
    }));
    return {
      elRef,
      classes,
      wrapClasses,
      tabsClasses,
      classNames: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/text-editor.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7-vue/components/text-editor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");

const _hoisted_1 = {
  class: "text-editor-content",
  contenteditable: ""
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "root-start"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "root-end"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "root")], 2);
}





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-text-editor',
  render,
  props: {
    mode: {
      type: String,
      default: undefined
    },
    value: {
      type: String,
      default: undefined
    },
    buttons: Array,
    customButtons: Object,
    dividers: {
      type: Boolean,
      default: undefined
    },
    imageUrlText: {
      type: String,
      default: undefined
    },
    linkUrlText: {
      type: String,
      default: undefined
    },
    placeholder: {
      type: String,
      default: undefined
    },
    clearFormattingOnPaste: {
      type: Boolean,
      default: undefined
    },
    resizable: {
      type: Boolean,
      default: false
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['texteditor:change', 'texteditor:input', 'texteditor:focus', 'texteditor:blur', 'texteditor:buttonclick', 'texteditor:keyboardopen', 'texteditor:keyboardclose', 'texteditor:popoveropen', 'texteditor:popoverclose', 'texteditor:insertlink', 'texteditor:insertimage', 'texteditorChange', 'texteditorInput', 'texteditorFocus', 'texteditorBlur'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    let f7TextEditor = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const onChange = (editor, editorValue) => {
      emit('texteditor:change', editorValue);
      emit('texteditorChange', editorValue);
    };

    const onInput = (editor, editorValue) => {
      emit('texteditor:input', editorValue);
      emit('texteditorInput', editorValue);
    };

    const onFocus = () => {
      emit('texteditor:focus');
      emit('texteditorFocus');
    };

    const onBlur = () => {
      emit('texteditor:blur');
      emit('texteditorBlur');
    };

    const onButtonClick = (editor, button) => {
      emit('texteditor:buttonclick', button);
    };

    const onKeyboardOpen = () => {
      emit('texteditor:keyboardopen');
    };

    const onKeyboardClose = () => {
      emit('texteditor:keyboardclose');
    };

    const onPopoverOpen = () => {
      emit('texteditor:popoveropen');
    };

    const onPopoverClose = () => {
      emit('texteditor:popoverclose');
    };

    const onInsertLink = (editor, url) => {
      emit('texteditor:insertlink', url);
    };

    const onInsertImage = (editor, url) => {
      emit('texteditor:insertimage', url);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.value, newValue => {
      if (f7TextEditor) {
        f7TextEditor.setValue(newValue);
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      const params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.noUndefinedProps)({
        el: elRef.value,
        mode: props.mode,
        value: props.value,
        buttons: props.buttons,
        customButtons: props.customButtons,
        dividers: props.dividers,
        imageUrlText: props.imageUrlText,
        linkUrlText: props.linkUrlText,
        placeholder: props.placeholder,
        clearFormattingOnPaste: props.clearFormattingOnPaste,
        on: {
          change: onChange,
          input: onInput,
          focus: onFocus,
          blur: onBlur,
          buttonClick: onButtonClick,
          keyboardOpen: onKeyboardOpen,
          keyboardClose: onKeyboardClose,
          popoverOpen: onPopoverOpen,
          popoverClose: onPopoverClose,
          insertLink: onInsertLink,
          insertImage: onInsertImage
        }
      });
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        f7TextEditor = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.textEditor.create(params);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7TextEditor && f7TextEditor.destroy) {
        f7TextEditor.destroy();
      }

      f7TextEditor = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('text-editor', props.resizable && 'text-editor-resizable', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      elRef,
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/toggle.js":
/*!**********************************************************!*\
  !*** ./node_modules/framework7-vue/components/toggle.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-tooltip.js */ "./node_modules/framework7-vue/shared/use-tooltip.js");

const _hoisted_1 = ["name", "disabled", "readonly", "checked", "value"];

const _hoisted_2 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("span", {
  class: "toggle-icon"
}, null, -1);

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("label", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("input", {
    type: "checkbox",
    name: _ctx.name,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    checked: _ctx.checked,
    value: _ctx.value,
    onChange: _cache[0] || (_cache[0] = function () {
      return _ctx.onChange && _ctx.onChange(...arguments);
    })
  }, null, 40, _hoisted_1), _hoisted_2], 2);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-toggle',
  render,
  props: {
    init: {
      type: Boolean,
      default: true
    },
    checked: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    name: String,
    value: [String, Number, Array],
    tooltip: String,
    tooltipTrigger: String,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['change', 'toggle:change', 'update:checked'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    let f7Toggle = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    (0,_shared_use_tooltip_js__WEBPACK_IMPORTED_MODULE_4__.useTooltip)(elRef, props);

    const onChange = event => {
      emit('change', event);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => props.checked, newValue => {
      if (!f7Toggle) return;
      f7Toggle.checked = newValue;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7ready)(() => {
        if (!props.init || !elRef.value) return;
        f7Toggle = _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.toggle.create({
          el: elRef.value,
          on: {
            change(toggleInstance) {
              emit('toggle:change', toggleInstance.checked);
              emit('update:checked', toggleInstance.checked);
            }

          }
        });
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (f7Toggle && f7Toggle.destroy && f7Toggle.$el) {
        f7Toggle.destroy();
      }

      f7Toggle = null;
    });
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('toggle', {
      disabled: props.disabled
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes,
      elRef,
      f7Toggle,
      onChange
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/toolbar.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7-vue/components/toolbar.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_use_theme_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/use-theme.js */ "./node_modules/framework7-vue/shared/use-theme.js");

const _hoisted_1 = {
  key: 0,
  className: "toolbar-inner"
};

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "before-inner"), _ctx.inner ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default", {
    key: 1
  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "after-inner")], 2);
}






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-toolbar',
  render,
  props: {
    tabbar: Boolean,
    labels: Boolean,
    scrollable: Boolean,
    hidden: Boolean,
    noShadow: Boolean,
    noHairline: Boolean,
    noBorder: Boolean,
    position: {
      type: String,
      default: undefined
    },
    topMd: {
      type: Boolean,
      default: undefined
    },
    topIos: {
      type: Boolean,
      default: undefined
    },
    topAurora: {
      type: Boolean,
      default: undefined
    },
    top: {
      type: Boolean,
      default: undefined
    },
    bottomMd: {
      type: Boolean,
      default: undefined
    },
    bottomIos: {
      type: Boolean,
      default: undefined
    },
    bottomAurora: {
      type: Boolean,
      default: undefined
    },
    bottom: {
      type: Boolean,
      default: undefined
    },
    inner: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },
  emits: ['toolbar:hide', 'toolbar:show'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const theme = (0,_shared_use_theme_js__WEBPACK_IMPORTED_MODULE_4__.useTheme)();

    const onHide = toolbarEl => {
      if (elRef.value !== toolbarEl) return;
      emit('toolbar:hide');
    };

    const onShow = toolbarEl => {
      if (elRef.value !== toolbarEl) return;
      emit('toolbar:show');
    };

    const hide = animate => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.toolbar.hide(elRef.value, animate);
    };

    const show = animate => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.toolbar.show(elRef.value, animate);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      if (props.tabbar && _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7 && elRef.value) {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.toolbar.setHighlight(elRef.value);
      }

      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('toolbarShow', onShow);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.on('toolbarHide', onHide);
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('toolbarShow', onShow);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_3__.f7.off('toolbarHide', onHide);
    });
    const TabbarContext = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ({
      tabbarHasLabels: props.labels
    }));
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)('TabbarContext', TabbarContext);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const {
        tabbar,
        bottomMd,
        bottomIos,
        bottomAurora,
        bottom,
        position,
        topMd,
        topIos,
        topAurora,
        top,
        labels,
        scrollable,
        hidden,
        noShadow,
        noHairline,
        noBorder
      } = props;
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('toolbar', {
        tabbar,
        'toolbar-bottom': theme.value && theme.value.md && bottomMd || theme.value && theme.value.ios && bottomIos || theme.value && theme.value.aurora && bottomAurora || bottom || position === 'bottom',
        'toolbar-top': theme.value && theme.value.md && topMd || theme.value && theme.value.ios && topIos || theme.value && theme.value.aurora && topAurora || top || position === 'top',
        'tabbar-labels': labels,
        'tabbar-scrollable': scrollable,
        'toolbar-hidden': hidden,
        'no-shadow': noShadow,
        'no-hairline': noHairline || noBorder
      }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props));
    });
    return {
      classes,
      elRef,
      hide,
      show
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/treeview-item.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7-vue/components/treeview-item.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_use_icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-icon.js */ "./node_modules/framework7-vue/shared/use-icon.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _use_icon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./use-icon.js */ "./node_modules/framework7-vue/components/use-icon.js");

const _hoisted_1 = {
  key: 0,
  className: "treeview-toggle"
};
const _hoisted_2 = {
  className: "treeview-item-content"
};
const _hoisted_3 = {
  className: "treeview-item-label"
};
const _hoisted_4 = {
  key: 0,
  className: "treeview-item-children"
};

function render(_ctx, _cache) {
  const _component_f7_use_icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-use-icon");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    ref: "elRef",
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent)(_ctx.itemRootTag), (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
    class: _ctx.itemRootClasses
  }, _ctx.itemRootAttrs, {
    onClick: _ctx.onClick
  }), {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "root-start"), _ctx.needToggle ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "content-start"), _ctx.icon ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_use_icon, {
      key: 0,
      icon: _ctx.icon
    }, null, 8, ["icon"])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "media"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_3, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "label-start"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(" " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.label) + " ", 1), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "label")]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "content"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "content-end")]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "root"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "root-end")]),
    _: 3
  }, 16, ["class", "onClick"])), _ctx.hasChildren ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "children-start"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "children")])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)], 2);
}







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-treeview-item',
  render,
  components: {
    f7UseIcon: _use_icon_js__WEBPACK_IMPORTED_MODULE_5__["default"]
  },
  props: {
    toggle: {
      type: Boolean,
      default: undefined
    },
    itemToggle: Boolean,
    selectable: Boolean,
    selected: Boolean,
    opened: Boolean,
    label: String,
    loadChildren: Boolean,
    link: {
      type: [Boolean, String],
      default: undefined
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.iconProps,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerProps
  },
  emits: ['click', 'treeview:open', 'treeview:close', 'treeview:loadchildren'],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const hasChildren = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return slots.default || slots.children || slots['children-start'];
    });
    const needToggle = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => typeof props.toggle === 'undefined' ? hasChildren.value : props.toggle);
    const icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_use_icon_js__WEBPACK_IMPORTED_MODULE_3__.useIcon)(props));

    const onClick = event => {
      emit('click', event);
    };

    const onOpen = el => {
      if (elRef.value !== el) return;
      emit('treeview:open', el);
    };

    const onClose = el => {
      if (elRef.value !== el) return;
      emit('treeview:close', el);
    };

    const onLoadChildren = (el, done) => {
      if (elRef.value !== el) return;
      emit('treeview:loadchildren', el, done);
    };

    const attachEvents = () => {
      if (!elRef.value) return;
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7ready)(() => {
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7.on('treeviewOpen', onOpen);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7.on('treeviewClose', onClose);
        _shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7.on('treeviewLoadChildren', onLoadChildren);
      });
    };

    const detachEvents = () => {
      if (!_shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7.off('treeviewOpen', onOpen);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7.off('treeviewClose', onClose);
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_4__.f7.off('treeviewLoadChildren', onLoadChildren);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => attachEvents());
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => detachEvents());
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('treeview-item', {
      'treeview-item-opened': props.opened,
      'treeview-load-children': props.loadChildren
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    const itemRootClasses = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('treeview-item-root', {
      'treeview-item-selectable': props.selectable,
      'treeview-item-selected': props.selected,
      'treeview-item-toggle': props.itemToggle
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerClasses)(props), (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsClasses)(props)));
    const itemRootTag = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.link || props.link === '' ? 'a' : 'div');
    const itemRootAttrs = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let href = props.link;
      if (props.link === true) href = '#';
      if (props.link === false) href = undefined; // no href attribute

      return {
        href,
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.routerAttrs)(props),
        ...(0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.actionsAttrs)(props)
      };
    });
    return {
      itemRootTag,
      itemRootAttrs,
      itemRootClasses,
      classes,
      icon,
      onClick,
      hasChildren,
      needToggle,
      elRef
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/treeview.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7-vue/components/treeview.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-treeview',
  render,
  props: { ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('treeview', (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/use-icon.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7-vue/components/use-icon.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ "./node_modules/framework7-vue/components/icon.js");
/* harmony import */ var _badge_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./badge.js */ "./node_modules/framework7-vue/components/badge.js");


function render(_ctx, _cache) {
  const _component_f7_badge = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-badge");

  const _component_f7_icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("f7-icon");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_icon, (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeProps)((0,vue__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps)(_ctx.icon.props)), {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [_ctx.icon.badge ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_f7_badge, (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeProps)((0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
      key: 0
    }, _ctx.icon.badge.props)), {
      default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.icon.badge.content), 1)]),
      _: 1
    }, 16)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", true)]),
    _: 1
  }, 16);
}



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-use-icon',
  render,
  components: {
    f7Icon: _icon_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    f7Badge: _badge_js__WEBPACK_IMPORTED_MODULE_2__["default"]
  },
  props: {
    icon: Object
  }
});

/***/ }),

/***/ "./node_modules/framework7-vue/components/view.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/components/view.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_use_tab_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/use-tab.js */ "./node_modules/framework7-vue/shared/use-tab.js");
/* harmony import */ var _shared_get_router_initial_component_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/get-router-initial-component.js */ "./node_modules/framework7-vue/shared/get-router-initial-component.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-view',
  props: {
    tab: Boolean,
    tabActive: Boolean,
    name: String,
    initRouterOnTabShow: {
      type: Boolean,
      default: undefined
    },
    router: {
      type: Boolean,
      default: true
    },
    linksView: [Object, String],
    url: String,
    main: {
      type: Boolean,
      default: undefined
    },
    stackPages: {
      type: Boolean,
      default: undefined
    },
    xhrCache: {
      type: Boolean,
      default: undefined
    },
    xhrCacheIgnore: Array,
    xhrCacheIgnoreGetParameters: {
      type: Boolean,
      default: undefined
    },
    xhrCacheDuration: Number,
    preloadPreviousPage: {
      type: Boolean,
      default: undefined
    },
    allowDuplicateUrls: {
      type: Boolean,
      default: undefined
    },
    reloadPages: {
      type: Boolean,
      default: undefined
    },
    reloadDetail: {
      type: Boolean,
      default: undefined
    },
    masterDetailResizable: {
      type: Boolean,
      default: undefined
    },
    masterDetailBreakpoint: Number,
    removeElements: {
      type: Boolean,
      default: undefined
    },
    removeElementsWithTimeout: {
      type: Boolean,
      default: undefined
    },
    removeElementsTimeout: Number,
    restoreScrollTopOnBack: {
      type: Boolean,
      default: undefined
    },
    loadInitialPage: {
      type: Boolean,
      default: undefined
    },
    // Swipe Back
    iosSwipeBack: {
      type: Boolean,
      default: undefined
    },
    iosSwipeBackAnimateShadow: {
      type: Boolean,
      default: undefined
    },
    iosSwipeBackAnimateOpacity: {
      type: Boolean,
      default: undefined
    },
    iosSwipeBackActiveArea: Number,
    iosSwipeBackThreshold: Number,
    mdSwipeBack: {
      type: Boolean,
      default: undefined
    },
    mdSwipeBackAnimateShadow: {
      type: Boolean,
      default: undefined
    },
    mdSwipeBackAnimateOpacity: {
      type: Boolean,
      default: undefined
    },
    mdSwipeBackActiveArea: Number,
    mdSwipeBackThreshold: Number,
    auroraSwipeBack: {
      type: Boolean,
      default: undefined
    },
    auroraSwipeBackAnimateShadow: {
      type: Boolean,
      default: undefined
    },
    auroraSwipeBackAnimateOpacity: {
      type: Boolean,
      default: undefined
    },
    auroraSwipeBackActiveArea: Number,
    auroraSwipeBackThreshold: Number,
    // Push State
    browserHistory: {
      type: Boolean,
      default: undefined
    },
    browserHistoryRoot: String,
    browserHistoryAnimate: {
      type: Boolean,
      default: undefined
    },
    browserHistoryAnimateOnLoad: {
      type: Boolean,
      default: undefined
    },
    browserHistorySeparator: String,
    browserHistoryOnLoad: {
      type: Boolean,
      default: undefined
    },
    browserHistoryInitialMatch: {
      type: Boolean,
      default: true
    },
    browserHistoryStoreHistory: {
      type: Boolean,
      default: undefined
    },
    // Animate Pages
    animate: {
      type: Boolean,
      default: undefined
    },
    transition: String,
    // iOS Dynamic Navbar
    iosDynamicNavbar: {
      type: Boolean,
      default: undefined
    },
    // Animate iOS Navbar Back Icon
    iosAnimateNavbarBackIcon: {
      type: Boolean,
      default: undefined
    },
    // MD Theme delay
    materialPageLoadDelay: Number,
    passRouteQueryToRequest: {
      type: Boolean,
      default: undefined
    },
    passRouteParamsToRequest: {
      type: Boolean,
      default: undefined
    },
    routes: Array,
    routesAdd: Array,
    // Routes hooks
    routesBeforeEnter: [Function, Array],
    routesBeforeLeave: [Function, Array],
    init: {
      type: Boolean,
      default: true
    },
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorProps
  },
  emits: ['view:init', 'view:resize', 'swipeback:move', 'swipeback:beforechange', 'swipeback:afterchange', 'swipeback:beforereset', 'swipeback:afterreset', 'tab:hide', 'tab:show'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    // const childrenArray = React.Children.toArray(children);
    // const initialPageComponent = childrenArray.filter((c) => c.props && c.props.initialPage)[0];
    // const restChildren = childrenArray.filter((c) => !c.props || !c.props.initialPage);
    const initialPageComponent = null;
    const shouldInitRouter = !(props.initRouterOnTabShow && props.tab && !props.tabActive);
    let f7View = null;
    const elRef = (0,vue__WEBPACK_IMPORTED_MODULE_5__.ref)(null);
    let routerData = null;
    let initialPage;
    let initialRoute;

    const onViewInit = view => {
      emit('view:init', view);

      if (!props.init) {
        routerData.instance = view;
        f7View = routerData.instance;
      }
    };

    const getViewParams = () => {
      const routes = (0,vue__WEBPACK_IMPORTED_MODULE_5__.toRaw)(props.routes || []);
      const routesAdd = (0,vue__WEBPACK_IMPORTED_MODULE_5__.toRaw)(props.routesAdd || []);
      return (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.noUndefinedProps)({ ...props,
        routes,
        routesAdd
      });
    };

    if (_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7 && !f7View && props.init) {
      const routerId = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.getRouterId)();
      f7View = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.views.create(elRef.value, { ...getViewParams(),
        routerId,
        init: false,
        on: {
          init: onViewInit
        }
      });
      routerData = {
        routerId,
        instance: f7View
      };
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7routers.views.push(routerData);

      if (shouldInitRouter && f7View && f7View.router && (props.url || props.main)) {
        const initialData = (0,_shared_get_router_initial_component_js__WEBPACK_IMPORTED_MODULE_4__.getRouterInitialComponent)(f7View.router, initialPageComponent);
        initialPage = initialData.initialPage;
        initialRoute = initialData.initialRoute;

        if (initialRoute && initialRoute.route && initialRoute.route.masterRoute) {
          initialPage = undefined;
          initialRoute = undefined;
        }
      }
    }

    const pages = (0,vue__WEBPACK_IMPORTED_MODULE_5__.ref)(initialPage ? [initialPage] : []);

    const setPages = newPages => {
      newPages.forEach(page => {
        // eslint-disable-next-line
        page.component = (0,vue__WEBPACK_IMPORTED_MODULE_5__.toRaw)(page.component);
      });
      pages.value = newPages;
    };

    const onResize = (view, width) => {
      emit('view:resize', width);
    };

    const onSwipeBackMove = data => {
      const swipeBackData = data;
      emit('swipeback:move', swipeBackData);
    };

    const onSwipeBackBeforeChange = data => {
      const swipeBackData = data;
      emit('swipeback:beforechange', swipeBackData);
    };

    const onSwipeBackAfterChange = data => {
      const swipeBackData = data;
      emit('swipeback:afterchange', swipeBackData);
    };

    const onSwipeBackBeforeReset = data => {
      const swipeBackData = data;
      emit('swipeback:beforereset', swipeBackData);
    };

    const onSwipeBackAfterReset = data => {
      const swipeBackData = data;
      emit('swipeback:afterreset', swipeBackData);
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_5__.onMounted)(() => {
      (0,_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7ready)(() => {
        if (f7View) {
          routerData.el = elRef.value;
          routerData.pages = pages.value;

          routerData.setPages = newPages => {
            setPages([...newPages]);
          };

          if (initialPage && initialPage.isAsync && !initialPage.initialComponent) {
            initialPage.component().then(() => {
              setTimeout(() => {
                f7View.init(elRef.value);

                if (initialPage) {
                  initialPage.el = f7View.router.currentPageEl;

                  if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
                    initialRoute.route.keepAliveData = {
                      pageEl: initialPage.el
                    };
                  }
                }
              }, 100);
            });
          } else {
            f7View.init(elRef.value);

            if (initialPage) {
              initialPage.el = f7View.router.currentPageEl;

              if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
                initialRoute.route.keepAliveData = {
                  pageEl: initialPage.el
                };
              }
            }
          }
        } else {
          const routerId = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.getRouterId)();
          routerData = {
            el: elRef.value,
            routerId,
            pages: pages.value,
            instance: f7View,

            setPages(newPages) {
              setPages([...newPages]);
            }

          };
          _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7routers.views.push(routerData);
          routerData.instance = _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7.views.create(elRef.value, {
            routerId,
            ...getViewParams(),
            on: {
              init: onViewInit
            }
          });
          f7View = routerData.instance;
        }

        if (!props.init) return;
        f7View.on('resize', onResize);
        f7View.on('swipebackMove', onSwipeBackMove);
        f7View.on('swipebackBeforeChange', onSwipeBackBeforeChange);
        f7View.on('swipebackAfterChange', onSwipeBackAfterChange);
        f7View.on('swipebackBeforeReset', onSwipeBackBeforeReset);
        f7View.on('swipebackAfterReset', onSwipeBackAfterReset);
      });
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_5__.onBeforeUnmount)(() => {
      if (f7View) {
        f7View.off('resize', onResize);
        f7View.off('swipebackMove', onSwipeBackMove);
        f7View.off('swipebackBeforeChange', onSwipeBackBeforeChange);
        f7View.off('swipebackAfterChange', onSwipeBackAfterChange);
        f7View.off('swipebackBeforeReset', onSwipeBackBeforeReset);
        f7View.off('swipebackAfterReset', onSwipeBackAfterReset);
        if (f7View.destroy) f7View.destroy();
        f7View = null;
      }

      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7routers.views.splice(_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7routers.views.indexOf(routerData), 1);
      routerData = null;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_5__.onUpdated)(() => {
      if (!routerData || !_shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7) return;
      _shared_f7_js__WEBPACK_IMPORTED_MODULE_2__.f7events.emit('viewRouterDidUpdate', routerData);
    });
    (0,_shared_use_tab_js__WEBPACK_IMPORTED_MODULE_3__.useTab)(elRef, emit);
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_5__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.classNames)('view', {
      'view-main': props.main,
      'tab-active': props.tabActive,
      tab: props.tab
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_1__.colorClasses)(props)));

    const getComponent = page => (0,vue__WEBPACK_IMPORTED_MODULE_5__.toRaw)(page.component);

    const getProps = page => {
      const {
        component: pageComponent,
        props: pageProps
      } = page;
      let keys = [];
      const passProps = {};
      if (pageComponent && pageComponent.props) keys = Object.keys(pageComponent.props);
      keys.forEach(key => {
        if (key in pageProps) passProps[key] = pageProps[key];
      });
      return passProps;
    };

    return () => {
      return (0,vue__WEBPACK_IMPORTED_MODULE_5__.h)('div', {
        ref: elRef,
        class: classes.value
      }, [slots.default && slots.default(), ...pages.value.map(page => (0,vue__WEBPACK_IMPORTED_MODULE_5__.h)(getComponent(page), {
        key: page.id,
        ...getProps(page)
      }))]);
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/components/views.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/components/views.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/mixins.js */ "./node_modules/framework7-vue/shared/mixins.js");


function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
    class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(_ctx.classes)
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "default")], 2);
}




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'f7-views',
  render,
  props: {
    tabs: Boolean,
    ..._shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorProps
  },

  setup(props) {
    const classes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.classNames)('views', {
      tabs: props.tabs
    }, (0,_shared_mixins_js__WEBPACK_IMPORTED_MODULE_2__.colorClasses)(props)));
    return {
      classes
    };
  }

});

/***/ }),

/***/ "./node_modules/framework7-vue/framework7-vue-bundle.js":
/*!**************************************************************!*\
  !*** ./node_modules/framework7-vue/framework7-vue-bundle.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "f7": () => (/* reexport safe */ _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__.f7),
/* harmony export */   "f7Accordion": () => (/* reexport safe */ _components_accordion_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "f7AccordionContent": () => (/* reexport safe */ _components_accordion_content_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "f7AccordionItem": () => (/* reexport safe */ _components_accordion_item_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "f7AccordionToggle": () => (/* reexport safe */ _components_accordion_toggle_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "f7Actions": () => (/* reexport safe */ _components_actions_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "f7ActionsButton": () => (/* reexport safe */ _components_actions_button_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "f7ActionsGroup": () => (/* reexport safe */ _components_actions_group_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "f7ActionsLabel": () => (/* reexport safe */ _components_actions_label_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "f7App": () => (/* reexport safe */ _components_app_js__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "f7Appbar": () => (/* reexport safe */ _components_appbar_js__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "f7AreaChart": () => (/* reexport safe */ _components_area_chart_js__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "f7Badge": () => (/* reexport safe */ _components_badge_js__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   "f7Block": () => (/* reexport safe */ _components_block_js__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   "f7BlockFooter": () => (/* reexport safe */ _components_block_footer_js__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   "f7BlockHeader": () => (/* reexport safe */ _components_block_header_js__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   "f7BlockTitle": () => (/* reexport safe */ _components_block_title_js__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   "f7Breadcrumbs": () => (/* reexport safe */ _components_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   "f7BreadcrumbsCollapsed": () => (/* reexport safe */ _components_breadcrumbs_collapsed_js__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   "f7BreadcrumbsItem": () => (/* reexport safe */ _components_breadcrumbs_item_js__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   "f7BreadcrumbsSeparator": () => (/* reexport safe */ _components_breadcrumbs_separator_js__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   "f7Button": () => (/* reexport safe */ _components_button_js__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   "f7Card": () => (/* reexport safe */ _components_card_js__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   "f7CardContent": () => (/* reexport safe */ _components_card_content_js__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   "f7CardFooter": () => (/* reexport safe */ _components_card_footer_js__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   "f7CardHeader": () => (/* reexport safe */ _components_card_header_js__WEBPACK_IMPORTED_MODULE_26__["default"]),
/* harmony export */   "f7Checkbox": () => (/* reexport safe */ _components_checkbox_js__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   "f7Chip": () => (/* reexport safe */ _components_chip_js__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   "f7Col": () => (/* reexport safe */ _components_col_js__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   "f7Fab": () => (/* reexport safe */ _components_fab_js__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   "f7FabBackdrop": () => (/* reexport safe */ _components_fab_backdrop_js__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   "f7FabButton": () => (/* reexport safe */ _components_fab_button_js__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   "f7FabButtons": () => (/* reexport safe */ _components_fab_buttons_js__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   "f7Gauge": () => (/* reexport safe */ _components_gauge_js__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   "f7Icon": () => (/* reexport safe */ _components_icon_js__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   "f7Input": () => (/* reexport safe */ _components_input_js__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   "f7Link": () => (/* reexport safe */ _components_link_js__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   "f7List": () => (/* reexport safe */ _components_list_js__WEBPACK_IMPORTED_MODULE_46__["default"]),
/* harmony export */   "f7ListButton": () => (/* reexport safe */ _components_list_button_js__WEBPACK_IMPORTED_MODULE_39__["default"]),
/* harmony export */   "f7ListGroup": () => (/* reexport safe */ _components_list_group_js__WEBPACK_IMPORTED_MODULE_40__["default"]),
/* harmony export */   "f7ListIndex": () => (/* reexport safe */ _components_list_index_js__WEBPACK_IMPORTED_MODULE_41__["default"]),
/* harmony export */   "f7ListInput": () => (/* reexport safe */ _components_list_input_js__WEBPACK_IMPORTED_MODULE_42__["default"]),
/* harmony export */   "f7ListItem": () => (/* reexport safe */ _components_list_item_js__WEBPACK_IMPORTED_MODULE_45__["default"]),
/* harmony export */   "f7ListItemCell": () => (/* reexport safe */ _components_list_item_cell_js__WEBPACK_IMPORTED_MODULE_43__["default"]),
/* harmony export */   "f7ListItemRow": () => (/* reexport safe */ _components_list_item_row_js__WEBPACK_IMPORTED_MODULE_44__["default"]),
/* harmony export */   "f7LoginScreen": () => (/* reexport safe */ _components_login_screen_js__WEBPACK_IMPORTED_MODULE_48__["default"]),
/* harmony export */   "f7LoginScreenTitle": () => (/* reexport safe */ _components_login_screen_title_js__WEBPACK_IMPORTED_MODULE_47__["default"]),
/* harmony export */   "f7Menu": () => (/* reexport safe */ _components_menu_js__WEBPACK_IMPORTED_MODULE_52__["default"]),
/* harmony export */   "f7MenuDropdown": () => (/* reexport safe */ _components_menu_dropdown_js__WEBPACK_IMPORTED_MODULE_50__["default"]),
/* harmony export */   "f7MenuDropdownItem": () => (/* reexport safe */ _components_menu_dropdown_item_js__WEBPACK_IMPORTED_MODULE_49__["default"]),
/* harmony export */   "f7MenuItem": () => (/* reexport safe */ _components_menu_item_js__WEBPACK_IMPORTED_MODULE_51__["default"]),
/* harmony export */   "f7Message": () => (/* reexport safe */ _components_message_js__WEBPACK_IMPORTED_MODULE_53__["default"]),
/* harmony export */   "f7Messagebar": () => (/* reexport safe */ _components_messagebar_js__WEBPACK_IMPORTED_MODULE_59__["default"]),
/* harmony export */   "f7MessagebarAttachment": () => (/* reexport safe */ _components_messagebar_attachment_js__WEBPACK_IMPORTED_MODULE_54__["default"]),
/* harmony export */   "f7MessagebarAttachments": () => (/* reexport safe */ _components_messagebar_attachments_js__WEBPACK_IMPORTED_MODULE_55__["default"]),
/* harmony export */   "f7MessagebarSheet": () => (/* reexport safe */ _components_messagebar_sheet_js__WEBPACK_IMPORTED_MODULE_58__["default"]),
/* harmony export */   "f7MessagebarSheetImage": () => (/* reexport safe */ _components_messagebar_sheet_image_js__WEBPACK_IMPORTED_MODULE_56__["default"]),
/* harmony export */   "f7MessagebarSheetItem": () => (/* reexport safe */ _components_messagebar_sheet_item_js__WEBPACK_IMPORTED_MODULE_57__["default"]),
/* harmony export */   "f7Messages": () => (/* reexport safe */ _components_messages_js__WEBPACK_IMPORTED_MODULE_61__["default"]),
/* harmony export */   "f7MessagesTitle": () => (/* reexport safe */ _components_messages_title_js__WEBPACK_IMPORTED_MODULE_60__["default"]),
/* harmony export */   "f7NavLeft": () => (/* reexport safe */ _components_nav_left_js__WEBPACK_IMPORTED_MODULE_62__["default"]),
/* harmony export */   "f7NavRight": () => (/* reexport safe */ _components_nav_right_js__WEBPACK_IMPORTED_MODULE_63__["default"]),
/* harmony export */   "f7NavTitle": () => (/* reexport safe */ _components_nav_title_js__WEBPACK_IMPORTED_MODULE_65__["default"]),
/* harmony export */   "f7NavTitleLarge": () => (/* reexport safe */ _components_nav_title_large_js__WEBPACK_IMPORTED_MODULE_64__["default"]),
/* harmony export */   "f7Navbar": () => (/* reexport safe */ _components_navbar_js__WEBPACK_IMPORTED_MODULE_66__["default"]),
/* harmony export */   "f7Page": () => (/* reexport safe */ _components_page_js__WEBPACK_IMPORTED_MODULE_68__["default"]),
/* harmony export */   "f7PageContent": () => (/* reexport safe */ _components_page_content_js__WEBPACK_IMPORTED_MODULE_67__["default"]),
/* harmony export */   "f7Panel": () => (/* reexport safe */ _components_panel_js__WEBPACK_IMPORTED_MODULE_69__["default"]),
/* harmony export */   "f7PhotoBrowser": () => (/* reexport safe */ _components_photo_browser_js__WEBPACK_IMPORTED_MODULE_70__["default"]),
/* harmony export */   "f7PieChart": () => (/* reexport safe */ _components_pie_chart_js__WEBPACK_IMPORTED_MODULE_71__["default"]),
/* harmony export */   "f7Popover": () => (/* reexport safe */ _components_popover_js__WEBPACK_IMPORTED_MODULE_72__["default"]),
/* harmony export */   "f7Popup": () => (/* reexport safe */ _components_popup_js__WEBPACK_IMPORTED_MODULE_73__["default"]),
/* harmony export */   "f7Preloader": () => (/* reexport safe */ _components_preloader_js__WEBPACK_IMPORTED_MODULE_74__["default"]),
/* harmony export */   "f7Progressbar": () => (/* reexport safe */ _components_progressbar_js__WEBPACK_IMPORTED_MODULE_75__["default"]),
/* harmony export */   "f7Radio": () => (/* reexport safe */ _components_radio_js__WEBPACK_IMPORTED_MODULE_76__["default"]),
/* harmony export */   "f7Range": () => (/* reexport safe */ _components_range_js__WEBPACK_IMPORTED_MODULE_77__["default"]),
/* harmony export */   "f7RoutableModals": () => (/* reexport safe */ _components_routable_modals_js__WEBPACK_IMPORTED_MODULE_78__["default"]),
/* harmony export */   "f7Row": () => (/* reexport safe */ _components_row_js__WEBPACK_IMPORTED_MODULE_79__["default"]),
/* harmony export */   "f7Searchbar": () => (/* reexport safe */ _components_searchbar_js__WEBPACK_IMPORTED_MODULE_80__["default"]),
/* harmony export */   "f7Segmented": () => (/* reexport safe */ _components_segmented_js__WEBPACK_IMPORTED_MODULE_81__["default"]),
/* harmony export */   "f7Sheet": () => (/* reexport safe */ _components_sheet_js__WEBPACK_IMPORTED_MODULE_82__["default"]),
/* harmony export */   "f7SkeletonAvatar": () => (/* reexport safe */ _components_skeleton_avatar_js__WEBPACK_IMPORTED_MODULE_83__["default"]),
/* harmony export */   "f7SkeletonBlock": () => (/* reexport safe */ _components_skeleton_block_js__WEBPACK_IMPORTED_MODULE_84__["default"]),
/* harmony export */   "f7SkeletonImage": () => (/* reexport safe */ _components_skeleton_image_js__WEBPACK_IMPORTED_MODULE_85__["default"]),
/* harmony export */   "f7SkeletonText": () => (/* reexport safe */ _components_skeleton_text_js__WEBPACK_IMPORTED_MODULE_86__["default"]),
/* harmony export */   "f7Stepper": () => (/* reexport safe */ _components_stepper_js__WEBPACK_IMPORTED_MODULE_87__["default"]),
/* harmony export */   "f7Subnavbar": () => (/* reexport safe */ _components_subnavbar_js__WEBPACK_IMPORTED_MODULE_88__["default"]),
/* harmony export */   "f7SwipeoutActions": () => (/* reexport safe */ _components_swipeout_actions_js__WEBPACK_IMPORTED_MODULE_89__["default"]),
/* harmony export */   "f7SwipeoutButton": () => (/* reexport safe */ _components_swipeout_button_js__WEBPACK_IMPORTED_MODULE_90__["default"]),
/* harmony export */   "f7Swiper": () => (/* reexport safe */ _components_swiper_js__WEBPACK_IMPORTED_MODULE_92__["default"]),
/* harmony export */   "f7SwiperSlide": () => (/* reexport safe */ _components_swiper_slide_js__WEBPACK_IMPORTED_MODULE_91__["default"]),
/* harmony export */   "f7Tab": () => (/* reexport safe */ _components_tab_js__WEBPACK_IMPORTED_MODULE_93__["default"]),
/* harmony export */   "f7Tabs": () => (/* reexport safe */ _components_tabs_js__WEBPACK_IMPORTED_MODULE_94__["default"]),
/* harmony export */   "f7TextEditor": () => (/* reexport safe */ _components_text_editor_js__WEBPACK_IMPORTED_MODULE_95__["default"]),
/* harmony export */   "f7Toggle": () => (/* reexport safe */ _components_toggle_js__WEBPACK_IMPORTED_MODULE_96__["default"]),
/* harmony export */   "f7Toolbar": () => (/* reexport safe */ _components_toolbar_js__WEBPACK_IMPORTED_MODULE_97__["default"]),
/* harmony export */   "f7Treeview": () => (/* reexport safe */ _components_treeview_js__WEBPACK_IMPORTED_MODULE_99__["default"]),
/* harmony export */   "f7TreeviewItem": () => (/* reexport safe */ _components_treeview_item_js__WEBPACK_IMPORTED_MODULE_98__["default"]),
/* harmony export */   "f7UseIcon": () => (/* reexport safe */ _components_use_icon_js__WEBPACK_IMPORTED_MODULE_100__["default"]),
/* harmony export */   "f7View": () => (/* reexport safe */ _components_view_js__WEBPACK_IMPORTED_MODULE_101__["default"]),
/* harmony export */   "f7Views": () => (/* reexport safe */ _components_views_js__WEBPACK_IMPORTED_MODULE_102__["default"]),
/* harmony export */   "f7ready": () => (/* reexport safe */ _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__.f7ready),
/* harmony export */   "registerComponents": () => (/* binding */ registerComponents),
/* harmony export */   "theme": () => (/* reexport safe */ _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__.theme),
/* harmony export */   "useStore": () => (/* reexport safe */ _shared_use_store_js__WEBPACK_IMPORTED_MODULE_2__.useStore)
/* harmony export */ });
/* harmony import */ var _shared_plugin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/plugin.js */ "./node_modules/framework7-vue/shared/plugin.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_use_store_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/use-store.js */ "./node_modules/framework7-vue/shared/use-store.js");
/* harmony import */ var _components_accordion_content_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/accordion-content.js */ "./node_modules/framework7-vue/components/accordion-content.js");
/* harmony import */ var _components_accordion_item_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/accordion-item.js */ "./node_modules/framework7-vue/components/accordion-item.js");
/* harmony import */ var _components_accordion_toggle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/accordion-toggle.js */ "./node_modules/framework7-vue/components/accordion-toggle.js");
/* harmony import */ var _components_accordion_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/accordion.js */ "./node_modules/framework7-vue/components/accordion.js");
/* harmony import */ var _components_actions_button_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/actions-button.js */ "./node_modules/framework7-vue/components/actions-button.js");
/* harmony import */ var _components_actions_group_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/actions-group.js */ "./node_modules/framework7-vue/components/actions-group.js");
/* harmony import */ var _components_actions_label_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/actions-label.js */ "./node_modules/framework7-vue/components/actions-label.js");
/* harmony import */ var _components_actions_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/actions.js */ "./node_modules/framework7-vue/components/actions.js");
/* harmony import */ var _components_app_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/app.js */ "./node_modules/framework7-vue/components/app.js");
/* harmony import */ var _components_appbar_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/appbar.js */ "./node_modules/framework7-vue/components/appbar.js");
/* harmony import */ var _components_area_chart_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/area-chart.js */ "./node_modules/framework7-vue/components/area-chart.js");
/* harmony import */ var _components_badge_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/badge.js */ "./node_modules/framework7-vue/components/badge.js");
/* harmony import */ var _components_block_footer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/block-footer.js */ "./node_modules/framework7-vue/components/block-footer.js");
/* harmony import */ var _components_block_header_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/block-header.js */ "./node_modules/framework7-vue/components/block-header.js");
/* harmony import */ var _components_block_title_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/block-title.js */ "./node_modules/framework7-vue/components/block-title.js");
/* harmony import */ var _components_block_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/block.js */ "./node_modules/framework7-vue/components/block.js");
/* harmony import */ var _components_breadcrumbs_collapsed_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/breadcrumbs-collapsed.js */ "./node_modules/framework7-vue/components/breadcrumbs-collapsed.js");
/* harmony import */ var _components_breadcrumbs_item_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/breadcrumbs-item.js */ "./node_modules/framework7-vue/components/breadcrumbs-item.js");
/* harmony import */ var _components_breadcrumbs_separator_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/breadcrumbs-separator.js */ "./node_modules/framework7-vue/components/breadcrumbs-separator.js");
/* harmony import */ var _components_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/breadcrumbs.js */ "./node_modules/framework7-vue/components/breadcrumbs.js");
/* harmony import */ var _components_button_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/button.js */ "./node_modules/framework7-vue/components/button.js");
/* harmony import */ var _components_card_content_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/card-content.js */ "./node_modules/framework7-vue/components/card-content.js");
/* harmony import */ var _components_card_footer_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/card-footer.js */ "./node_modules/framework7-vue/components/card-footer.js");
/* harmony import */ var _components_card_header_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./components/card-header.js */ "./node_modules/framework7-vue/components/card-header.js");
/* harmony import */ var _components_card_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./components/card.js */ "./node_modules/framework7-vue/components/card.js");
/* harmony import */ var _components_checkbox_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./components/checkbox.js */ "./node_modules/framework7-vue/components/checkbox.js");
/* harmony import */ var _components_chip_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./components/chip.js */ "./node_modules/framework7-vue/components/chip.js");
/* harmony import */ var _components_col_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./components/col.js */ "./node_modules/framework7-vue/components/col.js");
/* harmony import */ var _components_fab_backdrop_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./components/fab-backdrop.js */ "./node_modules/framework7-vue/components/fab-backdrop.js");
/* harmony import */ var _components_fab_button_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./components/fab-button.js */ "./node_modules/framework7-vue/components/fab-button.js");
/* harmony import */ var _components_fab_buttons_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./components/fab-buttons.js */ "./node_modules/framework7-vue/components/fab-buttons.js");
/* harmony import */ var _components_fab_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./components/fab.js */ "./node_modules/framework7-vue/components/fab.js");
/* harmony import */ var _components_gauge_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./components/gauge.js */ "./node_modules/framework7-vue/components/gauge.js");
/* harmony import */ var _components_icon_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./components/icon.js */ "./node_modules/framework7-vue/components/icon.js");
/* harmony import */ var _components_input_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./components/input.js */ "./node_modules/framework7-vue/components/input.js");
/* harmony import */ var _components_link_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./components/link.js */ "./node_modules/framework7-vue/components/link.js");
/* harmony import */ var _components_list_button_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./components/list-button.js */ "./node_modules/framework7-vue/components/list-button.js");
/* harmony import */ var _components_list_group_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./components/list-group.js */ "./node_modules/framework7-vue/components/list-group.js");
/* harmony import */ var _components_list_index_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./components/list-index.js */ "./node_modules/framework7-vue/components/list-index.js");
/* harmony import */ var _components_list_input_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./components/list-input.js */ "./node_modules/framework7-vue/components/list-input.js");
/* harmony import */ var _components_list_item_cell_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./components/list-item-cell.js */ "./node_modules/framework7-vue/components/list-item-cell.js");
/* harmony import */ var _components_list_item_row_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./components/list-item-row.js */ "./node_modules/framework7-vue/components/list-item-row.js");
/* harmony import */ var _components_list_item_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./components/list-item.js */ "./node_modules/framework7-vue/components/list-item.js");
/* harmony import */ var _components_list_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./components/list.js */ "./node_modules/framework7-vue/components/list.js");
/* harmony import */ var _components_login_screen_title_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./components/login-screen-title.js */ "./node_modules/framework7-vue/components/login-screen-title.js");
/* harmony import */ var _components_login_screen_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./components/login-screen.js */ "./node_modules/framework7-vue/components/login-screen.js");
/* harmony import */ var _components_menu_dropdown_item_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./components/menu-dropdown-item.js */ "./node_modules/framework7-vue/components/menu-dropdown-item.js");
/* harmony import */ var _components_menu_dropdown_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./components/menu-dropdown.js */ "./node_modules/framework7-vue/components/menu-dropdown.js");
/* harmony import */ var _components_menu_item_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./components/menu-item.js */ "./node_modules/framework7-vue/components/menu-item.js");
/* harmony import */ var _components_menu_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./components/menu.js */ "./node_modules/framework7-vue/components/menu.js");
/* harmony import */ var _components_message_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./components/message.js */ "./node_modules/framework7-vue/components/message.js");
/* harmony import */ var _components_messagebar_attachment_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./components/messagebar-attachment.js */ "./node_modules/framework7-vue/components/messagebar-attachment.js");
/* harmony import */ var _components_messagebar_attachments_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./components/messagebar-attachments.js */ "./node_modules/framework7-vue/components/messagebar-attachments.js");
/* harmony import */ var _components_messagebar_sheet_image_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./components/messagebar-sheet-image.js */ "./node_modules/framework7-vue/components/messagebar-sheet-image.js");
/* harmony import */ var _components_messagebar_sheet_item_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./components/messagebar-sheet-item.js */ "./node_modules/framework7-vue/components/messagebar-sheet-item.js");
/* harmony import */ var _components_messagebar_sheet_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./components/messagebar-sheet.js */ "./node_modules/framework7-vue/components/messagebar-sheet.js");
/* harmony import */ var _components_messagebar_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./components/messagebar.js */ "./node_modules/framework7-vue/components/messagebar.js");
/* harmony import */ var _components_messages_title_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./components/messages-title.js */ "./node_modules/framework7-vue/components/messages-title.js");
/* harmony import */ var _components_messages_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./components/messages.js */ "./node_modules/framework7-vue/components/messages.js");
/* harmony import */ var _components_nav_left_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./components/nav-left.js */ "./node_modules/framework7-vue/components/nav-left.js");
/* harmony import */ var _components_nav_right_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./components/nav-right.js */ "./node_modules/framework7-vue/components/nav-right.js");
/* harmony import */ var _components_nav_title_large_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./components/nav-title-large.js */ "./node_modules/framework7-vue/components/nav-title-large.js");
/* harmony import */ var _components_nav_title_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./components/nav-title.js */ "./node_modules/framework7-vue/components/nav-title.js");
/* harmony import */ var _components_navbar_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./components/navbar.js */ "./node_modules/framework7-vue/components/navbar.js");
/* harmony import */ var _components_page_content_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./components/page-content.js */ "./node_modules/framework7-vue/components/page-content.js");
/* harmony import */ var _components_page_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./components/page.js */ "./node_modules/framework7-vue/components/page.js");
/* harmony import */ var _components_panel_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./components/panel.js */ "./node_modules/framework7-vue/components/panel.js");
/* harmony import */ var _components_photo_browser_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./components/photo-browser.js */ "./node_modules/framework7-vue/components/photo-browser.js");
/* harmony import */ var _components_pie_chart_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./components/pie-chart.js */ "./node_modules/framework7-vue/components/pie-chart.js");
/* harmony import */ var _components_popover_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./components/popover.js */ "./node_modules/framework7-vue/components/popover.js");
/* harmony import */ var _components_popup_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./components/popup.js */ "./node_modules/framework7-vue/components/popup.js");
/* harmony import */ var _components_preloader_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./components/preloader.js */ "./node_modules/framework7-vue/components/preloader.js");
/* harmony import */ var _components_progressbar_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./components/progressbar.js */ "./node_modules/framework7-vue/components/progressbar.js");
/* harmony import */ var _components_radio_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./components/radio.js */ "./node_modules/framework7-vue/components/radio.js");
/* harmony import */ var _components_range_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./components/range.js */ "./node_modules/framework7-vue/components/range.js");
/* harmony import */ var _components_routable_modals_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./components/routable-modals.js */ "./node_modules/framework7-vue/components/routable-modals.js");
/* harmony import */ var _components_row_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./components/row.js */ "./node_modules/framework7-vue/components/row.js");
/* harmony import */ var _components_searchbar_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./components/searchbar.js */ "./node_modules/framework7-vue/components/searchbar.js");
/* harmony import */ var _components_segmented_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./components/segmented.js */ "./node_modules/framework7-vue/components/segmented.js");
/* harmony import */ var _components_sheet_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./components/sheet.js */ "./node_modules/framework7-vue/components/sheet.js");
/* harmony import */ var _components_skeleton_avatar_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./components/skeleton-avatar.js */ "./node_modules/framework7-vue/components/skeleton-avatar.js");
/* harmony import */ var _components_skeleton_block_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./components/skeleton-block.js */ "./node_modules/framework7-vue/components/skeleton-block.js");
/* harmony import */ var _components_skeleton_image_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./components/skeleton-image.js */ "./node_modules/framework7-vue/components/skeleton-image.js");
/* harmony import */ var _components_skeleton_text_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./components/skeleton-text.js */ "./node_modules/framework7-vue/components/skeleton-text.js");
/* harmony import */ var _components_stepper_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./components/stepper.js */ "./node_modules/framework7-vue/components/stepper.js");
/* harmony import */ var _components_subnavbar_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./components/subnavbar.js */ "./node_modules/framework7-vue/components/subnavbar.js");
/* harmony import */ var _components_swipeout_actions_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./components/swipeout-actions.js */ "./node_modules/framework7-vue/components/swipeout-actions.js");
/* harmony import */ var _components_swipeout_button_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./components/swipeout-button.js */ "./node_modules/framework7-vue/components/swipeout-button.js");
/* harmony import */ var _components_swiper_slide_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./components/swiper-slide.js */ "./node_modules/framework7-vue/components/swiper-slide.js");
/* harmony import */ var _components_swiper_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./components/swiper.js */ "./node_modules/framework7-vue/components/swiper.js");
/* harmony import */ var _components_tab_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./components/tab.js */ "./node_modules/framework7-vue/components/tab.js");
/* harmony import */ var _components_tabs_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./components/tabs.js */ "./node_modules/framework7-vue/components/tabs.js");
/* harmony import */ var _components_text_editor_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./components/text-editor.js */ "./node_modules/framework7-vue/components/text-editor.js");
/* harmony import */ var _components_toggle_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./components/toggle.js */ "./node_modules/framework7-vue/components/toggle.js");
/* harmony import */ var _components_toolbar_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./components/toolbar.js */ "./node_modules/framework7-vue/components/toolbar.js");
/* harmony import */ var _components_treeview_item_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./components/treeview-item.js */ "./node_modules/framework7-vue/components/treeview-item.js");
/* harmony import */ var _components_treeview_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./components/treeview.js */ "./node_modules/framework7-vue/components/treeview.js");
/* harmony import */ var _components_use_icon_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./components/use-icon.js */ "./node_modules/framework7-vue/components/use-icon.js");
/* harmony import */ var _components_view_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./components/view.js */ "./node_modules/framework7-vue/components/view.js");
/* harmony import */ var _components_views_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./components/views.js */ "./node_modules/framework7-vue/components/views.js");
/**
 * Framework7 Vue 7.0.9
 * Build full featured iOS & Android apps using Framework7 & Vue
 * https://framework7.io/vue/
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: November 21, 2022
 */











































































































/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_shared_plugin_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

function registerComponents(app) {
  app.component('f7-accordion-content', _components_accordion_content_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
  app.component('f7-accordion-item', _components_accordion_item_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
  app.component('f7-accordion-toggle', _components_accordion_toggle_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
  app.component('f7-accordion', _components_accordion_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
  app.component('f7-actions-button', _components_actions_button_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
  app.component('f7-actions-group', _components_actions_group_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
  app.component('f7-actions-label', _components_actions_label_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
  app.component('f7-actions', _components_actions_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
  app.component('f7-app', _components_app_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
  app.component('f7-appbar', _components_appbar_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
  app.component('f7-area-chart', _components_area_chart_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
  app.component('f7-badge', _components_badge_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
  app.component('f7-block-footer', _components_block_footer_js__WEBPACK_IMPORTED_MODULE_15__["default"]);
  app.component('f7-block-header', _components_block_header_js__WEBPACK_IMPORTED_MODULE_16__["default"]);
  app.component('f7-block-title', _components_block_title_js__WEBPACK_IMPORTED_MODULE_17__["default"]);
  app.component('f7-block', _components_block_js__WEBPACK_IMPORTED_MODULE_18__["default"]);
  app.component('f7-breadcrumbs-collapsed', _components_breadcrumbs_collapsed_js__WEBPACK_IMPORTED_MODULE_19__["default"]);
  app.component('f7-breadcrumbs-item', _components_breadcrumbs_item_js__WEBPACK_IMPORTED_MODULE_20__["default"]);
  app.component('f7-breadcrumbs-separator', _components_breadcrumbs_separator_js__WEBPACK_IMPORTED_MODULE_21__["default"]);
  app.component('f7-breadcrumbs', _components_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_22__["default"]);
  app.component('f7-button', _components_button_js__WEBPACK_IMPORTED_MODULE_23__["default"]);
  app.component('f7-card-content', _components_card_content_js__WEBPACK_IMPORTED_MODULE_24__["default"]);
  app.component('f7-card-footer', _components_card_footer_js__WEBPACK_IMPORTED_MODULE_25__["default"]);
  app.component('f7-card-header', _components_card_header_js__WEBPACK_IMPORTED_MODULE_26__["default"]);
  app.component('f7-card', _components_card_js__WEBPACK_IMPORTED_MODULE_27__["default"]);
  app.component('f7-checkbox', _components_checkbox_js__WEBPACK_IMPORTED_MODULE_28__["default"]);
  app.component('f7-chip', _components_chip_js__WEBPACK_IMPORTED_MODULE_29__["default"]);
  app.component('f7-col', _components_col_js__WEBPACK_IMPORTED_MODULE_30__["default"]);
  app.component('f7-fab-backdrop', _components_fab_backdrop_js__WEBPACK_IMPORTED_MODULE_31__["default"]);
  app.component('f7-fab-button', _components_fab_button_js__WEBPACK_IMPORTED_MODULE_32__["default"]);
  app.component('f7-fab-buttons', _components_fab_buttons_js__WEBPACK_IMPORTED_MODULE_33__["default"]);
  app.component('f7-fab', _components_fab_js__WEBPACK_IMPORTED_MODULE_34__["default"]);
  app.component('f7-gauge', _components_gauge_js__WEBPACK_IMPORTED_MODULE_35__["default"]);
  app.component('f7-icon', _components_icon_js__WEBPACK_IMPORTED_MODULE_36__["default"]);
  app.component('f7-input', _components_input_js__WEBPACK_IMPORTED_MODULE_37__["default"]);
  app.component('f7-link', _components_link_js__WEBPACK_IMPORTED_MODULE_38__["default"]);
  app.component('f7-list-button', _components_list_button_js__WEBPACK_IMPORTED_MODULE_39__["default"]);
  app.component('f7-list-group', _components_list_group_js__WEBPACK_IMPORTED_MODULE_40__["default"]);
  app.component('f7-list-index', _components_list_index_js__WEBPACK_IMPORTED_MODULE_41__["default"]);
  app.component('f7-list-input', _components_list_input_js__WEBPACK_IMPORTED_MODULE_42__["default"]);
  app.component('f7-list-item-cell', _components_list_item_cell_js__WEBPACK_IMPORTED_MODULE_43__["default"]);
  app.component('f7-list-item-row', _components_list_item_row_js__WEBPACK_IMPORTED_MODULE_44__["default"]);
  app.component('f7-list-item', _components_list_item_js__WEBPACK_IMPORTED_MODULE_45__["default"]);
  app.component('f7-list', _components_list_js__WEBPACK_IMPORTED_MODULE_46__["default"]);
  app.component('f7-login-screen-title', _components_login_screen_title_js__WEBPACK_IMPORTED_MODULE_47__["default"]);
  app.component('f7-login-screen', _components_login_screen_js__WEBPACK_IMPORTED_MODULE_48__["default"]);
  app.component('f7-menu-dropdown-item', _components_menu_dropdown_item_js__WEBPACK_IMPORTED_MODULE_49__["default"]);
  app.component('f7-menu-dropdown', _components_menu_dropdown_js__WEBPACK_IMPORTED_MODULE_50__["default"]);
  app.component('f7-menu-item', _components_menu_item_js__WEBPACK_IMPORTED_MODULE_51__["default"]);
  app.component('f7-menu', _components_menu_js__WEBPACK_IMPORTED_MODULE_52__["default"]);
  app.component('f7-message', _components_message_js__WEBPACK_IMPORTED_MODULE_53__["default"]);
  app.component('f7-messagebar-attachment', _components_messagebar_attachment_js__WEBPACK_IMPORTED_MODULE_54__["default"]);
  app.component('f7-messagebar-attachments', _components_messagebar_attachments_js__WEBPACK_IMPORTED_MODULE_55__["default"]);
  app.component('f7-messagebar-sheet-image', _components_messagebar_sheet_image_js__WEBPACK_IMPORTED_MODULE_56__["default"]);
  app.component('f7-messagebar-sheet-item', _components_messagebar_sheet_item_js__WEBPACK_IMPORTED_MODULE_57__["default"]);
  app.component('f7-messagebar-sheet', _components_messagebar_sheet_js__WEBPACK_IMPORTED_MODULE_58__["default"]);
  app.component('f7-messagebar', _components_messagebar_js__WEBPACK_IMPORTED_MODULE_59__["default"]);
  app.component('f7-messages-title', _components_messages_title_js__WEBPACK_IMPORTED_MODULE_60__["default"]);
  app.component('f7-messages', _components_messages_js__WEBPACK_IMPORTED_MODULE_61__["default"]);
  app.component('f7-nav-left', _components_nav_left_js__WEBPACK_IMPORTED_MODULE_62__["default"]);
  app.component('f7-nav-right', _components_nav_right_js__WEBPACK_IMPORTED_MODULE_63__["default"]);
  app.component('f7-nav-title-large', _components_nav_title_large_js__WEBPACK_IMPORTED_MODULE_64__["default"]);
  app.component('f7-nav-title', _components_nav_title_js__WEBPACK_IMPORTED_MODULE_65__["default"]);
  app.component('f7-navbar', _components_navbar_js__WEBPACK_IMPORTED_MODULE_66__["default"]);
  app.component('f7-page-content', _components_page_content_js__WEBPACK_IMPORTED_MODULE_67__["default"]);
  app.component('f7-page', _components_page_js__WEBPACK_IMPORTED_MODULE_68__["default"]);
  app.component('f7-panel', _components_panel_js__WEBPACK_IMPORTED_MODULE_69__["default"]);
  app.component('f7-photo-browser', _components_photo_browser_js__WEBPACK_IMPORTED_MODULE_70__["default"]);
  app.component('f7-pie-chart', _components_pie_chart_js__WEBPACK_IMPORTED_MODULE_71__["default"]);
  app.component('f7-popover', _components_popover_js__WEBPACK_IMPORTED_MODULE_72__["default"]);
  app.component('f7-popup', _components_popup_js__WEBPACK_IMPORTED_MODULE_73__["default"]);
  app.component('f7-preloader', _components_preloader_js__WEBPACK_IMPORTED_MODULE_74__["default"]);
  app.component('f7-progressbar', _components_progressbar_js__WEBPACK_IMPORTED_MODULE_75__["default"]);
  app.component('f7-radio', _components_radio_js__WEBPACK_IMPORTED_MODULE_76__["default"]);
  app.component('f7-range', _components_range_js__WEBPACK_IMPORTED_MODULE_77__["default"]);
  app.component('f7-routable-modals', _components_routable_modals_js__WEBPACK_IMPORTED_MODULE_78__["default"]);
  app.component('f7-row', _components_row_js__WEBPACK_IMPORTED_MODULE_79__["default"]);
  app.component('f7-searchbar', _components_searchbar_js__WEBPACK_IMPORTED_MODULE_80__["default"]);
  app.component('f7-segmented', _components_segmented_js__WEBPACK_IMPORTED_MODULE_81__["default"]);
  app.component('f7-sheet', _components_sheet_js__WEBPACK_IMPORTED_MODULE_82__["default"]);
  app.component('f7-skeleton-avatar', _components_skeleton_avatar_js__WEBPACK_IMPORTED_MODULE_83__["default"]);
  app.component('f7-skeleton-block', _components_skeleton_block_js__WEBPACK_IMPORTED_MODULE_84__["default"]);
  app.component('f7-skeleton-image', _components_skeleton_image_js__WEBPACK_IMPORTED_MODULE_85__["default"]);
  app.component('f7-skeleton-text', _components_skeleton_text_js__WEBPACK_IMPORTED_MODULE_86__["default"]);
  app.component('f7-stepper', _components_stepper_js__WEBPACK_IMPORTED_MODULE_87__["default"]);
  app.component('f7-subnavbar', _components_subnavbar_js__WEBPACK_IMPORTED_MODULE_88__["default"]);
  app.component('f7-swipeout-actions', _components_swipeout_actions_js__WEBPACK_IMPORTED_MODULE_89__["default"]);
  app.component('f7-swipeout-button', _components_swipeout_button_js__WEBPACK_IMPORTED_MODULE_90__["default"]);
  app.component('f7-swiper-slide', _components_swiper_slide_js__WEBPACK_IMPORTED_MODULE_91__["default"]);
  app.component('f7-swiper', _components_swiper_js__WEBPACK_IMPORTED_MODULE_92__["default"]);
  app.component('f7-tab', _components_tab_js__WEBPACK_IMPORTED_MODULE_93__["default"]);
  app.component('f7-tabs', _components_tabs_js__WEBPACK_IMPORTED_MODULE_94__["default"]);
  app.component('f7-text-editor', _components_text_editor_js__WEBPACK_IMPORTED_MODULE_95__["default"]);
  app.component('f7-toggle', _components_toggle_js__WEBPACK_IMPORTED_MODULE_96__["default"]);
  app.component('f7-toolbar', _components_toolbar_js__WEBPACK_IMPORTED_MODULE_97__["default"]);
  app.component('f7-treeview-item', _components_treeview_item_js__WEBPACK_IMPORTED_MODULE_98__["default"]);
  app.component('f7-treeview', _components_treeview_js__WEBPACK_IMPORTED_MODULE_99__["default"]);
  app.component('f7-use-icon', _components_use_icon_js__WEBPACK_IMPORTED_MODULE_100__["default"]);
  app.component('f7-view', _components_view_js__WEBPACK_IMPORTED_MODULE_101__["default"]);
  app.component('f7-views', _components_views_js__WEBPACK_IMPORTED_MODULE_102__["default"])
}


/***/ }),

/***/ "./node_modules/framework7-vue/framework7-vue.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7-vue/framework7-vue.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "f7": () => (/* reexport safe */ _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__.f7),
/* harmony export */   "f7Accordion": () => (/* reexport safe */ _components_accordion_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "f7AccordionContent": () => (/* reexport safe */ _components_accordion_content_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "f7AccordionItem": () => (/* reexport safe */ _components_accordion_item_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "f7AccordionToggle": () => (/* reexport safe */ _components_accordion_toggle_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "f7Actions": () => (/* reexport safe */ _components_actions_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "f7ActionsButton": () => (/* reexport safe */ _components_actions_button_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "f7ActionsGroup": () => (/* reexport safe */ _components_actions_group_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "f7ActionsLabel": () => (/* reexport safe */ _components_actions_label_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "f7App": () => (/* reexport safe */ _components_app_js__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "f7Appbar": () => (/* reexport safe */ _components_appbar_js__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "f7AreaChart": () => (/* reexport safe */ _components_area_chart_js__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "f7Badge": () => (/* reexport safe */ _components_badge_js__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   "f7Block": () => (/* reexport safe */ _components_block_js__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   "f7BlockFooter": () => (/* reexport safe */ _components_block_footer_js__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   "f7BlockHeader": () => (/* reexport safe */ _components_block_header_js__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   "f7BlockTitle": () => (/* reexport safe */ _components_block_title_js__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   "f7Breadcrumbs": () => (/* reexport safe */ _components_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   "f7BreadcrumbsCollapsed": () => (/* reexport safe */ _components_breadcrumbs_collapsed_js__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   "f7BreadcrumbsItem": () => (/* reexport safe */ _components_breadcrumbs_item_js__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   "f7BreadcrumbsSeparator": () => (/* reexport safe */ _components_breadcrumbs_separator_js__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   "f7Button": () => (/* reexport safe */ _components_button_js__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   "f7Card": () => (/* reexport safe */ _components_card_js__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   "f7CardContent": () => (/* reexport safe */ _components_card_content_js__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   "f7CardFooter": () => (/* reexport safe */ _components_card_footer_js__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   "f7CardHeader": () => (/* reexport safe */ _components_card_header_js__WEBPACK_IMPORTED_MODULE_26__["default"]),
/* harmony export */   "f7Checkbox": () => (/* reexport safe */ _components_checkbox_js__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   "f7Chip": () => (/* reexport safe */ _components_chip_js__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   "f7Col": () => (/* reexport safe */ _components_col_js__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   "f7Fab": () => (/* reexport safe */ _components_fab_js__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   "f7FabBackdrop": () => (/* reexport safe */ _components_fab_backdrop_js__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   "f7FabButton": () => (/* reexport safe */ _components_fab_button_js__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   "f7FabButtons": () => (/* reexport safe */ _components_fab_buttons_js__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   "f7Gauge": () => (/* reexport safe */ _components_gauge_js__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   "f7Icon": () => (/* reexport safe */ _components_icon_js__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   "f7Input": () => (/* reexport safe */ _components_input_js__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   "f7Link": () => (/* reexport safe */ _components_link_js__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   "f7List": () => (/* reexport safe */ _components_list_js__WEBPACK_IMPORTED_MODULE_46__["default"]),
/* harmony export */   "f7ListButton": () => (/* reexport safe */ _components_list_button_js__WEBPACK_IMPORTED_MODULE_39__["default"]),
/* harmony export */   "f7ListGroup": () => (/* reexport safe */ _components_list_group_js__WEBPACK_IMPORTED_MODULE_40__["default"]),
/* harmony export */   "f7ListIndex": () => (/* reexport safe */ _components_list_index_js__WEBPACK_IMPORTED_MODULE_41__["default"]),
/* harmony export */   "f7ListInput": () => (/* reexport safe */ _components_list_input_js__WEBPACK_IMPORTED_MODULE_42__["default"]),
/* harmony export */   "f7ListItem": () => (/* reexport safe */ _components_list_item_js__WEBPACK_IMPORTED_MODULE_45__["default"]),
/* harmony export */   "f7ListItemCell": () => (/* reexport safe */ _components_list_item_cell_js__WEBPACK_IMPORTED_MODULE_43__["default"]),
/* harmony export */   "f7ListItemRow": () => (/* reexport safe */ _components_list_item_row_js__WEBPACK_IMPORTED_MODULE_44__["default"]),
/* harmony export */   "f7LoginScreen": () => (/* reexport safe */ _components_login_screen_js__WEBPACK_IMPORTED_MODULE_48__["default"]),
/* harmony export */   "f7LoginScreenTitle": () => (/* reexport safe */ _components_login_screen_title_js__WEBPACK_IMPORTED_MODULE_47__["default"]),
/* harmony export */   "f7Menu": () => (/* reexport safe */ _components_menu_js__WEBPACK_IMPORTED_MODULE_52__["default"]),
/* harmony export */   "f7MenuDropdown": () => (/* reexport safe */ _components_menu_dropdown_js__WEBPACK_IMPORTED_MODULE_50__["default"]),
/* harmony export */   "f7MenuDropdownItem": () => (/* reexport safe */ _components_menu_dropdown_item_js__WEBPACK_IMPORTED_MODULE_49__["default"]),
/* harmony export */   "f7MenuItem": () => (/* reexport safe */ _components_menu_item_js__WEBPACK_IMPORTED_MODULE_51__["default"]),
/* harmony export */   "f7Message": () => (/* reexport safe */ _components_message_js__WEBPACK_IMPORTED_MODULE_53__["default"]),
/* harmony export */   "f7Messagebar": () => (/* reexport safe */ _components_messagebar_js__WEBPACK_IMPORTED_MODULE_59__["default"]),
/* harmony export */   "f7MessagebarAttachment": () => (/* reexport safe */ _components_messagebar_attachment_js__WEBPACK_IMPORTED_MODULE_54__["default"]),
/* harmony export */   "f7MessagebarAttachments": () => (/* reexport safe */ _components_messagebar_attachments_js__WEBPACK_IMPORTED_MODULE_55__["default"]),
/* harmony export */   "f7MessagebarSheet": () => (/* reexport safe */ _components_messagebar_sheet_js__WEBPACK_IMPORTED_MODULE_58__["default"]),
/* harmony export */   "f7MessagebarSheetImage": () => (/* reexport safe */ _components_messagebar_sheet_image_js__WEBPACK_IMPORTED_MODULE_56__["default"]),
/* harmony export */   "f7MessagebarSheetItem": () => (/* reexport safe */ _components_messagebar_sheet_item_js__WEBPACK_IMPORTED_MODULE_57__["default"]),
/* harmony export */   "f7Messages": () => (/* reexport safe */ _components_messages_js__WEBPACK_IMPORTED_MODULE_61__["default"]),
/* harmony export */   "f7MessagesTitle": () => (/* reexport safe */ _components_messages_title_js__WEBPACK_IMPORTED_MODULE_60__["default"]),
/* harmony export */   "f7NavLeft": () => (/* reexport safe */ _components_nav_left_js__WEBPACK_IMPORTED_MODULE_62__["default"]),
/* harmony export */   "f7NavRight": () => (/* reexport safe */ _components_nav_right_js__WEBPACK_IMPORTED_MODULE_63__["default"]),
/* harmony export */   "f7NavTitle": () => (/* reexport safe */ _components_nav_title_js__WEBPACK_IMPORTED_MODULE_65__["default"]),
/* harmony export */   "f7NavTitleLarge": () => (/* reexport safe */ _components_nav_title_large_js__WEBPACK_IMPORTED_MODULE_64__["default"]),
/* harmony export */   "f7Navbar": () => (/* reexport safe */ _components_navbar_js__WEBPACK_IMPORTED_MODULE_66__["default"]),
/* harmony export */   "f7Page": () => (/* reexport safe */ _components_page_js__WEBPACK_IMPORTED_MODULE_68__["default"]),
/* harmony export */   "f7PageContent": () => (/* reexport safe */ _components_page_content_js__WEBPACK_IMPORTED_MODULE_67__["default"]),
/* harmony export */   "f7Panel": () => (/* reexport safe */ _components_panel_js__WEBPACK_IMPORTED_MODULE_69__["default"]),
/* harmony export */   "f7PhotoBrowser": () => (/* reexport safe */ _components_photo_browser_js__WEBPACK_IMPORTED_MODULE_70__["default"]),
/* harmony export */   "f7PieChart": () => (/* reexport safe */ _components_pie_chart_js__WEBPACK_IMPORTED_MODULE_71__["default"]),
/* harmony export */   "f7Popover": () => (/* reexport safe */ _components_popover_js__WEBPACK_IMPORTED_MODULE_72__["default"]),
/* harmony export */   "f7Popup": () => (/* reexport safe */ _components_popup_js__WEBPACK_IMPORTED_MODULE_73__["default"]),
/* harmony export */   "f7Preloader": () => (/* reexport safe */ _components_preloader_js__WEBPACK_IMPORTED_MODULE_74__["default"]),
/* harmony export */   "f7Progressbar": () => (/* reexport safe */ _components_progressbar_js__WEBPACK_IMPORTED_MODULE_75__["default"]),
/* harmony export */   "f7Radio": () => (/* reexport safe */ _components_radio_js__WEBPACK_IMPORTED_MODULE_76__["default"]),
/* harmony export */   "f7Range": () => (/* reexport safe */ _components_range_js__WEBPACK_IMPORTED_MODULE_77__["default"]),
/* harmony export */   "f7RoutableModals": () => (/* reexport safe */ _components_routable_modals_js__WEBPACK_IMPORTED_MODULE_78__["default"]),
/* harmony export */   "f7Row": () => (/* reexport safe */ _components_row_js__WEBPACK_IMPORTED_MODULE_79__["default"]),
/* harmony export */   "f7Searchbar": () => (/* reexport safe */ _components_searchbar_js__WEBPACK_IMPORTED_MODULE_80__["default"]),
/* harmony export */   "f7Segmented": () => (/* reexport safe */ _components_segmented_js__WEBPACK_IMPORTED_MODULE_81__["default"]),
/* harmony export */   "f7Sheet": () => (/* reexport safe */ _components_sheet_js__WEBPACK_IMPORTED_MODULE_82__["default"]),
/* harmony export */   "f7SkeletonAvatar": () => (/* reexport safe */ _components_skeleton_avatar_js__WEBPACK_IMPORTED_MODULE_83__["default"]),
/* harmony export */   "f7SkeletonBlock": () => (/* reexport safe */ _components_skeleton_block_js__WEBPACK_IMPORTED_MODULE_84__["default"]),
/* harmony export */   "f7SkeletonImage": () => (/* reexport safe */ _components_skeleton_image_js__WEBPACK_IMPORTED_MODULE_85__["default"]),
/* harmony export */   "f7SkeletonText": () => (/* reexport safe */ _components_skeleton_text_js__WEBPACK_IMPORTED_MODULE_86__["default"]),
/* harmony export */   "f7Stepper": () => (/* reexport safe */ _components_stepper_js__WEBPACK_IMPORTED_MODULE_87__["default"]),
/* harmony export */   "f7Subnavbar": () => (/* reexport safe */ _components_subnavbar_js__WEBPACK_IMPORTED_MODULE_88__["default"]),
/* harmony export */   "f7SwipeoutActions": () => (/* reexport safe */ _components_swipeout_actions_js__WEBPACK_IMPORTED_MODULE_89__["default"]),
/* harmony export */   "f7SwipeoutButton": () => (/* reexport safe */ _components_swipeout_button_js__WEBPACK_IMPORTED_MODULE_90__["default"]),
/* harmony export */   "f7Swiper": () => (/* reexport safe */ _components_swiper_js__WEBPACK_IMPORTED_MODULE_92__["default"]),
/* harmony export */   "f7SwiperSlide": () => (/* reexport safe */ _components_swiper_slide_js__WEBPACK_IMPORTED_MODULE_91__["default"]),
/* harmony export */   "f7Tab": () => (/* reexport safe */ _components_tab_js__WEBPACK_IMPORTED_MODULE_93__["default"]),
/* harmony export */   "f7Tabs": () => (/* reexport safe */ _components_tabs_js__WEBPACK_IMPORTED_MODULE_94__["default"]),
/* harmony export */   "f7TextEditor": () => (/* reexport safe */ _components_text_editor_js__WEBPACK_IMPORTED_MODULE_95__["default"]),
/* harmony export */   "f7Toggle": () => (/* reexport safe */ _components_toggle_js__WEBPACK_IMPORTED_MODULE_96__["default"]),
/* harmony export */   "f7Toolbar": () => (/* reexport safe */ _components_toolbar_js__WEBPACK_IMPORTED_MODULE_97__["default"]),
/* harmony export */   "f7Treeview": () => (/* reexport safe */ _components_treeview_js__WEBPACK_IMPORTED_MODULE_99__["default"]),
/* harmony export */   "f7TreeviewItem": () => (/* reexport safe */ _components_treeview_item_js__WEBPACK_IMPORTED_MODULE_98__["default"]),
/* harmony export */   "f7UseIcon": () => (/* reexport safe */ _components_use_icon_js__WEBPACK_IMPORTED_MODULE_100__["default"]),
/* harmony export */   "f7View": () => (/* reexport safe */ _components_view_js__WEBPACK_IMPORTED_MODULE_101__["default"]),
/* harmony export */   "f7Views": () => (/* reexport safe */ _components_views_js__WEBPACK_IMPORTED_MODULE_102__["default"]),
/* harmony export */   "f7ready": () => (/* reexport safe */ _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__.f7ready),
/* harmony export */   "theme": () => (/* reexport safe */ _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__.theme),
/* harmony export */   "useStore": () => (/* reexport safe */ _shared_use_store_js__WEBPACK_IMPORTED_MODULE_2__.useStore)
/* harmony export */ });
/* harmony import */ var _shared_plugin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/plugin.js */ "./node_modules/framework7-vue/shared/plugin.js");
/* harmony import */ var _shared_f7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _shared_use_store_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/use-store.js */ "./node_modules/framework7-vue/shared/use-store.js");
/* harmony import */ var _components_accordion_content_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/accordion-content.js */ "./node_modules/framework7-vue/components/accordion-content.js");
/* harmony import */ var _components_accordion_item_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/accordion-item.js */ "./node_modules/framework7-vue/components/accordion-item.js");
/* harmony import */ var _components_accordion_toggle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/accordion-toggle.js */ "./node_modules/framework7-vue/components/accordion-toggle.js");
/* harmony import */ var _components_accordion_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/accordion.js */ "./node_modules/framework7-vue/components/accordion.js");
/* harmony import */ var _components_actions_button_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/actions-button.js */ "./node_modules/framework7-vue/components/actions-button.js");
/* harmony import */ var _components_actions_group_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/actions-group.js */ "./node_modules/framework7-vue/components/actions-group.js");
/* harmony import */ var _components_actions_label_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/actions-label.js */ "./node_modules/framework7-vue/components/actions-label.js");
/* harmony import */ var _components_actions_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/actions.js */ "./node_modules/framework7-vue/components/actions.js");
/* harmony import */ var _components_app_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/app.js */ "./node_modules/framework7-vue/components/app.js");
/* harmony import */ var _components_appbar_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/appbar.js */ "./node_modules/framework7-vue/components/appbar.js");
/* harmony import */ var _components_area_chart_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/area-chart.js */ "./node_modules/framework7-vue/components/area-chart.js");
/* harmony import */ var _components_badge_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/badge.js */ "./node_modules/framework7-vue/components/badge.js");
/* harmony import */ var _components_block_footer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/block-footer.js */ "./node_modules/framework7-vue/components/block-footer.js");
/* harmony import */ var _components_block_header_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/block-header.js */ "./node_modules/framework7-vue/components/block-header.js");
/* harmony import */ var _components_block_title_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/block-title.js */ "./node_modules/framework7-vue/components/block-title.js");
/* harmony import */ var _components_block_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/block.js */ "./node_modules/framework7-vue/components/block.js");
/* harmony import */ var _components_breadcrumbs_collapsed_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/breadcrumbs-collapsed.js */ "./node_modules/framework7-vue/components/breadcrumbs-collapsed.js");
/* harmony import */ var _components_breadcrumbs_item_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/breadcrumbs-item.js */ "./node_modules/framework7-vue/components/breadcrumbs-item.js");
/* harmony import */ var _components_breadcrumbs_separator_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/breadcrumbs-separator.js */ "./node_modules/framework7-vue/components/breadcrumbs-separator.js");
/* harmony import */ var _components_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/breadcrumbs.js */ "./node_modules/framework7-vue/components/breadcrumbs.js");
/* harmony import */ var _components_button_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/button.js */ "./node_modules/framework7-vue/components/button.js");
/* harmony import */ var _components_card_content_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/card-content.js */ "./node_modules/framework7-vue/components/card-content.js");
/* harmony import */ var _components_card_footer_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/card-footer.js */ "./node_modules/framework7-vue/components/card-footer.js");
/* harmony import */ var _components_card_header_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./components/card-header.js */ "./node_modules/framework7-vue/components/card-header.js");
/* harmony import */ var _components_card_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./components/card.js */ "./node_modules/framework7-vue/components/card.js");
/* harmony import */ var _components_checkbox_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./components/checkbox.js */ "./node_modules/framework7-vue/components/checkbox.js");
/* harmony import */ var _components_chip_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./components/chip.js */ "./node_modules/framework7-vue/components/chip.js");
/* harmony import */ var _components_col_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./components/col.js */ "./node_modules/framework7-vue/components/col.js");
/* harmony import */ var _components_fab_backdrop_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./components/fab-backdrop.js */ "./node_modules/framework7-vue/components/fab-backdrop.js");
/* harmony import */ var _components_fab_button_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./components/fab-button.js */ "./node_modules/framework7-vue/components/fab-button.js");
/* harmony import */ var _components_fab_buttons_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./components/fab-buttons.js */ "./node_modules/framework7-vue/components/fab-buttons.js");
/* harmony import */ var _components_fab_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./components/fab.js */ "./node_modules/framework7-vue/components/fab.js");
/* harmony import */ var _components_gauge_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./components/gauge.js */ "./node_modules/framework7-vue/components/gauge.js");
/* harmony import */ var _components_icon_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./components/icon.js */ "./node_modules/framework7-vue/components/icon.js");
/* harmony import */ var _components_input_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./components/input.js */ "./node_modules/framework7-vue/components/input.js");
/* harmony import */ var _components_link_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./components/link.js */ "./node_modules/framework7-vue/components/link.js");
/* harmony import */ var _components_list_button_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./components/list-button.js */ "./node_modules/framework7-vue/components/list-button.js");
/* harmony import */ var _components_list_group_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./components/list-group.js */ "./node_modules/framework7-vue/components/list-group.js");
/* harmony import */ var _components_list_index_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./components/list-index.js */ "./node_modules/framework7-vue/components/list-index.js");
/* harmony import */ var _components_list_input_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./components/list-input.js */ "./node_modules/framework7-vue/components/list-input.js");
/* harmony import */ var _components_list_item_cell_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./components/list-item-cell.js */ "./node_modules/framework7-vue/components/list-item-cell.js");
/* harmony import */ var _components_list_item_row_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./components/list-item-row.js */ "./node_modules/framework7-vue/components/list-item-row.js");
/* harmony import */ var _components_list_item_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./components/list-item.js */ "./node_modules/framework7-vue/components/list-item.js");
/* harmony import */ var _components_list_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./components/list.js */ "./node_modules/framework7-vue/components/list.js");
/* harmony import */ var _components_login_screen_title_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./components/login-screen-title.js */ "./node_modules/framework7-vue/components/login-screen-title.js");
/* harmony import */ var _components_login_screen_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./components/login-screen.js */ "./node_modules/framework7-vue/components/login-screen.js");
/* harmony import */ var _components_menu_dropdown_item_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./components/menu-dropdown-item.js */ "./node_modules/framework7-vue/components/menu-dropdown-item.js");
/* harmony import */ var _components_menu_dropdown_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./components/menu-dropdown.js */ "./node_modules/framework7-vue/components/menu-dropdown.js");
/* harmony import */ var _components_menu_item_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./components/menu-item.js */ "./node_modules/framework7-vue/components/menu-item.js");
/* harmony import */ var _components_menu_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./components/menu.js */ "./node_modules/framework7-vue/components/menu.js");
/* harmony import */ var _components_message_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./components/message.js */ "./node_modules/framework7-vue/components/message.js");
/* harmony import */ var _components_messagebar_attachment_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./components/messagebar-attachment.js */ "./node_modules/framework7-vue/components/messagebar-attachment.js");
/* harmony import */ var _components_messagebar_attachments_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./components/messagebar-attachments.js */ "./node_modules/framework7-vue/components/messagebar-attachments.js");
/* harmony import */ var _components_messagebar_sheet_image_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./components/messagebar-sheet-image.js */ "./node_modules/framework7-vue/components/messagebar-sheet-image.js");
/* harmony import */ var _components_messagebar_sheet_item_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./components/messagebar-sheet-item.js */ "./node_modules/framework7-vue/components/messagebar-sheet-item.js");
/* harmony import */ var _components_messagebar_sheet_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./components/messagebar-sheet.js */ "./node_modules/framework7-vue/components/messagebar-sheet.js");
/* harmony import */ var _components_messagebar_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./components/messagebar.js */ "./node_modules/framework7-vue/components/messagebar.js");
/* harmony import */ var _components_messages_title_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./components/messages-title.js */ "./node_modules/framework7-vue/components/messages-title.js");
/* harmony import */ var _components_messages_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./components/messages.js */ "./node_modules/framework7-vue/components/messages.js");
/* harmony import */ var _components_nav_left_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./components/nav-left.js */ "./node_modules/framework7-vue/components/nav-left.js");
/* harmony import */ var _components_nav_right_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./components/nav-right.js */ "./node_modules/framework7-vue/components/nav-right.js");
/* harmony import */ var _components_nav_title_large_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./components/nav-title-large.js */ "./node_modules/framework7-vue/components/nav-title-large.js");
/* harmony import */ var _components_nav_title_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./components/nav-title.js */ "./node_modules/framework7-vue/components/nav-title.js");
/* harmony import */ var _components_navbar_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./components/navbar.js */ "./node_modules/framework7-vue/components/navbar.js");
/* harmony import */ var _components_page_content_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./components/page-content.js */ "./node_modules/framework7-vue/components/page-content.js");
/* harmony import */ var _components_page_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./components/page.js */ "./node_modules/framework7-vue/components/page.js");
/* harmony import */ var _components_panel_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./components/panel.js */ "./node_modules/framework7-vue/components/panel.js");
/* harmony import */ var _components_photo_browser_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./components/photo-browser.js */ "./node_modules/framework7-vue/components/photo-browser.js");
/* harmony import */ var _components_pie_chart_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./components/pie-chart.js */ "./node_modules/framework7-vue/components/pie-chart.js");
/* harmony import */ var _components_popover_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./components/popover.js */ "./node_modules/framework7-vue/components/popover.js");
/* harmony import */ var _components_popup_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./components/popup.js */ "./node_modules/framework7-vue/components/popup.js");
/* harmony import */ var _components_preloader_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./components/preloader.js */ "./node_modules/framework7-vue/components/preloader.js");
/* harmony import */ var _components_progressbar_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./components/progressbar.js */ "./node_modules/framework7-vue/components/progressbar.js");
/* harmony import */ var _components_radio_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./components/radio.js */ "./node_modules/framework7-vue/components/radio.js");
/* harmony import */ var _components_range_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./components/range.js */ "./node_modules/framework7-vue/components/range.js");
/* harmony import */ var _components_routable_modals_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./components/routable-modals.js */ "./node_modules/framework7-vue/components/routable-modals.js");
/* harmony import */ var _components_row_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./components/row.js */ "./node_modules/framework7-vue/components/row.js");
/* harmony import */ var _components_searchbar_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./components/searchbar.js */ "./node_modules/framework7-vue/components/searchbar.js");
/* harmony import */ var _components_segmented_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./components/segmented.js */ "./node_modules/framework7-vue/components/segmented.js");
/* harmony import */ var _components_sheet_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./components/sheet.js */ "./node_modules/framework7-vue/components/sheet.js");
/* harmony import */ var _components_skeleton_avatar_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./components/skeleton-avatar.js */ "./node_modules/framework7-vue/components/skeleton-avatar.js");
/* harmony import */ var _components_skeleton_block_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./components/skeleton-block.js */ "./node_modules/framework7-vue/components/skeleton-block.js");
/* harmony import */ var _components_skeleton_image_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./components/skeleton-image.js */ "./node_modules/framework7-vue/components/skeleton-image.js");
/* harmony import */ var _components_skeleton_text_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./components/skeleton-text.js */ "./node_modules/framework7-vue/components/skeleton-text.js");
/* harmony import */ var _components_stepper_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./components/stepper.js */ "./node_modules/framework7-vue/components/stepper.js");
/* harmony import */ var _components_subnavbar_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./components/subnavbar.js */ "./node_modules/framework7-vue/components/subnavbar.js");
/* harmony import */ var _components_swipeout_actions_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./components/swipeout-actions.js */ "./node_modules/framework7-vue/components/swipeout-actions.js");
/* harmony import */ var _components_swipeout_button_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./components/swipeout-button.js */ "./node_modules/framework7-vue/components/swipeout-button.js");
/* harmony import */ var _components_swiper_slide_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./components/swiper-slide.js */ "./node_modules/framework7-vue/components/swiper-slide.js");
/* harmony import */ var _components_swiper_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./components/swiper.js */ "./node_modules/framework7-vue/components/swiper.js");
/* harmony import */ var _components_tab_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./components/tab.js */ "./node_modules/framework7-vue/components/tab.js");
/* harmony import */ var _components_tabs_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./components/tabs.js */ "./node_modules/framework7-vue/components/tabs.js");
/* harmony import */ var _components_text_editor_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./components/text-editor.js */ "./node_modules/framework7-vue/components/text-editor.js");
/* harmony import */ var _components_toggle_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./components/toggle.js */ "./node_modules/framework7-vue/components/toggle.js");
/* harmony import */ var _components_toolbar_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./components/toolbar.js */ "./node_modules/framework7-vue/components/toolbar.js");
/* harmony import */ var _components_treeview_item_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./components/treeview-item.js */ "./node_modules/framework7-vue/components/treeview-item.js");
/* harmony import */ var _components_treeview_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./components/treeview.js */ "./node_modules/framework7-vue/components/treeview.js");
/* harmony import */ var _components_use_icon_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./components/use-icon.js */ "./node_modules/framework7-vue/components/use-icon.js");
/* harmony import */ var _components_view_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./components/view.js */ "./node_modules/framework7-vue/components/view.js");
/* harmony import */ var _components_views_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./components/views.js */ "./node_modules/framework7-vue/components/views.js");
/**
 * Framework7 Vue 7.0.9
 * Build full featured iOS & Android apps using Framework7 & Vue
 * https://framework7.io/vue/
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: November 21, 2022
 */











































































































/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_shared_plugin_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/framework7-vue/shared/components-router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7-vue/shared/components-router.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _f7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* harmony import */ var _router_open_in_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./router-open-in.js */ "./node_modules/framework7-vue/shared/router-open-in.js");
/* eslint no-underscore-dangle: "off" */




const getChildrenArray = el => {
  const arr = [];

  for (let i = 0; i < el.children.length; i += 1) {
    arr.push(el.children[i]);
  }

  return arr;
};

const hasSameChildren = (childrenBefore, childrenAfter) => {
  if (childrenBefore.length !== childrenAfter.length) return false;
  const set = new Set([...childrenBefore, ...childrenAfter]);
  if (set.size === childrenBefore.length) return true;
  return false;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  proto: {
    openIn(router, navigateUrl, options) {
      return (0,_router_open_in_js__WEBPACK_IMPORTED_MODULE_2__.routerOpenIn)(router, navigateUrl, options);
    },

    pageComponentLoader(_ref) {
      let {
        routerEl,
        component,
        options,
        resolve,
        reject
      } = _ref;
      const router = this;
      const routerId = router.id;
      const el = routerEl;
      let viewRouter;
      _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7routers.views.forEach(data => {
        if (data.el && data.el === routerEl || data.routerId && data.routerId === routerId) {
          viewRouter = data;
        }
      });

      if (!viewRouter) {
        reject();
        return;
      }

      const pageData = {
        component,
        id: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getComponentId)(),
        props: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          f7route: options.route,
          f7router: router
        }, options.route.params, options.props || {})
      };
      let resolved;
      const childrenBefore = getChildrenArray(el);

      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== viewRouter || resolved) return;
        const childrenAfter = getChildrenArray(el);
        if (hasSameChildren(childrenBefore, childrenAfter)) return;
        _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7events.off('viewRouterDidUpdate', onDidUpdate);
        const pageEl = el.children[el.children.length - 1];
        pageData.el = pageEl;
        resolve(pageEl);
        resolved = true;
      }

      _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7events.on('viewRouterDidUpdate', onDidUpdate);
      viewRouter.pages.push(pageData);
      viewRouter.setPages(viewRouter.pages);
    },

    removePage($pageEl) {
      if (!$pageEl) return;
      const router = this;
      let f7Page;
      if ('length' in $pageEl && $pageEl[0]) f7Page = $pageEl[0].f7Page;else f7Page = $pageEl.f7Page;

      if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
        router.app.$($pageEl).remove();
        return;
      }

      let viewRouter;
      _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7routers.views.forEach(data => {
        if (data.el && data.el === router.el) {
          viewRouter = data;
        }
      });
      let pageEl;

      if ('length' in $pageEl) {
        // Dom7
        if ($pageEl.length === 0) return;
        pageEl = $pageEl[0];
      } else {
        pageEl = $pageEl;
      }

      if (!pageEl) return;
      let pageComponentFound;
      viewRouter.pages.forEach((page, index) => {
        if (page.el === pageEl) {
          pageComponentFound = true;
          viewRouter.pages.splice(index, 1);
          viewRouter.setPages(viewRouter.pages);
        }
      });

      if (!pageComponentFound) {
        pageEl.parentNode.removeChild(pageEl);
      }
    },

    tabComponentLoader(_temp) {
      let {
        tabEl,
        component,
        options,
        resolve,
        reject
      } = _temp === void 0 ? {} : _temp;
      const router = this;
      if (!tabEl) reject();
      let tabRouter;
      _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7routers.tabs.forEach(tabData => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });

      if (!tabRouter) {
        reject();
        return;
      }

      const id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getComponentId)();
      const tabContent = {
        id,
        component,
        props: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          f7route: options.route,
          f7router: router
        }, options.route.route && options.route.route.tab && options.route.route.tab.options && options.route.route.tab.options.props || {}, options.route.params, options.props || {})
      };
      let resolved;

      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== tabRouter || resolved) return;
        _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7events.off('tabRouterDidUpdate', onDidUpdate);
        const tabContentEl = tabEl.children[0];
        resolve(tabContentEl);
        resolved = true;
      }

      _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7events.on('tabRouterDidUpdate', onDidUpdate);
      tabRouter.setTabContent(tabContent);
    },

    removeTabContent(tabEl) {
      if (!tabEl) return;
      let tabRouter;
      _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7routers.tabs.forEach(tabData => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });

      if (!tabRouter) {
        tabEl.innerHTML = ''; // eslint-disable-line

        return;
      }

      tabRouter.setTabContent(null);
    },

    modalComponentLoader(_temp2) {
      let {
        component,
        options,
        resolve,
        reject
      } = _temp2 === void 0 ? {} : _temp2;
      const router = this;
      const modalsRouter = _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7routers.modals;

      if (!modalsRouter) {
        reject();
        return;
      }

      const modalData = {
        component,
        id: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getComponentId)(),
        props: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          f7route: options.route,
          f7router: router
        }, options.route.params, options.props || {})
      };
      let resolved;

      function onDidUpdate() {
        if (resolved) return;
        _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7events.off('modalsRouterDidUpdate', onDidUpdate);
        const modalEl = modalsRouter.el.children[modalsRouter.el.children.length - 1];
        modalData.el = modalEl;
        resolve(modalEl);
        resolved = true;
      }

      _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7events.on('modalsRouterDidUpdate', onDidUpdate);
      modalsRouter.modals.push(modalData);
      modalsRouter.setModals(modalsRouter.modals);
    },

    removeModal(modalEl) {
      const modalsRouter = _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7routers.modals;
      if (!modalsRouter) return;
      let modalDataToRemove;
      modalsRouter.modals.forEach(modalData => {
        if (modalData.el === modalEl) modalDataToRemove = modalData;
      });
      modalsRouter.modals.splice(modalsRouter.modals.indexOf(modalDataToRemove), 1);
      modalsRouter.setModals(modalsRouter.modals);
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7-vue/shared/f7.js":
/*!**************************************************!*\
  !*** ./node_modules/framework7-vue/shared/f7.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f7": () => (/* binding */ f7),
/* harmony export */   "f7events": () => (/* binding */ f7events),
/* harmony export */   "f7init": () => (/* binding */ f7init),
/* harmony export */   "f7initEvents": () => (/* binding */ f7initEvents),
/* harmony export */   "f7ready": () => (/* binding */ f7ready),
/* harmony export */   "f7routers": () => (/* binding */ f7routers),
/* harmony export */   "setTheme": () => (/* binding */ setTheme),
/* harmony export */   "theme": () => (/* binding */ theme)
/* harmony export */ });
/* harmony import */ var framework7_lite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7/lite */ "./node_modules/framework7/framework7-lite.esm.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/framework7-vue/shared/utils.js");
/* eslint-disable import/no-mutable-exports */


let f7;
let f7events;
const theme = {};
const f7routers = {
  views: [],
  tabs: [],
  modals: null
};

const setTheme = () => {
  if (!f7) return;
  theme.ios = f7.theme === 'ios';
  theme.md = f7.theme === 'md';
  theme.aurora = f7.theme === 'aurora';
};

const cleanup = () => {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.unsetRouterIds)();
  delete theme.ios;
  delete theme.md;
  delete theme.aurora;
  f7routers.views = [];
  f7routers.tabs = [];
  f7routers.modals = null;
};

const f7initEvents = () => {
  f7events = new framework7_lite__WEBPACK_IMPORTED_MODULE_1__["default"].Events();
};

const f7init = function (rootEl, params, init) {
  if (params === void 0) {
    params = {};
  }

  if (init === void 0) {
    init = true;
  }

  const f7Params = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, params, {
    el: rootEl,
    init
  });
  if (typeof params.store !== 'undefined') f7Params.store = params.store;
  if (!f7Params.routes) f7Params.routes = [];

  if (f7Params.userAgent && (f7Params.theme === 'auto' || !f7Params.theme)) {
    const device = framework7_lite__WEBPACK_IMPORTED_MODULE_1__["default"].getDevice({
      userAgent: f7Params.userAgent
    }, true);
    theme.ios = !!device.ios;
    theme.aurora = device.desktop && device.electron;
    theme.md = !theme.ios && !theme.aurora;
  } // eslint-disable-next-line


  if (f7 && typeof window !== 'undefined') return; // eslint-disable-next-line

  if (typeof window === 'undefined') cleanup();
  const instance = new framework7_lite__WEBPACK_IMPORTED_MODULE_1__["default"](f7Params);
  f7 = instance;
  setTheme();

  if (instance.initialized) {
    f7 = instance;
    f7events.emit('ready', f7);
  } else {
    instance.on('init', () => {
      f7 = instance;
      f7events.emit('ready', f7);
    });
  }
};

const f7ready = callback => {
  if (!callback) return;
  if (f7 && f7.initialized) callback(f7);else {
    f7events.once('ready', callback);
  }
};



/***/ }),

/***/ "./node_modules/framework7-vue/shared/get-router-initial-component.js":
/*!****************************************************************************!*\
  !*** ./node_modules/framework7-vue/shared/get-router-initial-component.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getRouterInitialComponent": () => (/* binding */ getRouterInitialComponent)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/framework7-vue/shared/utils.js");

const getRouterInitialComponent = (router, initialComponent) => {
  let initialComponentData;
  const {
    initialUrl
  } = router.getInitialUrl();
  const initialRoute = router.findMatchingRoute(initialUrl);
  let routeProps = {};

  if (initialRoute && initialRoute.route && initialRoute.route.options) {
    routeProps = initialRoute.route.options.props;
  }

  const isMasterRoute = route => {
    if (route.master === true) return true;
    if (typeof route.master === 'function') return route.master(router.app);
    return false;
  };

  if (initialRoute && initialRoute.route && (initialRoute.route.component || initialRoute.route.asyncComponent) && !isMasterRoute(initialRoute.route)) {
    initialComponentData = {
      component: initialRoute.route.component || initialRoute.route.asyncComponent,
      initialComponent,
      id: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getComponentId)(),
      isAsync: !!initialRoute.route.asyncComponent,
      props: {
        f7route: initialRoute,
        f7router: router,
        ...routeProps,
        ...initialRoute.params
      }
    };
  }

  return {
    initialPage: initialComponentData,
    initialRoute
  };
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/mixins.js":
/*!******************************************************!*\
  !*** ./node_modules/framework7-vue/shared/mixins.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actionsAttrs": () => (/* binding */ actionsAttrs),
/* harmony export */   "actionsClasses": () => (/* binding */ actionsClasses),
/* harmony export */   "actionsProps": () => (/* binding */ actionsProps),
/* harmony export */   "colorClasses": () => (/* binding */ colorClasses),
/* harmony export */   "colorProps": () => (/* binding */ colorProps),
/* harmony export */   "iconProps": () => (/* binding */ iconProps),
/* harmony export */   "routerAttrs": () => (/* binding */ routerAttrs),
/* harmony export */   "routerClasses": () => (/* binding */ routerClasses),
/* harmony export */   "routerProps": () => (/* binding */ routerProps)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/framework7-vue/shared/utils.js");

function colorClasses(props) {
  const {
    color,
    colorTheme,
    textColor,
    bgColor,
    borderColor,
    rippleColor,
    dark
  } = props;
  return {
    dark,
    [`color-${color}`]: color,
    [`color-theme-${colorTheme}`]: colorTheme,
    [`text-color-${textColor}`]: textColor,
    [`bg-color-${bgColor}`]: bgColor,
    [`border-color-${borderColor}`]: borderColor,
    [`ripple-color-${rippleColor}`]: rippleColor
  };
}
const colorProps = {
  color: String,
  colorTheme: String,
  textColor: String,
  bgColor: String,
  borderColor: String,
  rippleColor: String,
  dark: Boolean
};
const iconProps = {
  icon: String,
  iconMaterial: String,
  iconF7: String,
  iconIos: String,
  iconMd: String,
  iconAurora: String,
  iconColor: String,
  iconSize: [String, Number],
  iconBadge: [String, Number],
  iconBadgeColor: String
};
const routerProps = {
  back: Boolean,
  external: Boolean,
  force: Boolean,
  animate: {
    type: Boolean,
    default: undefined
  },
  ignoreCache: Boolean,
  reloadCurrent: Boolean,
  reloadAll: Boolean,
  reloadPrevious: Boolean,
  reloadDetail: {
    type: Boolean,
    default: undefined
  },
  routeTabId: String,
  view: String,
  routeProps: Object,
  preventRouter: Boolean,
  transition: String,
  openIn: String
};
function routerAttrs(props) {
  const {
    force,
    reloadCurrent,
    reloadPrevious,
    reloadAll,
    reloadDetail,
    animate,
    ignoreCache,
    routeTabId,
    view,
    transition,
    openIn
  } = props;
  let dataAnimate;

  if ('animate' in props && typeof animate !== 'undefined') {
    dataAnimate = animate.toString();
  }

  let dataReloadDetail;

  if ('reloadDetail' in props && typeof reloadDetail !== 'undefined') {
    dataReloadDetail = reloadDetail.toString();
  }

  return {
    'data-force': force || undefined,
    'data-reload-current': reloadCurrent || undefined,
    'data-reload-all': reloadAll || undefined,
    'data-reload-previous': reloadPrevious || undefined,
    'data-reload-detail': dataReloadDetail,
    'data-animate': dataAnimate,
    'data-ignore-cache': ignoreCache || undefined,
    'data-route-tab-id': routeTabId || undefined,
    'data-view': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(view) ? view : undefined,
    'data-transition': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(transition) ? transition : undefined,
    'data-open-in': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(openIn) ? openIn : undefined
  };
}
function routerClasses(props) {
  const {
    back,
    linkBack,
    external,
    preventRouter
  } = props;
  return {
    back: back || linkBack,
    external,
    'prevent-router': preventRouter
  };
}
const actionsProps = {
  searchbarEnable: [Boolean, String],
  searchbarDisable: [Boolean, String],
  searchbarClear: [Boolean, String],
  searchbarToggle: [Boolean, String],
  // Panel
  panelOpen: [Boolean, String],
  panelClose: [Boolean, String],
  panelToggle: [Boolean, String],
  // Popup
  popupOpen: [Boolean, String],
  popupClose: [Boolean, String],
  // Actions
  actionsOpen: [Boolean, String],
  actionsClose: [Boolean, String],
  // Popover
  popoverOpen: [Boolean, String],
  popoverClose: [Boolean, String],
  // Login Screen
  loginScreenOpen: [Boolean, String],
  loginScreenClose: [Boolean, String],
  // Picker
  sheetOpen: [Boolean, String],
  sheetClose: [Boolean, String],
  // Sortable
  sortableEnable: [Boolean, String],
  sortableDisable: [Boolean, String],
  sortableToggle: [Boolean, String],
  // Card
  cardOpen: [Boolean, String],
  cardPreventOpen: [Boolean, String],
  cardClose: [Boolean, String],
  // Menu
  menuClose: {
    type: [Boolean, String],
    default: undefined
  }
};
function actionsAttrs(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsOpen,
    actionsClose,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardClose
  } = props;
  return {
    'data-searchbar': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(searchbarEnable) && searchbarEnable || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(searchbarDisable) && searchbarDisable || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(searchbarClear) && searchbarClear || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(searchbarToggle) && searchbarToggle || undefined,
    'data-panel': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(panelOpen) && panelOpen || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(panelClose) && panelClose || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(panelToggle) && panelToggle || undefined,
    'data-popup': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(popupOpen) && popupOpen || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(popupClose) && popupClose || undefined,
    'data-actions': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(actionsOpen) && actionsOpen || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(actionsClose) && actionsClose || undefined,
    'data-popover': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(popoverOpen) && popoverOpen || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(popoverClose) && popoverClose || undefined,
    'data-sheet': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(sheetOpen) && sheetOpen || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(sheetClose) && sheetClose || undefined,
    'data-login-screen': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(loginScreenOpen) && loginScreenOpen || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(loginScreenClose) && loginScreenClose || undefined,
    'data-sortable': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(sortableEnable) && sortableEnable || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(sortableDisable) && sortableDisable || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(sortableToggle) && sortableToggle || undefined,
    'data-card': (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(cardOpen) && cardOpen || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStringProp)(cardClose) && cardClose || undefined
  };
}
function actionsClasses(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsClose,
    actionsOpen,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardPreventOpen,
    cardClose,
    menuClose
  } = props;
  return {
    'searchbar-enable': searchbarEnable || searchbarEnable === '',
    'searchbar-disable': searchbarDisable || searchbarDisable === '',
    'searchbar-clear': searchbarClear || searchbarClear === '',
    'searchbar-toggle': searchbarToggle || searchbarToggle === '',
    'panel-close': panelClose || panelClose === '',
    'panel-open': panelOpen || panelOpen === '',
    'panel-toggle': panelToggle || panelToggle === '',
    'popup-close': popupClose || popupClose === '',
    'popup-open': popupOpen || popupOpen === '',
    'actions-close': actionsClose || actionsClose === '',
    'actions-open': actionsOpen || actionsOpen === '',
    'popover-close': popoverClose || popoverClose === '',
    'popover-open': popoverOpen || popoverOpen === '',
    'sheet-close': sheetClose || sheetClose === '',
    'sheet-open': sheetOpen || sheetOpen === '',
    'login-screen-close': loginScreenClose || loginScreenClose === '',
    'login-screen-open': loginScreenOpen || loginScreenOpen === '',
    'sortable-enable': sortableEnable || sortableEnable === '',
    'sortable-disable': sortableDisable || sortableDisable === '',
    'sortable-toggle': sortableToggle || sortableToggle === '',
    'card-close': cardClose || cardClose === '',
    'card-open': cardOpen || cardOpen === '',
    'card-prevent-open': cardPreventOpen || cardPreventOpen === '',
    'menu-close': menuClose || menuClose === ''
  };
}

/***/ }),

/***/ "./node_modules/framework7-vue/shared/modal-state-classes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7-vue/shared/modal-state-classes.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "modalStateClasses": () => (/* binding */ modalStateClasses)
/* harmony export */ });
const modalStateClasses = function (_temp) {
  let {
    isOpened,
    isClosing
  } = _temp === void 0 ? {} : _temp;
  return {
    'modal-in': isOpened && !isClosing,
    'modal-out': isClosing
  };
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/plugin.js":
/*!******************************************************!*\
  !*** ./node_modules/framework7-vue/shared/plugin.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "f7": () => (/* reexport safe */ _f7_js__WEBPACK_IMPORTED_MODULE_1__.f7),
/* harmony export */   "f7ready": () => (/* reexport safe */ _f7_js__WEBPACK_IMPORTED_MODULE_1__.f7ready),
/* harmony export */   "theme": () => (/* reexport safe */ _f7_js__WEBPACK_IMPORTED_MODULE_1__.theme)
/* harmony export */ });
/* harmony import */ var framework7_lite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framework7/lite */ "./node_modules/framework7/framework7-lite.esm.js");
/* harmony import */ var _components_router_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components-router.js */ "./node_modules/framework7-vue/shared/components-router.js");
/* harmony import */ var _f7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./f7.js */ "./node_modules/framework7-vue/shared/f7.js");



const Framework7Vue = {
  name: 'vuePlugin',
  installed: false,

  install(params) {
    if (params === void 0) {
      params = {};
    }

    if (Framework7Vue.installed) return;
    Framework7Vue.installed = true;
    (0,_f7_js__WEBPACK_IMPORTED_MODULE_1__.f7initEvents)();
    const {
      theme: paramsTheme,
      userAgent
    } = params;
    if (paramsTheme === 'md') _f7_js__WEBPACK_IMPORTED_MODULE_1__.theme.md = true;
    if (paramsTheme === 'ios') _f7_js__WEBPACK_IMPORTED_MODULE_1__.theme.ios = true;
    if (paramsTheme === 'aurora') _f7_js__WEBPACK_IMPORTED_MODULE_1__.theme.aurora = true; // eslint-disable-next-line

    const needThemeCalc = typeof window === 'undefined' ? !!userAgent : true;

    if (needThemeCalc && (!paramsTheme || paramsTheme === 'auto')) {
      const device = framework7_lite__WEBPACK_IMPORTED_MODULE_2__["default"].getDevice({
        userAgent
      }, true);
      _f7_js__WEBPACK_IMPORTED_MODULE_1__.theme.ios = !!device.ios;
      _f7_js__WEBPACK_IMPORTED_MODULE_1__.theme.aurora = device.desktop && device.electron;
      _f7_js__WEBPACK_IMPORTED_MODULE_1__.theme.md = !_f7_js__WEBPACK_IMPORTED_MODULE_1__.theme.ios && !_f7_js__WEBPACK_IMPORTED_MODULE_1__.theme.aurora;
    }

    (0,_f7_js__WEBPACK_IMPORTED_MODULE_1__.f7ready)(() => {
      (0,_f7_js__WEBPACK_IMPORTED_MODULE_1__.setTheme)();
    });
    framework7_lite__WEBPACK_IMPORTED_MODULE_2__["default"].Router.use(_components_router_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
  }

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Framework7Vue);

/***/ }),

/***/ "./node_modules/framework7-vue/shared/router-open-in.js":
/*!**************************************************************!*\
  !*** ./node_modules/framework7-vue/shared/router-open-in.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "routerOpenIn": () => (/* binding */ routerOpenIn)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _components_popup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/popup.js */ "./node_modules/framework7-vue/components/popup.js");
/* harmony import */ var _components_view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/view.js */ "./node_modules/framework7-vue/components/view.js");
/* harmony import */ var _components_login_screen_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/login-screen.js */ "./node_modules/framework7-vue/components/login-screen.js");
/* harmony import */ var _components_sheet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/sheet.js */ "./node_modules/framework7-vue/components/sheet.js");
/* harmony import */ var _components_popover_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/popover.js */ "./node_modules/framework7-vue/components/popover.js");
/* harmony import */ var _components_panel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/panel.js */ "./node_modules/framework7-vue/components/panel.js");







const routerOpenIn = (router, url, options) => {
  const navigateOptions = {
    url,
    route: {
      path: url,
      options: { ...options,
        openIn: undefined
      }
    }
  };
  const params = { ...options
  };

  if (options.openIn === 'popup') {
    params.component = {
      setup() {
        return () => (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_popup_js__WEBPACK_IMPORTED_MODULE_0__["default"], {
          class: 'popup-router-open-in',
          'data-url': url
        }, [(0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_view_js__WEBPACK_IMPORTED_MODULE_1__["default"], {
          linksView: router.view.selector,
          url,
          ignoreOpenIn: true
        })]);
      }

    };
    navigateOptions.route.popup = params;
  }

  if (options.openIn === 'loginScreen') {
    params.component = {
      setup() {
        return () => (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_login_screen_js__WEBPACK_IMPORTED_MODULE_2__["default"], {
          class: 'login-screen-router-open-in',
          'data-url': url
        }, [(0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_view_js__WEBPACK_IMPORTED_MODULE_1__["default"], {
          linksView: router.view.selector,
          url,
          ignoreOpenIn: true
        })]);
      }

    };
    navigateOptions.route.loginScreen = params;
  }

  if (options.openIn === 'sheet') {
    params.component = {
      setup() {
        return () => (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_sheet_js__WEBPACK_IMPORTED_MODULE_3__["default"], {
          class: 'sheet-modal-router-open-in',
          'data-url': url
        }, [(0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_view_js__WEBPACK_IMPORTED_MODULE_1__["default"], {
          linksView: router.view.selector,
          url,
          ignoreOpenIn: true
        })]);
      }

    };
    navigateOptions.route.sheet = params;
  }

  if (options.openIn === 'popover') {
    params.targetEl = options.clickedEl || options.targetEl;
    params.component = {
      setup() {
        return () => (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_popover_js__WEBPACK_IMPORTED_MODULE_4__["default"], {
          class: 'popover-router-open-in',
          'data-url': url,
          targetEl: options.clickedEl || options.targetEl
        }, [(0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_view_js__WEBPACK_IMPORTED_MODULE_1__["default"], {
          linksView: router.view.selector,
          url,
          ignoreOpenIn: true
        })]);
      }

    };
    navigateOptions.route.popover = params;
  }

  if (options.openIn.indexOf('panel') >= 0) {
    const parts = options.openIn.split(':');
    const side = parts[1] || 'left';
    const effect = parts[2] || 'cover';
    params.component = {
      setup() {
        return () => (0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_panel_js__WEBPACK_IMPORTED_MODULE_5__["default"], {
          class: 'panel-router-open-in',
          'data-url': url,
          side,
          effect
        }, [(0,vue__WEBPACK_IMPORTED_MODULE_6__.h)(_components_view_js__WEBPACK_IMPORTED_MODULE_1__["default"], {
          linksView: router.view.selector,
          url,
          ignoreOpenIn: true
        })]);
      }

    };
    navigateOptions.route.panel = params;
  }

  return router.navigate(navigateOptions);
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/use-icon.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7-vue/shared/use-icon.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useIcon": () => (/* binding */ useIcon)
/* harmony export */ });
const useIcon = function (props) {
  if (props === void 0) {
    props = {};
  }

  const {
    icon,
    iconMaterial,
    iconF7,
    iconMd,
    iconIos,
    iconAurora,
    iconColor,
    iconSize,
    iconBadge,
    badgeColor,
    iconBadgeColor
  } = props;

  if (icon || iconMaterial || iconF7 || iconMd || iconIos || iconAurora) {
    return {
      props: {
        material: iconMaterial,
        f7: iconF7,
        icon,
        md: iconMd,
        ios: iconIos,
        aurora: iconAurora,
        color: iconColor,
        size: iconSize
      },
      badge: iconBadge || iconBadge === 0 ? {
        props: {
          color: badgeColor || iconBadgeColor
        },
        content: iconBadge
      } : null
    };
  }

  return null;
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/use-route-props.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7-vue/shared/use-route-props.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useRouteProps": () => (/* binding */ useRouteProps)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

const useRouteProps = function (elRef, _temp) {
  let {
    routeProps
  } = _temp === void 0 ? {} : _temp;
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
    if (elRef.value && routeProps) {
      elRef.value.f7RouteProps = routeProps;
    }
  });
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
    if (elRef.value && routeProps) {
      elRef.value.f7RouteProps = routeProps;
    } else if (elRef.value && elRef.value.f7RouteProps) {
      delete elRef.value.f7RouteProps;
    }
  });
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/use-smart-select.js":
/*!****************************************************************!*\
  !*** ./node_modules/framework7-vue/shared/use-smart-select.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useSmartSelect": () => (/* binding */ useSmartSelect)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _f7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./f7.js */ "./node_modules/framework7-vue/shared/f7.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/framework7-vue/shared/utils.js");



const useSmartSelect = (props, setInstance, getEl) => {
  let f7SmartSelect;
  (0,vue__WEBPACK_IMPORTED_MODULE_2__.onMounted)(() => {
    (0,_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7ready)(() => {
      if (props.smartSelect) {
        const ssParams = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          el: getEl()
        }, props.smartSelectParams || {});
        f7SmartSelect = _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7.smartSelect.create(ssParams);
        setInstance(f7SmartSelect);
      }
    });
  });
  (0,vue__WEBPACK_IMPORTED_MODULE_2__.onBeforeUnmount)(() => {
    if (f7SmartSelect && f7SmartSelect.destroy) {
      f7SmartSelect.destroy();
    }

    f7SmartSelect = null;
    setInstance(f7SmartSelect);
  });
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/use-store.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/shared/use-store.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useStore": () => (/* binding */ useStore)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _f7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./f7.js */ "./node_modules/framework7-vue/shared/f7.js");


const useStore = function () {
  // (store, getter)
  let store = arguments.length <= 0 ? undefined : arguments[0];
  let getter = arguments.length <= 1 ? undefined : arguments[1];

  if (arguments.length === 1) {
    // (getter)
    store = _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7.store;
    getter = arguments.length <= 0 ? undefined : arguments[0];
  } // eslint-disable-next-line


  const obj = store._gettersPlain[getter];
  const valueRef = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(obj.value);

  const callback = v => {
    valueRef.value = v;
  };

  obj.onUpdated(callback);
  (0,vue__WEBPACK_IMPORTED_MODULE_1__.onBeforeUnmount)(() => {
    // eslint-disable-next-line
    store.__removeCallback(callback);
  });
  return valueRef;
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/use-tab.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7-vue/shared/use-tab.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useTab": () => (/* binding */ useTab)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _f7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./f7.js */ "./node_modules/framework7-vue/shared/f7.js");


const useTab = (elRef, emit) => {
  const onTabShow = el => {
    if (elRef.value !== el) return;
    emit('tab:show', el);
  };

  const onTabHide = el => {
    if (elRef.value !== el) return;
    emit('tab:hide', el);
  };

  (0,vue__WEBPACK_IMPORTED_MODULE_1__.onMounted)(() => {
    if (!elRef.value) return;
    (0,_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7ready)(() => {
      _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7.on('tabShow', onTabShow);
      _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7.on('tabHide', onTabHide);
    });
  });
  (0,vue__WEBPACK_IMPORTED_MODULE_1__.onBeforeUnmount)(() => {
    if (!_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7) return;
    _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7.off('tabShow', onTabShow);
    _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7.off('tabHide', onTabHide);
  });
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/use-theme.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7-vue/shared/use-theme.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useTheme": () => (/* binding */ useTheme)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _f7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./f7.js */ "./node_modules/framework7-vue/shared/f7.js");


const useTheme = () => {
  const t = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7 ? _f7_js__WEBPACK_IMPORTED_MODULE_0__.theme : null);

  if (!_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7) {
    (0,_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7ready)(() => {
      t.value = _f7_js__WEBPACK_IMPORTED_MODULE_0__.theme;
    });
  }

  return t;
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/use-tooltip.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7-vue/shared/use-tooltip.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useTooltip": () => (/* binding */ useTooltip)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _f7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./f7.js */ "./node_modules/framework7-vue/shared/f7.js");


const useTooltip = (elRef, props) => {
  let f7Tooltip = null;
  const {
    tooltip,
    tooltipTrigger
  } = props;
  (0,vue__WEBPACK_IMPORTED_MODULE_1__.onMounted)(() => {
    if (!elRef.value) return;
    if (!tooltip) return;
    (0,_f7_js__WEBPACK_IMPORTED_MODULE_0__.f7ready)(() => {
      f7Tooltip = _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7.tooltip.create({
        targetEl: elRef.value,
        text: tooltip,
        trigger: tooltipTrigger
      });
    });
  });
  (0,vue__WEBPACK_IMPORTED_MODULE_1__.onBeforeUnmount)(() => {
    if (f7Tooltip && f7Tooltip.destroy) {
      f7Tooltip.destroy();
      f7Tooltip = null;
    }
  });
  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(() => props.tooltip, value => {
    if (!value && f7Tooltip) {
      f7Tooltip.destroy();
      f7Tooltip = null;
      return;
    }

    if (value && !f7Tooltip && _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7) {
      f7Tooltip = _f7_js__WEBPACK_IMPORTED_MODULE_0__.f7.tooltip.create({
        targetEl: elRef.value,
        text: value,
        trigger: tooltipTrigger
      });
      return;
    }

    if (!value || !f7Tooltip) return;
    f7Tooltip.setText(value);
  });
};

/***/ }),

/***/ "./node_modules/framework7-vue/shared/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/framework7-vue/shared/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "classNames": () => (/* binding */ classNames),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "getChildren": () => (/* binding */ getChildren),
/* harmony export */   "getComponentId": () => (/* binding */ getComponentId),
/* harmony export */   "getRouterId": () => (/* binding */ getRouterId),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isStringProp": () => (/* binding */ isStringProp),
/* harmony export */   "noUndefinedProps": () => (/* binding */ noUndefinedProps),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "unsetRouterIds": () => (/* binding */ unsetRouterIds)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

function noUndefinedProps(obj) {
  const o = {};
  Object.keys(obj).forEach(key => {
    if (typeof obj[key] !== 'undefined') o[key] = obj[key];
  });
  return o;
}
function isStringProp(val) {
  return typeof val === 'string' && val !== '';
}
function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
}
function now() {
  return Date.now();
}
function extend() {
  let deep = true;
  let to;
  let from;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (typeof args[0] === 'boolean') {
    [deep, to] = args;
    args.splice(0, 2);
    from = args;
  } else {
    [to] = args;
    args.splice(0, 1);
    from = args;
  }

  for (let i = 0; i < from.length; i += 1) {
    const nextSource = args[i];

    if (nextSource !== undefined && nextSource !== null) {
      const keysArray = Object.keys(Object(nextSource));

      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          if (!deep) {
            to[nextKey] = nextSource[nextKey];
          } else if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            extend(to[nextKey], nextSource[nextKey]);
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            extend(to[nextKey], nextSource[nextKey]);
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }

  return to;
}
function classNames() {
  const classes = [];

  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  args.forEach(arg => {
    if (typeof arg === 'object' && arg.constructor === Object) {
      Object.keys(arg).forEach(key => {
        if (arg[key]) classes.push(key);
      });
    } else if (arg) classes.push(arg);
  });
  const uniqueClasses = [];
  classes.forEach(c => {
    if (uniqueClasses.indexOf(c) < 0) uniqueClasses.push(c);
  });
  return uniqueClasses.join(' ');
}
let routerIdCounter = 0;
let routerComponentIdCounter = 0;
function unsetRouterIds() {
  routerIdCounter = 0;
  routerComponentIdCounter = 0;
}
function getRouterId() {
  routerIdCounter += 1;
  return `${now()}_${routerIdCounter}`;
}
function getComponentId() {
  routerComponentIdCounter += 1;
  return `${now()}_${routerComponentIdCounter}`;
}
function getChildren(slots, slotName) {
  if (slotName === void 0) {
    slotName = 'default';
  }

  const result = [];

  const getElementsChildren = els => {
    if (!Array.isArray(els)) {
      return;
    }

    els.forEach(vnode => {
      const isFragment = vnode.type === vue__WEBPACK_IMPORTED_MODULE_0__.Fragment;

      if (isFragment && vnode.children) {
        getElementsChildren(vnode.children);
      } else if (vnode.type && vnode.type !== vue__WEBPACK_IMPORTED_MODULE_0__.Comment) {
        result.push(vnode);
      }
    });
  };

  if (slots[slotName]) getElementsChildren(slots[slotName]());
  return result;
}

/***/ }),

/***/ "./node_modules/framework7/components/accordion/accordion.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/accordion/accordion.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const Accordion = {
  toggleClicked($clickedEl) {
    const app = this;
    let $accordionItemEl = $clickedEl.closest('.accordion-item').eq(0);
    if (!$accordionItemEl.length) $accordionItemEl = $clickedEl.parents('li').eq(0);
    const $accordionContent = $clickedEl.parents('.accordion-item-content').eq(0);

    if ($accordionContent.length) {
      if ($accordionContent.parents($accordionItemEl).length) return;
    }

    if ($clickedEl.parents('li').length > 1 && $clickedEl.parents('li')[0] !== $accordionItemEl[0]) return;
    app.accordion.toggle($accordionItemEl);
  },

  open(el) {
    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    let prevented = false;

    function prevent() {
      prevented = true;
    }

    $el.trigger('accordion:beforeopen', {
      prevent
    }, prevent);
    app.emit('accordionBeforeOpen', $el[0], prevent);
    if (prevented) return;
    const $list = $el.parents('.accordion-list').eq(0);
    let $contentEl = $el.children('.accordion-item-content');
    $contentEl.removeAttr('aria-hidden');
    if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
    if ($contentEl.length === 0) return;
    const $openedItem = $list.length > 0 && $el.parent().children('.accordion-item-opened');

    if ($openedItem.length > 0) {
      app.accordion.close($openedItem);
    }

    $contentEl.transitionEnd(() => {
      if ($el.hasClass('accordion-item-opened')) {
        $contentEl.transition(0);
        $contentEl.css('height', 'auto');
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextFrame)(() => {
          $contentEl.transition('');
          $el.trigger('accordion:opened');
          app.emit('accordionOpened', $el[0]);
        });
      } else {
        $contentEl.css('height', '');
        $el.trigger('accordion:closed');
        app.emit('accordionClosed', $el[0]);
      }
    });
    $contentEl.css('height', `${$contentEl[0].scrollHeight}px`);
    $el.trigger('accordion:open');
    $el.addClass('accordion-item-opened');
    app.emit('accordionOpen', $el[0]);
  },

  close(el) {
    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    let prevented = false;

    function prevent() {
      prevented = true;
    }

    $el.trigger('accordion:beforeclose', {
      prevent
    }, prevent);
    app.emit('accordionBeforeClose', $el[0], prevent);
    if (prevented) return;
    let $contentEl = $el.children('.accordion-item-content');
    if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
    $el.removeClass('accordion-item-opened');
    $contentEl.attr('aria-hidden', true);
    $contentEl.transition(0);
    $contentEl.css('height', `${$contentEl[0].scrollHeight}px`); // Close

    $contentEl.transitionEnd(() => {
      if ($el.hasClass('accordion-item-opened')) {
        $contentEl.transition(0);
        $contentEl.css('height', 'auto');
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextFrame)(() => {
          $contentEl.transition('');
          $el.trigger('accordion:opened');
          app.emit('accordionOpened', $el[0]);
        });
      } else {
        $contentEl.css('height', '');
        $el.trigger('accordion:closed');
        app.emit('accordionClosed', $el[0]);
      }
    });
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextFrame)(() => {
      $contentEl.transition('');
      $contentEl.css('height', '');
      $el.trigger('accordion:close');
      app.emit('accordionClose', $el[0]);
    });
  },

  toggle(el) {
    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    if ($el.length === 0) return;
    if ($el.hasClass('accordion-item-opened')) app.accordion.close(el);else app.accordion.open(el);
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'accordion',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.bindMethods)(app, {
      accordion: Accordion
    });
  },

  clicks: {
    '.accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a': function open($clickedEl) {
      const app = this;
      Accordion.toggleClicked.call(app, $clickedEl);
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/actions/actions-class.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7/components/actions/actions-class.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modal/modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/* eslint indent: ["off"] */





/** @jsx $jsx */



class Actions extends _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
      on: {}
    }, app.params.actions, params); // Extends with open/close Modal methods;

    super(app, extendedParams);
    const actions = this;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__.getDevice)();
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    actions.params = extendedParams; // Buttons

    let groups;

    if (actions.params.buttons) {
      groups = actions.params.buttons;
      if (!Array.isArray(groups[0])) groups = [groups];
    }

    actions.groups = groups; // Find Element

    let $el;

    if (actions.params.el) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(actions.params.el).eq(0);
    } else if (actions.params.content) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(actions.params.content).filter(node => node.nodeType === 1).eq(0);
    } else if (actions.params.buttons) {
      if (actions.params.convertToPopover) {
        actions.popoverHtml = actions.renderPopover();
      }

      actions.actionsHtml = actions.render();
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el && $el.length === 0 && !(actions.actionsHtml || actions.popoverHtml)) {
      return actions.destroy();
    } // Backdrop


    let $backdropEl;

    if (actions.params.backdrop && actions.params.backdropEl) {
      $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(actions.params.backdropEl);
    } else if (actions.params.backdrop) {
      if (actions.params.backdropUnique) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="popup-backdrop popup-backdrop-unique"></div>');
        actions.$containerEl.append($backdropEl);
      } else {
        $backdropEl = actions.$containerEl.children('.actions-backdrop');
      }

      if ($backdropEl.length === 0) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="actions-backdrop"></div>');
        actions.$containerEl.append($backdropEl);
      }
    }

    const originalOpen = actions.open;
    const originalClose = actions.close;
    let popover;

    function buttonOnClick(e) {
      const $buttonEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this);
      let buttonIndex;
      let groupIndex;

      if ($buttonEl.hasClass('list-button') || $buttonEl.hasClass('item-link')) {
        buttonIndex = $buttonEl.parents('li').index();
        groupIndex = $buttonEl.parents('.list').index();
      } else {
        buttonIndex = $buttonEl.index();
        groupIndex = $buttonEl.parents('.actions-group').index();
      }

      if (typeof groups !== 'undefined') {
        const button = groups[groupIndex][buttonIndex];
        if (button.onClick) button.onClick(actions, e);
        if (actions.params.onClick) actions.params.onClick(actions, e);
        if (button.close !== false) actions.close();
      }
    }

    actions.open = function open(animate) {
      let convertToPopover = false;
      const {
        targetEl,
        targetX,
        targetY,
        targetWidth,
        targetHeight
      } = actions.params;

      if (actions.params.convertToPopover && (targetEl || targetX !== undefined && targetY !== undefined)) {
        // Popover
        if (actions.params.forceToPopover || device.ios && device.ipad || app.width >= 768 || device.desktop && app.theme === 'aurora') {
          convertToPopover = true;
        }
      }

      if (convertToPopover && actions.popoverHtml) {
        popover = app.popover.create({
          containerEl: actions.params.containerEl,
          content: actions.popoverHtml,
          backdrop: actions.params.backdrop,
          targetEl,
          targetX,
          targetY,
          targetWidth,
          targetHeight,
          on: {
            open() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }

              actions.$el.trigger(`modal:open ${actions.type.toLowerCase()}:open`);
              actions.emit(`local::open modalOpen ${actions.type}Open`, actions);
            },

            opened() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }

              actions.$el.trigger(`modal:opened ${actions.type.toLowerCase()}:opened`);
              actions.emit(`local::opened modalOpened ${actions.type}Opened`, actions);
            },

            close() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }

              actions.$el.trigger(`modal:close ${actions.type.toLowerCase()}:close`);
              actions.emit(`local::close modalClose ${actions.type}Close`, actions);
            },

            closed() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }

              actions.$el.trigger(`modal:closed ${actions.type.toLowerCase()}:closed`);
              actions.emit(`local::closed modalClosed ${actions.type}Closed`, actions);
            }

          }
        });
        popover.open(animate);
        popover.once('popoverOpened', () => {
          popover.$el.find('.list-button, .item-link').each(buttonEl => {
            (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl).on('click', buttonOnClick);
          });
        });
        popover.once('popoverClosed', () => {
          popover.$el.find('.list-button, .item-link').each(buttonEl => {
            (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl).off('click', buttonOnClick);
          });
          (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
            popover.destroy();
            popover = undefined;
          });
        });
      } else {
        actions.$el = actions.actionsHtml ? (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(actions.actionsHtml) : actions.$el;
        actions.$el[0].f7Modal = actions;

        if (actions.groups) {
          actions.$el.find('.actions-button').each(buttonEl => {
            (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl).on('click', buttonOnClick);
          });
          actions.once('actionsClosed', () => {
            actions.$el.find('.actions-button').each(buttonEl => {
              (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl).off('click', buttonOnClick);
            });
          });
        }

        actions.el = actions.$el[0];
        originalOpen.call(actions, animate);
      }

      return actions;
    };

    actions.close = function close(animate) {
      if (popover) {
        popover.close(animate);
      } else {
        originalClose.call(actions, animate);
      }

      return actions;
    };

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(actions, {
      app,
      $el,
      el: $el ? $el[0] : undefined,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'actions'
    });

    function handleClick(e) {
      const target = e.target;
      const $target = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target);
      const keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened) return;

      if ($target.closest(actions.el).length === 0) {
        if (actions.params.closeByBackdropClick && actions.params.backdrop && actions.backdropEl && actions.backdropEl === target) {
          actions.close();
        } else if (actions.params.closeByOutsideClick) {
          actions.close();
        }
      }
    }

    function onKeyDown(e) {
      const keyCode = e.keyCode;

      if (keyCode === 27 && actions.params.closeOnEscape) {
        actions.close();
      }
    }

    if (actions.params.closeOnEscape) {
      actions.on('open', () => {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('keydown', onKeyDown);
      });
      actions.on('close', () => {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off('keydown', onKeyDown);
      });
    }

    actions.on('opened', () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.on('click', handleClick);
      }
    });
    actions.on('close', () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.off('click', handleClick);
      }
    });

    if ($el) {
      $el[0].f7Modal = actions;
    }

    return actions;
  }

  render() {
    const actions = this;
    if (actions.params.render) return actions.params.render.call(actions, actions);
    const {
      groups
    } = actions;
    const cssClass = actions.params.cssClass;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: `actions-modal${actions.params.grid ? ' actions-grid' : ''} ${cssClass || ''}`
    }, groups.map(group => (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "actions-group"
    }, group.map(button => {
      const buttonClasses = [`actions-${button.label ? 'label' : 'button'}`];
      const {
        color,
        bg,
        bold,
        disabled,
        label,
        text,
        icon
      } = button;
      if (color) buttonClasses.push(`color-${color}`);
      if (bg) buttonClasses.push(`bg-color-${bg}`);
      if (bold) buttonClasses.push('actions-button-bold');
      if (disabled) buttonClasses.push('disabled');

      if (label) {
        return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
          class: buttonClasses.join(' ')
        }, text);
      }

      return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
        class: buttonClasses.join(' ')
      }, icon && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
        class: "actions-button-media"
      }, icon), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
        class: "actions-button-text"
      }, text));
    }))));
  }

  renderPopover() {
    const actions = this;
    if (actions.params.renderPopover) return actions.params.renderPopover.call(actions, actions);
    const {
      groups
    } = actions;
    const cssClass = actions.params.cssClass;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: `popover popover-from-actions ${cssClass || ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "popover-inner"
    }, groups.map(group => (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "list"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("ul", null, group.map(button => {
      const itemClasses = [];
      const {
        color,
        bg,
        bold,
        disabled,
        label,
        text,
        icon
      } = button;
      if (color) itemClasses.push(`color-${color}`);
      if (bg) itemClasses.push(`bg-color-${bg}`);
      if (bold) itemClasses.push('popover-from-actions-bold');
      if (disabled) itemClasses.push('disabled');

      if (label) {
        itemClasses.push('popover-from-actions-label');
        return `<li class="${itemClasses.join(' ')}">${text}</li>`;
      }

      if (icon) {
        itemClasses.push('item-link item-content');
        return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("li", null, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
          class: itemClasses.join(' ')
        }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
          class: "item-media"
        }, icon), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
          class: "item-inner"
        }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
          class: "item-title"
        }, text))));
      }

      itemClasses.push('list-button');
      return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("li", null, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
        class: itemClasses.join(' ')
      }, text));
    }))))));
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Actions);

/***/ }),

/***/ "./node_modules/framework7/components/actions/actions.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/components/actions/actions.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _actions_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions-class.js */ "./node_modules/framework7/components/actions/actions-class.js");
/* harmony import */ var _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/modal-methods.js */ "./node_modules/framework7/shared/modal-methods.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'actions',
  params: {
    actions: {
      convertToPopover: true,
      forceToPopover: false,
      backdrop: true,
      backdropEl: undefined,
      backdropUnique: false,
      cssClass: null,
      closeByBackdropClick: true,
      closeOnEscape: false,
      render: null,
      renderPopover: null,
      containerEl: null
    }
  },
  static: {
    Actions: _actions_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;
    app.actions = (0,_shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
      app,
      constructor: _actions_class_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      defaultSelector: '.actions-modal.modal-in'
    });
  },

  clicks: {
    '.actions-open': function openActions($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.actions.open(data.actions, data.animate, $clickedEl);
    },
    '.actions-close': function closeActions($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.actions.close(data.actions, data.animate, $clickedEl);
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/app/app-class.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7/components/app/app-class.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_events_class_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../shared/events-class.js */ "./node_modules/framework7/shared/events-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");
/* harmony import */ var _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../shared/modal-methods.js */ "./node_modules/framework7/shared/modal-methods.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _load_module_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./load-module.js */ "./node_modules/framework7/components/app/load-module.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/* eslint-disable no-underscore-dangle */












class Framework7 extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(params) {
    if (params === void 0) {
      params = {};
    }

    super(params); // eslint-disable-next-line

    if (Framework7.instance && typeof window !== 'undefined') {
      throw new Error("Framework7 is already initialized and can't be initialized more than once");
    }

    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__.getDevice)({
      userAgent: params.userAgent || undefined
    });
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_4__.getSupport)();
    const passedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.extend)({}, params); // App Instance

    const app = this;
    app.device = device;
    app.support = support;
    const w = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const d = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    Framework7.instance = app; // Default

    const defaults = {
      version: '1.0.0',
      id: 'io.framework7.myapp',
      el: 'body',
      theme: 'auto',
      language: w.navigator.language,
      routes: [],
      name: 'Framework7',
      lazyModulesPath: null,
      initOnDeviceReady: true,
      init: true,
      autoDarkMode: false,
      iosTranslucentBars: true,
      iosTranslucentModals: true,
      component: undefined,
      componentUrl: undefined,
      userAgent: null,
      url: null
    }; // Extend defaults with modules params

    app.useModulesParams(defaults); // Extend defaults with passed params

    app.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.extend)(defaults, params);
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.extend)(app, {
      // App Id
      id: app.params.id,
      // App Name
      name: app.params.name,
      // App version
      version: app.params.version,
      // Routes
      routes: app.params.routes,
      // Lang
      language: app.params.language,
      // Theme
      theme: function getTheme() {
        if (app.params.theme === 'auto') {
          if (device.ios) return 'ios';
          if (device.desktop && device.electron) return 'aurora';
          return 'md';
        }

        return app.params.theme;
      }(),
      // Initially passed parameters
      passedParams,
      online: w.navigator.onLine
    });
    if (params.store) app.params.store = params.store; // Save Root

    if (app.$el && app.$el[0]) {
      app.$el[0].f7 = app;
    } // Install Modules


    app.useModules(); // Init Store

    app.initStore(); // Init

    if (app.params.init) {
      if (device.cordova && app.params.initOnDeviceReady) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(d).on('deviceready', () => {
          app.init();
        });
      } else {
        app.init();
      }
    } // Return app instance


    return app;
  }

  mount(rootEl) {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const $rootEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rootEl || app.params.el).eq(0);
    app.$el = $rootEl;

    if (app.$el && app.$el[0]) {
      app.el = app.$el[0];
      app.el.f7 = app;
      app.rtl = $rootEl.css('direction') === 'rtl';
    } // Auto Dark Mode


    const DARK = '(prefers-color-scheme: dark)';
    const LIGHT = '(prefers-color-scheme: light)';
    app.mq = {};

    if (window.matchMedia) {
      app.mq.dark = window.matchMedia(DARK);
      app.mq.light = window.matchMedia(LIGHT);
    }

    app.colorSchemeListener = function colorSchemeListener(_ref) {
      let {
        matches,
        media
      } = _ref;

      if (!matches) {
        return;
      }

      const html = document.querySelector('html');

      if (media === DARK) {
        html.classList.add('dark');
        app.darkMode = true;
        app.emit('darkModeChange', true);
      } else if (media === LIGHT) {
        html.classList.remove('dark');
        app.darkMode = false;
        app.emit('darkModeChange', false);
      }
    };

    app.emit('mount');
  }

  initStore() {
    const app = this;

    if (typeof app.params.store !== 'undefined' && app.params.store.__store) {
      app.store = app.params.store;
    } else {
      app.store = app.createStore(app.params.store);
    }
  }

  enableAutoDarkMode() {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    if (!window.matchMedia) return;
    const app = this;
    const html = document.querySelector('html');

    if (app.mq.dark && app.mq.light) {
      app.mq.dark.addListener(app.colorSchemeListener);
      app.mq.light.addListener(app.colorSchemeListener);
    }

    if (app.mq.dark && app.mq.dark.matches) {
      html.classList.add('dark');
      app.darkMode = true;
      app.emit('darkModeChange', true);
    } else if (app.mq.light && app.mq.light.matches) {
      html.classList.remove('dark');
      app.darkMode = false;
      app.emit('darkModeChange', false);
    }
  }

  disableAutoDarkMode() {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    if (!window.matchMedia) return;
    const app = this;
    if (app.mq.dark) app.mq.dark.removeListener(app.colorSchemeListener);
    if (app.mq.light) app.mq.light.removeListener(app.colorSchemeListener);
  }

  initAppComponent(callback) {
    const app = this;
    app.router.componentLoader(app.params.component, app.params.componentUrl, {
      componentOptions: {
        el: app.$el[0]
      }
    }, el => {
      app.$el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
      app.$el[0].f7 = app;
      app.$elComponent = el.f7Component;
      app.el = app.$el[0];
      if (callback) callback();
    }, () => {});
  }

  init(rootEl) {
    const app = this;
    app.mount(rootEl);

    const init = () => {
      if (app.initialized) return;
      app.$el.addClass('framework7-initializing'); // RTL attr

      if (app.rtl) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').attr('dir', 'rtl');
      } // Auto Dark Mode


      if (app.params.autoDarkMode) {
        app.enableAutoDarkMode();
      } // Watch for online/offline state


      const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
      window.addEventListener('offline', () => {
        app.online = false;
        app.emit('offline');
        app.emit('connection', false);
      });
      window.addEventListener('online', () => {
        app.online = true;
        app.emit('online');
        app.emit('connection', true);
      }); // Root class

      app.$el.addClass('framework7-root'); // Theme class

      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').removeClass('ios md aurora').addClass(app.theme); // iOS Translucent

      const device = app.device;

      if (app.params.iosTranslucentBars && app.theme === 'ios' && device.ios) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').addClass('ios-translucent-bars');
      }

      if (app.params.iosTranslucentModals && app.theme === 'ios' && device.ios) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').addClass('ios-translucent-modals');
      } // Init class


      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.nextFrame)(() => {
        app.$el.removeClass('framework7-initializing');
      }); // Emit, init other modules

      app.initialized = true;
      app.emit('init');
    };

    if (app.params.component || app.params.componentUrl) {
      app.initAppComponent(() => {
        init();
      });
    } else {
      init();
    }

    return app;
  } // eslint-disable-next-line


  loadModule() {
    return Framework7.loadModule(...arguments);
  } // eslint-disable-next-line


  loadModules() {
    return Framework7.loadModules(...arguments);
  }

  getVnodeHooks(hook, id) {
    const app = this;
    if (!app.vnodeHooks || !app.vnodeHooks[hook]) return [];
    return app.vnodeHooks[hook][id] || [];
  } // eslint-disable-next-line


  get $() {
    return _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  }

  static get Dom7() {
    return _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  }

  static get $() {
    return _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  }

  static get device() {
    return (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__.getDevice)();
  }

  static get support() {
    return (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_4__.getSupport)();
  }

  static get Class() {
    return _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  }

  static get Events() {
    return _shared_events_class_js__WEBPACK_IMPORTED_MODULE_6__["default"];
  }

}

Framework7.$jsx = _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_7__["default"];
Framework7.ModalMethods = _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_8__["default"];
Framework7.ConstructorMethods = _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_9__["default"];
Framework7.loadModule = _load_module_js__WEBPACK_IMPORTED_MODULE_10__["default"];

Framework7.loadModules = function loadModules(modules) {
  return Promise.all(modules.map(module => Framework7.loadModule(module)));
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Framework7);

/***/ }),

/***/ "./node_modules/framework7/components/app/load-module.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/components/app/load-module.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");



const fetchedModules = [];

function loadModule(moduleToLoad) {
  const Framework7 = this;
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  return new Promise((resolve, reject) => {
    const app = Framework7.instance;
    let modulePath;
    let moduleObj;
    let moduleFunc;

    if (!moduleToLoad) {
      reject(new Error('Framework7: Lazy module must be specified'));
      return;
    }

    function install(module) {
      Framework7.use(module);

      if (app) {
        app.useModuleParams(module, app.params);
        app.useModule(module);
      }
    }

    if (typeof moduleToLoad === 'string') {
      const matchNamePattern = moduleToLoad.match(/([a-z0-9-]*)/i);

      if (moduleToLoad.indexOf('.') < 0 && matchNamePattern && matchNamePattern[0].length === moduleToLoad.length) {
        if (!app || app && !app.params.lazyModulesPath) {
          reject(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name'));
          return;
        }

        modulePath = `${app.params.lazyModulesPath}/${moduleToLoad}/${moduleToLoad}.lazy.js`;
      } else {
        modulePath = moduleToLoad;
      }
    } else if (typeof moduleToLoad === 'function') {
      moduleFunc = moduleToLoad;
    } else {
      // considering F7-Plugin object
      moduleObj = moduleToLoad;
    }

    if (moduleFunc) {
      const module = moduleFunc(Framework7, false);

      if (!module) {
        reject(new Error("Framework7: Can't find Framework7 component in specified component function"));
        return;
      } // Check if it was added


      if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
        resolve();
        return;
      } // Install It


      install(module);
      resolve();
    }

    if (moduleObj) {
      const module = moduleObj;

      if (!module) {
        reject(new Error("Framework7: Can't find Framework7 component in specified component"));
        return;
      } // Check if it was added


      if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
        resolve();
        return;
      } // Install It


      install(module);
      resolve();
    }

    if (modulePath) {
      if (fetchedModules.indexOf(modulePath) >= 0) {
        resolve();
        return;
      }

      fetchedModules.push(modulePath);
      const scriptLoad = new Promise((resolveScript, rejectScript) => {
        Framework7.request.get(modulePath, scriptContent => {
          const callbackId = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.id)();
          const callbackLoadName = `f7_component_loader_callback_${callbackId}`;
          const scriptEl = document.createElement('script');
          scriptEl.innerHTML = `window.${callbackLoadName} = function (Framework7, Framework7AutoInstallComponent) {return ${scriptContent.trim()}}`;
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('head').append(scriptEl);
          const componentLoader = window[callbackLoadName];
          delete window[callbackLoadName];
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scriptEl).remove();
          const module = componentLoader(Framework7, false);

          if (!module) {
            rejectScript(new Error(`Framework7: Can't find Framework7 component in ${modulePath} file`));
            return;
          } // Check if it was added


          if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
            resolveScript();
            return;
          } // Install It


          install(module);
          resolveScript();
        }, (xhr, status) => {
          rejectScript(xhr, status);
        });
      });
      const styleLoad = new Promise(resolveStyle => {
        Framework7.request.get(modulePath.replace('.lazy.js', app.rtl ? '.rtl.css' : '.css').replace('.js', app.rtl ? '.rtl.css' : '.css'), styleContent => {
          const styleEl = document.createElement('style');
          styleEl.innerHTML = styleContent;
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('head').append(styleEl);
          resolveStyle();
        }, () => {
          resolveStyle();
        });
      });
      Promise.all([scriptLoad, styleLoad]).then(() => {
        resolve();
      }).catch(err => {
        reject(err);
      });
    }
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loadModule);

/***/ }),

/***/ "./node_modules/framework7/components/appbar/appbar.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7/components/appbar/appbar.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'appbar'
});

/***/ }),

/***/ "./node_modules/framework7/components/autocomplete/autocomplete-class.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/autocomplete/autocomplete-class.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/* eslint "no-useless-escape": "off" */




/** @jsx $jsx */



class Autocomplete extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const ac = this;
    ac.app = app;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
    const defaults = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
      on: {}
    }, app.params.autocomplete);

    if (typeof defaults.searchbarDisableButton === 'undefined') {
      defaults.searchbarDisableButton = app.theme !== 'aurora';
    } // Extend defaults with modules params


    ac.useModulesParams(defaults);
    ac.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(defaults, params);
    let $openerEl;

    if (ac.params.openerEl) {
      $openerEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ac.params.openerEl);
      if ($openerEl.length) $openerEl[0].f7Autocomplete = ac;
    }

    let $inputEl;

    if (ac.params.inputEl) {
      $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ac.params.inputEl);
      if ($inputEl.length) $inputEl[0].f7Autocomplete = ac;
    }

    const uniqueId = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.id)();
    let url = params.url;

    if (!url && $openerEl && $openerEl.length) {
      if ($openerEl.attr('href')) url = $openerEl.attr('href');else if ($openerEl.find('a').length > 0) {
        url = $openerEl.find('a').attr('href');
      }
    }

    if (!url || url === '#' || url === '') url = ac.params.url;
    const inputType = ac.params.multiple ? 'checkbox' : 'radio';
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(ac, {
      $openerEl,
      openerEl: $openerEl && $openerEl[0],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      id: uniqueId,
      url,
      value: ac.params.value || [],
      inputType,
      inputName: `${inputType}-${uniqueId}`,
      $modalEl: undefined,
      $dropdownEl: undefined
    });
    let previousQuery = '';

    function onInputChange() {
      let query = ac.$inputEl.val().trim();
      if (!ac.params.source) return;
      ac.params.source.call(ac, query, items => {
        let itemsHTML = '';
        const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
        ac.items = items;
        let regExp;

        if (ac.params.highlightMatches) {
          query = query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
          regExp = new RegExp(`(${query})`, 'i');
        }

        let firstValue;
        let firstItem;

        for (let i = 0; i < limit; i += 1) {
          const itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
          const itemText = typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i];

          if (i === 0) {
            firstValue = itemValue;
            firstItem = ac.items[i];
          }

          itemsHTML += ac.renderItem({
            value: itemValue,
            text: ac.params.highlightMatches ? itemText.replace(regExp, '<b>$1</b>') : itemText
          }, i);
        }

        if (itemsHTML === '' && query === '' && ac.params.dropdownPlaceholderText) {
          itemsHTML += ac.renderItem({
            placeholder: true,
            text: ac.params.dropdownPlaceholderText
          });
        }

        ac.$dropdownEl.find('ul').html(itemsHTML);

        if (ac.params.typeahead) {
          if (!firstValue || !firstItem) {
            return;
          }

          if (firstValue.toLowerCase().indexOf(query.toLowerCase()) !== 0) {
            return;
          }

          if (previousQuery.toLowerCase() === query.toLowerCase()) {
            ac.value = [];
            return;
          }

          if (previousQuery.toLowerCase().indexOf(query.toLowerCase()) === 0) {
            previousQuery = query;
            ac.value = [];
            return;
          }

          $inputEl.val(firstValue);
          $inputEl[0].setSelectionRange(query.length, firstValue.length);
          const previousValue = typeof ac.value[0] === 'object' ? ac.value[0][ac.params.valueProperty] : ac.value[0];

          if (!previousValue || firstValue.toLowerCase() !== previousValue.toLowerCase()) {
            ac.value = [firstItem];
            ac.emit('local::change autocompleteChange', [firstItem]);
          }
        }

        previousQuery = query;
      });
    }

    function onPageInputChange() {
      const inputEl = this;
      const value = inputEl.value;
      const isValues = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(inputEl).parents('.autocomplete-values').length > 0;
      let item;
      let itemValue;
      let aValue;

      if (isValues) {
        if (ac.inputType === 'checkbox' && !inputEl.checked) {
          for (let i = 0; i < ac.value.length; i += 1) {
            aValue = typeof ac.value[i] === 'string' ? ac.value[i] : ac.value[i][ac.params.valueProperty];

            if (aValue === value || aValue * 1 === value * 1) {
              ac.value.splice(i, 1);
            }
          }

          ac.updateValues();
          ac.emit('local::change autocompleteChange', ac.value);
        }

        return;
      } // Find Related Item


      for (let i = 0; i < ac.items.length; i += 1) {
        itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        if (itemValue === value || itemValue * 1 === value * 1) item = ac.items[i];
      }

      if (ac.inputType === 'radio') {
        ac.value = [item];
      } else if (inputEl.checked) {
        ac.value.push(item);
      } else {
        for (let i = 0; i < ac.value.length; i += 1) {
          aValue = typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i];

          if (aValue === value || aValue * 1 === value * 1) {
            ac.value.splice(i, 1);
          }
        }
      } // Update Values Block


      ac.updateValues(); // On Select Callback

      if (ac.inputType === 'radio' && inputEl.checked || ac.inputType === 'checkbox') {
        ac.emit('local::change autocompleteChange', ac.value);
      }
    }

    function onHtmlClick(e) {
      const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target);
      if ($targetEl.is(ac.$inputEl[0]) || ac.$dropdownEl && $targetEl.closest(ac.$dropdownEl[0]).length) return;
      ac.close();
    }

    function onOpenerClick() {
      ac.open();
    }

    function onInputFocus() {
      ac.open();
    }

    function onInputBlur() {
      if (ac.$dropdownEl.find('label.active-state').length > 0) return;
      setTimeout(() => {
        ac.close();
      }, 0);
    }

    function onResize() {
      ac.positionDropdown();
    }

    function onKeyDown(e) {
      if (!ac.opened) return;

      if (e.keyCode === 27) {
        // ESC
        e.preventDefault();
        ac.$inputEl.blur();
        return;
      }

      if (e.keyCode === 13) {
        // Enter
        const $selectedItemLabel = ac.$dropdownEl.find('.autocomplete-dropdown-selected label');

        if ($selectedItemLabel.length) {
          e.preventDefault();
          $selectedItemLabel.trigger('click');
          ac.$inputEl.blur();
          return;
        }

        if (ac.params.typeahead) {
          e.preventDefault();
          ac.$inputEl.blur();
        }

        return;
      }

      if (e.keyCode !== 40 && e.keyCode !== 38) return;
      e.preventDefault();
      const $selectedItem = ac.$dropdownEl.find('.autocomplete-dropdown-selected');
      let $newItem;

      if ($selectedItem.length) {
        $newItem = $selectedItem[e.keyCode === 40 ? 'next' : 'prev']('li');

        if (!$newItem.length) {
          $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
        }
      } else {
        $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
      }

      if ($newItem.hasClass('autocomplete-dropdown-placeholder')) return;
      $selectedItem.removeClass('autocomplete-dropdown-selected');
      $newItem.addClass('autocomplete-dropdown-selected');
    }

    function onDropdownClick() {
      const $clickedEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this);
      let clickedItem;

      for (let i = 0; i < ac.items.length; i += 1) {
        const itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        const value = $clickedEl.attr('data-value');

        if (itemValue === value || itemValue * 1 === value * 1) {
          clickedItem = ac.items[i];
        }
      }

      if (ac.params.updateInputValueOnSelect) {
        ac.$inputEl.val(typeof clickedItem === 'object' ? clickedItem[ac.params.valueProperty] : clickedItem);
        ac.$inputEl.trigger('input change');
      }

      ac.value = [clickedItem];
      ac.emit('local::change autocompleteChange', [clickedItem]);
      ac.close();
    }

    ac.attachEvents = function attachEvents() {
      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
        ac.$openerEl.on('click', onOpenerClick);
      }

      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
        ac.$inputEl.on('focus', onInputFocus);
        ac.$inputEl.on(ac.params.inputEvents, onInputChange);

        if (device.android) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('html').on('click', onHtmlClick);
        } else {
          ac.$inputEl.on('blur', onInputBlur);
        }

        ac.$inputEl.on('keydown', onKeyDown);
      }
    };

    ac.detachEvents = function attachEvents() {
      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
        ac.$openerEl.off('click', onOpenerClick);
      }

      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
        ac.$inputEl.off('focus', onInputFocus);
        ac.$inputEl.off(ac.params.inputEvents, onInputChange);

        if (device.android) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('html').off('click', onHtmlClick);
        } else {
          ac.$inputEl.off('blur', onInputBlur);
        }

        ac.$inputEl.off('keydown', onKeyDown);
      }
    };

    ac.attachDropdownEvents = function attachDropdownEvents() {
      ac.$dropdownEl.on('click', 'label', onDropdownClick);
      app.on('resize', onResize);
    };

    ac.detachDropdownEvents = function detachDropdownEvents() {
      ac.$dropdownEl.off('click', 'label', onDropdownClick);
      app.off('resize', onResize);
    };

    ac.attachPageEvents = function attachPageEvents() {
      ac.$el.on('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);

      if (ac.params.closeOnSelect && !ac.params.multiple) {
        ac.$el.once('click', '.list label', () => {
          (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
            ac.close();
          });
        });
      }
    };

    ac.detachPageEvents = function detachPageEvents() {
      ac.$el.off('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
    }; // Install Modules


    ac.useModules(); // Init

    ac.init();
    return ac;
  }

  get view() {
    const ac = this;
    const {
      $openerEl,
      $inputEl,
      app
    } = ac;
    let view;

    if (ac.params.view) {
      view = ac.params.view;
    } else if ($openerEl || $inputEl) {
      const $el = $openerEl || $inputEl;
      view = $el.closest('.view').length && $el.closest('.view')[0].f7View;
    }

    if (!view) view = app.views.main;
    return view;
  }

  positionDropdown() {
    const ac = this;
    const {
      $inputEl,
      app,
      $dropdownEl
    } = ac;
    const $pageContentEl = $inputEl.parents('.page-content');
    if ($pageContentEl.length === 0) return;
    const inputOffset = $inputEl.offset();
    const inputOffsetWidth = $inputEl[0].offsetWidth;
    const inputOffsetHeight = $inputEl[0].offsetHeight;
    const $listEl = $inputEl.parents('.list');
    let $listParent;
    $listEl.parents().each(parentEl => {
      if ($listParent) return;
      const $parentEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(parentEl);
      if ($parentEl.parent($pageContentEl).length) $listParent = $parentEl;
    });
    const listOffset = $listEl.offset();
    const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
    const listOffsetLeft = $listEl.length > 0 ? listOffset.left - $pageContentEl.offset().left : 0;
    const inputOffsetLeft = inputOffset.left - ($listEl.length > 0 ? listOffset.left : 0) - (app.rtl ? 0 : 0);
    const inputOffsetTop = inputOffset.top - ($pageContentEl.offset().top - $pageContentEl[0].scrollTop);
    const maxHeight = $pageContentEl[0].scrollHeight - paddingBottom - (inputOffsetTop + $pageContentEl[0].scrollTop) - $inputEl[0].offsetHeight;
    const paddingProp = app.rtl ? 'padding-right' : 'padding-left';
    let paddingValue;

    if ($listEl.length && !ac.params.expandInput) {
      paddingValue = (app.rtl ? $listEl[0].offsetWidth - inputOffsetLeft - inputOffsetWidth : inputOffsetLeft) - (app.theme === 'md' ? 16 : 15);
    }

    $dropdownEl.css({
      left: `${$listEl.length > 0 ? listOffsetLeft : inputOffsetLeft}px`,
      top: `${inputOffsetTop + $pageContentEl[0].scrollTop + inputOffsetHeight}px`,
      width: `${$listEl.length > 0 ? $listEl[0].offsetWidth : inputOffsetWidth}px`
    });
    $dropdownEl.children('.autocomplete-dropdown-inner').css({
      maxHeight: `${maxHeight}px`,
      [paddingProp]: $listEl.length > 0 && !ac.params.expandInput ? `${paddingValue}px` : ''
    });
  }

  focus() {
    const ac = this;
    ac.$el.find('input[type=search]').focus();
  }

  source(query) {
    const ac = this;
    if (!ac.params.source) return;
    const {
      $el
    } = ac;
    ac.params.source.call(ac, query, items => {
      let itemsHTML = '';
      const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
      ac.items = items;

      for (let i = 0; i < limit; i += 1) {
        let selected = false;
        const itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];

        for (let j = 0; j < ac.value.length; j += 1) {
          const aValue = typeof ac.value[j] === 'object' ? ac.value[j][ac.params.valueProperty] : ac.value[j];
          if (aValue === itemValue || aValue * 1 === itemValue * 1) selected = true;
        }

        itemsHTML += ac.renderItem({
          value: itemValue,
          text: typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i],
          inputType: ac.inputType,
          id: ac.id,
          inputName: ac.inputName,
          selected
        }, i);
      }

      $el.find('.autocomplete-found ul').html(itemsHTML);

      if (items.length === 0) {
        if (query.length !== 0) {
          $el.find('.autocomplete-not-found').show();
          $el.find('.autocomplete-found, .autocomplete-values').hide();
        } else {
          $el.find('.autocomplete-values').show();
          $el.find('.autocomplete-found, .autocomplete-not-found').hide();
        }
      } else {
        $el.find('.autocomplete-found').show();
        $el.find('.autocomplete-not-found, .autocomplete-values').hide();
      }
    });
  }

  updateValues() {
    const ac = this;
    let valuesHTML = '';

    for (let i = 0; i < ac.value.length; i += 1) {
      valuesHTML += ac.renderItem({
        value: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i],
        text: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.textProperty] : ac.value[i],
        inputType: ac.inputType,
        id: ac.id,
        inputName: `${ac.inputName}-checked}`,
        selected: true
      }, i);
    }

    ac.$el.find('.autocomplete-values ul').html(valuesHTML);
  }

  preloaderHide() {
    const ac = this;

    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
      ac.$dropdownEl.find('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
    } else {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
    }
  }

  preloaderShow() {
    const ac = this;

    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
      ac.$dropdownEl.find('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
    } else {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
    }
  }

  renderPreloader() {
    const ac = this;
    const preloaders = {
      iosPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.iosPreloaderContent,
      mdPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.mdPreloaderContent,
      auroraPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.auroraPreloaderContent
    };
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `autocomplete-preloader preloader ${ac.params.preloaderColor ? `color-${ac.params.preloaderColor}` : ''}`
    }, preloaders[`${ac.app.theme}PreloaderContent`] || '');
  }

  renderSearchbar() {
    const ac = this;
    if (ac.params.renderSearchbar) return ac.params.renderSearchbar.call(ac);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("form", {
      class: "searchbar"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "searchbar-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "searchbar-input-wrap"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("input", {
      type: "search",
      spellcheck: ac.params.searchbarSpellcheck || 'false',
      placeholder: ac.params.searchbarPlaceholder
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("i", {
      class: "searchbar-icon"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", {
      class: "input-clear-button"
    })), ac.params.searchbarDisableButton && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", {
      class: "searchbar-disable-button"
    }, ac.params.searchbarDisableText)));
  }

  renderItem(item, index) {
    const ac = this;
    if (ac.params.renderItem) return ac.params.renderItem.call(ac, item, index);
    const itemValue = item.value && typeof item.value === 'string' ? item.value.replace(/"/g, '&quot;') : item.value;

    if (ac.params.openIn !== 'dropdown') {
      return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("li", null, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("label", {
        class: `item-${item.inputType} item-content`
      }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("input", {
        type: item.inputType,
        name: item.inputName,
        value: itemValue,
        _checked: item.selected
      }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("i", {
        class: `icon icon-${item.inputType}`
      }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
        class: "item-inner"
      }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
        class: "item-title"
      }, item.text))));
    } // Dropdown


    if (!item.placeholder) {
      return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("li", null, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("label", {
        class: "item-radio item-content",
        "data-value": itemValue
      }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
        class: "item-inner"
      }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
        class: "item-title"
      }, item.text))));
    } // Dropwdown placeholder


    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("li", {
      class: "autocomplete-dropdown-placeholder"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("label", {
      class: "item-content"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "item-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "item-title"
    }, item.text))));
  }

  renderNavbar() {
    const ac = this;
    if (ac.params.renderNavbar) return ac.params.renderNavbar.call(ac);
    let pageTitle = ac.params.pageTitle;

    if (typeof pageTitle === 'undefined' && ac.$openerEl && ac.$openerEl.length) {
      pageTitle = ac.$openerEl.find('.item-title').text().trim();
    }

    const inPopup = ac.params.openIn === 'popup'; // eslint-disable-next-line

    const navbarLeft = inPopup ? ac.params.preloader && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "left"
    }, ac.renderPreloader()) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "left sliding"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("a", {
      class: "link back"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("i", {
      class: "icon icon-back"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", {
      class: "if-not-md"
    }, ac.params.pageBackLinkText)));
    const navbarRight = inPopup ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "right"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("a", {
      class: "link popup-close",
      "data-popup": ".autocomplete-popup"
    }, ac.params.popupCloseLinkText)) : ac.params.preloader && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "right"
    }, ac.renderPreloader());
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `navbar ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "navbar-bg"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `navbar-inner ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ''}`
    }, navbarLeft, pageTitle && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "title sliding"
    }, pageTitle), navbarRight, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "subnavbar sliding"
    }, ac.renderSearchbar())));
  }

  renderDropdown() {
    const ac = this;
    if (ac.params.renderDropdown) return ac.params.renderDropdown.call(ac, ac.items);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "autocomplete-dropdown"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "autocomplete-dropdown-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `list ${!ac.params.expandInput ? 'no-safe-areas' : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("ul", null))), ac.params.preloader && ac.renderPreloader());
  }

  renderPage(inPopup) {
    const ac = this;
    if (ac.params.renderPage) return ac.params.renderPage.call(ac, ac.items);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "page page-with-subnavbar autocomplete-page",
      "data-name": "autocomplete-page"
    }, ac.renderNavbar(inPopup), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "searchbar-backdrop"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "page-content"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `list autocomplete-list autocomplete-found autocomplete-list-${ac.id} ${ac.params.formColorTheme ? `color-${ac.params.formColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("ul", null)), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "list autocomplete-not-found"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("ul", null, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("li", {
      class: "item-content"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "item-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "item-title"
    }, ac.params.notFoundText))))), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "list autocomplete-values"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("ul", null))));
  }

  renderPopup() {
    const ac = this;
    if (ac.params.renderPopup) return ac.params.renderPopup.call(ac, ac.items);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "popup autocomplete-popup"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "view"
    }, ac.renderPage(true), ";"));
  }

  onOpen(type, el) {
    const ac = this;
    const app = ac.app;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    ac.$el = $el;
    ac.el = $el[0];
    ac.openedIn = type;
    ac.opened = true;

    if (ac.params.openIn === 'dropdown') {
      ac.attachDropdownEvents();
      ac.$dropdownEl.addClass('autocomplete-dropdown-in');
      ac.$inputEl.trigger('input');
    } else {
      // Init SB
      let $searchbarEl = $el.find('.searchbar');

      if (ac.params.openIn === 'page' && app.theme === 'ios' && $searchbarEl.length === 0) {
        $searchbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(app.navbar.getElByPage($el)).find('.searchbar');
      }

      ac.searchbar = app.searchbar.create({
        el: $searchbarEl,
        backdropEl: $el.find('.searchbar-backdrop'),
        customSearch: true,
        on: {
          search(sb, query) {
            if (query.length === 0 && ac.searchbar.enabled) {
              ac.searchbar.backdropShow();
            } else {
              ac.searchbar.backdropHide();
            }

            ac.source(query);
          }

        }
      }); // Attach page events

      ac.attachPageEvents(); // Update Values On Page Init

      ac.updateValues(); // Source on load

      if (ac.params.requestSourceOnOpen) ac.source('');
    }

    ac.emit('local::open autocompleteOpen', ac);
  }

  autoFocus() {
    const ac = this;

    if (ac.searchbar && ac.searchbar.$inputEl) {
      ac.searchbar.$inputEl.focus();
    }

    return ac;
  }

  onOpened() {
    const ac = this;

    if (ac.params.openIn !== 'dropdown' && ac.params.autoFocus) {
      ac.autoFocus();
    }

    ac.emit('local::opened autocompleteOpened', ac);
  }

  onClose() {
    const ac = this;
    if (ac.destroyed) return; // Destroy SB

    if (ac.searchbar && ac.searchbar.destroy) {
      ac.searchbar.destroy();
      ac.searchbar = null;
      delete ac.searchbar;
    }

    if (ac.params.openIn === 'dropdown') {
      ac.detachDropdownEvents();
      ac.$dropdownEl.removeClass('autocomplete-dropdown-in').remove();
      ac.$inputEl.parents('.item-content-dropdown-expanded').removeClass('item-content-dropdown-expanded');
    } else {
      ac.detachPageEvents();
    }

    ac.emit('local::close autocompleteClose', ac);
  }

  onClosed() {
    const ac = this;
    if (ac.destroyed) return;
    ac.opened = false;
    ac.$el = null;
    ac.el = null;
    delete ac.$el;
    delete ac.el;
    ac.emit('local::closed autocompleteClosed', ac);
  }

  openPage() {
    const ac = this;
    if (ac.opened) return ac;
    const pageHtml = ac.renderPage();
    ac.view.router.navigate({
      url: ac.url,
      route: {
        content: pageHtml,
        path: ac.url,
        on: {
          pageBeforeIn(e, page) {
            ac.onOpen('page', page.el);
          },

          pageAfterIn(e, page) {
            ac.onOpened('page', page.el);
          },

          pageBeforeOut(e, page) {
            ac.onClose('page', page.el);
          },

          pageAfterOut(e, page) {
            ac.onClosed('page', page.el);
          }

        },
        options: {
          animate: ac.params.animate
        }
      }
    });
    return ac;
  }

  openPopup() {
    const ac = this;
    if (ac.opened) return ac;
    const popupHtml = ac.renderPopup();
    const popupParams = {
      content: popupHtml,
      animate: ac.params.animate,
      push: ac.params.popupPush,
      swipeToClose: ac.params.popupSwipeToClose,
      on: {
        popupOpen(popup) {
          ac.onOpen('popup', popup.el);
        },

        popupOpened(popup) {
          ac.onOpened('popup', popup.el);
        },

        popupClose(popup) {
          ac.onClose('popup', popup.el);
        },

        popupClosed(popup) {
          ac.onClosed('popup', popup.el);
        }

      }
    };

    if (ac.params.routableModals && ac.view) {
      ac.view.router.navigate({
        url: ac.url,
        route: {
          path: ac.url,
          popup: popupParams
        }
      });
    } else {
      ac.modal = ac.app.popup.create(popupParams).open(ac.params.animate);
    }

    return ac;
  }

  openDropdown() {
    const ac = this;

    if (!ac.$dropdownEl) {
      ac.$dropdownEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ac.renderDropdown());
    }

    const $listEl = ac.$inputEl.parents('.list');

    if ($listEl.length && ac.$inputEl.parents('.item-content').length > 0 && ac.params.expandInput) {
      ac.$inputEl.parents('.item-content').addClass('item-content-dropdown-expanded');
    }

    const $pageContentEl = ac.$inputEl.parents('.page-content');

    if (ac.params.dropdownContainerEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ac.params.dropdownContainerEl).append(ac.$dropdownEl);
    } else if ($pageContentEl.length === 0) {
      ac.$dropdownEl.insertAfter(ac.$inputEl);
    } else {
      ac.positionDropdown();
      $pageContentEl.append(ac.$dropdownEl);
    }

    ac.onOpen('dropdown', ac.$dropdownEl);
    ac.onOpened('dropdown', ac.$dropdownEl);
  }

  open() {
    const ac = this;
    if (ac.opened) return ac;
    const openIn = ac.params.openIn;
    ac[`open${openIn.split('').map((el, index) => {
      if (index === 0) return el.toUpperCase();
      return el;
    }).join('')}`]();
    return ac;
  }

  close() {
    const ac = this;
    if (!ac.opened) return ac;

    if (ac.params.openIn === 'dropdown') {
      ac.onClose();
      ac.onClosed();
    } else if (ac.params.routableModals && ac.view || ac.openedIn === 'page') {
      ac.view.router.back({
        animate: ac.params.animate
      });
    } else {
      ac.modal.once('modalClosed', () => {
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
          if (ac.destroyed) return;
          ac.modal.destroy();
          delete ac.modal;
        });
      });
      ac.modal.close();
    }

    return ac;
  }

  init() {
    const ac = this;
    ac.attachEvents();
  }

  destroy() {
    const ac = this;
    ac.emit('local::beforeDestroy autocompleteBeforeDestroy', ac);
    ac.detachEvents();

    if (ac.$inputEl && ac.$inputEl[0]) {
      delete ac.$inputEl[0].f7Autocomplete;
    }

    if (ac.$openerEl && ac.$openerEl[0]) {
      delete ac.$openerEl[0].f7Autocomplete;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.deleteProps)(ac);
    ac.destroyed = true;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Autocomplete);

/***/ }),

/***/ "./node_modules/framework7/components/autocomplete/autocomplete.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7/components/autocomplete/autocomplete.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _autocomplete_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autocomplete-class.js */ "./node_modules/framework7/components/autocomplete/autocomplete-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'autocomplete',
  params: {
    autocomplete: {
      openerEl: undefined,
      inputEl: undefined,
      view: undefined,
      // DropDown
      dropdownContainerEl: undefined,
      dropdownPlaceholderText: undefined,
      typeahead: false,
      highlightMatches: true,
      expandInput: false,
      updateInputValueOnSelect: true,
      inputEvents: 'input',
      value: undefined,
      multiple: false,
      source: undefined,
      limit: undefined,
      valueProperty: 'id',
      textProperty: 'text',
      openIn: 'page',
      // or 'popup' or 'dropdown'
      pageBackLinkText: 'Back',
      popupCloseLinkText: 'Close',
      pageTitle: undefined,
      searchbarPlaceholder: 'Search...',
      searchbarDisableText: 'Cancel',
      searchbarDisableButton: undefined,
      searchbarSpellcheck: false,
      popupPush: false,
      popupSwipeToClose: undefined,
      animate: true,
      autoFocus: false,
      closeOnSelect: false,
      notFoundText: 'Nothing found',
      requestSourceOnOpen: false,
      // Preloader
      preloaderColor: undefined,
      preloader: false,
      // Colors
      formColorTheme: undefined,
      navbarColorTheme: undefined,
      // Routing
      routableModals: false,
      url: 'select/',
      // Custom render functions
      renderDropdown: undefined,
      renderPage: undefined,
      renderPopup: undefined,
      renderItem: undefined,
      renderSearchbar: undefined,
      renderNavbar: undefined
    }
  },
  static: {
    Autocomplete: _autocomplete_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;
    app.autocomplete = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: undefined,
      constructor: _autocomplete_class_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      app,
      domProp: 'f7Autocomplete'
    }), {
      open(autocompleteEl) {
        const ac = app.autocomplete.get(autocompleteEl);
        if (ac && ac.open) return ac.open();
        return undefined;
      },

      close(autocompleteEl) {
        const ac = app.autocomplete.get(autocompleteEl);
        if (ac && ac.close) return ac.close();
        return undefined;
      }

    });
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/breadcrumbs/breadcrumbs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/framework7/components/breadcrumbs/breadcrumbs.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");

const Breadcrumbs = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'breadrumbs',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.bindMethods)(app, {
      breadrumbs: Breadcrumbs
    });
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/calendar/calendar-class.js":
/*!***********************************************************************!*\
  !*** ./node_modules/framework7/components/calendar/calendar-class.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");





/** @jsx $jsx */



class Calendar extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const calendar = this;
    calendar.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, app.params.calendar, params);
    let $containerEl;

    if (calendar.params.containerEl) {
      $containerEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(calendar.params.containerEl);
      if ($containerEl.length === 0) return calendar;
    }

    let $inputEl;

    if (calendar.params.inputEl) {
      $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(calendar.params.inputEl);
    }

    const isHorizontal = calendar.params.direction === 'horizontal';
    let inverter = 1;

    if (isHorizontal) {
      inverter = app.rtl ? -1 : 1;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(calendar, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      initialized: false,
      opened: false,
      url: calendar.params.url,
      isHorizontal,
      inverter,
      animating: false,
      allowTouchMove: true,
      hasTimePicker: calendar.params.timePicker && !calendar.params.rangePicker && !calendar.params.multiple
    });

    calendar.dayFormatter = date => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        day: 'numeric'
      });
      return formatter.format(date).replace(/日/, '');
    };

    calendar.monthFormatter = date => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        month: 'long'
      });
      return formatter.format(date);
    };

    calendar.yearFormatter = date => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        year: 'numeric'
      });
      return formatter.format(date);
    };

    calendar.timeSelectorFormatter = date => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, calendar.params.timePickerFormat);
      return formatter.format(date);
    };

    const timeFormatCheckDate = calendar.timeSelectorFormatter(new Date()).toLowerCase();
    calendar.is12HoursFormat = timeFormatCheckDate.indexOf('pm') >= 0 || timeFormatCheckDate.indexOf('am') >= 0; // Auto names

    let {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    } = calendar.params;
    const {
      monthNamesIntl,
      monthNamesShortIntl,
      dayNamesIntl,
      dayNamesShortIntl
    } = calendar.getIntlNames();
    if (monthNames === 'auto') monthNames = monthNamesIntl;
    if (monthNamesShort === 'auto') monthNamesShort = monthNamesShortIntl;
    if (dayNames === 'auto') dayNames = dayNamesIntl;
    if (dayNamesShort === 'auto') dayNamesShort = dayNamesShortIntl;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(calendar, {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    });

    function onInputClick() {
      calendar.open();
    }

    function onInputFocus(e) {
      e.preventDefault();
    }

    function onInputClear() {
      calendar.setValue([]);

      if (calendar.opened) {
        calendar.update();
      }
    }

    function onHtmlClick(e) {
      const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target);
      if (calendar.destroyed || !calendar.params) return;
      if (calendar.isPopover()) return;
      if (!calendar.opened || calendar.closing) return;
      if ($targetEl.closest('[class*="backdrop"]').length) return;
      if (calendar.monthPickerPopover || calendar.yearPickerPopover || calendar.timePickerPopover) return;

      if ($inputEl && $inputEl.length > 0) {
        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal, .calendar-modal').length === 0) {
          calendar.close();
        }
      } else if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.sheet-modal, .calendar-modal').length === 0) {
        calendar.close();
      }
    } // Events


    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(calendar, {
      attachInputEvents() {
        calendar.$inputEl.on('click', onInputClick);
        calendar.$inputEl.on('input:clear', onInputClear);

        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.on('focus mousedown', onInputFocus);

          if (calendar.$inputEl[0]) {
            calendar.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },

      detachInputEvents() {
        calendar.$inputEl.off('click', onInputClick);
        calendar.$inputEl.off('input:clear', onInputClear);

        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.off('focus mousedown', onInputFocus);

          if (calendar.$inputEl[0]) {
            delete calendar.$inputEl[0].f7ValidateReadonly;
          }
        }
      },

      attachHtmlEvents() {
        app.on('click', onHtmlClick);
      },

      detachHtmlEvents() {
        app.off('click', onHtmlClick);
      }

    });

    calendar.attachCalendarEvents = function attachCalendarEvents() {
      let allowItemClick = true;
      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchCurrentX;
      let touchCurrentY;
      let touchStartTime;
      let touchEndTime;
      let currentTranslate;
      let wrapperWidth;
      let wrapperHeight;
      let percentage;
      let touchesDiff;
      let isScrolling;
      const {
        $el,
        $wrapperEl
      } = calendar;

      function handleTouchStart(e) {
        if (isMoved || isTouched) return;
        isTouched = true;
        touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentX = touchStartX;
        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        touchStartTime = new Date().getTime();
        percentage = 0;
        allowItemClick = true;
        isScrolling = undefined;
        currentTranslate = calendar.monthsTranslate;
      }

      function handleTouchMove(e) {
        if (!isTouched) return;
        const {
          isHorizontal: isH
        } = calendar;
        touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
        }

        if (isH && isScrolling || !calendar.allowTouchMove) {
          isTouched = false;
          return;
        }

        e.preventDefault();

        if (calendar.animating) {
          isTouched = false;
          return;
        }

        allowItemClick = false;

        if (!isMoved) {
          // First move
          isMoved = true;
          wrapperWidth = $wrapperEl[0].offsetWidth;
          wrapperHeight = $wrapperEl[0].offsetHeight;
          $wrapperEl.transition(0);
        }

        touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
        percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
        currentTranslate = (calendar.monthsTranslate * calendar.inverter + percentage) * 100; // Transform wrapper

        $wrapperEl.transform(`translate3d(${isH ? currentTranslate : 0}%, ${isH ? 0 : currentTranslate}%, 0)`);
      }

      function handleTouchEnd() {
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }

        isTouched = false;
        isMoved = false;
        touchEndTime = new Date().getTime();

        if (touchEndTime - touchStartTime < 300) {
          if (Math.abs(touchesDiff) < 10) {
            calendar.resetMonth();
          } else if (touchesDiff >= 10) {
            if (app.rtl) calendar.nextMonth();else calendar.prevMonth();
          } else if (app.rtl) calendar.prevMonth();else calendar.nextMonth();
        } else if (percentage <= -0.5) {
          if (app.rtl) calendar.prevMonth();else calendar.nextMonth();
        } else if (percentage >= 0.5) {
          if (app.rtl) calendar.nextMonth();else calendar.prevMonth();
        } else {
          calendar.resetMonth();
        } // Allow click


        setTimeout(() => {
          allowItemClick = true;
        }, 100);
      }

      function handleDayClick(e) {
        if (!allowItemClick) return;
        let $dayEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).parents('.calendar-day');

        if ($dayEl.length === 0 && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).hasClass('calendar-day')) {
          $dayEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target);
        }

        if ($dayEl.length === 0) return;
        if ($dayEl.hasClass('calendar-day-disabled')) return;

        if (!calendar.params.rangePicker) {
          if ($dayEl.hasClass('calendar-day-next')) calendar.nextMonth();
          if ($dayEl.hasClass('calendar-day-prev')) calendar.prevMonth();
        }

        const dateYear = parseInt($dayEl.attr('data-year'), 10);
        const dateMonth = parseInt($dayEl.attr('data-month'), 10);
        const dateDay = parseInt($dayEl.attr('data-day'), 10);
        calendar.emit('local::dayClick calendarDayClick', calendar, $dayEl[0], dateYear, dateMonth, dateDay);

        if (!$dayEl.hasClass('calendar-day-selected') || calendar.params.multiple || calendar.params.rangePicker) {
          const valueToAdd = new Date(dateYear, dateMonth, dateDay, 0, 0, 0);

          if (calendar.hasTimePicker) {
            if (calendar.value && calendar.value[0]) {
              valueToAdd.setHours(calendar.value[0].getHours(), calendar.value[0].getMinutes());
            } else {
              valueToAdd.setHours(new Date().getHours(), new Date().getMinutes());
            }
          }

          calendar.addValue(valueToAdd);
        }

        if (calendar.params.closeOnSelect) {
          if (calendar.params.rangePicker && calendar.value.length === 2 || !calendar.params.rangePicker) {
            calendar.close();
          }
        }
      }

      function onNextMonthClick() {
        calendar.nextMonth();
      }

      function onPrevMonthClick() {
        calendar.prevMonth();
      }

      function onNextYearClick() {
        calendar.nextYear();
      }

      function onPrevYearClick() {
        calendar.prevYear();
      }

      function onMonthSelectorClick() {
        calendar.openMonthPicker();
      }

      function onYearSelectorClick() {
        calendar.openYearPicker();
      }

      function onTimeSelectorClick() {
        calendar.openTimePicker();
      }

      const passiveListener = app.touchEvents.start === 'touchstart' && (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__.getSupport)().passiveListener ? {
        passive: true,
        capture: false
      } : false; // Selectors clicks

      $el.find('.calendar-prev-month-button').on('click', onPrevMonthClick);
      $el.find('.calendar-next-month-button').on('click', onNextMonthClick);
      $el.find('.calendar-prev-year-button').on('click', onPrevYearClick);
      $el.find('.calendar-next-year-button').on('click', onNextYearClick);

      if (calendar.params.monthPicker) {
        $el.find('.current-month-value').on('click', onMonthSelectorClick);
      }

      if (calendar.params.yearPicker) {
        $el.find('.current-year-value').on('click', onYearSelectorClick);
      }

      if (calendar.hasTimePicker) {
        $el.find('.calendar-time-selector a').on('click', onTimeSelectorClick);
      } // Day clicks


      $wrapperEl.on('click', handleDayClick); // Touch events

      if (calendar.params.touchMove) {
        $wrapperEl.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      }

      calendar.detachCalendarEvents = function detachCalendarEvents() {
        $el.find('.calendar-prev-month-button').off('click', onPrevMonthClick);
        $el.find('.calendar-next-month-button').off('click', onNextMonthClick);
        $el.find('.calendar-prev-year-button').off('click', onPrevYearClick);
        $el.find('.calendar-next-year-button').off('click', onNextYearClick);

        if (calendar.params.monthPicker) {
          $el.find('.current-month-value').off('click', onMonthSelectorClick);
        }

        if (calendar.params.yearPicker) {
          $el.find('.current-year-value').off('click', onYearSelectorClick);
        }

        if (calendar.hasTimePicker) {
          $el.find('.calendar-time-selector a').off('click', onTimeSelectorClick);
        }

        $wrapperEl.off('click', handleDayClick);

        if (calendar.params.touchMove) {
          $wrapperEl.off(app.touchEvents.start, handleTouchStart, passiveListener);
          app.off('touchmove:active', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
        }
      };
    };

    calendar.init();
    return calendar;
  }

  get view() {
    const {
      $inputEl,
      app,
      params
    } = this;
    let view;

    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
    }

    if (!view) view = app.views.main;
    return view;
  }

  getIntlNames() {
    const calendar = this;
    const locale = calendar.params.locale;
    const monthNamesIntl = [];
    const monthNamesShortIntl = [];
    const dayNamesIntl = [];
    const dayNamesShortIntl = [];
    const formatterMonthNames = new Intl.DateTimeFormat(locale, {
      month: 'long'
    });
    const formatterMonthNamesShort = new Intl.DateTimeFormat(locale, {
      month: 'short'
    });
    const formatterDayNames = new Intl.DateTimeFormat(locale, {
      weekday: 'long'
    });
    const formatterDayNamesShort = new Intl.DateTimeFormat(locale, {
      weekday: 'short'
    });
    let year;
    let yearStarted;
    let yearEnded;

    for (let i = 0; i < 24; i += 1) {
      const date = new Date().setMonth(i, 1);
      const currentYear = calendar.yearFormatter(date);

      if (year && currentYear !== year) {
        if (yearStarted) yearEnded = true;
        yearStarted = true;
        year = currentYear;
      }

      if (!year) {
        year = currentYear;
      }

      if (yearStarted && year === currentYear && !yearEnded) {
        monthNamesIntl.push(formatterMonthNames.format(date));
        monthNamesShortIntl.push(formatterMonthNamesShort.format(date));
      }
    }

    const weekDay = new Date().getDay();

    for (let i = 0; i < 7; i += 1) {
      const date = new Date().getTime() + (i - weekDay) * 24 * 60 * 60 * 1000;
      dayNamesIntl.push(formatterDayNames.format(date));
      dayNamesShortIntl.push(formatterDayNamesShort.format(date));
    }

    return {
      monthNamesIntl,
      monthNamesShortIntl,
      dayNamesIntl,
      dayNamesShortIntl
    };
  }

  normalizeDate(date) {
    const calendar = this;
    const d = new Date(date);

    if (calendar.hasTimePicker) {
      return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
    }

    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }

  normalizeValues(values) {
    const calendar = this;
    let newValues = [];

    if (values && Array.isArray(values)) {
      newValues = values.map(val => calendar.normalizeDate(val));
    }

    return newValues;
  }

  initInput() {
    const calendar = this;
    if (!calendar.$inputEl) return;
    if (calendar.params.inputReadOnly) calendar.$inputEl.prop('readOnly', true);
  }

  isPopover() {
    const calendar = this;
    const {
      app,
      modal,
      params
    } = calendar;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__.getDevice)();
    if (params.openIn === 'sheet') return false;
    if (modal && modal.type !== 'popover') return false;

    if (!calendar.inline && calendar.inputEl) {
      if (params.openIn === 'popover') return true;

      if (device.ios) {
        return !!device.ipad;
      }

      if (app.width >= 768) {
        return true;
      }

      if (device.desktop && app.theme === 'aurora') {
        return true;
      }
    }

    return false;
  }

  formatDate(d) {
    const calendar = this;
    const date = new Date(d);
    const year = date.getFullYear();
    const month = date.getMonth();
    const month1 = month + 1;
    const day = date.getDate();
    const weekDay = date.getDay();
    const {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    } = calendar;
    const {
      dateFormat,
      locale
    } = calendar.params;

    function twoDigits(number) {
      return number < 10 ? `0${number}` : number;
    }

    if (typeof dateFormat === 'string') {
      const tokens = {
        yyyy: year,
        yy: String(year).substring(2),
        mm: twoDigits(month1),
        m: month1,
        MM: monthNames[month],
        M: monthNamesShort[month],
        dd: twoDigits(day),
        d: day,
        DD: dayNames[weekDay],
        D: dayNamesShort[weekDay]
      };

      if (calendar.params.timePicker) {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        let hours12 = hours;
        if (hours > 12) hours12 = hours - 12;
        if (hours === 0) hours12 = 12;
        const a = hours >= 12 && hours !== 0 ? 'pm' : 'am';
        Object.assign(tokens, {
          HH: twoDigits(hours),
          H: hours,
          hh: twoDigits(hours12),
          h: hours12,
          ss: twoDigits(seconds),
          s: seconds,
          ':mm': twoDigits(minutes),
          ':m': minutes,
          a,
          A: a.toUpperCase()
        });
      }

      const regexp = new RegExp(Object.keys(tokens).map(t => `(${t})`).join('|'), 'g');
      return dateFormat.replace(regexp, token => {
        if (token in tokens) return tokens[token];
        return token;
      });
    }

    if (typeof dateFormat === 'function') {
      return dateFormat(date);
    } // Intl Object


    const formatter = new Intl.DateTimeFormat(locale, dateFormat);
    return formatter.format(date);
  }

  formatValue() {
    const calendar = this;
    const {
      value
    } = calendar;

    if (calendar.params.formatValue) {
      return calendar.params.formatValue.call(calendar, value);
    }

    return value.map(v => calendar.formatDate(v)).join(calendar.params.rangePicker ? ' - ' : ', ');
  }

  addValue(newValue) {
    const calendar = this;
    const {
      multiple,
      rangePicker,
      rangePickerMinDays,
      rangePickerMaxDays
    } = calendar.params;

    if (multiple) {
      if (!calendar.value) calendar.value = [];
      let inValuesIndex;

      for (let i = 0; i < calendar.value.length; i += 1) {
        if (new Date(newValue).getTime() === new Date(calendar.value[i]).getTime()) {
          inValuesIndex = i;
        }
      }

      if (typeof inValuesIndex === 'undefined') {
        calendar.value.push(newValue);
      } else {
        calendar.value.splice(inValuesIndex, 1);
      }

      calendar.updateValue();
    } else if (rangePicker) {
      if (!calendar.value) calendar.value = [];

      if (calendar.value.length === 2 || calendar.value.length === 0) {
        calendar.value = [];
      }

      if (calendar.value.length === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) >= (rangePickerMinDays - 1) * 60 * 60 * 24 * 1000 && (rangePickerMaxDays === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) <= (rangePickerMaxDays - 1) * 60 * 60 * 24 * 1000)) calendar.value.push(newValue);else calendar.value = [];
      calendar.value.sort((a, b) => a - b);
      calendar.updateValue();
    } else {
      calendar.value = [newValue];
      calendar.updateValue();
    }
  }

  setValue(values) {
    const calendar = this;
    const currentValue = calendar.value;

    if (Array.isArray(currentValue) && Array.isArray(values) && currentValue.length === values.length) {
      let equal = true;
      currentValue.forEach((v, index) => {
        if (v !== values[index]) equal = false;
      });
      if (equal) return;
    }

    calendar.value = values;
    calendar.updateValue();
  }

  getValue() {
    const calendar = this;
    return calendar.value;
  }

  updateValue(onlyHeader) {
    const calendar = this;
    const {
      $el,
      $wrapperEl,
      $inputEl,
      value,
      params
    } = calendar;
    let i;

    if ($el && $el.length > 0) {
      $wrapperEl.find('.calendar-day-selected').removeClass('calendar-day-selected calendar-day-selected-range calendar-day-selected-left calendar-day-selected-right');
      let valueDate;

      if (params.rangePicker && value.length === 2) {
        const leftDate = new Date(value[0]).getTime();
        const rightDate = new Date(value[1]).getTime();

        for (i = leftDate; i <= rightDate; i += 24 * 60 * 60 * 1000) {
          valueDate = new Date(i);
          let addClass = 'calendar-day-selected';

          if (leftDate !== rightDate) {
            if (i !== leftDate && i !== rightDate) {
              addClass += ' calendar-day-selected-range';
            }

            if (i === leftDate) {
              addClass += ' calendar-day-selected-left';
            }

            if (i === rightDate) {
              addClass += ' calendar-day-selected-right';
            }
          }

          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass(addClass);
        }

        valueDate = new Date(leftDate);
        $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).removeClass('calendar-day-selected-range').addClass('calendar-day-selected calendar-day-selected-left');
        valueDate = new Date(rightDate);
        $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).removeClass('calendar-day-selected-range').addClass('calendar-day-selected calendar-day-selected-right');
      } else {
        for (i = 0; i < calendar.value.length; i += 1) {
          valueDate = new Date(value[i]);
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass('calendar-day-selected');
        }
      }
    }

    if (!onlyHeader) {
      calendar.emit('local::change calendarChange', calendar, value);
    }

    if ($el && $el.length > 0 && calendar.hasTimePicker) {
      $el.find('.calendar-time-selector a').text(value && value.length ? calendar.timeSelectorFormatter(value[0]) : calendar.params.timePickerPlaceholder);
    }

    if ($inputEl && $inputEl.length || params.header) {
      const inputValue = calendar.formatValue(value);

      if (params.header && $el && $el.length) {
        $el.find('.calendar-selected-date').text(inputValue);
      }

      if ($inputEl && $inputEl.length && !onlyHeader) {
        $inputEl.val(inputValue);
        $inputEl.trigger('change');
      }
    }
  }

  updateCurrentMonthYear(dir) {
    const calendar = this;
    const {
      $months,
      $el,
      monthNames
    } = calendar;
    let currentLocaleMonth;
    let currentLocaleYear;

    if (typeof dir === 'undefined') {
      calendar.currentMonth = parseInt($months.eq(1).attr('data-month'), 10);
      calendar.currentYear = parseInt($months.eq(1).attr('data-year'), 10);
      currentLocaleMonth = $months.eq(1).attr('data-locale-month');
      currentLocaleYear = $months.eq(1).attr('data-locale-year');
    } else {
      calendar.currentMonth = parseInt($months.eq(dir === 'next' ? $months.length - 1 : 0).attr('data-month'), 10);
      calendar.currentYear = parseInt($months.eq(dir === 'next' ? $months.length - 1 : 0).attr('data-year'), 10);
      currentLocaleMonth = $months.eq(dir === 'next' ? $months.length - 1 : 0).attr('data-locale-month');
      currentLocaleYear = $months.eq(dir === 'next' ? $months.length - 1 : 0).attr('data-locale-year');
    }

    $el.find('.current-month-value').text(monthNames[currentLocaleMonth]);
    $el.find('.current-year-value').text(currentLocaleYear);
  }

  update() {
    const calendar = this;
    const {
      currentYear,
      currentMonth,
      $wrapperEl
    } = calendar;
    const currentDate = new Date(currentYear, currentMonth);
    const prevMonthHtml = calendar.renderMonth(currentDate, 'prev');
    const currentMonthHtml = calendar.renderMonth(currentDate);
    const nextMonthHtml = calendar.renderMonth(currentDate, 'next');
    $wrapperEl.transition(0).html(`${prevMonthHtml}${currentMonthHtml}${nextMonthHtml}`).transform('translate3d(0,0,0)');
    calendar.$months = $wrapperEl.find('.calendar-month');
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();
    calendar.$months.each(monthEl => {
      calendar.emit('local::monthAdd calendarMonthAdd', monthEl);
    });
  }

  onMonthChangeStart(dir) {
    const calendar = this;
    const {
      $months,
      currentYear,
      currentMonth
    } = calendar;
    calendar.updateCurrentMonthYear(dir);
    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
    const currentIndex = dir === 'next' ? $months.length - 1 : 0;
    $months.eq(currentIndex).addClass('calendar-month-current');
    $months.eq(dir === 'next' ? currentIndex - 1 : currentIndex + 1).addClass(dir === 'next' ? 'calendar-month-prev' : 'calendar-month-next');
    calendar.emit('local::monthYearChangeStart calendarMonthYearChangeStart', calendar, currentYear, currentMonth);
  }

  onMonthChangeEnd(dir, rebuildBoth) {
    const calendar = this;
    const {
      currentYear,
      currentMonth,
      $wrapperEl,
      monthsTranslate
    } = calendar;
    calendar.animating = false;
    let nextMonthHtml;
    let prevMonthHtml;
    let currentMonthHtml;
    $wrapperEl.find('.calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)').remove();

    if (typeof dir === 'undefined') {
      dir = 'next'; // eslint-disable-line

      rebuildBoth = true; // eslint-disable-line
    }

    if (!rebuildBoth) {
      currentMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), dir);
    } else {
      $wrapperEl.find('.calendar-month-next, .calendar-month-prev').remove();
      prevMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'prev');
      nextMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'next');
    }

    if (dir === 'next' || rebuildBoth) {
      $wrapperEl.append(currentMonthHtml || nextMonthHtml);
    }

    if (dir === 'prev' || rebuildBoth) {
      $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
    }

    const $months = $wrapperEl.find('.calendar-month');
    calendar.$months = $months;
    calendar.setMonthsTranslate(monthsTranslate);
    calendar.emit('local::monthAdd calendarMonthAdd', calendar, dir === 'next' ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]);
    calendar.emit('local::monthYearChangeEnd calendarMonthYearChangeEnd', calendar, currentYear, currentMonth);
  }

  setMonthsTranslate(translate) {
    const calendar = this;
    const {
      $months,
      isHorizontal: isH,
      inverter
    } = calendar; // eslint-disable-next-line

    translate = translate || calendar.monthsTranslate || 0;

    if (typeof calendar.monthsTranslate === 'undefined') {
      calendar.monthsTranslate = translate;
    }

    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
    const prevMonthTranslate = -(translate + 1) * 100 * inverter;
    const currentMonthTranslate = -translate * 100 * inverter;
    const nextMonthTranslate = -(translate - 1) * 100 * inverter;
    $months.eq(0).transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`).addClass('calendar-month-prev');
    $months.eq(1).transform(`translate3d(${isH ? currentMonthTranslate : 0}%, ${isH ? 0 : currentMonthTranslate}%, 0)`).addClass('calendar-month-current');
    $months.eq(2).transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`).addClass('calendar-month-next');
  }

  nextMonth(transition) {
    const calendar = this;
    const {
      params,
      $wrapperEl,
      inverter,
      isHorizontal: isH
    } = calendar;

    if (typeof transition === 'undefined' || typeof transition === 'object') {
      transition = ''; // eslint-disable-line

      if (!params.animate) transition = 0; // eslint-disable-line
    }

    const nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-month'), 10);
    const nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-year'), 10);
    const nextDate = new Date(nextYear, nextMonth);
    const nextDateTime = nextDate.getTime();
    const transitionEndCallback = !calendar.animating;

    if (params.maxDate) {
      if (nextDateTime > new Date(params.maxDate).getTime()) {
        calendar.resetMonth();
        return;
      }
    }

    calendar.monthsTranslate -= 1;

    if (nextMonth === calendar.currentMonth) {
      const nextMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
      const nextMonthHtml = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(calendar.renderMonth(nextDateTime, 'next')).transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`).addClass('calendar-month-next');
      $wrapperEl.append(nextMonthHtml[0]);
      calendar.$months = $wrapperEl.find('.calendar-month');
      calendar.emit('local::monthAdd calendarMonthAdd', calendar.$months.eq(calendar.$months.length - 1)[0]);
    }

    calendar.animating = true;
    calendar.onMonthChangeStart('next');
    const translate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);

    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd('next');
      });
    }

    if (!params.animate) {
      calendar.onMonthChangeEnd('next');
    }
  }

  prevMonth(transition) {
    const calendar = this;
    const {
      params,
      $wrapperEl,
      inverter,
      isHorizontal: isH
    } = calendar;

    if (typeof transition === 'undefined' || typeof transition === 'object') {
      transition = ''; // eslint-disable-line

      if (!params.animate) transition = 0; // eslint-disable-line
    }

    const prevMonth = parseInt(calendar.$months.eq(0).attr('data-month'), 10);
    const prevYear = parseInt(calendar.$months.eq(0).attr('data-year'), 10);
    const prevDate = new Date(prevYear, prevMonth + 1, -1);
    const prevDateTime = prevDate.getTime();
    const transitionEndCallback = !calendar.animating;

    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);

      if (prevDateTime < minDate.getTime()) {
        calendar.resetMonth();
        return;
      }
    }

    calendar.monthsTranslate += 1;

    if (prevMonth === calendar.currentMonth) {
      const prevMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
      const prevMonthHtml = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(calendar.renderMonth(prevDateTime, 'prev')).transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`).addClass('calendar-month-prev');
      $wrapperEl.prepend(prevMonthHtml[0]);
      calendar.$months = $wrapperEl.find('.calendar-month');
      calendar.emit('local::monthAdd calendarMonthAdd', calendar.$months.eq(0)[0]);
    }

    calendar.animating = true;
    calendar.onMonthChangeStart('prev');
    const translate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);

    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd('prev');
      });
    }

    if (!params.animate) {
      calendar.onMonthChangeEnd('prev');
    }
  }

  resetMonth(transition) {
    if (transition === void 0) {
      transition = '';
    }

    const calendar = this;
    const {
      $wrapperEl,
      inverter,
      isHorizontal: isH,
      monthsTranslate
    } = calendar;
    const translate = monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
  } // eslint-disable-next-line


  setYearMonth(year, month, transition) {
    const calendar = this;
    const {
      params,
      isHorizontal: isH,
      $wrapperEl,
      inverter
    } = calendar; // eslint-disable-next-line

    if (typeof year === 'undefined') year = calendar.currentYear; // eslint-disable-next-line

    if (typeof month === 'undefined') month = calendar.currentMonth;

    if (typeof transition === 'undefined' || typeof transition === 'object') {
      // eslint-disable-next-line
      transition = ''; // eslint-disable-next-line

      if (!params.animate) transition = 0;
    }

    let targetDate;

    if (year < calendar.currentYear) {
      targetDate = new Date(year, month + 1, -1).getTime();
    } else {
      targetDate = new Date(year, month).getTime();
    }

    if (params.maxDate && targetDate > new Date(params.maxDate).getTime()) {
      return false;
    }

    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);

      if (targetDate < minDate.getTime()) {
        return false;
      }
    }

    const currentDate = new Date(calendar.currentYear, calendar.currentMonth).getTime();
    const dir = targetDate > currentDate ? 'next' : 'prev';
    const newMonthHTML = calendar.renderMonth(new Date(year, month));
    calendar.monthsTranslate = calendar.monthsTranslate || 0;
    const prevTranslate = calendar.monthsTranslate;
    let monthTranslate;
    const transitionEndCallback = !calendar.animating && transition !== 0;

    if (targetDate > currentDate) {
      // To next
      calendar.monthsTranslate -= 1;
      if (!calendar.animating) calendar.$months.eq(calendar.$months.length - 1).remove();
      $wrapperEl.append(newMonthHTML);
      calendar.$months = $wrapperEl.find('.calendar-month');
      monthTranslate = -(prevTranslate - 1) * 100 * inverter;
      calendar.$months.eq(calendar.$months.length - 1).transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`).addClass('calendar-month-next');
    } else {
      // To prev
      calendar.monthsTranslate += 1;
      if (!calendar.animating) calendar.$months.eq(0).remove();
      $wrapperEl.prepend(newMonthHTML);
      calendar.$months = $wrapperEl.find('.calendar-month');
      monthTranslate = -(prevTranslate + 1) * 100 * inverter;
      calendar.$months.eq(0).transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`).addClass('calendar-month-prev');
    }

    calendar.emit('local::monthAdd calendarMonthAdd', dir === 'next' ? calendar.$months.eq(calendar.$months.length - 1)[0] : calendar.$months.eq(0)[0]);
    calendar.animating = true;
    calendar.onMonthChangeStart(dir);
    const wrapperTranslate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition).transform(`translate3d(${isH ? wrapperTranslate : 0}%, ${isH ? 0 : wrapperTranslate}%, 0)`);

    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd(dir, true);
      });
    }

    if (!params.animate || transition === 0) {
      calendar.onMonthChangeEnd(dir, true);
    }
  }

  nextYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear + 1);
  }

  prevYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear - 1);
  } // eslint-disable-next-line


  dateInRange(dayDate, range) {
    let match = false;
    let i;
    if (!range) return false;

    if (Array.isArray(range)) {
      for (i = 0; i < range.length; i += 1) {
        if (range[i].from || range[i].to) {
          if (range[i].from && range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime() && dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].from) {
            if (dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime()) {
              match = true;
            }
          }
        } else if (range[i].date) {
          if (dayDate === new Date(range[i].date).getTime()) {
            match = true;
          }
        } else if (dayDate === new Date(range[i]).getTime()) {
          match = true;
        }
      }
    } else if (range.from || range.to) {
      if (range.from && range.to) {
        if (dayDate <= new Date(range.to).getTime() && dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.from) {
        if (dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.to) {
        if (dayDate <= new Date(range.to).getTime()) {
          match = true;
        }
      }
    } else if (range.date) {
      match = dayDate === new Date(range.date).getTime();
    } else if (typeof range === 'function') {
      match = range(new Date(dayDate));
    }

    return match;
  } // eslint-disable-next-line


  daysInMonth(date) {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
  }

  renderMonths(date) {
    const calendar = this;

    if (calendar.params.renderMonths) {
      return calendar.params.renderMonths.call(calendar, date);
    }

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-months-wrapper"
    }, calendar.renderMonth(date, 'prev'), calendar.renderMonth(date), calendar.renderMonth(date, 'next'));
  }

  renderMonth(d, offset) {
    const calendar = this;
    const {
      params,
      value
    } = calendar;

    if (params.renderMonth) {
      return params.renderMonth.call(calendar, d, offset);
    }

    let date = new Date(d);
    let year = date.getFullYear();
    let month = date.getMonth();
    let localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter(date));
    if (localeMonth < 0) localeMonth = month;
    let localeYear = calendar.yearFormatter(date);

    if (offset === 'next') {
      if (month === 11) date = new Date(year + 1, 0);else date = new Date(year, month + 1, 1);
    }

    if (offset === 'prev') {
      if (month === 0) date = new Date(year - 1, 11);else date = new Date(year, month - 1, 1);
    }

    if (offset === 'next' || offset === 'prev') {
      month = date.getMonth();
      year = date.getFullYear();
      localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter(date));
      if (localeMonth < 0) localeMonth = month;
      localeYear = calendar.yearFormatter(date);
    }

    const currentValues = [];
    const today = new Date().setHours(0, 0, 0, 0);
    const minDate = params.minDate ? new Date(params.minDate).getTime() : null;
    const maxDate = params.maxDate ? new Date(params.maxDate).getTime() : null;
    const rows = 6;
    const cols = 7;
    const daysInPrevMonth = calendar.daysInMonth(new Date(date.getFullYear(), date.getMonth()).getTime() - 10 * 24 * 60 * 60 * 1000);
    const daysInMonth = calendar.daysInMonth(date);
    const minDayNumber = params.firstDay === 6 ? 0 : 1;
    let monthHtml = '';
    let dayIndex = 0 + (params.firstDay - 1);
    let disabled;
    let hasEvents;
    let firstDayOfMonthIndex = new Date(date.getFullYear(), date.getMonth()).getDay();
    if (firstDayOfMonthIndex === 0) firstDayOfMonthIndex = 7;

    if (value && value.length) {
      for (let i = 0; i < value.length; i += 1) {
        currentValues.push(new Date(value[i]).setHours(0, 0, 0, 0));
      }
    }

    for (let row = 1; row <= rows; row += 1) {
      let rowHtml = '';

      for (let col = 1; col <= cols; col += 1) {
        dayIndex += 1;
        let dayDate;
        let dayNumber = dayIndex - firstDayOfMonthIndex;
        let addClass = '';

        if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
          dayIndex -= 7;
          dayNumber = dayIndex - firstDayOfMonthIndex;
        }

        const weekDayIndex = col - 1 + params.firstDay > 6 ? col - 1 - 7 + params.firstDay : col - 1 + params.firstDay;

        if (dayNumber < 0) {
          dayNumber = daysInPrevMonth + dayNumber + 1;
          addClass += ' calendar-day-prev';
          dayDate = new Date(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
        } else {
          dayNumber += 1;

          if (dayNumber > daysInMonth) {
            dayNumber -= daysInMonth;
            addClass += ' calendar-day-next';
            dayDate = new Date(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
          } else {
            dayDate = new Date(year, month, dayNumber).getTime();
          }
        } // Today


        if (dayDate === today) addClass += ' calendar-day-today'; // Selected

        if (params.rangePicker && currentValues.length === 2) {
          if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) {
            addClass += ' calendar-day-selected';
          }

          if (currentValues[0] !== currentValues[1]) {
            if (dayDate > currentValues[0] && dayDate < currentValues[1]) {
              addClass += ' calendar-day-selected-range';
            }

            if (dayDate === currentValues[0]) {
              addClass += ' calendar-day-selected-left';
            }

            if (dayDate === currentValues[1]) {
              addClass += ' calendar-day-selected-right';
            }
          }
        } else if (currentValues.indexOf(dayDate) >= 0) addClass += ' calendar-day-selected'; // Weekend


        if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
          addClass += ' calendar-day-weekend';
        } // Events


        let eventsHtml = '';
        hasEvents = false;

        if (params.events) {
          if (calendar.dateInRange(dayDate, params.events)) {
            hasEvents = true;
          }
        }

        if (hasEvents) {
          addClass += ' calendar-day-has-events'; // prettier-ignore

          eventsHtml = `
            <span class="calendar-day-events">
              <span class="calendar-day-event"></span>
            </span>
          `;

          if (Array.isArray(params.events)) {
            const eventDots = [];
            params.events.forEach(ev => {
              const color = ev.color || '';

              if (eventDots.indexOf(color) < 0 && calendar.dateInRange(dayDate, ev)) {
                eventDots.push(color);
              }
            }); // prettier-ignore

            eventsHtml = `
              <span class="calendar-day-events">
                ${eventDots.map(color => `
                  <span class="calendar-day-event" style="${color ? `background-color: ${color}` : ''}"></span>
                `.trim()).join('')}
              </span>
            `;
          }
        } // Custom Ranges


        if (params.rangesClasses) {
          for (let k = 0; k < params.rangesClasses.length; k += 1) {
            if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
              addClass += ` ${params.rangesClasses[k].cssClass}`;
            }
          }
        } // Disabled


        disabled = false;

        if (minDate && dayDate < minDate || maxDate && dayDate > maxDate) {
          disabled = true;
        }

        if (params.disabled) {
          if (calendar.dateInRange(dayDate, params.disabled)) {
            disabled = true;
          }
        }

        if (disabled) {
          addClass += ' calendar-day-disabled';
        }

        dayDate = new Date(dayDate);
        const dayYear = dayDate.getFullYear();
        const dayMonth = dayDate.getMonth();
        const dayNumberDisplay = calendar.dayFormatter(dayDate); // prettier-ignore

        rowHtml += `
          <div data-year="${dayYear}" data-month="${dayMonth}" data-day="${dayNumber}" class="calendar-day${addClass}" data-date="${dayYear}-${dayMonth}-${dayNumber}">
            <span class="calendar-day-number">${dayNumberDisplay}${eventsHtml}</span>
          </div>`.trim();
      }

      monthHtml += `<div class="calendar-row">${rowHtml}</div>`;
    }

    monthHtml = `<div class="calendar-month" data-year="${year}" data-month="${month}" data-locale-year="${localeYear}" data-locale-month="${localeMonth}">${monthHtml}</div>`;
    return monthHtml;
  }

  renderWeekHeader() {
    const calendar = this;

    if (calendar.params.renderWeekHeader) {
      return calendar.params.renderWeekHeader.call(calendar);
    }

    const {
      params
    } = calendar;
    let weekDaysHtml = '';

    for (let i = 0; i < 7; i += 1) {
      const dayIndex = i + params.firstDay > 6 ? i - 7 + params.firstDay : i + params.firstDay;
      const dayName = calendar.dayNamesShort[dayIndex];
      weekDaysHtml += `<div class="calendar-week-day">${dayName}</div>`;
    }

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-week-header"
    }, weekDaysHtml);
  }

  renderMonthSelector() {
    const calendar = this;

    if (calendar.params.renderMonthSelector) {
      return calendar.params.renderMonthSelector.call(calendar);
    }

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-month-selector"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
      class: "link icon-only calendar-prev-month-button"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("i", {
      class: "icon icon-prev"
    })), calendar.params.monthPicker ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
      class: "current-month-value link"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("span", {
      class: "current-month-value"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
      class: "link icon-only calendar-next-month-button"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("i", {
      class: "icon icon-next"
    })));
  }

  renderYearSelector() {
    const calendar = this;

    if (calendar.params.renderYearSelector) {
      return calendar.params.renderYearSelector.call(calendar);
    }

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-year-selector"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
      class: "link icon-only calendar-prev-year-button"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("i", {
      class: "icon icon-prev"
    })), calendar.params.yearPicker ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
      class: "current-year-value link"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("span", {
      class: "current-year-value"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
      class: "link icon-only calendar-next-year-button"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("i", {
      class: "icon icon-next"
    })));
  } // eslint-disable-next-line


  renderTimeSelector() {
    const calendar = this;
    const value = calendar.value && calendar.value[0];
    let timeString;
    if (value) timeString = calendar.timeSelectorFormatter(value);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-time-selector"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("span", null, calendar.params.timePickerLabel), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
      class: "link"
    }, timeString || calendar.params.timePickerPlaceholder));
  }

  renderHeader() {
    const calendar = this;

    if (calendar.params.renderHeader) {
      return calendar.params.renderHeader.call(calendar);
    }

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-header"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-selected-date"
    }, calendar.params.headerPlaceholder));
  }

  renderFooter() {
    const calendar = this;
    const app = calendar.app;

    if (calendar.params.renderFooter) {
      return calendar.params.renderFooter.call(calendar);
    }

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-footer"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("a", {
      class: `${app.theme === 'md' ? 'button' : 'link'} calendar-close sheet-close popover-close`
    }, calendar.params.toolbarCloseText));
  }

  renderToolbar() {
    const calendar = this;

    if (calendar.params.renderToolbar) {
      return calendar.params.renderToolbar.call(calendar, calendar);
    } // prettier-ignore


    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "toolbar toolbar-top no-shadow"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "toolbar-inner"
    }, calendar.params.monthSelector ? calendar.renderMonthSelector() : '', calendar.params.yearSelector ? calendar.renderYearSelector() : ''));
  } // eslint-disable-next-line


  renderInline() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: `calendar calendar-inline ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }

  renderCustomModal() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: `calendar calendar-modal ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }

  renderSheet() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: `sheet-modal calendar calendar-sheet ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "sheet-modal-inner calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }

  renderPopover() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "popover calendar-popover"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "popover-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: `calendar ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter())));
  }

  render() {
    const calendar = this;
    const {
      params
    } = calendar;
    if (params.render) return params.render.call(calendar);

    if (!calendar.inline) {
      let modalType = params.openIn;
      if (modalType === 'auto') modalType = calendar.isPopover() ? 'popover' : 'sheet';
      if (modalType === 'popover') return calendar.renderPopover();
      if (modalType === 'sheet') return calendar.renderSheet();
      return calendar.renderCustomModal();
    }

    return calendar.renderInline();
  }

  openMonthPicker() {
    const calendar = this;
    const {
      $el,
      app
    } = calendar;
    if (!$el || !$el.length) return;
    $el.append('<div class="popover calendar-popover calendar-month-picker-popover"><div class="popover-inner"><div class="calendar-month-picker"></div></div></div>');
    calendar.monthPickerPopover = app.popover.create({
      el: $el.find('.calendar-month-picker-popover'),
      targetEl: $el.find('.calendar-month-selector'),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeMonthPicker();
        },

        closed() {
          if (calendar.monthPickerPopover.$el) calendar.monthPickerPopover.$el.remove();
          calendar.monthPickerPopover.destroy();

          if (calendar.monthPickerInstance) {
            calendar.monthPickerInstance.close();
            calendar.monthPickerInstance.destroy();
          }

          delete calendar.monthPickerInstance;
          delete calendar.monthPickerPopover;
        }

      }
    });
    calendar.monthPickerPopover.open();
    const localeMonth = parseInt(calendar.$el.find('.calendar-month-current').attr('data-locale-month'), 10);
    const values = [];
    const displayValues = [];
    calendar.monthNames.forEach((m, index) => {
      values.push(index);
      displayValues.push(m);
    });
    calendar.monthPickerInstance = app.picker.create({
      containerEl: calendar.monthPickerPopover.$el.find('.calendar-month-picker'),
      value: [localeMonth],
      toolbar: false,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [{
        values,
        displayValues
      }]
    });
  }

  closeMonthPicker() {
    const calendar = this;
    if (calendar.monthPickerPopover && calendar.monthPickerPopover.opened) calendar.monthPickerPopover.close();
    const index = calendar.monthPickerInstance.value[0];
    const localeMonthIndex = parseInt(calendar.$el.find('.calendar-month-current').attr('data-locale-month'), 10);
    const monthIndex = calendar.currentMonth;
    const diff = localeMonthIndex - monthIndex;
    const diffIndex = index - diff;
    calendar.setYearMonth(calendar.currentYear, diffIndex, 0);
  }

  openYearPicker() {
    const calendar = this;
    const {
      $el,
      app
    } = calendar;
    if (!$el || !$el.length) return;
    $el.append('<div class="popover calendar-popover calendar-year-picker-popover"><div class="popover-inner"><div class="calendar-year-picker"></div></div></div>');
    calendar.yearPickerPopover = app.popover.create({
      el: $el.find('.calendar-year-picker-popover'),
      targetEl: $el.find('.calendar-year-selector'),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeYearPicker();
        },

        closed() {
          if (calendar.yearPickerPopover.$el) calendar.yearPickerPopover.$el.remove();
          calendar.yearPickerPopover.destroy();

          if (calendar.yearPickerInstance) {
            calendar.yearPickerInstance.close();
            calendar.yearPickerInstance.destroy();
          }

          delete calendar.yearPickerInstance;
          delete calendar.yearPickerPopover;
        }

      }
    });
    calendar.yearPickerPopover.open();
    const currentYear = calendar.currentYear;
    let yearMin = calendar.params.yearPickerMin || new Date().getFullYear() - 100;

    if (calendar.params.minDate) {
      yearMin = Math.max(yearMin, new Date(calendar.params.minDate).getFullYear());
    }

    let yearMax = calendar.params.yearPickerMax || new Date().getFullYear() + 100;

    if (calendar.params.maxDate) {
      yearMax = Math.min(yearMax, new Date(calendar.params.maxDate).getFullYear());
    }

    const years = [];

    for (let i = yearMin; i <= yearMax; i += 1) {
      years.push(i);
    }

    calendar.yearPickerInstance = app.picker.create({
      containerEl: calendar.yearPickerPopover.$el.find('.calendar-year-picker'),
      value: [currentYear],
      toolbar: false,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [{
        values: years
      }]
    });
  }

  closeYearPicker() {
    const calendar = this;
    if (calendar.yearPickerPopover && calendar.yearPickerPopover.opened) calendar.yearPickerPopover.close();
    calendar.setYearMonth(calendar.yearPickerInstance.value[0], undefined, 0);
  }

  openTimePicker() {
    const calendar = this;
    const {
      $el,
      app,
      is12HoursFormat
    } = calendar;
    if (!$el || !$el.length) return;
    $el.append('<div class="popover calendar-popover calendar-time-picker-popover"><div class="popover-inner"><div class="calendar-time-picker"></div></div></div>');
    const hoursArr = [];
    const minutesArr = [];
    const hoursMin = is12HoursFormat ? 1 : 0;
    const hoursMax = is12HoursFormat ? 12 : 23;

    for (let i = hoursMin; i <= hoursMax; i += 1) {
      hoursArr.push(i);
    }

    for (let i = 0; i <= 59; i += 1) {
      minutesArr.push(i);
    }

    let value;

    if (calendar.value && calendar.value.length) {
      value = [calendar.value[0].getHours(), calendar.value[0].getMinutes()];
    } else {
      value = [new Date().getHours(), new Date().getMinutes()];
    }

    if (is12HoursFormat) {
      value.push(value[0] < 12 ? 'AM' : 'PM');
      if (value[0] > 12) value[0] -= 12;
      if (value[0] === 0) value[0] = 12;
    }

    calendar.timePickerPopover = app.popover.create({
      el: $el.find('.calendar-time-picker-popover'),
      targetEl: $el.find('.calendar-time-selector .link'),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeTimePicker();
        },

        closed() {
          if (calendar.timePickerPopover.$el) calendar.timePickerPopover.$el.remove();
          calendar.timePickerPopover.destroy();

          if (calendar.timePickerInstance) {
            calendar.timePickerInstance.close();
            calendar.timePickerInstance.destroy();
          }

          delete calendar.timePickerInstance;
          delete calendar.timePickerPopover;
        }

      }
    });
    calendar.timePickerPopover.open();
    calendar.timePickerInstance = app.picker.create({
      containerEl: calendar.timePickerPopover.$el.find('.calendar-time-picker'),
      value,
      toolbar: false,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [{
        values: hoursArr
      }, {
        divider: true,
        content: ':'
      }, {
        values: minutesArr,
        displayValues: minutesArr.map(m => m < 10 ? `0${m}` : m)
      }, ...(is12HoursFormat ? [{
        values: ['AM', 'PM']
      }] : [])]
    });
  }

  closeTimePicker() {
    const calendar = this;
    const {
      is12HoursFormat
    } = calendar;

    if (calendar.timePickerInstance) {
      const timePickerValue = calendar.timePickerInstance.value;
      let hours = parseInt(timePickerValue[0], 10);
      const minutes = parseInt(timePickerValue[1], 10);
      const period = calendar.timePickerInstance.value[2];

      if (is12HoursFormat) {
        if (period === 'AM' && hours === 12) {
          hours = 0;
        } else if (period === 'PM' && hours !== 12) {
          hours += 12;
        }
      }

      let value = calendar.value && calendar.value.length && calendar.value[0];

      if (!value) {
        value = new Date();
        value.setHours(hours, minutes, 0, 0);
      } else {
        value = new Date(value);
        value.setHours(hours, minutes);
      }

      calendar.setValue([value]);
      if (calendar.timePickerPopover && calendar.timePickerPopover.opened) calendar.timePickerPopover.close();
    }
  }

  onOpen() {
    const calendar = this;
    const {
      initialized,
      $el,
      app,
      $inputEl,
      inline,
      value,
      params
    } = calendar;
    calendar.closing = false;
    calendar.opened = true;
    calendar.opening = true; // Init main events

    calendar.attachCalendarEvents();
    const updateValue = !value && params.value; // Set value

    if (!initialized) {
      if (value) calendar.setValue(value, 0);else if (params.value) {
        calendar.setValue(calendar.normalizeValues(params.value), 0);
      }
    } else if (value) {
      calendar.setValue(value, 0);
    } // Update current month and year


    calendar.updateCurrentMonthYear(); // Set initial translate

    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate(); // Update input value

    if (updateValue) calendar.updateValue();else if (params.header && value) {
      calendar.updateValue(true);
    } // Extra focus

    if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
      $inputEl.trigger('focus');
    }

    calendar.initialized = true;
    calendar.$months.each(monthEl => {
      calendar.emit('local::monthAdd calendarMonthAdd', monthEl);
    }); // Trigger events

    if ($el) {
      $el.trigger('calendar:open');
    }

    if ($inputEl) {
      $inputEl.trigger('calendar:open');
    }

    calendar.emit('local::open calendarOpen', calendar);
  }

  onOpened() {
    const calendar = this;
    calendar.opening = false;

    if (calendar.$el) {
      calendar.$el.trigger('calendar:opened');
    }

    if (calendar.$inputEl) {
      calendar.$inputEl.trigger('calendar:opened');
    }

    calendar.emit('local::opened calendarOpened', calendar);
  }

  onClose() {
    const calendar = this;
    const app = calendar.app;
    calendar.opening = false;
    calendar.closing = true;

    if (calendar.$inputEl) {
      if (app.theme === 'md') {
        calendar.$inputEl.trigger('blur');
      } else {
        const validate = calendar.$inputEl.attr('validate');
        const required = calendar.$inputEl.attr('required');

        if (validate && required) {
          app.input.validate(calendar.$inputEl);
        }
      }
    }

    if (calendar.detachCalendarEvents) {
      calendar.detachCalendarEvents();
    }

    if (calendar.$el) {
      calendar.$el.trigger('calendar:close');
    }

    if (calendar.$inputEl) {
      calendar.$inputEl.trigger('calendar:close');
    }

    calendar.emit('local::close calendarClose', calendar);
  }

  onClosed() {
    const calendar = this;
    calendar.opened = false;
    calendar.closing = false;

    if (!calendar.inline) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
        if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
          if (!calendar.params.routableModals) {
            calendar.modal.destroy();
          }
        }

        delete calendar.modal;
      });
    }

    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }

    if (calendar.$el) {
      calendar.$el.trigger('calendar:closed');
    }

    if (calendar.$inputEl) {
      calendar.$inputEl.trigger('calendar:closed');
    }

    calendar.emit('local::closed calendarClosed', calendar);
  }

  open() {
    const calendar = this;
    const {
      app,
      opened,
      inline,
      $inputEl,
      params
    } = calendar;
    if (opened) return;

    if (inline) {
      calendar.$el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(calendar.render());
      calendar.$el[0].f7Calendar = calendar;
      calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
      calendar.$months = calendar.$wrapperEl.find('.calendar-month');
      calendar.$containerEl.append(calendar.$el);
      calendar.onOpen();
      calendar.onOpened();
      return;
    }

    let modalType = params.openIn;

    if (modalType === 'auto') {
      modalType = calendar.isPopover() ? 'popover' : 'sheet';
    }

    const modalContent = calendar.render();
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: params.scrollToInput ? $inputEl : undefined,
      content: modalContent,
      backdrop: params.backdrop === true || modalType === 'popover' && app.params.popover.backdrop !== false && params.backdrop !== false,
      closeByBackdropClick: params.closeByBackdropClick,
      on: {
        open() {
          const modal = this;
          calendar.modal = modal;
          calendar.$el = modalType === 'popover' ? modal.$el.find('.calendar') : modal.$el;
          calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
          calendar.$months = calendar.$wrapperEl.find('.calendar-month');
          calendar.$el[0].f7Calendar = calendar;

          if (modalType === 'customModal') {
            (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(calendar.$el).find('.calendar-close').once('click', () => {
              calendar.close();
            });
          }

          calendar.onOpen();
        },

        opened() {
          calendar.onOpened();
        },

        close() {
          calendar.onClose();
        },

        closed() {
          calendar.onClosed();
        }

      }
    };

    if (modalType === 'sheet') {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }

    if (params.routableModals && calendar.view) {
      calendar.view.router.navigate({
        url: calendar.url,
        route: {
          path: calendar.url,
          [modalType]: modalParams
        }
      });
    } else {
      calendar.modal = app[modalType].create(modalParams);
      calendar.modal.open();
    }
  }

  close() {
    const calendar = this;
    const {
      opened,
      inline
    } = calendar;
    if (!opened) return;

    if (inline) {
      calendar.onClose();
      calendar.onClosed();
      return;
    }

    if (calendar.params.routableModals && calendar.view) {
      calendar.view.router.back();
    } else {
      calendar.modal.close();
    }
  }

  init() {
    const calendar = this;
    calendar.initInput();

    if (calendar.inline) {
      calendar.open();
      calendar.emit('local::init calendarInit', calendar);
      return;
    }

    if (!calendar.initialized && calendar.params.value) {
      calendar.setValue(calendar.normalizeValues(calendar.params.value));
    } // Attach input Events


    if (calendar.$inputEl) {
      calendar.attachInputEvents();
    }

    if (calendar.params.closeByOutsideClick) {
      calendar.attachHtmlEvents();
    }

    calendar.emit('local::init calendarInit', calendar);
  }

  destroy() {
    const calendar = this;
    if (calendar.destroyed) return;
    const {
      $el
    } = calendar;
    calendar.emit('local::beforeDestroy calendarBeforeDestroy', calendar);
    if ($el) $el.trigger('calendar:beforedestroy');
    calendar.close(); // Detach Events

    if (calendar.$inputEl) {
      calendar.detachInputEvents();
    }

    if (calendar.params.closeByOutsideClick) {
      calendar.detachHtmlEvents();
    }

    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }

    if ($el && $el.length) delete calendar.$el[0].f7Calendar;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(calendar);
    calendar.destroyed = true;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Calendar);

/***/ }),

/***/ "./node_modules/framework7/components/calendar/calendar.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/calendar/calendar.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");
/* harmony import */ var _calendar_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calendar-class.js */ "./node_modules/framework7/components/calendar/calendar-class.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'calendar',
  static: {
    Calendar: _calendar_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.calendar = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.calendar',
      constructor: _calendar_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7Calendar'
    });

    app.calendar.close = function close(el) {
      if (el === void 0) {
        el = '.calendar';
      }

      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
      if ($el.length === 0) return;
      const calendar = $el[0].f7Calendar;
      if (!calendar || calendar && !calendar.opened) return;
      calendar.close();
    };
  },

  params: {
    calendar: {
      // Calendar settings
      dateFormat: undefined,
      monthNames: 'auto',
      monthNamesShort: 'auto',
      dayNames: 'auto',
      dayNamesShort: 'auto',
      locale: undefined,
      firstDay: 1,
      // First day of the week, Monday
      weekendDays: [0, 6],
      // Sunday and Saturday
      multiple: false,
      rangePicker: false,
      rangePickerMinDays: 1,
      // when calendar is used as rangePicker
      rangePickerMaxDays: 0,
      // when calendar is used as rangePicker, 0 means unlimited
      direction: 'horizontal',
      // or 'vertical'
      minDate: null,
      maxDate: null,
      disabled: null,
      // dates range of disabled days
      events: null,
      // dates range of days with events
      rangesClasses: null,
      // array with custom classes date ranges
      touchMove: true,
      animate: true,
      closeOnSelect: false,
      monthSelector: true,
      monthPicker: true,
      yearSelector: true,
      yearPicker: true,
      yearPickerMin: undefined,
      yearPickerMax: undefined,
      timePicker: false,
      timePickerLabel: 'Time',
      timePickerFormat: {
        hour: 'numeric',
        minute: 'numeric'
      },
      timePickerPlaceholder: 'Select time',
      weekHeader: true,
      value: null,
      // Common opener settings
      containerEl: null,
      openIn: 'auto',
      // or 'popover' or 'sheet' or 'customModal'
      sheetPush: false,
      sheetSwipeToClose: undefined,
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      header: false,
      headerPlaceholder: 'Select date',
      toolbar: true,
      toolbarCloseText: 'Done',
      footer: false,
      cssClass: null,
      routableModals: false,
      view: null,
      url: 'date/',
      backdrop: null,
      closeByBackdropClick: true,
      // Render functions
      renderWeekHeader: null,
      renderMonths: null,
      renderMonth: null,
      renderMonthSelector: null,
      renderYearSelector: null,
      renderHeader: null,
      renderFooter: null,
      renderToolbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      render: null
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/card/card.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/components/card/card.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* eslint no-param-reassign: "off" */





const CardExpandable = {
  open(cardEl, animate) {
    if (cardEl === void 0) {
      cardEl = '.card-expandable';
    }

    if (animate === void 0) {
      animate = true;
    }

    const app = this;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__.getSupport)();
    const $cardEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(cardEl).eq(0);
    if (!$cardEl || !$cardEl.length) return;
    if ($cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) return;
    const $pageEl = $cardEl.parents('.page').eq(0);
    if (!$pageEl.length) return;

    if ($pageEl.find('.card-opened').length) {
      return;
    }

    let prevented;

    function prevent() {
      prevented = true;
    }

    $cardEl.trigger('card:beforeopen', {
      prevent
    });
    app.emit('cardBeforeOpen', $cardEl[0], prevent);
    if (prevented) return;
    const cardParams = Object.assign({
      animate
    }, app.params.card, $cardEl.dataset());
    const $pageContentEl = $cardEl.parents('.page-content');
    let $backdropEl;

    if ($cardEl.attr('data-backdrop-el')) {
      $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])($cardEl.attr('data-backdrop-el'));
    }

    if (!$backdropEl && cardParams.backdrop) {
      $backdropEl = $pageContentEl.find('.card-backdrop');

      if (!$backdropEl.length) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="card-backdrop"></div>');
        $pageContentEl.append($backdropEl);
      }
    }

    let $navbarEl;
    let $toolbarEl;

    if (cardParams.hideNavbarOnOpen) {
      $navbarEl = $pageEl.children('.navbar');

      if (!$navbarEl.length) {
        if ($pageEl[0].f7Page) $navbarEl = $pageEl[0].f7Page.$navbarEl;
      }
    }

    if (cardParams.hideToolbarOnOpen) {
      $toolbarEl = $pageEl.children('.toolbar');

      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents('.view').children('.toolbar');
      }

      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents('.views').children('.toolbar');
      }
    }

    const currTransform = $cardEl.css('transform');
    let hasTransform;

    if (currTransform && currTransform.match(/[2-9]/)) {
      hasTransform = true;
    }

    const $cardContentEl = $cardEl.children('.card-content');
    const $cardSizeEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document.createElement('div')).addClass('card-expandable-size');
    $cardEl.append($cardSizeEl);
    let cardWidth = $cardEl[0].offsetWidth;
    let cardHeight = $cardEl[0].offsetHeight;
    let pageWidth = $pageEl[0].offsetWidth;
    let pageHeight = $pageEl[0].offsetHeight;
    let maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
    let maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;
    let statusbarHeight;

    if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
      statusbarHeight = parseInt($navbarEl.css('--f7-safe-area-top'), 10);
      if (Number.isNaN(statusbarHeight)) statusbarHeight = 0;
    }

    if (statusbarHeight) {
      maxHeight -= statusbarHeight;
    }

    let scaleX = maxWidth / cardWidth;
    let scaleY = maxHeight / cardHeight;
    let offset = $cardEl.offset();
    let pageOffset = $pageEl.offset();

    if (statusbarHeight) {
      pageOffset.top += statusbarHeight / 2;
    }

    offset.left -= pageOffset.left;
    let cardLeftOffset;
    let cardTopOffset;

    if (hasTransform) {
      const transformValues = currTransform.replace(/matrix\(|\)/g, '').split(',').map(el => el.trim());

      if (transformValues && transformValues.length > 1) {
        const scale = parseFloat(transformValues[0]);
        cardLeftOffset = offset.left - cardWidth * (1 - scale) / 2;
        cardTopOffset = offset.top - pageOffset.top - cardHeight * (1 - scale) / 2;
        if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
      } else {
        cardLeftOffset = $cardEl[0].offsetLeft;
        cardTopOffset = $cardEl[0].offsetTop - ($pageContentEl.length ? $pageContentEl[0].scrollTop : 0);
      }
    } else {
      cardLeftOffset = offset.left;
      cardTopOffset = offset.top - pageOffset.top;
      if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
    }

    cardLeftOffset -= (pageWidth - maxWidth) / 2;
    cardTopOffset -= (pageHeight - maxHeight) / 2;
    let cardRightOffset = maxWidth - cardWidth - cardLeftOffset;

    if (app.rtl) {
      [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
    }

    let cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
    let translateX = (cardRightOffset - cardLeftOffset) / 2;
    let translateY = (cardBottomOffset - cardTopOffset) / 2;

    if (cardParams.hideNavbarOnOpen && $navbarEl && $navbarEl.length) {
      if ($navbarEl.closest('.navbar-hidden').length) {
        // Was hidden
        $cardEl[0].f7KeepNavbarOnClose = true;
      } else {
        delete $cardEl[0].f7KeepNavbarOnClose;
        app.navbar.hide($navbarEl, cardParams.animate, cardParams.hideStatusbarOnOpen, true);
      }
    }

    if (cardParams.hideToolbarOnOpen && $toolbarEl && $toolbarEl.length) {
      if ($toolbarEl.closest('.toolbar-hidden').length) {
        // Was hidden
        $cardEl[0].f7KeepToolbarOnClose = true;
      } else {
        delete $cardEl[0].f7KeepToolbarOnClose;
        app.toolbar.hide($toolbarEl, cardParams.animate);
      }
    }

    if ($backdropEl) {
      $backdropEl.removeClass('card-backdrop-out').addClass('card-backdrop-in');
    }

    $cardEl.removeClass('card-transitioning');

    if (cardParams.animate) {
      $cardEl.addClass('card-opening');
    }

    $cardEl.trigger('card:open');
    app.emit('cardOpen', $cardEl[0]);

    function transitionEnd() {
      $pageEl.addClass('page-with-card-opened');

      if (device.ios && $pageContentEl.length) {
        $pageContentEl.css('height', `${$pageContentEl[0].offsetHeight + 1}px`);
        setTimeout(() => {
          $pageContentEl.css('height', '');
        });
      }

      $cardEl.addClass('card-opened');
      $cardEl.removeClass('card-opening');
      $cardEl.trigger('card:opened');
      app.emit('cardOpened', $cardEl[0], $pageEl[0]);
    }

    $cardContentEl.css({
      width: `${maxWidth}px`,
      height: `${maxHeight}px`
    }).transform(`translate3d(${app.rtl ? cardLeftOffset + translateX : -cardLeftOffset - translateX}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);
    $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);

    if (cardParams.animate) {
      $cardEl.transitionEnd(() => {
        transitionEnd();
      });
    } else {
      transitionEnd();
    }

    function onResize() {
      $cardEl.removeClass('card-transitioning');
      cardWidth = $cardEl[0].offsetWidth;
      cardHeight = $cardEl[0].offsetHeight;
      pageWidth = $pageEl[0].offsetWidth;
      pageHeight = $pageEl[0].offsetHeight;
      maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
      maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;
      statusbarHeight = 0;

      if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
        statusbarHeight = parseInt($navbarEl.css('--f7-safe-area-top'), 10);
        if (Number.isNaN(statusbarHeight)) statusbarHeight = 0;
      }

      if (statusbarHeight) {
        maxHeight -= statusbarHeight;
      }

      scaleX = maxWidth / cardWidth;
      scaleY = maxHeight / cardHeight;
      $cardEl.transform('translate3d(0px, 0px, 0) scale(1)');
      offset = $cardEl.offset();
      pageOffset = $pageEl.offset();

      if (statusbarHeight) {
        pageOffset.top += statusbarHeight / 2;
      }

      offset.left -= pageOffset.left;
      offset.top -= pageOffset.top;
      cardLeftOffset = offset.left - (pageWidth - maxWidth) / 2;
      if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
      cardTopOffset = offset.top - (pageHeight - maxHeight) / 2;
      cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
      cardBottomOffset = maxHeight - cardHeight - cardTopOffset;

      if (app.rtl) {
        [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
      }

      translateX = (cardRightOffset - cardLeftOffset) / 2;
      translateY = (cardBottomOffset - cardTopOffset) / 2;
      $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
      $cardContentEl.css({
        width: `${maxWidth}px`,
        height: `${maxHeight}px`
      }).transform(`translate3d(${app.rtl ? cardLeftOffset + translateX : -cardLeftOffset - translateX}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);
    }

    let cardScrollTop;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchEndX;
    let touchEndY;
    let isScrolling;
    let progress;
    let isV;
    let isH;
    let $cardScrollableEl;

    function onTouchStart(e) {
      if (!(0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest($cardEl).length) return;
      if (!$cardEl.hasClass('card-opened')) return;
      $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);

      if ($cardScrollableEl[0] && $cardScrollableEl[0] !== $cardContentEl[0] && !$cardScrollableEl[0].contains(e.target)) {
        cardScrollTop = 0;
      } else {
        cardScrollTop = $cardScrollableEl.scrollTop();
      }

      isTouched = true;
      touchStartX = e.targetTouches[0].pageX;
      touchStartY = e.targetTouches[0].pageY;
      isScrolling = undefined;
      isV = false;
      isH = false;
    }

    function onTouchMove(e) {
      if (!isTouched) return;
      touchEndX = e.targetTouches[0].pageX;
      touchEndY = e.targetTouches[0].pageY;

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(touchEndY - touchStartY) > Math.abs(touchEndX - touchStartX));
      }

      if (!isH && !isV) {
        if (!isScrolling && e.targetTouches[0].clientX <= 50) {
          isH = true;
        } else {
          isV = true;
        }
      }

      if (!(isH || isV) || isV && cardScrollTop !== 0) {
        isTouched = true;
        isMoved = true;
        return;
      }

      if (!isMoved) {
        $cardEl.removeClass('card-transitioning');
      }

      isMoved = true;
      progress = isV ? Math.max((touchEndY - touchStartY) / 150, 0) : Math.max((touchEndX - touchStartX) / (cardWidth / 2), 0);

      if (progress > 0 && isV || isH) {
        if (isV && device.ios && $cardScrollableEl[0] === $cardContentEl[0]) {
          $cardScrollableEl.css('-webkit-overflow-scrolling', 'auto');
          $cardScrollableEl.scrollTop(0);
        }

        e.preventDefault();
      }

      if (progress > 1) progress **= 0.3;

      if (progress > (isV ? 1.3 : 1.1)) {
        isTouched = false;
        isMoved = false;
        app.card.close($cardEl);
      } else {
        $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX * (1 - progress * 0.2)}, ${scaleY * (1 - progress * 0.2)})`);
      }
    }

    function onTouchEnd() {
      if (!isTouched || !isMoved) return;
      isTouched = false;
      isMoved = false;

      if (device.ios) {
        $cardScrollableEl.css('-webkit-overflow-scrolling', '');
      }

      if (progress >= 0.8) {
        app.card.close($cardEl);
      } else {
        $cardEl.addClass('card-transitioning').transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
      }
    }

    $cardEl[0].detachEventHandlers = function detachEventHandlers() {
      app.off('resize', onResize);

      if (support.touch && cardParams.swipeToClose) {
        app.off('touchstart:passive', onTouchStart);
        app.off('touchmove:active', onTouchMove);
        app.off('touchend:passive', onTouchEnd);
      }
    };

    app.on('resize', onResize);

    if (support.touch && cardParams.swipeToClose) {
      app.on('touchstart:passive', onTouchStart);
      app.on('touchmove:active', onTouchMove);
      app.on('touchend:passive', onTouchEnd);
    }
  },

  close(cardEl, animate) {
    if (cardEl === void 0) {
      cardEl = '.card-expandable.card-opened';
    }

    if (animate === void 0) {
      animate = true;
    }

    const app = this;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
    const $cardEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(cardEl).eq(0);
    if (!$cardEl || !$cardEl.length) return;
    if (!$cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) return;
    const $cardContentEl = $cardEl.children('.card-content');
    const $pageContentEl = $cardEl.parents('.page-content');
    const $pageEl = $cardEl.parents('.page').eq(0);
    if (!$pageEl.length) return;
    const cardParams = Object.assign({
      animate
    }, app.params.card, $cardEl.dataset());
    const $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);
    let $navbarEl;
    let $toolbarEl;
    let $backdropEl;

    if ($cardEl.attr('data-backdrop-el')) {
      $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])($cardEl.attr('data-backdrop-el'));
    }

    if (cardParams.backdrop) {
      $backdropEl = $cardEl.parents('.page-content').find('.card-backdrop');
    }

    if (cardParams.hideNavbarOnOpen) {
      $navbarEl = $pageEl.children('.navbar');

      if (!$navbarEl.length) {
        if ($pageEl[0].f7Page) $navbarEl = $pageEl[0].f7Page.$navbarEl;
      }

      if ($navbarEl && $navbarEl.length && !$cardEl[0].f7KeepNavbarOnClose) {
        app.navbar.show($navbarEl, cardParams.animate, true);
      }
    }

    if (cardParams.hideToolbarOnOpen) {
      $toolbarEl = $pageEl.children('.toolbar');

      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents('.view').children('.toolbar');
      }

      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents('.views').children('.toolbar');
      }

      if ($toolbarEl && $toolbarEl.length && !$cardEl[0].f7KeepToolbarOnClose) {
        app.toolbar.show($toolbarEl, cardParams.animate);
      }
    }

    $pageEl.removeClass('page-with-card-opened');

    if (device.ios && $pageContentEl.length) {
      $pageContentEl.css('height', `${$pageContentEl[0].offsetHeight + 1}px`);
      setTimeout(() => {
        $pageContentEl.css('height', '');
      });
    }

    if ($backdropEl && $backdropEl.length) {
      $backdropEl.removeClass('card-backdrop-in').addClass('card-backdrop-out');
    }

    $cardEl.removeClass('card-opened card-transitioning');

    if (cardParams.animate) {
      $cardEl.addClass('card-closing');
    } else {
      $cardEl.addClass('card-no-transition');
    }

    $cardEl.transform('');
    $cardEl.trigger('card:close');
    app.emit('cardClose', $cardEl[0], $pageEl[0]);
    const animateWidth = $cardEl.hasClass('card-expandable-animate-width');

    function transitionEnd() {
      if (!animateWidth) {
        $cardContentEl.css({
          width: '',
          height: ''
        });
      }

      if ($backdropEl && $backdropEl.length) {
        $backdropEl.removeClass('card-backdrop-in card-backdrop-out');
      }

      $cardEl.removeClass('card-closing card-no-transition');
      $cardEl.trigger('card:closed');
      $cardEl.find('.card-expandable-size').remove();
      app.emit('cardClosed', $cardEl[0], $pageEl[0]);
    }

    if (animateWidth) {
      $cardContentEl.css({
        width: '',
        height: ''
      });
    }

    $cardContentEl.transform('').scrollTop(0, animate ? 300 : 0);

    if ($cardScrollableEl.length && $cardScrollableEl[0] !== $cardContentEl[0]) {
      $cardScrollableEl.scrollTop(0, animate ? 300 : 0);
    }

    if (animate) {
      $cardContentEl.transitionEnd(() => {
        transitionEnd();
      });
    } else {
      transitionEnd();
    }

    if ($cardEl[0].detachEventHandlers) {
      $cardEl[0].detachEventHandlers();
      delete $cardEl[0].detachEventHandlers;
    }
  },

  toggle(cardEl, animate) {
    if (cardEl === void 0) {
      cardEl = '.card-expandable';
    }

    const app = this;
    const $cardEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(cardEl).eq(0);
    if (!$cardEl.length) return;

    if ($cardEl.hasClass('card-opened')) {
      app.card.close($cardEl, animate);
    } else {
      app.card.open($cardEl, animate);
    }
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'card',
  params: {
    card: {
      hideNavbarOnOpen: true,
      hideStatusbarOnOpen: true,
      hideToolbarOnOpen: true,
      scrollableEl: '.card-content',
      swipeToClose: true,
      closeByBackdropClick: true,
      backdrop: true
    }
  },

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.bindMethods)(app, {
      card: CardExpandable
    });
  },

  on: {
    pageBeforeIn(page) {
      const app = this;

      if (app.params.card.hideNavbarOnOpen && page.navbarEl && page.$el.find('.card-opened.card-expandable').length) {
        app.navbar.hide(page.navbarEl, true, app.params.card.hideStatusbarOnOpen, true);
      }

      if (app.params.card.hideToolbarOnOpen && page.$el.find('.card-opened.card-expandable').length) {
        let $toolbarEl = page.$el.children('.toolbar');

        if (!$toolbarEl.length) {
          $toolbarEl = page.$el.parents('.view').children('.toolbar');
        }

        if (!$toolbarEl.length) {
          $toolbarEl = page.$el.parents('.views').children('.toolbar');
        }

        if ($toolbarEl && $toolbarEl.length) {
          app.toolbar.hide($toolbarEl);
        }
      }
    }

  },
  clicks: {
    '.card-close': function closeCard($clickedEl, data) {
      const app = this;
      app.card.close(data.card, data.animate);
    },
    '.card-open': function closeCard($clickedEl, data) {
      const app = this;
      app.card.open(data.card, data.animate);
    },
    '.card-expandable': function toggleExpandableCard($clickedEl, data, e) {
      const app = this;
      if ($clickedEl.hasClass('card-opened') || $clickedEl.hasClass('card-opening') || $clickedEl.hasClass('card-closing')) return;
      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest('.card-prevent-open, .card-close').length) return;
      app.card.open($clickedEl);
    },
    '.card-backdrop-in': function onBackdropClick() {
      const app = this;
      let needToClose = false;
      if (app.params.card.closeByBackdropClick) needToClose = true;
      const $openedCardEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.card-opened');
      if (!$openedCardEl.length) return;

      if ($openedCardEl.attr('data-close-by-backdrop-click') === 'true') {
        needToClose = true;
      } else if ($openedCardEl.attr('data-close-by-backdrop-click') === 'false') {
        needToClose = false;
      }

      if (needToClose) app.card.close($openedCardEl);
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/checkbox/checkbox.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/checkbox/checkbox.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'checkbox'
});

/***/ }),

/***/ "./node_modules/framework7/components/chip/chip.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/components/chip/chip.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'chip'
});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/color-picker-class.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/color-picker-class.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _modules_alpha_slider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/alpha-slider.js */ "./node_modules/framework7/components/color-picker/modules/alpha-slider.js");
/* harmony import */ var _modules_current_color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/current-color.js */ "./node_modules/framework7/components/color-picker/modules/current-color.js");
/* harmony import */ var _modules_hex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/hex.js */ "./node_modules/framework7/components/color-picker/modules/hex.js");
/* harmony import */ var _modules_hsb_sliders_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/hsb-sliders.js */ "./node_modules/framework7/components/color-picker/modules/hsb-sliders.js");
/* harmony import */ var _modules_hue_slider_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/hue-slider.js */ "./node_modules/framework7/components/color-picker/modules/hue-slider.js");
/* harmony import */ var _modules_brightness_slider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/brightness-slider.js */ "./node_modules/framework7/components/color-picker/modules/brightness-slider.js");
/* harmony import */ var _modules_palette_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/palette.js */ "./node_modules/framework7/components/color-picker/modules/palette.js");
/* harmony import */ var _modules_initial_current_colors_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/initial-current-colors.js */ "./node_modules/framework7/components/color-picker/modules/initial-current-colors.js");
/* harmony import */ var _modules_rgb_bars_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/rgb-bars.js */ "./node_modules/framework7/components/color-picker/modules/rgb-bars.js");
/* harmony import */ var _modules_rgb_sliders_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/rgb-sliders.js */ "./node_modules/framework7/components/color-picker/modules/rgb-sliders.js");
/* harmony import */ var _modules_sb_spectrum_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/sb-spectrum.js */ "./node_modules/framework7/components/color-picker/modules/sb-spectrum.js");
/* harmony import */ var _modules_hs_spectrum_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/hs-spectrum.js */ "./node_modules/framework7/components/color-picker/modules/hs-spectrum.js");
/* harmony import */ var _modules_wheel_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/wheel.js */ "./node_modules/framework7/components/color-picker/modules/wheel.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");

















/** @jsx $jsx */



class ColorPicker extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const self = this;
    self.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, app.params.colorPicker, params);
    let $containerEl;

    if (self.params.containerEl) {
      $containerEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(self.params.containerEl);
      if ($containerEl.length === 0) return self;
    }

    let $inputEl;

    if (self.params.inputEl) {
      $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(self.params.inputEl);
    }

    let $targetEl;

    if (self.params.targetEl) {
      $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(self.params.targetEl);
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(self, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      $targetEl,
      targetEl: $targetEl && $targetEl[0],
      initialized: false,
      opened: false,
      url: self.params.url,
      modules: {
        'alpha-slider': _modules_alpha_slider_js__WEBPACK_IMPORTED_MODULE_3__["default"],
        'current-color': _modules_current_color_js__WEBPACK_IMPORTED_MODULE_4__["default"],
        hex: _modules_hex_js__WEBPACK_IMPORTED_MODULE_5__["default"],
        // eslint-disable-line
        'hsb-sliders': _modules_hsb_sliders_js__WEBPACK_IMPORTED_MODULE_6__["default"],
        'hue-slider': _modules_hue_slider_js__WEBPACK_IMPORTED_MODULE_7__["default"],
        'brightness-slider': _modules_brightness_slider_js__WEBPACK_IMPORTED_MODULE_8__["default"],
        palette: _modules_palette_js__WEBPACK_IMPORTED_MODULE_9__["default"],
        // eslint-disable-line
        'initial-current-colors': _modules_initial_current_colors_js__WEBPACK_IMPORTED_MODULE_10__["default"],
        'rgb-bars': _modules_rgb_bars_js__WEBPACK_IMPORTED_MODULE_11__["default"],
        'rgb-sliders': _modules_rgb_sliders_js__WEBPACK_IMPORTED_MODULE_12__["default"],
        'sb-spectrum': _modules_sb_spectrum_js__WEBPACK_IMPORTED_MODULE_13__["default"],
        'hs-spectrum': _modules_hs_spectrum_js__WEBPACK_IMPORTED_MODULE_14__["default"],
        wheel: _modules_wheel_js__WEBPACK_IMPORTED_MODULE_15__["default"] // eslint-disable-line

      }
    });

    function onInputClick() {
      self.open();
    }

    function onInputFocus(e) {
      e.preventDefault();
    }

    function onTargetClick() {
      self.open();
    }

    function onHtmlClick(e) {
      if (self.destroyed || !self.params) return;
      if (self.params.openIn === 'page') return;
      const $clickTargetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target);
      if (!self.opened || self.closing) return;
      if ($clickTargetEl.closest('[class*="backdrop"]').length) return;
      if ($clickTargetEl.closest('.color-picker-popup, .color-picker-popover').length) return;

      if ($inputEl && $inputEl.length > 0) {
        if ($clickTargetEl[0] !== $inputEl[0] && $clickTargetEl.closest('.sheet-modal').length === 0) {
          self.close();
        }
      } else if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.sheet-modal').length === 0) {
        self.close();
      }
    } // Events


    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(self, {
      attachInputEvents() {
        self.$inputEl.on('click', onInputClick);

        if (self.params.inputReadOnly) {
          self.$inputEl.on('focus mousedown', onInputFocus);

          if (self.$inputEl[0]) {
            self.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },

      detachInputEvents() {
        self.$inputEl.off('click', onInputClick);

        if (self.params.inputReadOnly) {
          self.$inputEl.off('focus mousedown', onInputFocus);

          if (self.$inputEl[0]) {
            delete self.$inputEl[0].f7ValidateReadonly;
          }
        }
      },

      attachTargetEvents() {
        self.$targetEl.on('click', onTargetClick);
      },

      detachTargetEvents() {
        self.$targetEl.off('click', onTargetClick);
      },

      attachHtmlEvents() {
        app.on('click', onHtmlClick);
      },

      detachHtmlEvents() {
        app.off('click', onHtmlClick);
      }

    });
    self.init();
    return self;
  }

  get view() {
    const {
      $inputEl,
      $targetEl,
      app,
      params
    } = this;
    let view;

    if (params.view) {
      view = params.view;
    } else {
      if ($inputEl) {
        view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
      }

      if (!view && $targetEl) {
        view = $targetEl.parents('.view').length && $targetEl.parents('.view')[0].f7View;
      }
    }

    if (!view) view = app.views.main;
    return view;
  }

  attachEvents() {
    const self = this;
    self.centerModules = self.centerModules.bind(self);

    if (self.params.centerModules) {
      self.app.on('resize', self.centerModules);
    }
  }

  detachEvents() {
    const self = this;

    if (self.params.centerModules) {
      self.app.off('resize', self.centerModules);
    }
  }

  centerModules() {
    const self = this;
    if (!self.opened || !self.$el || self.inline) return;
    const $pageContentEl = self.$el.find('.page-content');
    if (!$pageContentEl.length) return;
    const {
      scrollHeight,
      offsetHeight
    } = $pageContentEl[0];

    if (scrollHeight <= offsetHeight) {
      $pageContentEl.addClass('justify-content-center');
    } else {
      $pageContentEl.removeClass('justify-content-center');
    }
  }

  initInput() {
    const self = this;
    if (!self.$inputEl) return;
    if (self.params.inputReadOnly) self.$inputEl.prop('readOnly', true);
  }

  getModalType() {
    const self = this;
    const {
      app,
      modal,
      params
    } = self;
    const {
      openIn,
      openInPhone
    } = params;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_16__.getDevice)();
    if (modal && modal.type) return modal.type;
    if (openIn !== 'auto') return openIn;
    if (self.inline) return null;

    if (device.ios) {
      return device.ipad ? 'popover' : openInPhone;
    }

    if (app.width >= 768 || device.desktop && app.theme === 'aurora') {
      return 'popover';
    }

    return openInPhone;
  }

  formatValue() {
    const self = this;
    const {
      value
    } = self;

    if (self.params.formatValue) {
      return self.params.formatValue.call(self, value);
    }

    return value.hex;
  } // eslint-disable-next-line


  normalizeHsValues(arr) {
    return [Math.floor(arr[0] * 10) / 10, Math.floor(arr[1] * 1000) / 1000, Math.floor(arr[2] * 1000) / 1000];
  }

  setValue(value, updateModules) {
    if (value === void 0) {
      value = {};
    }

    if (updateModules === void 0) {
      updateModules = true;
    }

    const self = this;
    if (typeof value === 'undefined') return;
    let {
      hex,
      rgb,
      hsl,
      hsb,
      alpha = 1,
      hue,
      rgba,
      hsla
    } = self.value || {};
    const needChangeEvent = self.value || !self.value && !self.params.value;
    let valueChanged;
    Object.keys(value).forEach(k => {
      if (!self.value || typeof self.value[k] === 'undefined') {
        valueChanged = true;
        return;
      }

      const v = value[k];

      if (Array.isArray(v)) {
        v.forEach((subV, subIndex) => {
          if (subV !== self.value[k][subIndex]) {
            valueChanged = true;
          }
        });
      } else if (v !== self.value[k]) {
        valueChanged = true;
      }
    });
    if (!valueChanged) return;

    if (value.rgb || value.rgba) {
      const [r, g, b, a = alpha] = value.rgb || value.rgba;
      rgb = [r, g, b];
      hex = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorRgbToHex)(...rgb);
      hsl = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorRgbToHsl)(...rgb);
      hsb = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHslToHsb)(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }

    if (value.hsl || value.hsla) {
      const [h, s, l, a = alpha] = value.hsl || value.hsla;
      hsl = [h, s, l];
      rgb = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHslToRgb)(...hsl);
      hex = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorRgbToHex)(...rgb);
      hsb = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHslToHsb)(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }

    if (value.hsb) {
      const [h, s, b, a = alpha] = value.hsb;
      hsb = [h, s, b];
      hsl = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHsbToHsl)(...hsb);
      rgb = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHslToRgb)(...hsl);
      hex = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorRgbToHex)(...rgb);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }

    if (value.hex) {
      rgb = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHexToRgb)(value.hex);
      hex = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorRgbToHex)(...rgb);
      hsl = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorRgbToHsl)(...rgb);
      hsb = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHslToHsb)(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      rgba = [rgb[0], rgb[1], rgb[2], alpha];
      hsla = [hsl[0], hsl[1], hsl[2], alpha];
    }

    if (typeof value.alpha !== 'undefined') {
      alpha = value.alpha;

      if (typeof rgb !== 'undefined') {
        rgba = [rgb[0], rgb[1], rgb[2], alpha];
      }

      if (typeof hsl !== 'undefined') {
        hsla = [hsl[0], hsl[1], hsl[2], alpha];
      }
    }

    if (typeof value.hue !== 'undefined') {
      const [h, s, l] = hsl; // eslint-disable-line

      hsl = [value.hue, s, l];
      hsb = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHslToHsb)(...hsl);
      rgb = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHslToRgb)(...hsl);
      hex = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorRgbToHex)(...rgb);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      rgba = [rgb[0], rgb[1], rgb[2], alpha];
      hsla = [hsl[0], hsl[1], hsl[2], alpha];
    }

    self.value = {
      hex,
      alpha,
      hue,
      rgb,
      hsl,
      hsb,
      rgba,
      hsla
    };
    if (!self.initialValue) self.initialValue = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, self.value);
    self.updateValue(needChangeEvent);

    if (self.opened && updateModules) {
      self.updateModules();
    }
  }

  getValue() {
    const self = this;
    return self.value;
  }

  updateValue(fireEvents) {
    if (fireEvents === void 0) {
      fireEvents = true;
    }

    const self = this;
    const {
      $inputEl,
      value,
      $targetEl
    } = self;

    if ($targetEl && self.params.targetElSetBackgroundColor) {
      const {
        rgba
      } = value;
      $targetEl.css('background-color', `rgba(${rgba.join(', ')})`);
    }

    if (fireEvents) {
      self.emit('local::change colorPickerChange', self, value);
    }

    if ($inputEl && $inputEl.length) {
      const inputValue = self.formatValue(value);

      if ($inputEl && $inputEl.length) {
        $inputEl.val(inputValue);

        if (fireEvents) {
          $inputEl.trigger('change');
        }
      }
    }
  }

  updateModules() {
    const self = this;
    const {
      modules
    } = self;
    self.params.modules.forEach(m => {
      if (typeof m === 'string' && modules[m] && modules[m].update) {
        modules[m].update(self);
      } else if (m && m.update) {
        m.update(self);
      }
    });
  }

  update() {
    const self = this;
    self.updateModules();
  }

  renderPicker() {
    const self = this;
    const {
      params,
      modules
    } = self;
    let html = '';
    params.modules.forEach(m => {
      if (typeof m === 'string' && modules[m] && modules[m].render) {
        html += modules[m].render(self);
      } else if (m && m.render) {
        html += m.render(self);
      }
    });
    return html;
  }

  renderNavbar() {
    const self = this;

    if (self.params.renderNavbar) {
      return self.params.renderNavbar.call(self, self);
    }

    const {
      openIn,
      navbarTitleText,
      navbarBackLinkText,
      navbarCloseText
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "navbar"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "navbar-bg"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "navbar-inner sliding"
    }, openIn === 'page' && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "left"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("a", {
      class: "link back"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("i", {
      class: "icon icon-back"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("span", {
      class: "if-not-md"
    }, navbarBackLinkText))), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "title"
    }, navbarTitleText), openIn !== 'page' && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "right"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("a", {
      class: "link popup-close",
      "data-popup": ".color-picker-popup"
    }, navbarCloseText))));
  }

  renderToolbar() {
    const self = this;

    if (self.params.renderToolbar) {
      return self.params.renderToolbar.call(self, self);
    }

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "toolbar toolbar-top no-shadow"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "toolbar-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "left"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "right"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("a", {
      class: "link sheet-close popover-close",
      "data-sheet": ".color-picker-sheet-modal",
      "data-popover": ".color-picker-popover"
    }, self.params.toolbarCloseText))));
  }

  renderInline() {
    const self = this;
    const {
      cssClass,
      groupedModules
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: `color-picker color-picker-inline ${groupedModules ? 'color-picker-grouped-modules' : ''} ${cssClass || ''}`
    }, self.renderPicker());
  }

  renderSheet() {
    const self = this;
    const {
      cssClass,
      toolbarSheet,
      groupedModules
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: `sheet-modal color-picker color-picker-sheet-modal ${groupedModules ? 'color-picker-grouped-modules' : ''} ${cssClass || ''}`
    }, toolbarSheet && self.renderToolbar(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "sheet-modal-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "page-content"
    }, self.renderPicker())));
  }

  renderPopover() {
    const self = this;
    const {
      cssClass,
      toolbarPopover,
      groupedModules
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: `popover color-picker-popover ${cssClass || ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "popover-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: `color-picker ${groupedModules ? 'color-picker-grouped-modules' : ''}`
    }, toolbarPopover && self.renderToolbar(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "page-content"
    }, self.renderPicker()))));
  }

  renderPopup() {
    const self = this;
    const {
      cssClass,
      navbarPopup,
      groupedModules
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: `popup color-picker-popup ${cssClass || ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "page"
    }, navbarPopup && self.renderNavbar(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: `color-picker ${groupedModules ? 'color-picker-grouped-modules' : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "page-content"
    }, self.renderPicker()))));
  }

  renderPage() {
    const self = this;
    const {
      cssClass,
      groupedModules
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: `page color-picker-page ${cssClass || ''}`,
      "data-name": "color-picker-page"
    }, self.renderNavbar(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: `color-picker ${groupedModules ? 'color-picker-grouped-modules' : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_17__["default"])("div", {
      class: "page-content"
    }, self.renderPicker())));
  } // eslint-disable-next-line


  render() {
    const self = this;
    const {
      params
    } = self;
    if (params.render) return params.render.call(self);
    if (self.inline) return self.renderInline();

    if (params.openIn === 'page') {
      return self.renderPage();
    }

    const modalType = self.getModalType();
    if (modalType === 'popover') return self.renderPopover();
    if (modalType === 'sheet') return self.renderSheet();
    if (modalType === 'popup') return self.renderPopup();
  }

  onOpen() {
    const self = this;
    const {
      initialized,
      $el,
      app,
      $inputEl,
      inline,
      value,
      params,
      modules
    } = self;
    self.closing = false;
    self.opened = true;
    self.opening = true; // Init main events

    self.attachEvents();
    params.modules.forEach(m => {
      if (typeof m === 'string' && modules[m] && modules[m].init) {
        modules[m].init(self);
      } else if (m && m.init) {
        m.init(self);
      }
    });
    const updateValue = !value && params.value; // Set value

    if (!initialized) {
      if (value) self.setValue(value);else if (params.value) {
        self.setValue(params.value, false);
      } else if (!params.value) {
        self.setValue({
          hex: '#ff0000'
        }, false);
      }
    } else if (value) {
      self.initialValue = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, value);
      self.setValue(value, false);
    } // Update input value


    if (updateValue) self.updateValue();
    self.updateModules(); // Center modules

    if (params.centerModules) {
      self.centerModules();
    } // Extra focus


    if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
      $inputEl.trigger('focus');
    }

    self.initialized = true; // Trigger events

    if ($el) {
      $el.trigger('colorpicker:open');
    }

    if ($inputEl) {
      $inputEl.trigger('colorpicker:open');
    }

    self.emit('local::open colorPickerOpen', self);
  }

  onOpened() {
    const self = this;
    self.opening = false;

    if (self.$el) {
      self.$el.trigger('colorpicker:opened');
    }

    if (self.$inputEl) {
      self.$inputEl.trigger('colorpicker:opened');
    }

    self.emit('local::opened colorPickerOpened', self);
  }

  onClose() {
    const self = this;
    const {
      app,
      params,
      modules
    } = self;
    self.opening = false;
    self.closing = true; // Detach events

    self.detachEvents();

    if (self.$inputEl) {
      if (app.theme === 'md') {
        self.$inputEl.trigger('blur');
      } else {
        const validate = self.$inputEl.attr('validate');
        const required = self.$inputEl.attr('required');

        if (validate && required) {
          app.input.validate(self.$inputEl);
        }
      }
    }

    params.modules.forEach(m => {
      if (typeof m === 'string' && modules[m] && modules[m].destroy) {
        modules[m].destroy(self);
      } else if (m && m.destroy) {
        m.destroy(self);
      }
    });

    if (self.$el) {
      self.$el.trigger('colorpicker:close');
    }

    if (self.$inputEl) {
      self.$inputEl.trigger('colorpicker:close');
    }

    self.emit('local::close colorPickerClose', self);
  }

  onClosed() {
    const self = this;
    self.opened = false;
    self.closing = false;

    if (!self.inline) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
        if (self.modal && self.modal.el && self.modal.destroy) {
          if (!self.params.routableModals) {
            self.modal.destroy();
          }
        }

        delete self.modal;
      });
    }

    if (self.$el) {
      self.$el.trigger('colorpicker:closed');
    }

    if (self.$inputEl) {
      self.$inputEl.trigger('colorpicker:closed');
    }

    self.emit('local::closed colorPickerClosed', self);
  }

  open() {
    const self = this;
    const {
      app,
      opened,
      inline,
      $inputEl,
      $targetEl,
      params
    } = self;
    if (opened) return;

    if (inline) {
      self.$el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(self.render());
      self.$el[0].f7ColorPicker = self;
      self.$containerEl.append(self.$el);
      self.onOpen();
      self.onOpened();
      return;
    }

    const colorPickerContent = self.render();

    if (params.openIn === 'page') {
      self.view.router.navigate({
        url: self.url,
        route: {
          content: colorPickerContent,
          path: self.url,
          on: {
            pageBeforeIn(e, page) {
              self.$el = page.$el.find('.color-picker');
              self.$el[0].f7ColorPicker = self;
              self.onOpen();
            },

            pageAfterIn() {
              self.onOpened();
            },

            pageBeforeOut() {
              self.onClose();
            },

            pageAfterOut() {
              self.onClosed();

              if (self.$el && self.$el[0]) {
                self.$el[0].f7ColorPicker = null;
                delete self.$el[0].f7ColorPicker;
              }
            }

          }
        }
      });
    } else {
      const modalType = self.getModalType();
      let backdrop = params.backdrop;

      if (backdrop === null || typeof backdrop === 'undefined') {
        if (modalType === 'popover' && app.params.popover.backdrop !== false) backdrop = true;
        if (modalType === 'popup') backdrop = true;
      }

      const modalParams = {
        targetEl: $targetEl || $inputEl,
        scrollToEl: params.scrollToInput ? $targetEl || $inputEl : undefined,
        content: colorPickerContent,
        backdrop,
        closeByBackdropClick: params.closeByBackdropClick,
        on: {
          open() {
            const modal = this;
            self.modal = modal;
            self.$el = modalType === 'popover' || modalType === 'popup' ? modal.$el.find('.color-picker') : modal.$el;
            self.$el[0].f7ColorPicker = self;
            self.onOpen();
          },

          opened() {
            self.onOpened();
          },

          close() {
            self.onClose();
          },

          closed() {
            self.onClosed();

            if (self.$el && self.$el[0]) {
              self.$el[0].f7ColorPicker = null;
              delete self.$el[0].f7ColorPicker;
            }
          }

        }
      };

      if (modalType === 'popup') {
        modalParams.push = params.popupPush;
        modalParams.swipeToClose = params.popupSwipeToClose;
      }

      if (modalType === 'sheet') {
        modalParams.push = params.sheetPush;
        modalParams.swipeToClose = params.sheetSwipeToClose;
      }

      if (params.routableModals && self.view) {
        self.view.router.navigate({
          url: self.url,
          route: {
            path: self.url,
            [modalType]: modalParams
          }
        });
      } else {
        self.modal = app[modalType].create(modalParams);
        self.modal.open();
      }
    }
  }

  close() {
    const self = this;
    const {
      opened,
      inline
    } = self;
    if (!opened) return;

    if (inline) {
      self.onClose();
      self.onClosed();
      return;
    }

    if (self.params.routableModals && self.view || self.params.openIn === 'page') {
      self.view.router.back();
    } else {
      self.modal.close();
    }
  }

  init() {
    const self = this;
    self.initInput();

    if (self.inline) {
      self.open();
      self.emit('local::init colorPickerInit', self);
      return;
    }

    if (!self.initialized && self.params.value) {
      self.setValue(self.params.value);
    } // Attach input Events


    if (self.$inputEl) {
      self.attachInputEvents();
    }

    if (self.$targetEl) {
      self.attachTargetEvents();
    }

    if (self.params.closeByOutsideClick) {
      self.attachHtmlEvents();
    }

    self.emit('local::init colorPickerInit', self);
  }

  destroy() {
    const self = this;
    if (self.destroyed) return;
    const {
      $el
    } = self;
    self.emit('local::beforeDestroy colorPickerBeforeDestroy', self);
    if ($el) $el.trigger('colorpicker:beforedestroy');
    self.close(); // Detach Events

    self.detachEvents();

    if (self.$inputEl) {
      self.detachInputEvents();
    }

    if (self.$targetEl) {
      self.detachTargetEvents();
    }

    if (self.params.closeByOutsideClick) {
      self.detachHtmlEvents();
    }

    if ($el && $el.length) delete self.$el[0].f7ColorPicker;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(self);
    self.destroyed = true;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorPicker);

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/color-picker.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/color-picker.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");
/* harmony import */ var _color_picker_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color-picker-class.js */ "./node_modules/framework7/components/color-picker/color-picker-class.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'colorPicker',
  static: {
    ColorPicker: _color_picker_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.colorPicker = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.color-picker',
      constructor: _color_picker_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7ColorPicker'
    });

    app.colorPicker.close = function close(el) {
      if (el === void 0) {
        el = '.color-picker';
      }

      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
      if ($el.length === 0) return;
      const colorPicker = $el[0].f7ColorPicker;
      if (!colorPicker || colorPicker && !colorPicker.opened) return;
      colorPicker.close();
    };
  },

  params: {
    colorPicker: {
      // Color picker settings
      value: null,
      modules: ['wheel'],
      palette: [['#FFEBEE', '#FFCDD2', '#EF9A9A', '#E57373', '#EF5350', '#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C'], ['#F3E5F5', '#E1BEE7', '#CE93D8', '#BA68C8', '#AB47BC', '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C'], ['#E8EAF6', '#C5CAE9', '#9FA8DA', '#7986CB', '#5C6BC0', '#3F51B5', '#3949AB', '#303F9F', '#283593', '#1A237E'], ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#01579B'], ['#E0F2F1', '#B2DFDB', '#80CBC4', '#4DB6AC', '#26A69A', '#009688', '#00897B', '#00796B', '#00695C', '#004D40'], ['#F1F8E9', '#DCEDC8', '#C5E1A5', '#AED581', '#9CCC65', '#8BC34A', '#7CB342', '#689F38', '#558B2F', '#33691E'], ['#FFFDE7', '#FFF9C4', '#FFF59D', '#FFF176', '#FFEE58', '#FFEB3B', '#FDD835', '#FBC02D', '#F9A825', '#F57F17'], ['#FFF3E0', '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726', '#FF9800', '#FB8C00', '#F57C00', '#EF6C00', '#E65100']],
      groupedModules: false,
      centerModules: true,
      sliderLabel: false,
      sliderValue: false,
      sliderValueEdiable: false,
      barLabel: false,
      barValue: false,
      barValueEdiable: false,
      hexLabel: false,
      hexValueEditable: false,
      redLabelText: 'R',
      greenLabelText: 'G',
      blueLabelText: 'B',
      hueLabelText: 'H',
      saturationLabelText: 'S',
      brightnessLabelText: 'B',
      hexLabelText: 'HEX',
      alphaLabelText: 'A',
      // Common opener settings
      containerEl: null,
      openIn: 'popover',
      // or 'popover' or 'sheet' or 'popup' or 'page' or 'auto'
      openInPhone: 'popup',
      // or 'popover' or 'sheet' or 'popup' or 'page'
      popupPush: false,
      popupSwipeToClose: undefined,
      sheetPush: false,
      sheetSwipeToClose: undefined,
      formatValue: null,
      targetEl: null,
      targetElSetBackgroundColor: false,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      toolbarSheet: true,
      toolbarPopover: false,
      toolbarCloseText: 'Done',
      navbarPopup: true,
      navbarCloseText: 'Done',
      navbarTitleText: 'Color',
      navbarBackLinkText: 'Back',
      cssClass: null,
      routableModals: false,
      view: null,
      url: 'color/',
      backdrop: null,
      closeByBackdropClick: true,
      // Render functions
      renderToolbar: null,
      renderNavbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      renderPopup: null,
      render: null
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/alpha-slider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/alpha-slider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      alphaLabelText
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-module color-picker-module-alpha-slider"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-slider-label"
    }, alphaLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "range-slider color-picker-slider color-picker-slider-alpha"
    }), sliderValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      type: "number",
      step: "0.01",
      min: "0",
      max: "1",
      class: "color-picker-value-alpha"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "color-picker-value-alpha"
    }))));
  },

  init(self) {
    self.alphaRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-alpha'),
      min: 0,
      max: 1,
      step: 0.01,
      value: 1,
      on: {
        change(range, value) {
          const alpha = Math.floor(value * 100) / 100;
          self.setValue({
            alpha
          });
        }

      }
    });

    function handleInputChange(e) {
      const alpha = self.value.alpha;
      let value = parseFloat(e.target.value);

      if (Number.isNaN(value)) {
        e.target.value = alpha;
        return;
      }

      value = Math.max(0, Math.min(1, value));
      self.setValue({
        alpha: value
      });
    }

    self.$el.on('change', '.color-picker-module-alpha-slider input', handleInputChange);

    self.destroyAlphaSliderEvents = function destroyAlphaSliderEvents() {
      self.$el.off('change', '.color-picker-module-alpha-slider input', handleInputChange);
    };
  },

  update(self) {
    const {
      value
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      alpha
    } = value;
    self.alphaRangeSlider.value = alpha;
    self.alphaRangeSlider.layout();

    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-alpha').val(alpha);
    } else {
      self.$el.find('span.color-picker-value-alpha').text(alpha);
    }
  },

  destroy(self) {
    if (self.alphaRangeSlider && self.alphaRangeSlider.destroy) {
      self.alphaRangeSlider.destroy();
    }

    delete self.alphaRangeSlider;
    if (self.destroyAlphaSliderEvents) self.destroyAlphaSliderEvents();
    delete self.destroyAlphaSliderEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/brightness-slider.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/brightness-slider.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");

/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      brightnessLabelText
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-module color-picker-module-brightness-slider"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-slider-label"
    }, brightnessLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "range-slider color-picker-slider color-picker-slider-brightness"
    }), sliderValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "100",
      class: "color-picker-value-brightness"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "color-picker-value-brightness"
    }))));
  },

  init(self) {
    self.brightnessRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-brightness'),
      min: 0,
      max: 1,
      step: 0.001,
      value: 0,
      on: {
        change(range, value) {
          const b = Math.floor(value * 1000) / 1000;
          self.setValue({
            hsb: [self.value.hsb[0], self.value.hsb[1], b]
          });
        }

      }
    });
  },

  update(self) {
    const {
      value,
      app
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      hsb
    } = value;
    self.brightnessRangeSlider.value = hsb[2];
    self.brightnessRangeSlider.layout();
    const hslCurrent = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorHsbToHsl)(hsb[0], hsb[1], hsb[2]);
    const hslLeft = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorHsbToHsl)(hsb[0], hsb[1], 0);
    const hslRight = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorHsbToHsl)(hsb[0], hsb[1], 1);
    self.brightnessRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`);
    self.brightnessRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${app.rtl ? 'to left' : 'to right'}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`);

    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-brightness').val(`${hsb[2] * 1000 / 10}`);
    } else if (sliderValue) {
      self.$el.find('span.color-picker-value-brightness').text(`${hsb[2] * 1000 / 10}`);
    }
  },

  destroy(self) {
    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
      self.brightnessRangeSlider.destroy();
    }

    delete self.brightnessRangeSlider;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/current-color.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/current-color.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render() {
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-module color-picker-module-current-color"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-current-color"
    }));
  },

  update(self) {
    self.$el.find('.color-picker-module-current-color .color-picker-current-color').css('background-color', self.value.hex);
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/hex.js":
/*!************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/hex.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render(self) {
    const {
      hexLabel,
      hexLabelText,
      hexValueEditable
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-module color-picker-module-hex"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-hex-wrap"
    }, hexLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-hex-label"
    }, hexLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-hex-value"
    }, hexValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      type: "text",
      class: "color-picker-value-hex"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "color-picker-value-hex"
    }))));
  },

  init(self) {
    function handleInputChange(e) {
      const hex = self.value.hex;
      let value = e.target.value.replace(/#/g, '');

      if (Number.isNaN(value) || !value || value.length !== 3 && value.length !== 6) {
        e.target.value = hex;
        return;
      }

      const min = 0;
      const current = parseInt(value, 16);
      const max = parseInt('ffffff', 16); // eslint-disable-line

      if (current > max) {
        value = 'fff';
      }

      if (current < min) {
        value = '000';
      }

      self.setValue({
        hex: value
      });
    }

    self.$el.on('change', '.color-picker-module-hex input', handleInputChange);

    self.destroyHexEvents = function destroyHexEvents() {
      self.$el.off('change', '.color-picker-module-hex input', handleInputChange);
    };
  },

  update(self) {
    const {
      value
    } = self;
    const {
      hexValueEditable
    } = self.params;
    const {
      hex
    } = value;

    if (hexValueEditable) {
      self.$el.find('input.color-picker-value-hex').val(hex);
    } else {
      self.$el.find('span.color-picker-value-hex').text(hex);
    }
  },

  destroy(self) {
    if (self.destroyHexEvents) self.destroyHexEvents();
    delete self.destroyHexEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/hs-spectrum.js":
/*!********************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/hs-spectrum.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");



/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render() {
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-module color-picker-module-hs-spectrum"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-hs-spectrum"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-hs-spectrum-handle"
    })));
  },

  init(self) {
    const {
      app
    } = self;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;
    const {
      $el
    } = self;

    function setHSFromSpecterCoords(x, y) {
      let h = (x - specterRect.left) / specterRect.width * 360;
      let s = (y - specterRect.top) / specterRect.height;
      h = Math.max(0, Math.min(360, h));
      s = 1 - Math.max(0, Math.min(1, s));
      self.setValue({
        hsb: [h, s, self.value.hsb[2]]
      });
    }

    function handleTouchStart(e) {
      if (isMoved || isTouched) return;
      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target);
      specterHandleIsTouched = $targetEl.closest('.color-picker-hs-spectrum-handle').length > 0;

      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest('.color-picker-hs-spectrum').length > 0;
      }

      if (specterIsTouched) {
        specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
        setHSFromSpecterCoords(touchStartX, touchStartY);
      }

      if (specterHandleIsTouched || specterIsTouched) {
        $el.find('.color-picker-hs-spectrum-handle').addClass('color-picker-hs-spectrum-handle-pressed');
      }
    }

    function handleTouchMove(e) {
      if (!(specterIsTouched || specterHandleIsTouched)) return;
      touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();

      if (!isMoved) {
        // First move
        isMoved = true;

        if (specterHandleIsTouched) {
          specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
        }
      }

      if (specterIsTouched || specterHandleIsTouched) {
        setHSFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }

    function handleTouchEnd() {
      isMoved = false;

      if (specterIsTouched || specterHandleIsTouched) {
        $el.find('.color-picker-hs-spectrum-handle').removeClass('color-picker-hs-spectrum-handle-pressed');
      }

      specterIsTouched = false;
      specterHandleIsTouched = false;
    }

    function handleResize() {
      self.modules['hs-spectrum'].update(self);
    }

    const passiveListener = app.touchEvents.start === 'touchstart' && (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)().passiveListener ? {
      passive: true,
      capture: false
    } : false;
    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    app.on('resize', handleResize);

    self.destroySpectrumEvents = function destroySpectrumEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('resize', handleResize);
    };
  },

  update(self) {
    const {
      value
    } = self;
    const {
      hsb
    } = value;
    const specterWidth = self.$el.find('.color-picker-hs-spectrum')[0].offsetWidth;
    const specterHeight = self.$el.find('.color-picker-hs-spectrum')[0].offsetHeight;
    const hslBright = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.colorHsbToHsl)(hsb[0], hsb[1], 1);
    self.$el.find('.color-picker-hs-spectrum-handle').css('background-color', `hsl(${hslBright[0]}, ${hslBright[1] * 100}%, ${hslBright[2] * 100}%)`).transform(`translate(${specterWidth * (hsb[0] / 360)}px, ${specterHeight * (1 - hsb[1])}px)`);
  },

  destroy(self) {
    if (self.destroySpectrumEvents) self.destroySpectrumEvents();
    delete self.destroySpectrumEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/hsb-sliders.js":
/*!********************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/hsb-sliders.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");


/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      hueLabelText,
      saturationLabelText,
      brightnessLabelText
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-module color-picker-module-hsb-sliders"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-label"
    }, hueLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider color-picker-slider color-picker-slider-hue"
    }), sliderValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "360",
      class: "color-picker-value-hue",
      "data-color-index": "0"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "color-picker-value-hue"
    }))), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-label"
    }, saturationLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider color-picker-slider color-picker-slider-saturation"
    }), sliderValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "100",
      class: "color-picker-value-saturation",
      "data-color-index": "1"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "color-picker-value-saturation"
    }))), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-label"
    }, brightnessLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider color-picker-slider color-picker-slider-brightness"
    }), sliderValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "100",
      class: "color-picker-value-brightness",
      "data-color-index": "2"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "color-picker-value-brightness"
    }))));
  },

  init(self) {
    self.hueRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-hue'),
      min: 0,
      max: 360,
      step: 0.1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            hue: value
          });
        }

      }
    });
    self.saturationRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-saturation'),
      min: 0,
      max: 1,
      step: 0.001,
      value: 0,
      on: {
        change(range, value) {
          const s = Math.floor(value * 1000) / 1000;
          self.setValue({
            hsb: [self.value.hsb[0], s, self.value.hsb[2]]
          });
        }

      }
    });
    self.brightnessRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-brightness'),
      min: 0,
      max: 1,
      step: 0.001,
      value: 0,
      on: {
        change(range, value) {
          const b = Math.floor(value * 1000) / 1000;
          self.setValue({
            hsb: [self.value.hsb[0], self.value.hsb[1], b]
          });
        }

      }
    });

    function handleInputChange(e) {
      const hsb = [...self.value.hsb];
      const index = parseInt((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).attr('data-color-index'), 10);
      let value = parseFloat(e.target.value);

      if (Number.isNaN(value)) {
        e.target.value = hsb[index];
        return;
      }

      if (index === 0) {
        value = Math.max(0, Math.min(360, value));
      } else {
        value = Math.max(0, Math.min(100, value)) / 100;
      }

      hsb[index] = value;
      self.setValue({
        hsb
      });
    }

    self.$el.on('change', '.color-picker-module-hsb-sliders input', handleInputChange);

    self.destroyHsbSlidersEvents = function destroyHsbSlidersEvents() {
      self.$el.off('change', '.color-picker-module-hsb-sliders input', handleInputChange);
    };
  },

  update(self) {
    const {
      app,
      value
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      hsb,
      hue
    } = value;
    self.hueRangeSlider.value = hue;
    self.saturationRangeSlider.value = hsb[1];
    self.brightnessRangeSlider.value = hsb[2];
    self.hueRangeSlider.layout();
    self.saturationRangeSlider.layout();
    self.brightnessRangeSlider.layout();
    const hslCurrent = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHsbToHsl)(hsb[0], hsb[1], 1);
    const hslLeft = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHsbToHsl)(hsb[0], 0, 1);
    const hslRight = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.colorHsbToHsl)(hsb[0], 1, 1);
    const brightness = hsb[2];
    self.hueRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `hsl(${hue}, 100%, 50%)`);
    self.saturationRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`);
    self.brightnessRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${brightness * 255}, ${brightness * 255}, ${brightness * 255})`);
    self.saturationRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${app.rtl ? 'to left' : 'to right'}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`);

    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-hue').val(`${hue}`);
      self.$el.find('input.color-picker-value-saturation').val(`${hsb[1] * 1000 / 10}`);
      self.$el.find('input.color-picker-value-brightness').val(`${hsb[2] * 1000 / 10}`);
    } else if (sliderValue) {
      self.$el.find('span.color-picker-value-hue').text(`${hue}`);
      self.$el.find('span.color-picker-value-saturation').text(`${hsb[1] * 1000 / 10}`);
      self.$el.find('span.color-picker-value-brightness').text(`${hsb[2] * 1000 / 10}`);
    }
  },

  destroy(self) {
    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
      self.hueRangeSlider.destroy();
    }

    if (self.saturationRangeSlider && self.saturationRangeSlider.destroy) {
      self.saturationRangeSlider.destroy();
    }

    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
      self.brightnessRangeSlider.destroy();
    }

    delete self.hueRangeSlider;
    delete self.saturationRangeSlider;
    delete self.brightnessRangeSlider;
    if (self.destroyHsbSlidersEvents) self.destroyHsbSlidersEvents();
    delete self.destroyHsbSlidersEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/hue-slider.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/hue-slider.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      hueLabelText
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-module color-picker-module-hue-slider"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-slider-label"
    }, hueLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "range-slider color-picker-slider color-picker-slider-hue"
    }), sliderValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "360",
      class: "color-picker-value-hue"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "color-picker-value-hue"
    }))));
  },

  init(self) {
    self.hueRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-hue'),
      min: 0,
      max: 360,
      step: 0.1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            hue: value
          });
        }

      }
    });
  },

  update(self) {
    const {
      value
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      hue
    } = value;
    self.hueRangeSlider.value = hue;
    self.hueRangeSlider.layout();
    self.hueRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `hsl(${hue}, 100%, 50%)`);

    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-hue').val(`${hue}`);
    } else if (sliderValue) {
      self.$el.find('span.color-picker-value-hue').text(`${hue}`);
    }
  },

  destroy(self) {
    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
      self.hueRangeSlider.destroy();
    }

    delete self.hueRangeSlider;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/initial-current-colors.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/initial-current-colors.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render() {
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-module color-picker-module-initial-current-colors"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-initial-current-colors"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-initial-color"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "color-picker-current-color"
    })));
  },

  init(self) {
    function handleInitialColorClick() {
      if (self.initialValue) {
        const {
          hex,
          alpha
        } = self.initialValue;
        self.setValue({
          hex,
          alpha
        });
      }
    }

    self.$el.on('click', '.color-picker-initial-color', handleInitialColorClick);

    self.destroyInitialCurrentEvents = function destroyInitialCurrentEvents() {
      self.$el.off('click', '.color-picker-initial-color', handleInitialColorClick);
    };
  },

  update(self) {
    self.$el.find('.color-picker-module-initial-current-colors .color-picker-initial-color').css('background-color', self.initialValue.hex);
    self.$el.find('.color-picker-module-initial-current-colors .color-picker-current-color').css('background-color', self.value.hex);
  },

  destroy(self) {
    if (self.destroyInitialCurrentEvents) {
      self.destroyInitialCurrentEvents();
    }

    delete self.destroyInitialCurrentEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/palette.js":
/*!****************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/palette.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/* eslint indent: ["off"] */

/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render(self) {
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-module color-picker-module-palette"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-palette"
    }, self.params.palette.map(p => {
      if (Array.isArray(p)) {
        let row = '<div class="color-picker-palette-row">'; // prettier-ignore

        row += p.map(c => `
                <div class="color-picker-palette-value" data-palette-color="${c}" style="background-color: ${c}"></div>
              `).join('');
        row += '</div>';
        return row;
      }

      return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
        class: "color-picker-palette-value",
        "data-palette-color": p,
        style: `background-color: ${p}`
      });
    })));
  },

  init(self) {
    function handlePaletteClick(e) {
      const hex = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).attr('data-palette-color');
      self.setValue({
        hex
      });
    }

    self.$el.on('click', '.color-picker-module-palette .color-picker-palette-value', handlePaletteClick);

    self.destroyPaletteEvents = function destroyPaletteEvents() {
      self.$el.off('click', '.color-picker-module-hex input', handlePaletteClick);
    };
  },

  destroy(self) {
    if (self.destroyPaletteEvents) {
      self.destroyPaletteEvents();
    }

    delete self.destroyPaletteEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/rgb-bars.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/rgb-bars.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");

/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render(self) {
    const {
      barLabel,
      barValue,
      barValueEditable,
      redLabelText,
      greenLabelText,
      blueLabelText
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-module color-picker-module-rgb-bars"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-bar-wrap"
    }, barLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-bar-label"
    }, redLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider color-picker-bar color-picker-bar-red"
    }), barValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-bar-value"
    }, barValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-bar-red",
      "data-color-index": "0"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "color-picker-value-bar-red"
    }))), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-bar-wrap"
    }, barLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-bar-label"
    }, greenLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider color-picker-bar color-picker-bar-green"
    }), barValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-bar-value"
    }, barValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-bar-green",
      "data-color-index": "1"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "color-picker-value-bar-green"
    }))), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-bar-wrap"
    }, barLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-bar-label"
    }, blueLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider color-picker-bar color-picker-bar-blue"
    }), barValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-bar-value"
    }, barValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-bar-blue",
      "data-color-index": "2"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "color-picker-value-bar-blue"
    }))));
  },

  init(self) {
    self.redBar = self.app.range.create({
      el: self.$el.find('.color-picker-bar-red'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [value, self.value.rgb[1], self.value.rgb[2]]
          });
        }

      }
    });
    self.greenBar = self.app.range.create({
      el: self.$el.find('.color-picker-bar-green'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], value, self.value.rgb[2]]
          });
        }

      }
    });
    self.blueBar = self.app.range.create({
      el: self.$el.find('.color-picker-bar-blue'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], self.value.rgb[1], value]
          });
        }

      }
    });

    function handleInputChange(e) {
      const rgb = [...self.value.rgb];
      const index = parseInt((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).attr('data-color-index'), 10);
      let value = parseInt(e.target.value, 10);

      if (Number.isNaN(value)) {
        e.target.value = rgb[index];
        return;
      }

      value = Math.max(0, Math.min(255, value));
      rgb[index] = value;
      self.setValue({
        rgb
      });
    }

    self.$el.on('change', '.color-picker-module-rgb-bars input', handleInputChange);

    self.destroyRgbBarsEvents = function destroyRgbBarsEvents() {
      self.$el.off('change', '.color-picker-module-rgb-bars input', handleInputChange);
    };
  },

  update(self) {
    const {
      value,
      redBar,
      greenBar,
      blueBar
    } = self;
    const {
      barValue,
      barValueEditable
    } = self.params;
    const {
      rgb
    } = value;
    redBar.value = rgb[0];
    greenBar.value = rgb[1];
    blueBar.value = rgb[2];
    redBar.layout();
    greenBar.layout();
    blueBar.layout();
    redBar.$el.find('.range-bar').css('background-image', `linear-gradient(to top, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
    greenBar.$el.find('.range-bar').css('background-image', `linear-gradient(to top, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
    blueBar.$el.find('.range-bar').css('background-image', `linear-gradient(to top, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);

    if (barValue && barValueEditable) {
      self.$el.find('input.color-picker-value-bar-red').val(rgb[0]);
      self.$el.find('input.color-picker-value-bar-green').val(rgb[1]);
      self.$el.find('input.color-picker-value-bar-blue').val(rgb[2]);
    } else if (barValue) {
      self.$el.find('span.color-picker-value-bar-red').text(rgb[0]);
      self.$el.find('span.color-picker-value-bar-green').text(rgb[1]);
      self.$el.find('span.color-picker-value-bar-blue').text(rgb[2]);
    }
  },

  destroy(self) {
    if (self.redBar && self.redBar.destroy) {
      self.redBar.destroy();
    }

    if (self.greenBar && self.greenBar.destroy) {
      self.greenBar.destroy();
    }

    if (self.blueBar && self.blueBar.destroy) {
      self.blueBar.destroy();
    }

    delete self.redBar;
    delete self.greenBar;
    delete self.blueBar;
    if (self.destroyRgbBarsEvents) self.destroyRgbBarsEvents();
    delete self.destroyRgbBarsEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/rgb-sliders.js":
/*!********************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/rgb-sliders.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");

/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      redLabelText,
      greenLabelText,
      blueLabelText
    } = self.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-module color-picker-module-rgb-sliders"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-label"
    }, redLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider color-picker-slider color-picker-slider-red"
    }), sliderValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-red",
      "data-color-index": "0"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "color-picker-value-red"
    }))), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-label"
    }, greenLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider color-picker-slider color-picker-slider-green"
    }), sliderValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-green",
      "data-color-index": "1"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "color-picker-value-green"
    }))), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-label"
    }, blueLabelText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider color-picker-slider color-picker-slider-blue"
    }), sliderValue && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-blue",
      "data-color-index": "2"
    }) : (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "color-picker-value-blue"
    }))));
  },

  init(self) {
    self.redRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-red'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [value, self.value.rgb[1], self.value.rgb[2]]
          });
        }

      }
    });
    self.greenRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-green'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], value, self.value.rgb[2]]
          });
        }

      }
    });
    self.blueRangeSlider = self.app.range.create({
      el: self.$el.find('.color-picker-slider-blue'),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], self.value.rgb[1], value]
          });
        }

      }
    });

    function handleInputChange(e) {
      const rgb = [...self.value.rgb];
      const index = parseInt((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).attr('data-color-index'), 10);
      let value = parseInt(e.target.value, 10);

      if (Number.isNaN(value)) {
        e.target.value = rgb[index];
        return;
      }

      value = Math.max(0, Math.min(255, value));
      rgb[index] = value;
      self.setValue({
        rgb
      });
    }

    self.$el.on('change', '.color-picker-module-rgb-sliders input', handleInputChange);

    self.destroyRgbSlidersEvents = function destroyRgbSlidersEvents() {
      self.$el.off('change', '.color-picker-module-rgb-sliders input', handleInputChange);
    };
  },

  update(self) {
    const {
      app,
      value,
      redRangeSlider,
      greenRangeSlider,
      blueRangeSlider
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      rgb
    } = value;
    redRangeSlider.value = rgb[0];
    greenRangeSlider.value = rgb[1];
    blueRangeSlider.value = rgb[2];
    redRangeSlider.layout();
    greenRangeSlider.layout();
    blueRangeSlider.layout();
    redRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    greenRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    blueRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    const direction = app.rtl ? 'to left' : 'to right';
    redRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${direction}, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
    greenRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${direction}, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
    blueRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${direction}, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);

    if (sliderValue && sliderValueEditable) {
      self.$el.find('input.color-picker-value-red').val(rgb[0]);
      self.$el.find('input.color-picker-value-green').val(rgb[1]);
      self.$el.find('input.color-picker-value-blue').val(rgb[2]);
    } else if (sliderValue) {
      self.$el.find('span.color-picker-value-red').text(rgb[0]);
      self.$el.find('span.color-picker-value-green').text(rgb[1]);
      self.$el.find('span.color-picker-value-blue').text(rgb[2]);
    }
  },

  destroy(self) {
    if (self.redRangeSlider && self.redRangeSlider.destroy) {
      self.redRangeSlider.destroy();
    }

    if (self.greenRangeSlider && self.greenRangeSlider.destroy) {
      self.greenRangeSlider.destroy();
    }

    if (self.blueRangeSlider && self.blueRangeSlider.destroy) {
      self.blueRangeSlider.destroy();
    }

    delete self.redRangeSlider;
    delete self.greenRangeSlider;
    delete self.blueRangeSlider;
    if (self.destroyRgbSlidersEvents) self.destroyRgbSlidersEvents();
    delete self.destroyRgbSlidersEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/sb-spectrum.js":
/*!********************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/sb-spectrum.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");


/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render() {
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-module color-picker-module-sb-spectrum"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-sb-spectrum",
      style: "background-color: hsl(0, 100%, 50%)"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-sb-spectrum-handle"
    })));
  },

  init(self) {
    const {
      app
    } = self;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;
    const {
      $el
    } = self;

    function setSBFromSpecterCoords(x, y) {
      let s = (x - specterRect.left) / specterRect.width;
      let b = (y - specterRect.top) / specterRect.height;
      s = Math.max(0, Math.min(1, s));
      b = 1 - Math.max(0, Math.min(1, b));
      self.setValue({
        hsb: [self.value.hue, s, b]
      });
    }

    function handleTouchStart(e) {
      if (isMoved || isTouched) return;
      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target);
      specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;

      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
      }

      if (specterIsTouched) {
        specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
        setSBFromSpecterCoords(touchStartX, touchStartY);
      }

      if (specterHandleIsTouched || specterIsTouched) {
        $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
      }
    }

    function handleTouchMove(e) {
      if (!(specterIsTouched || specterHandleIsTouched)) return;
      touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();

      if (!isMoved) {
        // First move
        isMoved = true;

        if (specterHandleIsTouched) {
          specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
        }
      }

      if (specterIsTouched || specterHandleIsTouched) {
        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }

    function handleTouchEnd() {
      isMoved = false;

      if (specterIsTouched || specterHandleIsTouched) {
        $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
      }

      specterIsTouched = false;
      specterHandleIsTouched = false;
    }

    function handleResize() {
      self.modules['sb-spectrum'].update(self);
    }

    const passiveListener = app.touchEvents.start === 'touchstart' && (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)().passiveListener ? {
      passive: true,
      capture: false
    } : false;
    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    app.on('resize', handleResize);

    self.destroySpectrumEvents = function destroySpectrumEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('resize', handleResize);
    };
  },

  update(self) {
    const {
      value
    } = self;
    const {
      hsl,
      hsb
    } = value;
    const specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
    const specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;
    self.$el.find('.color-picker-sb-spectrum').css('background-color', `hsl(${hsl[0]}, 100%, 50%)`);
    self.$el.find('.color-picker-sb-spectrum-handle').css('background-color', `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`).transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
  },

  destroy(self) {
    if (self.destroySpectrumEvents) self.destroySpectrumEvents();
    delete self.destroySpectrumEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/color-picker/modules/wheel.js":
/*!**************************************************************************!*\
  !*** ./node_modules/framework7/components/color-picker/modules/wheel.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");


/** @jsx $jsx */



function svgWheelCircles() {
  const total = 256;
  let circles = '';

  for (let i = total; i > 0; i -= 1) {
    const angle = i * Math.PI / (total / 2);
    const hue = 360 / total * i;
    circles += `<circle cx="${150 - Math.sin(angle) * 125}" cy="${150 - Math.cos(angle) * 125}" r="25" fill="hsl(${hue}, 100%, 50%)"></circle>`;
  }

  return circles;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  render() {
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-module color-picker-module-wheel"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-wheel"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("svg", {
      viewBox: "0 0 300 300",
      width: "300",
      height: "300"
    }, svgWheelCircles()), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-wheel-handle"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-sb-spectrum",
      style: "background-color: hsl(0, 100%, 50%)"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "color-picker-sb-spectrum-handle"
    }))));
  },

  init(self) {
    const {
      app
    } = self;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;
    let wheelRect;
    let wheelIsTouched;
    let wheelHandleIsTouched;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;
    const {
      $el
    } = self;

    function setHueFromWheelCoords(x, y) {
      const wheelCenterX = wheelRect.left + wheelRect.width / 2;
      const wheelCenterY = wheelRect.top + wheelRect.height / 2;
      const angleRad = Math.atan2(y - wheelCenterY, x - wheelCenterX);
      let angleDeg = angleRad * 180 / Math.PI + 90;
      if (angleDeg < 0) angleDeg += 360;
      angleDeg = 360 - angleDeg;
      self.setValue({
        hue: angleDeg
      });
    }

    function setSBFromSpecterCoords(x, y) {
      let s = (x - specterRect.left) / specterRect.width;
      let b = (y - specterRect.top) / specterRect.height;
      s = Math.max(0, Math.min(1, s));
      b = 1 - Math.max(0, Math.min(1, b));
      self.setValue({
        hsb: [self.value.hue, s, b]
      });
    }

    function handleTouchStart(e) {
      if (isMoved || isTouched) return;
      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target);
      wheelHandleIsTouched = $targetEl.closest('.color-picker-wheel-handle').length > 0;
      wheelIsTouched = $targetEl.closest('circle').length > 0;
      specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;

      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
      }

      if (wheelIsTouched) {
        wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
        setHueFromWheelCoords(touchStartX, touchStartY);
      }

      if (specterIsTouched) {
        specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
        setSBFromSpecterCoords(touchStartX, touchStartY);
      }

      if (specterHandleIsTouched || specterIsTouched) {
        $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
      }
    }

    function handleTouchMove(e) {
      if (!(wheelIsTouched || wheelHandleIsTouched) && !(specterIsTouched || specterHandleIsTouched)) return;
      touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();

      if (!isMoved) {
        // First move
        isMoved = true;

        if (wheelHandleIsTouched) {
          wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
        }

        if (specterHandleIsTouched) {
          specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
        }
      }

      if (wheelIsTouched || wheelHandleIsTouched) {
        setHueFromWheelCoords(touchCurrentX, touchCurrentY);
      }

      if (specterIsTouched || specterHandleIsTouched) {
        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }

    function handleTouchEnd() {
      isMoved = false;

      if (specterIsTouched || specterHandleIsTouched) {
        $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
      }

      wheelIsTouched = false;
      wheelHandleIsTouched = false;
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }

    function handleResize() {
      self.modules.wheel.update(self);
    }

    const passiveListener = app.touchEvents.start === 'touchstart' && (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)().passiveListener ? {
      passive: true,
      capture: false
    } : false;
    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    app.on('resize', handleResize);

    self.destroyWheelEvents = function destroyWheelEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('resize', handleResize);
    };
  },

  update(self) {
    const {
      value
    } = self;
    const {
      hsl,
      hsb
    } = value;
    const specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
    const specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;
    const wheelSize = self.$el.find('.color-picker-wheel')[0].offsetWidth;
    const wheelHalfSize = wheelSize / 2;
    const angleRad = value.hue * Math.PI / 180;
    const handleSize = wheelSize / 6;
    const handleHalfSize = handleSize / 2;
    const tX = wheelHalfSize - Math.sin(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
    const tY = wheelHalfSize - Math.cos(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
    self.$el.find('.color-picker-wheel-handle').css('background-color', `hsl(${hsl[0]}, 100%, 50%)`).transform(`translate(${tX}px, ${tY}px)`);
    self.$el.find('.color-picker-sb-spectrum').css('background-color', `hsl(${hsl[0]}, 100%, 50%)`);
    self.$el.find('.color-picker-sb-spectrum-handle').css('background-color', `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`).transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
  },

  destroy(self) {
    if (self.destroyWheelEvents) self.destroyWheelEvents();
    delete self.destroyWheelEvents;
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/contacts-list/contacts-list.js":
/*!***************************************************************************!*\
  !*** ./node_modules/framework7/components/contacts-list/contacts-list.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'contactsList'
});

/***/ }),

/***/ "./node_modules/framework7/components/data-table/data-table-class.js":
/*!***************************************************************************!*\
  !*** ./node_modules/framework7/components/data-table/data-table-class.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");




class DataTable extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const table = this;
    const defaults = {}; // Extend defaults with modules params

    table.useModulesParams(defaults);
    table.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(defaults, params); // El

    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(table.params.el);
    if ($el.length === 0) return undefined;
    table.$el = $el;
    table.el = $el[0];

    if (table.$el[0].f7DataTable) {
      const instance = table.$el[0].f7DataTable;
      table.destroy();
      return instance;
    }

    table.$el[0].f7DataTable = table;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(table, {
      collapsible: $el.hasClass('data-table-collapsible'),
      // Headers
      $headerEl: $el.find('.data-table-header'),
      $headerSelectedEl: $el.find('.data-table-header-selected')
    }); // Events

    function handleChange(e) {
      if (e.detail && e.detail.sentByF7DataTable) {
        // Scripted event, don't do anything
        return;
      }

      const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this);
      const checked = $inputEl[0].checked;
      const columnIndex = $inputEl.parents('td,th').index();

      if ($inputEl.parents('thead').length > 0) {
        if (columnIndex === 0) {
          $el.find('tbody tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
        }

        $el.find(`tbody tr td:nth-child(${columnIndex + 1}) input`).prop('checked', checked).trigger('change', {
          sentByF7DataTable: true
        });
        $inputEl.prop('indeterminate', false);
      } else {
        if (columnIndex === 0) {
          $inputEl.parents('tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
        }

        const checkedRows = $el.find(`tbody .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]:checked`).length;
        const totalRows = $el.find('tbody tr').length;
        const $headCheckboxEl = $el.find(`thead .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]`);

        if (!checked) {
          $headCheckboxEl.prop('checked', false);
        } else if (checkedRows === totalRows) {
          $headCheckboxEl.prop('checked', true).trigger('change', {
            sentByF7DataTable: true
          });
        }

        $headCheckboxEl.prop('indeterminate', checkedRows > 0 && checkedRows < totalRows);
      }

      table.checkSelectedHeader();
    }

    function handleSortableClick() {
      const $cellEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this);
      const isActive = $cellEl.hasClass('sortable-cell-active');
      const currentSort = $cellEl.hasClass('sortable-desc') ? 'desc' : 'asc';
      let newSort;

      if (isActive) {
        newSort = currentSort === 'desc' ? 'asc' : 'desc';
        $cellEl.removeClass('sortable-desc sortable-asc').addClass(`sortable-${newSort}`);
      } else {
        $el.find('thead .sortable-cell-active').removeClass('sortable-cell-active');
        $cellEl.addClass('sortable-cell-active');
        newSort = currentSort;
      }

      $cellEl.trigger('datatable:sort', newSort);
      table.emit('local::sort dataTableSort', table, newSort);
    }

    table.attachEvents = function attachEvents() {
      table.$el.on('change', '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find('thead .sortable-cell').on('click', handleSortableClick);
    };

    table.detachEvents = function detachEvents() {
      table.$el.off('change', '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find('thead .sortable-cell').off('click', handleSortableClick);
    }; // Install Modules


    table.useModules(); // Init

    table.init();
    return table;
  }

  setCollapsibleLabels() {
    const table = this;
    if (!table.collapsible) return;
    table.$el.find('tbody td:not(.checkbox-cell)').each(el => {
      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
      const elIndex = $el.index();
      const collapsibleTitle = $el.attr('data-collapsible-title');

      if (!collapsibleTitle && collapsibleTitle !== '') {
        $el.attr('data-collapsible-title', table.$el.find('thead th').eq(elIndex).text());
      }
    });
  }

  checkSelectedHeader() {
    const table = this;

    if (table.$headerEl.length > 0 && table.$headerSelectedEl.length > 0) {
      const checkedItems = table.$el.find('tbody .checkbox-cell input:checked').length;
      table.$el[checkedItems > 0 ? 'addClass' : 'removeClass']('data-table-has-checked');
      table.$headerSelectedEl.find('.data-table-selected-count').text(checkedItems);
    }
  }

  init() {
    const table = this;
    table.attachEvents();
    table.setCollapsibleLabels();
    table.checkSelectedHeader();
  }

  destroy() {
    let table = this;
    table.$el.trigger('datatable:beforedestroy');
    table.emit('local::beforeDestroy dataTableBeforeDestroy', table);
    table.attachEvents();

    if (table.$el[0]) {
      table.$el[0].f7DataTable = null;
      delete table.$el[0].f7DataTable;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(table);
    table = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataTable);

/***/ }),

/***/ "./node_modules/framework7/components/data-table/data-table.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7/components/data-table/data-table.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _data_table_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-table-class.js */ "./node_modules/framework7/components/data-table/data-table-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'dataTable',
  static: {
    DataTable: _data_table_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.dataTable = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.data-table',
      constructor: _data_table_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7DataTable'
    });
  },

  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.data-table-init').each(tableEl => {
        app.dataTable.destroy(tableEl);
      });
    },

    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.data-table-init').each(tableEl => {
        app.dataTable.create({
          el: tableEl
        });
      });
    },

    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.data-table-init').each(tableEl => {
        app.dataTable.destroy(tableEl);
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.data-table-init').each(tableEl => {
        app.dataTable.create({
          el: tableEl
        });
      });
    }

  },
  vnode: {
    'data-table-init': {
      insert(vnode) {
        const app = this;
        const tableEl = vnode.elm;
        app.dataTable.create({
          el: tableEl
        });
      },

      destroy(vnode) {
        const app = this;
        const tableEl = vnode.elm;
        app.dataTable.destroy(tableEl);
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/dialog/dialog-class.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/dialog/dialog-class.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modal/modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");





/** @jsx $jsx */



class Dialog extends _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
      title: app.params.dialog.title,
      text: undefined,
      content: '',
      buttons: [],
      verticalButtons: false,
      onClick: undefined,
      cssClass: undefined,
      destroyOnClose: false,
      on: {}
    }, params);

    if (typeof extendedParams.closeByBackdropClick === 'undefined') {
      extendedParams.closeByBackdropClick = app.params.dialog.closeByBackdropClick;
    }

    if (typeof extendedParams.backdrop === 'undefined') {
      extendedParams.backdrop = app.params.dialog.backdrop;
    } // Extends with open/close Modal methods;


    super(app, extendedParams);
    const dialog = this;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__.getDevice)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const {
      title,
      text,
      content,
      buttons,
      verticalButtons,
      cssClass,
      backdrop
    } = extendedParams;
    dialog.params = extendedParams; // Find Element

    let $el;

    if (!dialog.params.el) {
      const dialogClasses = ['dialog'];
      if (buttons.length === 0) dialogClasses.push('dialog-no-buttons');
      if (buttons.length > 0) dialogClasses.push(`dialog-buttons-${buttons.length}`);
      if (verticalButtons) dialogClasses.push('dialog-buttons-vertical');
      if (cssClass) dialogClasses.push(cssClass);
      let buttonsHTML = '';

      if (buttons.length > 0) {
        buttonsHTML = (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
          class: "dialog-buttons"
        }, buttons.map(button => (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("span", {
          class: `dialog-button${button.bold ? ' dialog-button-bold' : ''}${button.color ? ` color-${button.color}` : ''}${button.cssClass ? ` ${button.cssClass}` : ''}`
        }, button.text)));
      }

      const dialogHtml = (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
        class: dialogClasses.join(' ')
      }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
        class: "dialog-inner"
      }, title && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
        class: "dialog-title"
      }, title), text && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_5__["default"])("div", {
        class: "dialog-text"
      }, text), content), buttonsHTML);
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dialogHtml);
    } else {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dialog.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return dialog.destroy();
    }

    let $backdropEl;

    if (backdrop) {
      $backdropEl = app.$el.children('.dialog-backdrop');

      if ($backdropEl.length === 0) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="dialog-backdrop"></div>');
        app.$el.append($backdropEl);
      }
    } // Assign events


    function buttonOnClick(e) {
      const buttonEl = this;
      const index = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl).index();
      const button = buttons[index];
      if (button.onClick) button.onClick(dialog, e);
      if (dialog.params.onClick) dialog.params.onClick(dialog, index);
      if (button.close !== false) dialog.close();
    }

    let addKeyboardHander;

    function onKeyDown(e) {
      const keyCode = e.keyCode;
      buttons.forEach((button, index) => {
        if (button.keyCodes && button.keyCodes.indexOf(keyCode) >= 0) {
          if (document.activeElement) document.activeElement.blur();
          if (button.onClick) button.onClick(dialog, e);
          if (dialog.params.onClick) dialog.params.onClick(dialog, index);
          if (button.close !== false) dialog.close();
        }
      });
    }

    if (buttons && buttons.length > 0) {
      dialog.on('open', () => {
        $el.find('.dialog-button').each((buttonEl, index) => {
          const button = buttons[index];
          if (button.keyCodes) addKeyboardHander = true;
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl).on('click', buttonOnClick);
        });

        if (addKeyboardHander && !device.ios && !device.android && !device.cordova && !device.capacitor) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('keydown', onKeyDown);
        }
      });
      dialog.on('close', () => {
        $el.find('.dialog-button').each(buttonEl => {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl).off('click', buttonOnClick);
        });

        if (addKeyboardHander && !device.ios && !device.android && !device.cordova && !device.capacitor) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off('keydown', onKeyDown);
        }

        addKeyboardHander = false;
      });
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(dialog, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'dialog',

      setProgress(progress, duration) {
        app.progressbar.set($el.find('.progressbar'), progress, duration);
        return dialog;
      },

      setText(newText) {
        let $textEl = $el.find('.dialog-text');

        if ($textEl.length === 0) {
          $textEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="dialog-text"></div>');

          if (typeof title !== 'undefined') {
            $textEl.insertAfter($el.find('.dialog-title'));
          } else {
            $el.find('.dialog-inner').prepend($textEl);
          }
        }

        $textEl.html(newText);
        dialog.params.text = newText;
        return dialog;
      },

      setTitle(newTitle) {
        let $titleEl = $el.find('.dialog-title');

        if ($titleEl.length === 0) {
          $titleEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="dialog-title"></div>');
          $el.find('.dialog-inner').prepend($titleEl);
        }

        $titleEl.html(newTitle);
        dialog.params.title = newTitle;
        return dialog;
      }

    });

    function handleClick(e) {
      const target = e.target;
      const $target = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target);

      if ($target.closest(dialog.el).length === 0) {
        if (dialog.params.closeByBackdropClick && dialog.backdropEl && dialog.backdropEl === target) {
          dialog.close();
        }
      }
    }

    dialog.on('opened', () => {
      if (dialog.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    dialog.on('close', () => {
      if (dialog.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }
    });
    $el[0].f7Modal = dialog;

    if (dialog.params.destroyOnClose) {
      dialog.once('closed', () => {
        setTimeout(() => {
          dialog.destroy();
        }, 0);
      });
    }

    return dialog;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dialog);

/***/ }),

/***/ "./node_modules/framework7/components/dialog/dialog.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7/components/dialog/dialog.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dialog-class.js */ "./node_modules/framework7/components/dialog/dialog-class.js");
/* harmony import */ var _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/modal-methods.js */ "./node_modules/framework7/shared/modal-methods.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'dialog',
  params: {
    dialog: {
      title: undefined,
      buttonOk: 'OK',
      buttonCancel: 'Cancel',
      usernamePlaceholder: 'Username',
      passwordPlaceholder: 'Password',
      preloaderTitle: 'Loading... ',
      progressTitle: 'Loading... ',
      backdrop: true,
      closeByBackdropClick: false,
      destroyPredefinedDialogs: true,
      keyboardActions: true,
      autoFocus: true
    }
  },
  static: {
    Dialog: _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;

    function defaultDialogTitle() {
      return app.params.dialog.title || app.name;
    }

    const destroyOnClose = app.params.dialog.destroyPredefinedDialogs;
    const keyboardActions = app.params.dialog.keyboardActions;
    const autoFocus = app.params.dialog.autoFocus;
    const autoFocusHandler = autoFocus ? {
      on: {
        opened(dialog) {
          dialog.$el.find('input').eq(0).focus();
        }

      }
    } : {};
    app.dialog = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      app,
      constructor: _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      defaultSelector: '.dialog.modal-in'
    }), {
      // Shortcuts
      alert() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        let [text, title, callbackOk] = args;

        if (args.length === 2 && typeof args[1] === 'function') {
          [text, callbackOk, title] = args;
        }

        return new _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](app, {
          title: typeof title === 'undefined' ? defaultDialogTitle() : title,
          text,
          buttons: [{
            text: app.params.dialog.buttonOk,
            bold: true,
            onClick: callbackOk,
            keyCodes: keyboardActions ? [13, 27] : null
          }],
          destroyOnClose
        }).open();
      },

      prompt() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        let [text, title, callbackOk, callbackCancel, defaultValue] = args;

        if (typeof args[1] === 'function') {
          [text, callbackOk, callbackCancel, defaultValue, title] = args;
        }

        defaultValue = typeof defaultValue === 'undefined' || defaultValue === null ? '' : defaultValue;
        return new _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](app, {
          title: typeof title === 'undefined' ? defaultDialogTitle() : title,
          text,
          content: `<div class="dialog-input-field input"><input type="text" class="dialog-input" value="${defaultValue}"></div>`,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === 'aurora' ? 'gray' : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            keyCodes: keyboardActions ? [13] : null
          }],

          onClick(dialog, index) {
            const inputValue = dialog.$el.find('.dialog-input').val();
            if (index === 0 && callbackCancel) callbackCancel(inputValue);
            if (index === 1 && callbackOk) callbackOk(inputValue);
          },

          destroyOnClose,
          ...autoFocusHandler
        }).open();
      },

      confirm() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        let [text, title, callbackOk, callbackCancel] = args;

        if (typeof args[1] === 'function') {
          [text, callbackOk, callbackCancel, title] = args;
        }

        return new _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](app, {
          title: typeof title === 'undefined' ? defaultDialogTitle() : title,
          text,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            onClick: callbackCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === 'aurora' ? 'gray' : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            onClick: callbackOk,
            keyCodes: keyboardActions ? [13] : null
          }],
          destroyOnClose
        }).open();
      },

      login() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        let [text, title, callbackOk, callbackCancel] = args;

        if (typeof args[1] === 'function') {
          [text, callbackOk, callbackCancel, title] = args;
        }

        return new _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](app, {
          title: typeof title === 'undefined' ? defaultDialogTitle() : title,
          text,
          // prettier-ignore
          content: `
              <div class="dialog-input-field dialog-input-double input">
                <input type="text" name="dialog-username" placeholder="${app.params.dialog.usernamePlaceholder}" class="dialog-input">
              </div>
              <div class="dialog-input-field dialog-input-double input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === 'aurora' ? 'gray' : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            keyCodes: keyboardActions ? [13] : null
          }],

          onClick(dialog, index) {
            const username = dialog.$el.find('[name="dialog-username"]').val();
            const password = dialog.$el.find('[name="dialog-password"]').val();
            if (index === 0 && callbackCancel) callbackCancel(username, password);
            if (index === 1 && callbackOk) callbackOk(username, password);
          },

          destroyOnClose,
          ...autoFocusHandler
        }).open();
      },

      password() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        let [text, title, callbackOk, callbackCancel] = args;

        if (typeof args[1] === 'function') {
          [text, callbackOk, callbackCancel, title] = args;
        }

        return new _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](app, {
          title: typeof title === 'undefined' ? defaultDialogTitle() : title,
          text,
          // prettier-ignore
          content: `
              <div class="dialog-input-field input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === 'aurora' ? 'gray' : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            keyCodes: keyboardActions ? [13] : null
          }],

          onClick(dialog, index) {
            const password = dialog.$el.find('[name="dialog-password"]').val();
            if (index === 0 && callbackCancel) callbackCancel(password);
            if (index === 1 && callbackOk) callbackOk(password);
          },

          destroyOnClose,
          ...autoFocusHandler
        }).open();
      },

      preloader(title, color) {
        const preloaders = {
          iosPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.iosPreloaderContent,
          mdPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.mdPreloaderContent,
          auroraPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.auroraPreloaderContent
        };
        const preloaderInner = preloaders[`${app.theme}PreloaderContent`] || '';
        return new _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](app, {
          title: typeof title === 'undefined' || title === null ? app.params.dialog.preloaderTitle : title,
          // prettier-ignore
          content: `<div class="preloader${color ? ` color-${color}` : ''}">${preloaderInner}</div>`,
          cssClass: 'dialog-preloader',
          destroyOnClose
        }).open();
      },

      progress() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        let [title, progress, color] = args;

        if (args.length === 2) {
          if (typeof args[0] === 'number') {
            [progress, color, title] = args;
          } else if (typeof args[0] === 'string' && typeof args[1] === 'string') {
            [title, color, progress] = args;
          }
        } else if (args.length === 1) {
          if (typeof args[0] === 'number') {
            [progress, title, color] = args;
          }
        }

        const infinite = typeof progress === 'undefined';
        const dialog = new _dialog_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](app, {
          title: typeof title === 'undefined' ? app.params.dialog.progressTitle : title,
          cssClass: 'dialog-progress',
          // prettier-ignore
          content: `
              <div class="progressbar${infinite ? '-infinite' : ''}${color ? ` color-${color}` : ''}">
                ${!infinite ? '<span></span>' : ''}
              </div>
            `,
          destroyOnClose
        });
        if (!infinite) dialog.setProgress(progress);
        return dialog.open();
      }

    });
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/elevation/elevation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/elevation/elevation.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'elevation'
});

/***/ }),

/***/ "./node_modules/framework7/components/fab/fab.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7/components/fab/fab.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const Fab = {
  morphOpen(fabEl, targetEl) {
    const app = this;
    const $fabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fabEl);
    const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(targetEl);
    if ($targetEl.length === 0) return;
    $targetEl.transition(0).addClass('fab-morph-target-visible');
    const target = {
      width: $targetEl[0].offsetWidth,
      height: $targetEl[0].offsetHeight,
      offset: $targetEl.offset(),
      borderRadius: $targetEl.css('border-radius'),
      zIndex: $targetEl.css('z-index')
    };
    const fab = {
      width: $fabEl[0].offsetWidth,
      height: $fabEl[0].offsetHeight,
      offset: $fabEl.offset(),
      translateX: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.getTranslate)($fabEl[0], 'x'),
      translateY: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.getTranslate)($fabEl[0], 'y')
    };
    $fabEl[0].f7FabMorphData = {
      $targetEl,
      target,
      fab
    };
    const diffX = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
    const diffY = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;
    let borderRadius = Math.ceil(parseInt(target.borderRadius, 10) / Math.max(scaleX, scaleY));
    if (borderRadius > 0) borderRadius += 2;

    $fabEl[0].f7FabMorphResizeHandler = function resizeHandler() {
      $fabEl.transition(0).transform('');
      $targetEl.transition(0);
      target.width = $targetEl[0].offsetWidth;
      target.height = $targetEl[0].offsetHeight;
      target.offset = $targetEl.offset();
      fab.offset = $fabEl.offset();
      const diffXNew = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
      const diffYNew = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
      const scaleXNew = target.width / fab.width;
      const scaleYNew = target.height / fab.height;
      $fabEl.transform(`translate3d(${-diffXNew}px, ${-diffYNew}px, 0) scale(${scaleXNew}, ${scaleYNew})`);
    };

    $targetEl.css('opacity', 0).transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl.addClass('fab-opened').css('z-index', target.zIndex - 1).transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $targetEl.transition('');
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextFrame)(() => {
        $targetEl.css('opacity', 1).transform('scale(1,1)');
        $fabEl.transform(`translate3d(${-diffX}px, ${-diffY}px, 0) scale(${scaleX}, ${scaleY})`).css('border-radius', `${borderRadius}px`).css('box-shadow', 'none').css('opacity', '0');
      });
      app.on('resize', $fabEl[0].f7FabMorphResizeHandler);

      if ($targetEl.parents('.page-content').length > 0) {
        $targetEl.parents('.page-content').on('scroll', $fabEl[0].f7FabMorphResizeHandler);
      }
    });
  },

  morphClose(fabEl) {
    const app = this;
    const $fabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fabEl);
    const morphData = $fabEl[0].f7FabMorphData;
    if (!morphData) return;
    const {
      $targetEl,
      target,
      fab
    } = morphData;
    if ($targetEl.length === 0) return;
    const diffX = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
    const diffY = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;
    app.off('resize', $fabEl[0].f7FabMorphResizeHandler);

    if ($targetEl.parents('.page-content').length > 0) {
      $targetEl.parents('.page-content').off('scroll', $fabEl[0].f7FabMorphResizeHandler);
    }

    $targetEl.css('opacity', 0).transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl.transition('').css('box-shadow', '').css('border-radius', '').css('opacity', '1').transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $fabEl.css('z-index', '').removeClass('fab-opened').transform('');
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextFrame)(() => {
        $fabEl.transitionEnd(() => {
          $targetEl.removeClass('fab-morph-target-visible').css('opacity', '').transform('').transition('');
        });
      });
    });
  },

  open(fabEl, targetEl) {
    const app = this;
    const $fabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fabEl).eq(0);
    const $buttonsEl = $fabEl.find('.fab-buttons');
    if (!$fabEl.length) return;
    if ($fabEl.hasClass('fab-opened')) return;
    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;

    if (app.fab.openedEl) {
      if (app.fab.openedEl === $fabEl[0]) return;
      app.fab.close(app.fab.openedEl);
    }

    app.fab.openedEl = $fabEl[0];

    if ($fabEl.hasClass('fab-morph')) {
      app.fab.morphOpen($fabEl, targetEl || $fabEl.attr('data-morph-to'));
    } else {
      $fabEl.addClass('fab-opened');
    }

    $fabEl.siblings('.fab-backdrop').addClass('backdrop-in');
    $fabEl.trigger('fab:open');
  },

  close(fabEl) {
    if (fabEl === void 0) {
      fabEl = '.fab-opened';
    }

    const app = this;
    const $fabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fabEl).eq(0);
    const $buttonsEl = $fabEl.find('.fab-buttons');
    if (!$fabEl.length) return;
    if (!$fabEl.hasClass('fab-opened')) return;
    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;
    app.fab.openedEl = null;

    if ($fabEl.hasClass('fab-morph')) {
      app.fab.morphClose($fabEl);
    } else {
      $fabEl.removeClass('fab-opened');
    }

    $fabEl.siblings('.fab-backdrop').removeClass('backdrop-in');
    $fabEl.trigger('fab:close');
  },

  toggle(fabEl) {
    const app = this;
    const $fabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fabEl);
    if (!$fabEl.hasClass('fab-opened')) app.fab.open(fabEl);else app.fab.close(fabEl);
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'fab',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.bindMethods)(app, {
      fab: {
        openedEl: null,
        ...Fab
      }
    });
  },

  clicks: {
    '.fab > a': function open($clickedEl) {
      const app = this;
      app.fab.toggle($clickedEl.parents('.fab'));
    },
    '.fab-open': function open($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.fab.open(data.fab);
    },
    '.fab-close': function close($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.fab.close(data.fab);
    },
    '.fab-backdrop': function close() {
      const app = this;
      app.fab.close();
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/form/form.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/components/form/form.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


 // Form Data

const FormData = {
  store(form, data) {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    let formId = form;
    const $formEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(form);

    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
      formId = $formEl.attr('id');
    } // Store form data in app.formsData


    app.form.data[`form-${formId}`] = data; // Store form data in local storage also

    window.localStorage[`f7form-${formId}`] = JSON.stringify(data);
  },

  get(form) {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    let formId = form;
    const $formEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(form);

    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
      formId = $formEl.attr('id');
    }

    if (window.localStorage[`f7form-${formId}`]) {
      return JSON.parse(window.localStorage[`f7form-${formId}`]);
    }

    if (app.form.data[`form-${formId}`]) {
      return app.form.data[`form-${formId}`];
    }

    return undefined;
  },

  remove(form) {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    let formId = form;
    const $formEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(form);

    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
      formId = $formEl.attr('id');
    } // Delete form data from app.formsData


    if (app.form.data[`form-${formId}`]) {
      app.form.data[`form-${formId}`] = '';
      delete app.form.data[`form-${formId}`];
    } // Delete form data from local storage also


    if (window.localStorage[`f7form-${formId}`]) {
      window.localStorage[`f7form-${formId}`] = '';
      window.localStorage.removeItem(`f7form-${formId}`);
    }
  }

}; // Form Storage

const FormStorage = {
  init(formEl) {
    const app = this;
    const $formEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(formEl);
    const formId = $formEl.attr('id');
    if (!formId) return;
    const initialData = app.form.getFormData(formId);

    if (initialData) {
      app.form.fillFromData($formEl, initialData);
    }

    function store() {
      const data = app.form.convertToData($formEl);
      if (!data) return;
      app.form.storeFormData(formId, data);
      $formEl.trigger('form:storedata', data);
      app.emit('formStoreData', $formEl[0], data);
    }

    $formEl.on('change submit', store);
  },

  destroy(formEl) {
    const $formEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(formEl);
    $formEl.off('change submit');
  }

}; // Form To/From Data

function formToData(formEl) {
  const app = this;
  const $formEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(formEl).eq(0);
  if ($formEl.length === 0) return undefined; // Form data

  const data = {}; // Skip input types

  const skipTypes = ['submit', 'image', 'button', 'file'];
  const skipNames = [];
  $formEl.find('input, select, textarea').each(inputEl => {
    const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(inputEl);

    if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
      return;
    }

    const name = $inputEl.attr('name');
    const type = $inputEl.attr('type');
    const tag = inputEl.nodeName.toLowerCase();
    if (skipTypes.indexOf(type) >= 0) return;
    if (skipNames.indexOf(name) >= 0 || !name) return;

    if (tag === 'select' && $inputEl.prop('multiple')) {
      skipNames.push(name);
      data[name] = [];
      $formEl.find(`select[name="${name}"] option`).each(el => {
        if (el.selected) data[name].push(el.value);
      });
    } else {
      switch (type) {
        case 'checkbox':
          skipNames.push(name);
          data[name] = [];
          $formEl.find(`input[name="${name}"]`).each(el => {
            if (el.checked) data[name].push(el.value);
          });
          break;

        case 'radio':
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each(el => {
            if (el.checked) data[name] = el.value;
          });
          break;

        default:
          data[name] = $inputEl.val();
          break;
      }
    }
  });
  $formEl.trigger('form:todata', data);
  app.emit('formToData', $formEl[0], data);
  return data;
}

function formFromData(formEl, formData) {
  const app = this;
  const $formEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(formEl).eq(0);
  if (!$formEl.length) return;
  let data = formData;
  const formId = $formEl.attr('id');

  if (!data && formId) {
    data = app.form.getFormData(formId);
  }

  if (!data) return; // Skip input types

  const skipTypes = ['submit', 'image', 'button', 'file'];
  const skipNames = [];
  $formEl.find('input, select, textarea').each(inputEl => {
    const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(inputEl);

    if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
      return;
    }

    const name = $inputEl.attr('name');
    const type = $inputEl.attr('type');
    const tag = inputEl.nodeName.toLowerCase();
    if (typeof data[name] === 'undefined' || data[name] === null) return;
    if (skipTypes.indexOf(type) >= 0) return;
    if (skipNames.indexOf(name) >= 0 || !name) return;

    if (tag === 'select' && $inputEl.prop('multiple')) {
      skipNames.push(name);
      $formEl.find(`select[name="${name}"] option`).each(el => {
        const selectEl = el;
        if (data[name].indexOf(el.value) >= 0) selectEl.selected = true;else selectEl.selected = false;
      });
    } else {
      switch (type) {
        case 'checkbox':
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each(el => {
            const checkboxEl = el;
            if (data[name].indexOf(el.value) >= 0) checkboxEl.checked = true;else checkboxEl.checked = false;
          });
          break;

        case 'radio':
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each(el => {
            const radioEl = el;
            if (data[name] === el.value) radioEl.checked = true;else radioEl.checked = false;
          });
          break;

        default:
          $inputEl.val(data[name]);
          break;
      }
    }

    if (tag === 'select' || tag === 'input' || tag === 'textarea') {
      $inputEl.trigger('change', 'fromdata');
    }
  });
  $formEl.trigger('form:fromdata', data);
  app.emit('formFromData', $formEl[0], data);
}

function initAjaxForm() {
  const app = this;
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

  function onSubmitChange(e, fromData) {
    const $formEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this);
    if (e.type === 'change' && !$formEl.hasClass('form-ajax-submit-onchange')) return;
    if (e.type === 'submit') e.preventDefault();
    if (e.type === 'change' && fromData === 'fromdata') return;
    const method = ($formEl.attr('method') || 'GET').toUpperCase();
    const contentType = $formEl.prop('enctype') || $formEl.attr('enctype');
    const url = $formEl.attr('action');
    if (!url) return;
    let data;

    if (method === 'POST') {
      if (contentType === 'application/x-www-form-urlencoded') {
        data = app.form.convertToData($formEl[0]);
      } else {
        data = new window.FormData($formEl[0]);
      }
    } else {
      data = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.serializeObject)(app.form.convertToData($formEl[0]));
    }

    app.request({
      method,
      url,
      contentType,
      data,

      beforeSend(xhr) {
        $formEl.trigger('formajax:beforesend', {
          data,
          xhr
        });
        app.emit('formAjaxBeforeSend', $formEl[0], data, xhr);
      },

      error(xhr) {
        $formEl.trigger('formajax:error', {
          data,
          xhr
        });
        app.emit('formAjaxError', $formEl[0], data, xhr);
      },

      complete(xhr) {
        $formEl.trigger('formajax:complete', {
          data,
          xhr
        });
        app.emit('formAjaxComplete', $formEl[0], data, xhr);
      },

      success(response, status, xhr) {
        $formEl.trigger('formajax:success', {
          data,
          xhr
        });
        app.emit('formAjaxSuccess', $formEl[0], data, xhr);
      }

    });
  }

  (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('submit change', 'form.form-ajax-submit, form.form-ajax-submit-onchange', onSubmitChange);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'form',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(app, {
      form: {
        data: {},
        storeFormData: FormData.store.bind(app),
        getFormData: FormData.get.bind(app),
        removeFormData: FormData.remove.bind(app),
        convertToData: formToData.bind(app),
        fillFromData: formFromData.bind(app),
        storage: {
          init: FormStorage.init.bind(app),
          destroy: FormStorage.destroy.bind(app)
        }
      }
    });
  },

  on: {
    init() {
      const app = this;
      initAjaxForm.call(app);
    },

    tabBeforeRemove(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl).find('.form-store-data').each(formEl => {
        app.form.storage.destroy(formEl);
      });
    },

    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl).find('.form-store-data').each(formEl => {
        app.form.storage.init(formEl);
      });
    },

    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.form-store-data').each(formEl => {
        app.form.storage.destroy(formEl);
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.form-store-data').each(formEl => {
        app.form.storage.init(formEl);
      });
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/components/grid/grid.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/components/grid/grid.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");




function getElMinSize(dimension, $el) {
  let minSize = $el.css(`min-${dimension}`);

  if (minSize === 'auto' || minSize === 'none') {
    minSize = 0;
  } else if (minSize.indexOf('px') >= 0) {
    minSize = parseFloat(minSize);
  } else if (minSize.indexOf('%') >= 0) {
    minSize = $el.parent()[0][dimension === 'height' ? 'offsetHeight' : 'offsetWidth'] * parseFloat(minSize) / 100;
  }

  return minSize;
}

function getElMaxSize(dimension, $el) {
  let maxSize = $el.css(`max-${dimension}`);

  if (maxSize === 'auto' || maxSize === 'none') {
    maxSize = null;
  } else if (maxSize.indexOf('px') >= 0) {
    maxSize = parseFloat(maxSize);
  } else if (maxSize.indexOf('%') >= 0) {
    maxSize = $el.parent()[0][dimension === 'height' ? 'offsetHeight' : 'offsetWidth'] * parseFloat(maxSize) / 100;
  }

  return maxSize;
}

const Grid = {
  init() {
    const app = this;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let $resizeHandlerEl;
    let $prevResizableEl;
    let $nextResizableEl;
    let prevElSize;
    let prevElMinSize;
    let prevElMaxSize;
    let nextElSize;
    let nextElMinSize;
    let nextElMaxSize;
    let parentSize;
    let itemsInFlow;
    let gapSize;
    let isScrolling;

    function handleTouchStart(e) {
      if (isTouched || isMoved) return;
      $resizeHandlerEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest('.resize-handler');
      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      $prevResizableEl = undefined;
      $nextResizableEl = undefined;
      isScrolling = undefined;
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      const isRow = $resizeHandlerEl.parent('.row').length === 1;
      const sizeProp = isRow ? 'height' : 'width';
      const getSizeProp = isRow ? 'offsetHeight' : 'offsetWidth';

      if (!isMoved) {
        $prevResizableEl = $resizeHandlerEl.parent(isRow ? '.row' : '.col');

        if ($prevResizableEl.length && (!$prevResizableEl.hasClass('resizable') || $prevResizableEl.hasClass('resizable-fixed'))) {
          $prevResizableEl = $prevResizableEl.prevAll('.resizable:not(.resizable-fixed)').eq(0);
        }

        $nextResizableEl = $prevResizableEl.next(isRow ? '.row' : '.col');

        if ($nextResizableEl.length && (!$nextResizableEl.hasClass('resizable') || $nextResizableEl.hasClass('resizable-fixed'))) {
          $nextResizableEl = $nextResizableEl.nextAll('.resizable:not(.resizable-fixed)').eq(0);
        }

        if ($prevResizableEl.length) {
          prevElSize = $prevResizableEl[0][getSizeProp];
          prevElMinSize = getElMinSize(sizeProp, $prevResizableEl);
          prevElMaxSize = getElMaxSize(sizeProp, $prevResizableEl);
          parentSize = $prevResizableEl.parent()[0][getSizeProp];
          itemsInFlow = $prevResizableEl.parent().children(isRow ? '.row' : '[class*="col-"], .col').length;
          gapSize = parseFloat($prevResizableEl.css(isRow ? '--f7-grid-row-gap' : '--f7-grid-gap'));
        }

        if ($nextResizableEl.length) {
          nextElSize = $nextResizableEl[0][getSizeProp];
          nextElMinSize = getElMinSize(sizeProp, $nextResizableEl);
          nextElMaxSize = getElMaxSize(sizeProp, $nextResizableEl);

          if (!$prevResizableEl.length) {
            parentSize = $nextResizableEl.parent()[0][getSizeProp];
            itemsInFlow = $nextResizableEl.parent().children(isRow ? '.row' : '[class*="col-"], .col').length;
            gapSize = parseFloat($nextResizableEl.css(isRow ? '--f7-grid-row-gap' : '--f7-grid-gap'));
          }
        }
      }

      isMoved = true;
      const touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (typeof isScrolling === 'undefined' && !isRow) {
        isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
      }

      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }

      const isAbsolute = $prevResizableEl.hasClass('resizable-absolute') || $nextResizableEl.hasClass('resizable-absolute');
      const resizeNextEl = !isRow || isRow && !isAbsolute;

      if (resizeNextEl && !$nextResizableEl.length || !$prevResizableEl.length) {
        isTouched = false;
        isMoved = false;
        return;
      }

      e.preventDefault();
      let diff = isRow ? touchCurrentY - touchStartY : touchCurrentX - touchStartX;
      let prevElNewSize;
      let nextElNewSize;

      if ($prevResizableEl.length) {
        prevElNewSize = prevElSize + diff;

        if (prevElNewSize < prevElMinSize) {
          prevElNewSize = prevElMinSize;
          diff = prevElNewSize - prevElSize;
        }

        if (prevElMaxSize && prevElNewSize > prevElMaxSize) {
          prevElNewSize = prevElMaxSize;
          diff = prevElNewSize - prevElSize;
        }
      }

      if ($nextResizableEl.length && resizeNextEl) {
        nextElNewSize = nextElSize - diff;

        if (nextElNewSize < nextElMinSize) {
          nextElNewSize = nextElMinSize;
          diff = nextElSize - nextElNewSize;
          prevElNewSize = prevElSize + diff;
        }

        if (nextElMaxSize && nextElNewSize > nextElMaxSize) {
          nextElNewSize = nextElMaxSize;
          diff = nextElSize - nextElNewSize;
          prevElNewSize = prevElSize + diff;
        }
      }

      if (isAbsolute) {
        $prevResizableEl[0].style[sizeProp] = `${prevElNewSize}px`;

        if (resizeNextEl) {
          $nextResizableEl[0].style[sizeProp] = `${nextElNewSize}px`;
        }

        $prevResizableEl.trigger('grid:resize');
        $nextResizableEl.trigger('grid:resize');
        app.emit('gridResize', $prevResizableEl[0]);
        app.emit('gridResize', $nextResizableEl[0]);
        return;
      }

      const gapAddSize = (itemsInFlow - 1) * gapSize / itemsInFlow;
      const gapAddSizeCSS = isRow ? `${itemsInFlow - 1} * var(--f7-grid-row-gap) / ${itemsInFlow}` : '(var(--f7-cols-per-row) - 1) * var(--f7-grid-gap) / var(--f7-cols-per-row)';
      const prevElNewSizeNormalized = prevElNewSize + gapAddSize;
      const nextElNewSizeNormalized = nextElNewSize + gapAddSize;
      $prevResizableEl[0].style[sizeProp] = `calc(${prevElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
      $nextResizableEl[0].style[sizeProp] = `calc(${nextElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
      $prevResizableEl.trigger('grid:resize');
      $nextResizableEl.trigger('grid:resize');
      app.emit('gridResize', $prevResizableEl[0]);
      app.emit('gridResize', $nextResizableEl[0]);
    }

    function handleTouchEnd() {
      if (!isTouched) return;

      if (!isMoved) {
        isTouched = false;
      }

      isTouched = false;
      isMoved = false;
    }

    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on(app.touchEvents.start, '.col > .resize-handler, .row > .resize-handler', handleTouchStart);
    app.on('touchmove', handleTouchMove);
    app.on('touchend', handleTouchEnd);
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'grid',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(app, {
      grid: {
        init: Grid.init.bind(app)
      }
    });
  },

  on: {
    init() {
      const app = this;
      app.grid.init();
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/components/infinite-scroll/infinite-scroll.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/infinite-scroll/infinite-scroll.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const InfiniteScroll = {
  handle(el, e) {
    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    const scrollTop = $el[0].scrollTop;
    const scrollHeight = $el[0].scrollHeight;
    const height = $el[0].offsetHeight;
    let distance = $el[0].getAttribute('data-infinite-distance');
    const virtualListContainer = $el.find('.virtual-list');
    let virtualList;
    const onTop = $el.hasClass('infinite-scroll-top');
    if (!distance) distance = 50;

    if (typeof distance === 'string' && distance.indexOf('%') >= 0) {
      distance = parseInt(distance, 10) / 100 * height;
    }

    if (distance > height) distance = height;

    if (onTop) {
      if (scrollTop < distance) {
        $el.trigger('infinite', e);
        app.emit('infinite', $el[0], e);
      }
    } else if (scrollTop + height >= scrollHeight - distance) {
      if (virtualListContainer.length > 0) {
        virtualList = virtualListContainer.eq(-1)[0].f7VirtualList;

        if (virtualList && !virtualList.reachEnd && !virtualList.params.updatableScroll) {
          return;
        }
      }

      $el.trigger('infinite', e);
      app.emit('infinite', $el[0], e);
    }
  },

  create(el) {
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    const app = this;

    function scrollHandler(e) {
      app.infiniteScroll.handle(this, e);
    }

    $el.each(element => {
      element.f7InfiniteScrollHandler = scrollHandler;
      element.addEventListener('scroll', element.f7InfiniteScrollHandler);
    });
  },

  destroy(el) {
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    $el.each(element => {
      element.removeEventListener('scroll', element.f7InfiniteScrollHandler);
      delete element.f7InfiniteScrollHandler;
    });
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'infiniteScroll',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.bindMethods)(app, {
      infiniteScroll: InfiniteScroll
    });
  },

  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl);
      const $isEls = $tabEl.find('.infinite-scroll-content');
      if ($tabEl.is('.infinite-scroll-content')) $isEls.add($tabEl);
      $isEls.each(el => {
        app.infiniteScroll.create(el);
      });
    },

    tabBeforeRemove(tabEl) {
      const $tabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl);
      const app = this;
      const $isEls = $tabEl.find('.infinite-scroll-content');
      if ($tabEl.is('.infinite-scroll-content')) $isEls.add($tabEl);
      $isEls.each(el => {
        app.infiniteScroll.destroy(el);
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.infinite-scroll-content').each(el => {
        app.infiniteScroll.create(el);
      });
    },

    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.infinite-scroll-content').each(el => {
        app.infiniteScroll.destroy(el);
      });
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/components/input/input.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7/components/input/input.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");




const Input = {
  ignoreTypes: ['checkbox', 'button', 'submit', 'range', 'radio', 'image'],

  createTextareaResizableShadow() {
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const $shadowEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document.createElement('textarea'));
    $shadowEl.addClass('textarea-resizable-shadow');
    $shadowEl.prop({
      disabled: true,
      readonly: true
    });
    Input.textareaResizableShadow = $shadowEl;
  },

  textareaResizableShadow: undefined,

  resizeTextarea(textareaEl) {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const $textareaEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(textareaEl);

    if (!Input.textareaResizableShadow) {
      Input.createTextareaResizableShadow();
    }

    const $shadowEl = Input.textareaResizableShadow;
    if (!$textareaEl.length) return;
    if (!$textareaEl.hasClass('resizable')) return;

    if (Input.textareaResizableShadow.parents().length === 0) {
      app.$el.append($shadowEl);
    }

    const styles = window.getComputedStyle($textareaEl[0]);
    'padding-top padding-bottom padding-left padding-right margin-left margin-right margin-top margin-bottom width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display'.split(' ').forEach(style => {
      let styleValue = styles[style];

      if ('font-size line-height letter-spacing width'.split(' ').indexOf(style) >= 0) {
        styleValue = styleValue.replace(',', '.');
      }

      $shadowEl.css(style, styleValue);
    });
    const currentHeight = $textareaEl[0].clientHeight;
    $shadowEl.val('');
    const initialHeight = $shadowEl[0].scrollHeight;
    $shadowEl.val($textareaEl.val());
    $shadowEl.css('height', 0);
    const scrollHeight = $shadowEl[0].scrollHeight;

    if (currentHeight !== scrollHeight) {
      if (scrollHeight > initialHeight) {
        $textareaEl.css('height', `${scrollHeight}px`);
      } else if (scrollHeight < currentHeight) {
        $textareaEl.css('height', '');
      }

      if (scrollHeight > initialHeight || scrollHeight < currentHeight) {
        $textareaEl.trigger('textarea:resize', {
          initialHeight,
          currentHeight,
          scrollHeight
        });
        app.emit('textareaResize', {
          initialHeight,
          currentHeight,
          scrollHeight
        });
      }
    }
  },

  validate(inputEl) {
    const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(inputEl);
    if (!$inputEl.length) return true;
    const $itemInputEl = $inputEl.parents('.item-input');
    const $inputWrapEl = $inputEl.parents('.input');

    function unsetReadonly() {
      if ($inputEl[0].f7ValidateReadonly) {
        $inputEl[0].readOnly = false;
      }
    }

    function setReadonly() {
      if ($inputEl[0].f7ValidateReadonly) {
        $inputEl[0].readOnly = true;
      }
    }

    unsetReadonly();
    const validity = $inputEl[0].validity;
    const validationMessage = $inputEl.dataset().errorMessage || $inputEl[0].validationMessage || '';

    if (!validity) {
      setReadonly();
      return true;
    }

    if (!validity.valid) {
      let $errorEl = $inputEl.nextAll('.item-input-error-message, .input-error-message');

      if (validationMessage) {
        if ($errorEl.length === 0) {
          $errorEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(`<div class="${$inputWrapEl.length ? 'input-error-message' : 'item-input-error-message'}"></div>`);
          $errorEl.insertAfter($inputEl);
        }

        $errorEl.text(validationMessage);
      }

      if ($errorEl.length > 0) {
        $itemInputEl.addClass('item-input-with-error-message');
        $inputWrapEl.addClass('input-with-error-message');
      }

      $itemInputEl.addClass('item-input-invalid');
      $inputWrapEl.addClass('input-invalid');
      $inputEl.addClass('input-invalid');
      setReadonly();
      return false;
    }

    $itemInputEl.removeClass('item-input-invalid item-input-with-error-message');
    $inputWrapEl.removeClass('input-invalid input-with-error-message');
    $inputEl.removeClass('input-invalid');
    setReadonly();
    return true;
  },

  validateInputs(el) {
    const app = this;
    const validates = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el).find('input, textarea, select').map(inputEl => app.input.validate(inputEl));
    return validates.indexOf(false) < 0;
  },

  focus(inputEl) {
    const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(inputEl);
    const type = $inputEl.attr('type');
    if (Input.ignoreTypes.indexOf(type) >= 0) return;
    $inputEl.parents('.item-input').addClass('item-input-focused');
    $inputEl.parents('.input').addClass('input-focused');
    $inputEl.addClass('input-focused');
  },

  blur(inputEl) {
    const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(inputEl);
    $inputEl.parents('.item-input').removeClass('item-input-focused');
    $inputEl.parents('.input').removeClass('input-focused');
    $inputEl.removeClass('input-focused');
  },

  checkEmptyState(inputEl) {
    const app = this;
    let $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(inputEl);

    if (!$inputEl.is('input, select, textarea, .item-input [contenteditable]')) {
      $inputEl = $inputEl.find('input, select, textarea, .item-input [contenteditable]').eq(0);
    }

    if (!$inputEl.length) return;
    const isContentEditable = $inputEl[0].hasAttribute('contenteditable');
    let value;

    if (isContentEditable) {
      if ($inputEl.find('.text-editor-placeholder').length) value = '';else value = $inputEl.html();
    } else {
      value = $inputEl.val();
    }

    const $itemInputEl = $inputEl.parents('.item-input');
    const $inputWrapEl = $inputEl.parents('.input');

    if (value && typeof value === 'string' && value.trim() !== '' || Array.isArray(value) && value.length > 0) {
      $itemInputEl.addClass('item-input-with-value');
      $inputWrapEl.addClass('input-with-value');
      $inputEl.addClass('input-with-value');
      $inputEl.trigger('input:notempty');
      app.emit('inputNotEmpty', $inputEl[0]);
    } else {
      $itemInputEl.removeClass('item-input-with-value');
      $inputWrapEl.removeClass('input-with-value');
      $inputEl.removeClass('input-with-value');
      $inputEl.trigger('input:empty');
      app.emit('inputEmpty', $inputEl[0]);
    }
  },

  scrollIntoView(inputEl, duration, centered, force) {
    if (duration === void 0) {
      duration = 0;
    }

    const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(inputEl);
    const $scrollableEl = $inputEl.parents('.page-content, .panel, .card-expandable .card-content').eq(0);

    if (!$scrollableEl.length) {
      return false;
    }

    const contentHeight = $scrollableEl[0].offsetHeight;
    const contentScrollTop = $scrollableEl[0].scrollTop;
    const contentPaddingTop = parseInt($scrollableEl.css('padding-top'), 10);
    const contentPaddingBottom = parseInt($scrollableEl.css('padding-bottom'), 10);
    const contentOffsetTop = $scrollableEl.offset().top - contentScrollTop;
    const inputOffsetTop = $inputEl.offset().top - contentOffsetTop;
    const inputHeight = $inputEl[0].offsetHeight;
    const min = inputOffsetTop + contentScrollTop - contentPaddingTop;
    const max = inputOffsetTop + contentScrollTop - contentHeight + contentPaddingBottom + inputHeight;
    const centeredPosition = min + (max - min) / 2;

    if (contentScrollTop > min) {
      $scrollableEl.scrollTop(centered ? centeredPosition : min, duration);
      return true;
    }

    if (contentScrollTop < max) {
      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
      return true;
    }

    if (force) {
      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
    }

    return false;
  },

  init() {
    const app = this;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    Input.createTextareaResizableShadow();

    function onFocus() {
      const inputEl = this;

      if (app.params.input.scrollIntoViewOnFocus) {
        if (device.android) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).once('resize', () => {
            if (document && document.activeElement === inputEl) {
              app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
            }
          });
        } else {
          app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
        }
      }

      app.input.focus(inputEl);
    }

    function onBlur() {
      const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this);
      const tag = $inputEl[0].nodeName.toLowerCase();
      app.input.blur($inputEl);

      if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null || $inputEl.attr('data-validate-on-blur') !== null) {
        app.input.validate($inputEl);
      } // Resize textarea


      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
        if (Input.textareaResizableShadow) Input.textareaResizableShadow.remove();
      }
    }

    function onChange() {
      const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this);
      const type = $inputEl.attr('type');
      const tag = $inputEl[0].nodeName.toLowerCase();
      const isContentEditable = $inputEl[0].hasAttribute('contenteditable');
      if (Input.ignoreTypes.indexOf(type) >= 0) return; // Check Empty State

      app.input.checkEmptyState($inputEl);
      if (isContentEditable) return; // Check validation

      if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
        app.input.validate($inputEl);
      } // Resize textarea


      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
        app.input.resizeTextarea($inputEl);
      }
    }

    function onInvalid(e) {
      const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this);

      if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
        e.preventDefault();
        app.input.validate($inputEl);
      }
    }

    function clearInput() {
      const $clicked = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this);
      const $inputEl = $clicked.siblings('input, textarea').eq(0);
      const previousValue = $inputEl.val();
      $inputEl.val('').trigger('input change').focus().trigger('input:clear', previousValue);
      app.emit('inputClear', previousValue);
    }

    function preventDefault(e) {
      e.preventDefault();
    }

    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('click', '.input-clear-button', clearInput);
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('mousedown', '.input-clear-button', preventDefault);
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('change input', 'input, textarea, select, .item-input [contenteditable]', onChange, true);
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('focus', 'input, textarea, select, .item-input [contenteditable]', onFocus, true);
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('blur', 'input, textarea, select, .item-input [contenteditable]', onBlur, true);
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('invalid', 'input, textarea, select', onInvalid, true);
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'input',
  params: {
    input: {
      scrollIntoViewOnFocus: undefined,
      scrollIntoViewCentered: false,
      scrollIntoViewDuration: 0,
      scrollIntoViewAlways: false
    }
  },

  create() {
    const app = this;

    if (typeof app.params.input.scrollIntoViewOnFocus === 'undefined') {
      app.params.input.scrollIntoViewOnFocus = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)().android;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.bindMethods)(app, {
      input: Input
    });
  },

  on: {
    init() {
      const app = this;
      app.input.init();
    },

    tabMounted(tabEl) {
      const app = this;
      const $tabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl);
      $tabEl.find('.item-input, .input').each(itemInputEl => {
        const $itemInputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(itemInputEl);
        $itemInputEl.find('input, select, textarea, [contenteditable]').each(inputEl => {
          const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $tabEl.find('textarea.resizable').each(textareaEl => {
        app.input.resizeTextarea(textareaEl);
      });
    },

    pageInit(page) {
      const app = this;
      const $pageEl = page.$el;
      $pageEl.find('.item-input, .input').each(itemInputEl => {
        const $itemInputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(itemInputEl);
        $itemInputEl.find('input, select, textarea, [contenteditable]').each(inputEl => {
          const $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $pageEl.find('textarea.resizable').each(textareaEl => {
        app.input.resizeTextarea(textareaEl);
      });
    },

    'panelBreakpoint panelCollapsedBreakpoint panelResize panelOpen panelSwipeOpen resize viewMasterDetailBreakpoint': function onPanelOpen(instance) {
      const app = this;

      if (instance && instance.$el) {
        instance.$el.find('textarea.resizable').each(textareaEl => {
          app.input.resizeTextarea(textareaEl);
        });
      } else {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('textarea.resizable').each(textareaEl => {
          app.input.resizeTextarea(textareaEl);
        });
      }
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/lazy/lazy.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/components/lazy/lazy.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");




const Lazy = {
  destroy(pageEl) {
    const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageEl).closest('.page');
    if (!$pageEl.length) return;

    if ($pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy();
    }
  },

  create(pageEl) {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)();
    const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageEl).closest('.page').eq(0); // Lazy images

    const $lazyLoadImages = $pageEl.find('.lazy');
    if ($lazyLoadImages.length === 0 && !$pageEl.hasClass('lazy')) return; // Placeholder

    const placeholderSrc = app.params.lazy.placeholder;

    if (placeholderSrc !== false) {
      $lazyLoadImages.each(lazyEl => {
        if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(lazyEl).attr('data-src') && !(0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(lazyEl).attr('src')) (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(lazyEl).attr('src', placeholderSrc);
      });
    } // load image


    const imagesSequence = [];
    let imageIsLoading = false;

    function onImageComplete(lazyEl) {
      if (imagesSequence.indexOf(lazyEl) >= 0) {
        imagesSequence.splice(imagesSequence.indexOf(lazyEl), 1);
      }

      imageIsLoading = false;

      if (app.params.lazy.sequential && imagesSequence.length > 0) {
        imageIsLoading = true;
        app.lazy.loadImage(imagesSequence[0], onImageComplete);
      }
    }

    function observerCallback(entries, observer) {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          if (app.params.lazy.sequential && imageIsLoading) {
            if (imagesSequence.indexOf(entry.target) < 0) imagesSequence.push(entry.target);
            return;
          } // Load image


          imageIsLoading = true;
          app.lazy.loadImage(entry.target, onImageComplete); // Detach

          observer.unobserve(entry.target);
        }
      });
    }

    if (app.params.lazy.observer && support.intersectionObserver) {
      let observer = $pageEl[0].f7LazyObserver;

      if (!observer) {
        observer = new window.IntersectionObserver(observerCallback, {
          root: $pageEl[0]
        });
      }

      $lazyLoadImages.each(el => {
        if (el.f7LazyObserverAdded) return;
        el.f7LazyObserverAdded = true;
        observer.observe(el);
      });

      if (!$pageEl[0].f7LazyDestroy) {
        $pageEl[0].f7LazyDestroy = () => {
          observer.disconnect();
          delete $pageEl[0].f7LazyDestroy;
          delete $pageEl[0].f7LazyObserver;
        };
      }

      return;
    }

    function lazyHandler() {
      app.lazy.load($pageEl, lazyEl => {
        if (app.params.lazy.sequential && imageIsLoading) {
          if (imagesSequence.indexOf(lazyEl) < 0) imagesSequence.push(lazyEl);
          return;
        }

        imageIsLoading = true;
        app.lazy.loadImage(lazyEl, onImageComplete);
      });
    }

    function attachEvents() {
      $pageEl[0].f7LazyAttached = true;
      $pageEl.on('lazy', lazyHandler);
      $pageEl.on('scroll', lazyHandler, true);
      $pageEl.find('.tab').on('tab:mounted tab:show', lazyHandler);
      app.on('resize', lazyHandler);
    }

    function detachEvents() {
      $pageEl[0].f7LazyAttached = false;
      delete $pageEl[0].f7LazyAttached;
      $pageEl.off('lazy', lazyHandler);
      $pageEl.off('scroll', lazyHandler, true);
      $pageEl.find('.tab').off('tab:mounted tab:show', lazyHandler);
      app.off('resize', lazyHandler);
    } // Store detach function


    if (!$pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy = detachEvents;
    } // Attach events


    if (!$pageEl[0].f7LazyAttached) {
      attachEvents();
    } // Run loader on page load/init


    lazyHandler();
  },

  isInViewport(lazyEl) {
    const app = this;
    const rect = lazyEl.getBoundingClientRect();
    const threshold = app.params.lazy.threshold || 0;
    return rect.top >= 0 - threshold && rect.left >= 0 - threshold && rect.top <= app.height + threshold && rect.left <= app.width + threshold;
  },

  loadImage(imageEl, callback) {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const $imageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(imageEl);
    const bg = $imageEl.attr('data-background');
    const src = bg || $imageEl.attr('data-src');

    function onLoad() {
      $imageEl.removeClass('lazy').addClass('lazy-loaded');

      if (bg) {
        $imageEl.css('background-image', `url(${src})`);
      } else if (src) {
        $imageEl.attr('src', src);
      }

      if (callback) callback(imageEl);
      $imageEl.trigger('lazy:loaded');
      app.emit('lazyLoaded', $imageEl[0]);
    }

    if (!src) {
      $imageEl.trigger('lazy:load');
      app.emit('lazyLoad', $imageEl[0]);
      onLoad();
      return;
    }

    function onError() {
      $imageEl.removeClass('lazy').addClass('lazy-loaded');

      if (bg) {
        $imageEl.css('background-image', `url(${app.params.lazy.placeholder || ''})`);
      } else {
        $imageEl.attr('src', app.params.lazy.placeholder || '');
      }

      if (callback) callback(imageEl);
      $imageEl.trigger('lazy:error');
      app.emit('lazyError', $imageEl[0]);
    }

    const image = new window.Image();
    image.onload = onLoad;
    image.onerror = onError;
    image.src = src;
    $imageEl.removeAttr('data-src').removeAttr('data-background'); // Add loaded callback and events

    $imageEl.trigger('lazy:load');
    app.emit('lazyLoad', $imageEl[0]);
  },

  load(pageEl, callback) {
    const app = this;
    let $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageEl);
    if (!$pageEl.hasClass('page')) $pageEl = $pageEl.parents('.page').eq(0);

    if ($pageEl.length === 0) {
      return;
    }

    $pageEl.find('.lazy').each(lazyEl => {
      const $lazyEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(lazyEl);

      if ($lazyEl.parents('.tab:not(.tab-active)').length > 0) {
        return;
      }

      if (app.lazy.isInViewport(lazyEl)) {
        if (callback) callback(lazyEl);else app.lazy.loadImage(lazyEl);
      }
    });
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'lazy',
  params: {
    lazy: {
      placeholder: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==',
      threshold: 0,
      sequential: true,
      observer: true
    }
  },

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.bindMethods)(app, {
      lazy: Lazy
    });
  },

  on: {
    pageInit(page) {
      const app = this;

      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
        app.lazy.create(page.$el);
      }
    },

    pageAfterIn(page) {
      const app = this;
      const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)();
      if (app.params.lazy.observer && support.intersectionObserver) return;

      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
        app.lazy.create(page.$el);
      }
    },

    pageBeforeRemove(page) {
      const app = this;

      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
        app.lazy.destroy(page.$el);
      }
    },

    tabMounted(tabEl) {
      const app = this;
      const $tabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl);

      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
        app.lazy.create($tabEl);
      }
    },

    tabBeforeRemove(tabEl) {
      const app = this;
      const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)();
      if (app.params.lazy.observer && support.intersectionObserver) return;
      const $tabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl);

      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
        app.lazy.destroy($tabEl);
      }
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/components/list-index/list-index-class.js":
/*!***************************************************************************!*\
  !*** ./node_modules/framework7/components/list-index/list-index-class.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");





class ListIndex extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const index = this;
    const defaults = {
      el: null,
      // where to render indexes
      listEl: null,
      // list el to generate indexes
      indexes: 'auto',
      // or array of indexes
      iosItemHeight: 14,
      mdItemHeight: 14,
      auroraItemHeight: 14,
      scrollList: true,
      label: false,

      // eslint-disable-next-line
      renderItem(itemContent, itemIndex) {
        return `
          <li>${itemContent}</li>
        `.trim();
      },

      renderSkipPlaceholder() {
        return '<li class="list-index-skip-placeholder"></li>';
      },

      on: {}
    }; // Extend defaults with modules params

    index.useModulesParams(defaults);
    index.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(defaults, params);
    let $el;
    let $listEl;
    let $pageContentEl;
    let $ul;

    if (index.params.el) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(index.params.el);
    } else {
      return index;
    }

    if ($el[0].f7ListIndex) {
      return $el[0].f7ListIndex;
    }

    $ul = $el.find('ul');

    if ($ul.length === 0) {
      $ul = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<ul></ul>');
      $el.append($ul);
    }

    if (index.params.listEl) {
      $listEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(index.params.listEl);
    }

    if (index.params.indexes === 'auto' && !$listEl) {
      return index;
    }

    if ($listEl) {
      $pageContentEl = $listEl.parents('.page-content').eq(0);
    } else {
      $pageContentEl = $el.siblings('.page-content').eq(0);

      if ($pageContentEl.length === 0) {
        $pageContentEl = $el.parents('.page').eq(0).find('.page-content').eq(0);
      }
    }

    $el[0].f7ListIndex = index;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(index, {
      app,
      $el,
      el: $el && $el[0],
      $ul,
      ul: $ul && $ul[0],
      $listEl,
      listEl: $listEl && $listEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl && $pageContentEl[0],
      indexes: params.indexes,
      height: 0,
      skipRate: 0
    }); // Install Modules

    index.useModules(); // Attach events

    function handleResize() {
      const height = {
        index
      };
      index.calcSize();

      if (height !== index.height) {
        index.render();
      }
    }

    function handleClick(e) {
      const $clickedLi = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('li');
      if (!$clickedLi.length) return;
      let itemIndex = $clickedLi.index();

      if (index.skipRate > 0) {
        const percentage = itemIndex / ($clickedLi.siblings('li').length - 1);
        itemIndex = Math.round((index.indexes.length - 1) * percentage);
      }

      const itemContent = index.indexes[itemIndex];
      index.$el.trigger('listindex:click', {
        content: itemContent,
        index: itemIndex
      });
      index.emit('local::click listIndexClick', index, itemContent, itemIndex);
      index.$el.trigger('listindex:select', {
        content: itemContent,
        index: itemIndex
      });
      index.emit('local::select listIndexSelect', index, itemContent, itemIndex);

      if (index.$listEl && index.params.scrollList) {
        index.scrollListToIndex(itemContent, itemIndex);
      }
    }

    const touchesStart = {};
    let isTouched;
    let isMoved;
    let topPoint;
    let bottomPoint;
    let $labelEl;
    let previousIndex = null;

    function handleTouchStart(e) {
      const $children = $ul.children();
      if (!$children.length) return;
      topPoint = $children[0].getBoundingClientRect().top;
      bottomPoint = $children[$children.length - 1].getBoundingClientRect().top + $children[0].offsetHeight;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isMoved = false;
      previousIndex = null;
    }

    function handleTouchMove(e) {
      if (!isTouched) return;

      if (!isMoved && index.params.label) {
        $labelEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<span class="list-index-label"></span>');
        $el.append($labelEl);
      }

      isMoved = true;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      let percentage = (pageY - topPoint) / (bottomPoint - topPoint);
      percentage = Math.min(Math.max(percentage, 0), 1);
      const itemIndex = Math.round((index.indexes.length - 1) * percentage);
      const itemContent = index.indexes[itemIndex];
      const ulHeight = bottomPoint - topPoint;
      const bubbleBottom = (index.height - ulHeight) / 2 + (1 - percentage) * ulHeight;

      if (itemIndex !== previousIndex) {
        if (index.params.label) {
          $labelEl.html(itemContent).transform(`translateY(-${bubbleBottom}px)`);
        }

        if (index.$listEl && index.params.scrollList) {
          index.scrollListToIndex(itemContent, itemIndex);
        }
      }

      previousIndex = itemIndex;
      index.$el.trigger('listindex:select');
      index.emit('local::select listIndexSelect', index, itemContent, itemIndex);
    }

    function handleTouchEnd() {
      if (!isTouched) return;
      isTouched = false;
      isMoved = false;

      if (index.params.label) {
        if ($labelEl) $labelEl.remove();
        $labelEl = undefined;
      }
    }

    const passiveListener = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__.getSupport)().passiveListener ? {
      passive: true
    } : false;

    index.attachEvents = function attachEvents() {
      $el.parents('.tab').on('tab:show', handleResize);
      $el.parents('.page').on('page:reinit', handleResize);
      $el.parents('.panel').on('panel:open', handleResize);
      $el.parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast').on('modal:open', handleResize);
      app.on('resize', handleResize);
      $el.on('click', handleClick);
      $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
    };

    index.detachEvents = function attachEvents() {
      $el.parents('.tab').off('tab:show', handleResize);
      $el.parents('.page').off('page:reinit', handleResize);
      $el.parents('.panel').off('panel:open', handleResize);
      $el.parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast').off('modal:open', handleResize);
      app.off('resize', handleResize);
      $el.off('click', handleClick);
      $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
    }; // Init


    index.init();
    return index;
  } // eslint-disable-next-line


  scrollListToIndex(itemContent, itemIndex) {
    const index = this;
    const {
      $listEl,
      $pageContentEl,
      app
    } = index;
    if (!$listEl || !$pageContentEl || $pageContentEl.length === 0) return index;
    let $scrollToEl;
    $listEl.find('.list-group-title, .item-divider').each(el => {
      if ($scrollToEl) return;
      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);

      if ($el.text() === itemContent) {
        $scrollToEl = $el;
      }
    });
    if (!$scrollToEl || $scrollToEl.length === 0) return index;
    const parentTop = $scrollToEl.parent().offset().top;
    let paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
    const scrollTop = $pageContentEl[0].scrollTop;
    const scrollToElTop = $scrollToEl.offset().top;

    if ($pageContentEl.parents('.page-with-navbar-large').length) {
      const navbarInnerEl = app.navbar.getElByPage($pageContentEl.parents('.page-with-navbar-large').eq(0));
      const $titleLargeEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarInnerEl).find('.title-large');

      if ($titleLargeEl.length) {
        paddingTop -= $titleLargeEl[0].offsetHeight || 0;
      }
    }

    if (parentTop <= paddingTop) {
      $pageContentEl.scrollTop(parentTop + scrollTop - paddingTop);
    } else {
      $pageContentEl.scrollTop(scrollToElTop + scrollTop - paddingTop);
    }

    return index;
  }

  renderSkipPlaceholder() {
    const index = this;
    return index.params.renderSkipPlaceholder.call(index);
  }

  renderItem(itemContent, itemIndex) {
    const index = this;
    return index.params.renderItem.call(index, itemContent, itemIndex);
  }

  render() {
    const index = this;
    const {
      $ul,
      indexes,
      skipRate
    } = index;
    let wasSkipped;
    const html = indexes.map((itemContent, itemIndex) => {
      if (itemIndex % skipRate !== 0 && skipRate > 0) {
        wasSkipped = true;
        return '';
      }

      let itemHtml = index.renderItem(itemContent, itemIndex);

      if (wasSkipped) {
        itemHtml = index.renderSkipPlaceholder() + itemHtml;
      }

      wasSkipped = false;
      return itemHtml;
    }).join('');
    $ul.html(html);
    return index;
  }

  calcSize() {
    const index = this;
    const {
      app,
      params,
      el,
      indexes
    } = index;
    const height = el.offsetHeight;
    const itemHeight = params[`${app.theme}ItemHeight`];
    const maxItems = Math.floor(height / itemHeight);
    const items = indexes.length;
    let skipRate = 0;

    if (items > maxItems) {
      skipRate = Math.ceil((items * 2 - 1) / maxItems);
    }

    index.height = height;
    index.skipRate = skipRate;
    return index;
  }

  calcIndexes() {
    const index = this;

    if (index.params.indexes === 'auto') {
      index.indexes = [];
      index.$listEl.find('.list-group-title, .item-divider').each(el => {
        const elContent = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).text();

        if (index.indexes.indexOf(elContent) < 0) {
          index.indexes.push(elContent);
        }
      });
    } else {
      index.indexes = index.params.indexes;
    }

    return index;
  }

  update() {
    const index = this;
    index.calcIndexes();
    index.calcSize();
    index.render();
    return index;
  }

  init() {
    const index = this;
    index.calcIndexes();
    index.calcSize();
    index.render();
    index.attachEvents();
  }

  destroy() {
    let index = this;
    index.$el.trigger('listindex:beforedestroy', index);
    index.emit('local::beforeDestroy listIndexBeforeDestroy');
    index.detachEvents();

    if (index.$el[0]) {
      index.$el[0].f7ListIndex = null;
      delete index.$el[0].f7ListIndex;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(index);
    index = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListIndex);

/***/ }),

/***/ "./node_modules/framework7/components/list-index/list-index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7/components/list-index/list-index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _list_index_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./list-index-class.js */ "./node_modules/framework7/components/list-index/list-index-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'listIndex',
  static: {
    ListIndex: _list_index_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.listIndex = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.list-index',
      constructor: _list_index_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7ListIndex'
    });
  },

  on: {
    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.list-index-init').each(listIndexEl => {
        const params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(listIndexEl).dataset(), {
          el: listIndexEl
        });
        app.listIndex.create(params);
      });
    },

    tabBeforeRemove(tabEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.list-index-init').each(listIndexEl => {
        if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.list-index-init').each(listIndexEl => {
        const params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(listIndexEl).dataset(), {
          el: listIndexEl
        });
        app.listIndex.create(params);
      });
    },

    pageBeforeRemove(page) {
      page.$el.find('.list-index-init').each(listIndexEl => {
        if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
      });
    }

  },
  vnode: {
    'list-index-init': {
      insert(vnode) {
        const app = this;
        const listIndexEl = vnode.elm;
        const params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(listIndexEl).dataset(), {
          el: listIndexEl
        });
        app.listIndex.create(params);
      },

      destroy(vnode) {
        const listIndexEl = vnode.elm;
        if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/login-screen/login-screen-class.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/login-screen/login-screen-class.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modal/modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");




class LoginScreen extends _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
      on: {}
    }, params); // Extends with open/close Modal methods;

    super(app, extendedParams);
    const loginScreen = this;
    loginScreen.params = extendedParams; // Find Element

    let $el;

    if (!loginScreen.params.el) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(loginScreen.params.content).filter(node => node.nodeType === 1).eq(0);
    } else {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(loginScreen.params.el).eq(0);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return loginScreen.destroy();
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(loginScreen, {
      app,
      $el,
      el: $el[0],
      type: 'loginScreen'
    });
    $el[0].f7Modal = loginScreen;
    return loginScreen;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoginScreen);

/***/ }),

/***/ "./node_modules/framework7/components/login-screen/login-screen.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7/components/login-screen/login-screen.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _login_screen_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./login-screen-class.js */ "./node_modules/framework7/components/login-screen/login-screen-class.js");
/* harmony import */ var _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/modal-methods.js */ "./node_modules/framework7/shared/modal-methods.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'loginScreen',
  static: {
    LoginScreen: _login_screen_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;
    app.loginScreen = (0,_shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
      app,
      constructor: _login_screen_class_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      defaultSelector: '.login-screen.modal-in'
    });
  },

  clicks: {
    '.login-screen-open': function openLoginScreen($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.loginScreen.open(data.loginScreen, data.animate, $clickedEl);
    },
    '.login-screen-close': function closeLoginScreen($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.loginScreen.close(data.loginScreen, data.animate, $clickedEl);
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/menu/menu.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/components/menu/menu.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const Menu = {
  open(el) {
    if (el === void 0) {
      el = '.menu-item-dropdown';
    }

    const app = this;
    if (!el) return;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).closest('.menu-item-dropdown');
    if (!$el.length) return;
    const $menuEl = $el.closest('.menu').eq(0);

    if ($menuEl.length) {
      const zIndex = $menuEl.css('z-index');
      const originalZIndex = $menuEl[0].style.zIndex;
      $menuEl.css('z-index', parseInt(zIndex || 0, 10) + 1);
      $menuEl[0].f7MenuZIndex = originalZIndex;
    }

    $el.eq(0).addClass('menu-item-dropdown-opened').trigger('menu:opened');
    app.emit('menuOpened', $el.eq(0)[0]);
  },

  close(el) {
    if (el === void 0) {
      el = '.menu-item-dropdown-opened';
    }

    const app = this;
    if (!el) return;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).closest('.menu-item-dropdown-opened');
    if (!$el.length) return;
    const $menuEl = $el.closest('.menu').eq(0);

    if ($menuEl.length) {
      const zIndex = $menuEl[0].f7MenuZIndex;
      $menuEl.css('z-index', zIndex);
      delete $menuEl[0].f7MenuZIndex;
    }

    $el.eq(0).removeClass('menu-item-dropdown-opened').trigger('menu:closed');
    app.emit('menuClosed', $el.eq(0)[0]);
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'menu',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.bindMethods)(app, {
      menu: Menu
    });
  },

  on: {
    click(e) {
      const app = this;
      const openedMenus = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.menu-item-dropdown-opened');
      if (!openedMenus.length) return;
      openedMenus.each(el => {
        if (!(0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.menu-item-dropdown-opened').length) {
          app.menu.close(el);
        }
      });
    }

  },
  clicks: {
    '.menu-item-dropdown': function onClick($clickedEl, dataset, e) {
      const app = this;

      if ($clickedEl.hasClass('menu-item-dropdown-opened')) {
        if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.menu-dropdown').length) return;
        app.menu.close($clickedEl);
      } else {
        app.menu.open($clickedEl);
      }
    },
    '.menu-close': function onClick() {
      const app = this;
      app.menu.close();
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/messagebar/messagebar-class.js":
/*!***************************************************************************!*\
  !*** ./node_modules/framework7/components/messagebar/messagebar-class.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");




class Messagebar extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const messagebar = this;
    const defaults = {
      top: false,
      topOffset: 0,
      bottomOffset: 0,
      attachments: [],
      renderAttachments: undefined,
      renderAttachment: undefined,
      maxHeight: null,
      resizePage: true
    }; // Extend defaults with modules params

    messagebar.useModulesParams(defaults);
    messagebar.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(defaults, params); // El

    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messagebar.params.el);
    if ($el.length === 0) return messagebar;
    if ($el[0].f7Messagebar) return $el[0].f7Messagebar;
    $el[0].f7Messagebar = messagebar; // Page and PageContent

    const $pageEl = $el.parents('.page').eq(0);
    const $pageContentEl = $pageEl.find('.page-content').eq(0); // Area

    const $areaEl = $el.find('.messagebar-area'); // Textarea

    let $textareaEl;

    if (messagebar.params.textareaEl) {
      $textareaEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messagebar.params.textareaEl);
    } else {
      $textareaEl = $el.find('textarea');
    } // Attachments & Library


    const $attachmentsEl = $el.find('.messagebar-attachments');
    const $sheetEl = $el.find('.messagebar-sheet');

    if (messagebar.params.top) {
      $el.addClass('messagebar-top');
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(messagebar, {
      $el,
      el: $el[0],
      $areaEl,
      areaEl: $areaEl[0],
      $textareaEl,
      textareaEl: $textareaEl[0],
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0],
      attachmentsVisible: $attachmentsEl.hasClass('messagebar-attachments-visible'),
      $sheetEl,
      sheetEl: $sheetEl[0],
      sheetVisible: $sheetEl.hasClass('messagebar-sheet-visible'),
      $pageEl,
      pageEl: $pageEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl,
      top: $el.hasClass('messagebar-top') || messagebar.params.top,
      attachments: []
    }); // Events

    function onAppResize() {
      if (messagebar.params.resizePage) {
        messagebar.resizePage();
      }
    }

    function onSubmit(e) {
      e.preventDefault();
    }

    function onAttachmentClick(e) {
      const index = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).index();

      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.messagebar-attachment-delete').length) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).trigger('messagebar:attachmentdelete', index);
        messagebar.emit('local::attachmentDelete messagebarAttachmentDelete', messagebar, this, index);
      } else {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).trigger('messagebar:attachmentclick', index);
        messagebar.emit('local::attachmentClick messagebarAttachmentClick', messagebar, this, index);
      }
    }

    function onTextareaChange() {
      messagebar.checkEmptyState();
      messagebar.$el.trigger('messagebar:change');
      messagebar.emit('local::change messagebarChange', messagebar);
    }

    function onTextareaFocus() {
      messagebar.sheetHide();
      messagebar.$el.addClass('messagebar-focused');
      messagebar.$el.trigger('messagebar:focus');
      messagebar.emit('local::focus messagebarFocus', messagebar);
    }

    function onTextareaBlur() {
      messagebar.$el.removeClass('messagebar-focused');
      messagebar.$el.trigger('messagebar:blur');
      messagebar.emit('local::blur messagebarBlur', messagebar);
    }

    messagebar.attachEvents = function attachEvents() {
      $el.on('textarea:resize', onAppResize);
      $el.on('submit', onSubmit);
      $el.on('click', '.messagebar-attachment', onAttachmentClick);
      $textareaEl.on('change input', onTextareaChange);
      $textareaEl.on('focus', onTextareaFocus);
      $textareaEl.on('blur', onTextareaBlur);
      app.on('resize', onAppResize);
    };

    messagebar.detachEvents = function detachEvents() {
      $el.off('textarea:resize', onAppResize);
      $el.off('submit', onSubmit);
      $el.off('click', '.messagebar-attachment', onAttachmentClick);
      $textareaEl.off('change input', onTextareaChange);
      $textareaEl.off('focus', onTextareaFocus);
      $textareaEl.off('blur', onTextareaBlur);
      app.off('resize', onAppResize);
    }; // Install Modules


    messagebar.useModules(); // Init

    messagebar.init();
    return messagebar;
  }

  focus() {
    const messagebar = this;
    messagebar.$textareaEl.focus();
    return messagebar;
  }

  blur() {
    const messagebar = this;
    messagebar.$textareaEl.blur();
    return messagebar;
  }

  clear() {
    const messagebar = this;
    messagebar.$textareaEl.val('').trigger('change');
    return messagebar;
  }

  getValue() {
    const messagebar = this;
    return messagebar.$textareaEl.val().trim();
  }

  setValue(value) {
    const messagebar = this;
    messagebar.$textareaEl.val(value).trigger('change');
    return messagebar;
  }

  setPlaceholder(placeholder) {
    const messagebar = this;
    messagebar.$textareaEl.attr('placeholder', placeholder);
    return messagebar;
  }

  resizePage() {
    const messagebar = this;
    const {
      params,
      $el,
      top,
      $pageEl,
      $pageContentEl,
      $areaEl,
      $textareaEl,
      $sheetEl,
      $attachmentsEl
    } = messagebar;
    const elHeight = $el[0].offsetHeight;
    let maxHeight = params.maxHeight;

    if (top) {
      /*
      Disable at the moment
      const requiredPaddingTop = elHeight + params.topOffset;
      const currentPaddingTop = parseInt($pageContentEl.css('padding-top'), 10);
      if (requiredPaddingTop !== currentPaddingTop) {
        if (!maxHeight) {
          maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css('margin-top'), 10) - parseInt($areaEl.css('margin-bottom'), 10);
        }
        $textareaEl.css('max-height', `${maxHeight}px`);
        $pageContentEl.css('padding-top', `${requiredPaddingTop}px`);
        $el.trigger('messagebar:resizePage');
        messagebar.emit('local::resizepage messagebarResizePage');
      }
      */
    } else {
      const currentPaddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
      const requiredPaddingBottom = elHeight + params.bottomOffset;

      if (requiredPaddingBottom !== currentPaddingBottom && $pageContentEl.length) {
        const currentPaddingTop = parseInt($pageContentEl.css('padding-top'), 10);
        const pageScrollHeight = $pageContentEl[0].scrollHeight;
        const pageOffsetHeight = $pageContentEl[0].offsetHeight;
        const pageScrollTop = $pageContentEl[0].scrollTop;
        const scrollOnBottom = pageScrollTop === pageScrollHeight - pageOffsetHeight;

        if (!maxHeight) {
          maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css('margin-top'), 10) - parseInt($areaEl.css('margin-bottom'), 10);
        }

        $textareaEl.css('max-height', `${maxHeight}px`);
        $pageContentEl.css('padding-bottom', `${requiredPaddingBottom}px`);

        if (scrollOnBottom) {
          $pageContentEl.scrollTop($pageContentEl[0].scrollHeight - pageOffsetHeight);
        }

        $el.trigger('messagebar:resizepage');
        messagebar.emit('local::resizePage messagebarResizePage', messagebar);
      }
    }
  }

  checkEmptyState() {
    const messagebar = this;
    const {
      $el,
      $textareaEl
    } = messagebar;
    const value = $textareaEl.val().trim();

    if (value && value.length) {
      $el.addClass('messagebar-with-value');
    } else {
      $el.removeClass('messagebar-with-value');
    }
  }

  attachmentsCreate(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = '';
    }

    const messagebar = this;
    const $attachmentsEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="messagebar-attachments">${innerHTML}</div>`);
    $attachmentsEl.insertBefore(messagebar.$textareaEl);
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(messagebar, {
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0]
    });
    return messagebar;
  }

  attachmentsShow(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = '';
    }

    const messagebar = this;
    messagebar.$attachmentsEl = messagebar.$el.find('.messagebar-attachments');

    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(innerHTML);
    }

    messagebar.$el.addClass('messagebar-attachments-visible');
    messagebar.attachmentsVisible = true;

    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }

    return messagebar;
  }

  attachmentsHide() {
    const messagebar = this;
    messagebar.$el.removeClass('messagebar-attachments-visible');
    messagebar.attachmentsVisible = false;

    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }

    return messagebar;
  }

  attachmentsToggle() {
    const messagebar = this;

    if (messagebar.attachmentsVisible) {
      messagebar.attachmentsHide();
    } else {
      messagebar.attachmentsShow();
    }

    return messagebar;
  }

  renderAttachment(attachment) {
    const messagebar = this;

    if (messagebar.params.renderAttachment) {
      return messagebar.params.renderAttachment.call(messagebar, attachment);
    }

    return `
      <div class="messagebar-attachment">
        <img src="${attachment}">
        <span class="messagebar-attachment-delete"></span>
      </div>
    `;
  }

  renderAttachments() {
    const messagebar = this;
    let html;

    if (messagebar.params.renderAttachments) {
      html = messagebar.params.renderAttachments.call(messagebar, messagebar.attachments);
    } else {
      html = `${messagebar.attachments.map(attachment => messagebar.renderAttachment(attachment)).join('')}`;
    }

    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(html);
    } else {
      messagebar.$attachmentsEl.html(html);
    }
  }

  sheetCreate(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = '';
    }

    const messagebar = this;
    const $sheetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="messagebar-sheet">${innerHTML}</div>`);
    messagebar.$el.append($sheetEl);
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(messagebar, {
      $sheetEl,
      sheetEl: $sheetEl[0]
    });
    return messagebar;
  }

  sheetShow(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = '';
    }

    const messagebar = this;
    messagebar.$sheetEl = messagebar.$el.find('.messagebar-sheet');

    if (messagebar.$sheetEl.length === 0) {
      messagebar.sheetCreate(innerHTML);
    }

    messagebar.$el.addClass('messagebar-sheet-visible');
    messagebar.sheetVisible = true;

    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }

    return messagebar;
  }

  sheetHide() {
    const messagebar = this;
    messagebar.$el.removeClass('messagebar-sheet-visible');
    messagebar.sheetVisible = false;

    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }

    return messagebar;
  }

  sheetToggle() {
    const messagebar = this;

    if (messagebar.sheetVisible) {
      messagebar.sheetHide();
    } else {
      messagebar.sheetShow();
    }

    return messagebar;
  }

  init() {
    const messagebar = this;
    messagebar.attachEvents();
    messagebar.checkEmptyState();
    return messagebar;
  }

  destroy() {
    const messagebar = this;
    messagebar.emit('local::beforeDestroy messagebarBeforeDestroy', messagebar);
    messagebar.$el.trigger('messagebar:beforedestroy');
    messagebar.detachEvents();

    if (messagebar.$el[0]) {
      messagebar.$el[0].f7Messagebar = null;
      delete messagebar.$el[0].f7Messagebar;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(messagebar);
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Messagebar);

/***/ }),

/***/ "./node_modules/framework7/components/messagebar/messagebar.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7/components/messagebar/messagebar.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _messagebar_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./messagebar-class.js */ "./node_modules/framework7/components/messagebar/messagebar-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'messagebar',
  static: {
    Messagebar: _messagebar_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.messagebar = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.messagebar',
      constructor: _messagebar_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7Messagebar',
      addMethods: 'clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle'.split(' ')
    });
  },

  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.messagebar-init').each(messagebarEl => {
        app.messagebar.destroy(messagebarEl);
      });
    },

    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.messagebar-init').each(messagebarEl => {
        app.messagebar.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
          el: messagebarEl
        }, (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messagebarEl).dataset()));
      });
    },

    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.messagebar-init').each(messagebarEl => {
        app.messagebar.destroy(messagebarEl);
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.messagebar-init').each(messagebarEl => {
        app.messagebar.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
          el: messagebarEl
        }, (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messagebarEl).dataset()));
      });
    }

  },
  vnode: {
    'messagebar-init': {
      insert(vnode) {
        const app = this;
        const messagebarEl = vnode.elm;
        app.messagebar.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
          el: messagebarEl
        }, (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messagebarEl).dataset()));
      },

      destroy(vnode) {
        const app = this;
        const messagebarEl = vnode.elm;
        app.messagebar.destroy(messagebarEl);
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/messages/messages-class.js":
/*!***********************************************************************!*\
  !*** ./node_modules/framework7/components/messages/messages-class.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }




/** @jsx $jsx */



class Messages extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const m = this;
    const defaults = {
      autoLayout: true,
      messages: [],
      newMessagesFirst: false,
      scrollMessages: true,
      scrollMessagesOnEdge: true,
      firstMessageRule: undefined,
      lastMessageRule: undefined,
      tailMessageRule: undefined,
      sameNameMessageRule: undefined,
      sameHeaderMessageRule: undefined,
      sameFooterMessageRule: undefined,
      sameAvatarMessageRule: undefined,
      customClassMessageRule: undefined,
      renderMessage: undefined
    }; // Extend defaults with modules params

    m.useModulesParams(defaults);
    m.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(defaults, params);
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params.el).eq(0);
    if ($el.length === 0) return m;
    if ($el[0].f7Messages) return $el[0].f7Messages;
    $el[0].f7Messages = m;
    const $pageContentEl = $el.closest('.page-content').eq(0);
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(m, {
      messages: m.params.messages,
      $el,
      el: $el[0],
      $pageContentEl,
      pageContentEl: $pageContentEl[0]
    }); // Install Modules

    m.useModules(); // Init

    m.init();
    return m;
  } // eslint-disable-next-line


  getMessageData(messageEl) {
    const $messageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messageEl);
    const data = {
      name: $messageEl.find('.message-name').html(),
      header: $messageEl.find('.message-header').html(),
      textHeader: $messageEl.find('.message-text-header').html(),
      textFooter: $messageEl.find('.message-text-footer').html(),
      footer: $messageEl.find('.message-footer').html(),
      isTitle: $messageEl.hasClass('messages-title'),
      type: $messageEl.hasClass('message-sent') ? 'sent' : 'received',
      text: $messageEl.find('.message-text').html(),
      image: $messageEl.find('.message-image').html(),
      imageSrc: $messageEl.find('.message-image img').attr('src'),
      typing: $messageEl.hasClass('message-typing')
    };

    if (data.isTitle) {
      data.text = $messageEl.html();
    }

    if (data.text && data.textHeader) {
      data.text = data.text.replace(`<div class="message-text-header">${data.textHeader}</div>`, '');
    }

    if (data.text && data.textFooter) {
      data.text = data.text.replace(`<div class="message-text-footer">${data.textFooter}</div>`, '');
    }

    let avatar = $messageEl.find('.message-avatar').css('background-image');
    if (avatar === 'none' || avatar === '') avatar = undefined;

    if (avatar && typeof avatar === 'string') {
      avatar = avatar.replace('url(', '').replace(')', '').replace(/"/g, '').replace(/'/g, '');
    } else {
      avatar = undefined;
    }

    data.avatar = avatar;
    return data;
  }

  getMessagesData() {
    const m = this;
    const data = [];
    m.$el.find('.message, .messages-title').each(messageEl => {
      data.push(m.getMessageData(messageEl));
    });
    return data;
  }

  renderMessage(messageToRender) {
    const m = this;
    const message = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
      type: 'sent',
      attrs: {}
    }, messageToRender);

    if (m.params.renderMessage) {
      return m.params.renderMessage.call(m, message);
    }

    if (message.isTitle) {
      return `<div class="messages-title">${message.text}</div>`;
    }

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", _extends({
      class: `message message-${message.type} ${message.isTyping ? 'message-typing' : ''} ${message.cssClass || ''}`
    }, message.attrs), message.avatar && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-avatar",
      style: `background-image:url(${message.avatar})`
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-content"
    }, message.name && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-name"
    }, message.name), message.header && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-header"
    }, message.header), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-bubble"
    }, message.textHeader && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-text-header"
    }, message.textHeader), message.image && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-image"
    }, message.image), message.imageSrc && !message.image && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-image"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("img", {
      src: message.imageSrc
    })), (message.text || message.isTyping) && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-text"
    }, message.text || '', message.isTyping && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-typing-indicator"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", null), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", null), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", null))), message.textFooter && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-text-footer"
    }, message.textFooter)), message.footer && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "message-footer"
    }, message.footer)));
  }

  renderMessages(messagesToRender, method) {
    if (messagesToRender === void 0) {
      messagesToRender = this.messages;
    }

    if (method === void 0) {
      method = this.params.newMessagesFirst ? 'prepend' : 'append';
    }

    const m = this;
    const html = messagesToRender.map(message => m.renderMessage(message)).join('');
    m.$el[method](html);
  }

  isFirstMessage() {
    const m = this;
    if (m.params.firstMessageRule) return m.params.firstMessageRule(...arguments);
    return false;
  }

  isLastMessage() {
    const m = this;
    if (m.params.lastMessageRule) return m.params.lastMessageRule(...arguments);
    return false;
  }

  isTailMessage() {
    const m = this;
    if (m.params.tailMessageRule) return m.params.tailMessageRule(...arguments);
    return false;
  }

  isSameNameMessage() {
    const m = this;
    if (m.params.sameNameMessageRule) return m.params.sameNameMessageRule(...arguments);
    return false;
  }

  isSameHeaderMessage() {
    const m = this;
    if (m.params.sameHeaderMessageRule) return m.params.sameHeaderMessageRule(...arguments);
    return false;
  }

  isSameFooterMessage() {
    const m = this;
    if (m.params.sameFooterMessageRule) return m.params.sameFooterMessageRule(...arguments);
    return false;
  }

  isSameAvatarMessage() {
    const m = this;
    if (m.params.sameAvatarMessageRule) return m.params.sameAvatarMessageRule(...arguments);
    return false;
  }

  isCustomClassMessage() {
    const m = this;
    if (m.params.customClassMessageRule) return m.params.customClassMessageRule(...arguments);
    return undefined;
  }

  layout() {
    const m = this;
    m.$el.find('.message, .messages-title').each((messageEl, index) => {
      const $messageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messageEl);

      if (!m.messages) {
        m.messages = m.getMessagesData();
      }

      const classes = [];
      const message = m.messages[index];
      const previousMessage = m.messages[index - 1];
      const nextMessage = m.messages[index + 1];

      if (m.isFirstMessage(message, previousMessage, nextMessage)) {
        classes.push('message-first');
      }

      if (m.isLastMessage(message, previousMessage, nextMessage)) {
        classes.push('message-last');
      }

      if (m.isTailMessage(message, previousMessage, nextMessage)) {
        classes.push('message-tail');
      }

      if (m.isSameNameMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-name');
      }

      if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-header');
      }

      if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-footer');
      }

      if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-avatar');
      }

      let customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);

      if (customMessageClasses && customMessageClasses.length) {
        if (typeof customMessageClasses === 'string') {
          customMessageClasses = customMessageClasses.split(' ');
        }

        customMessageClasses.forEach(customClass => {
          classes.push(customClass);
        });
      }

      $messageEl.removeClass('message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar');
      classes.forEach(className => {
        $messageEl.addClass(className);
      });
    });
  }

  clear() {
    const m = this;
    m.messages = [];
    m.$el.html('');
  }

  removeMessage(messageToRemove, layout) {
    if (layout === void 0) {
      layout = true;
    }

    const m = this; // Index or El

    let index;
    let $el;

    if (typeof messageToRemove === 'number') {
      index = messageToRemove;
      $el = m.$el.find('.message, .messages-title').eq(index);
    } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {
      index = m.messages.indexOf(messageToRemove);
      $el = m.$el.children().eq(index);
    } else {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messageToRemove);
      index = $el.index();
    }

    if ($el.length === 0) {
      return m;
    }

    $el.remove();
    m.messages.splice(index, 1);
    if (m.params.autoLayout && layout) m.layout();
    return m;
  }

  removeMessages(messagesToRemove, layout) {
    if (layout === void 0) {
      layout = true;
    }

    const m = this;

    if (Array.isArray(messagesToRemove)) {
      const messagesToRemoveEls = [];
      messagesToRemove.forEach(messageToRemoveIndex => {
        messagesToRemoveEls.push(m.$el.find('.message, .messages-title').eq(messageToRemoveIndex));
      });
      messagesToRemoveEls.forEach(messageToRemove => {
        m.removeMessage(messageToRemove, false);
      });
    } else {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messagesToRemove).each(messageToRemove => {
        m.removeMessage(messageToRemove, false);
      });
    }

    if (m.params.autoLayout && layout) m.layout();
    return m;
  }

  addMessage() {
    const m = this;
    let messageToAdd;
    let animate;
    let method;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (typeof args[1] === 'boolean') {
      [messageToAdd, animate, method] = args;
    } else {
      [messageToAdd, method, animate] = args;
    }

    if (typeof animate === 'undefined') {
      animate = true;
    }

    if (typeof method === 'undefined') {
      method = m.params.newMessagesFirst ? 'prepend' : 'append';
    }

    return m.addMessages([messageToAdd], animate, method);
  }

  setScrollData() {
    const m = this; // Define scroll positions before new messages added

    const scrollHeightBefore = m.pageContentEl.scrollHeight;
    const heightBefore = m.pageContentEl.offsetHeight;
    const scrollBefore = m.pageContentEl.scrollTop;
    m.scrollData = {
      scrollHeightBefore,
      heightBefore,
      scrollBefore
    };
    return {
      scrollHeightBefore,
      heightBefore,
      scrollBefore
    };
  }

  addMessages() {
    const m = this;
    let messagesToAdd;
    let animate;
    let method;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (typeof args[1] === 'boolean') {
      [messagesToAdd, animate, method] = args;
    } else {
      [messagesToAdd, method, animate] = args;
    }

    if (typeof animate === 'undefined') {
      animate = true;
    }

    if (typeof method === 'undefined') {
      method = m.params.newMessagesFirst ? 'prepend' : 'append';
    }

    const {
      scrollHeightBefore,
      scrollBefore
    } = m.setScrollData(); // Add message to DOM and data

    let messagesHTML = '';
    const typingMessage = m.messages.filter(el => el.isTyping)[0];
    messagesToAdd.forEach(messageToAdd => {
      if (typingMessage) {
        if (method === 'append') {
          m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);
        } else {
          m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);
        }
      } else {
        m.messages[method === 'append' ? 'push' : 'unshift'](messageToAdd);
      }

      messagesHTML += m.renderMessage(messageToAdd);
    });
    const $messagesEls = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(messagesHTML);

    if (animate) {
      if (method === 'append' && !m.params.newMessagesFirst) {
        $messagesEls.addClass('message-appear-from-bottom');
      }

      if (method === 'prepend' && m.params.newMessagesFirst) {
        $messagesEls.addClass('message-appear-from-top');
      }
    }

    if (typingMessage) {
      if (method === 'append') {
        $messagesEls.insertBefore(m.$el.find('.message-typing'));
      } else {
        $messagesEls.insertAfter(m.$el.find('.message-typing'));
      }
    } else {
      m.$el[method]($messagesEls);
    } // Layout


    if (m.params.autoLayout) m.layout();

    if (method === 'prepend' && !typingMessage) {
      m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);
    }

    if (m.params.scrollMessages && (method === 'append' && !m.params.newMessagesFirst || method === 'prepend' && m.params.newMessagesFirst && !typingMessage)) {
      m.scrollWithEdgeCheck(animate);
    }

    return m;
  }

  showTyping(message) {
    if (message === void 0) {
      message = {};
    }

    const m = this;
    const typingMessage = m.messages.filter(el => el.isTyping)[0];

    if (typingMessage) {
      m.removeMessage(m.messages.indexOf(typingMessage));
    }

    m.addMessage((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
      type: 'received',
      isTyping: true
    }, message));
    return m;
  }

  hideTyping() {
    const m = this;
    let typingMessageIndex;
    let typingFound;
    m.messages.forEach((message, index) => {
      if (message.isTyping) typingMessageIndex = index;
    });

    if (typeof typingMessageIndex !== 'undefined') {
      if (m.$el.find('.message').eq(typingMessageIndex).hasClass('message-typing')) {
        typingFound = true;
        m.removeMessage(typingMessageIndex);
      }
    }

    if (!typingFound) {
      const $typingMessageEl = m.$el.find('.message-typing');

      if ($typingMessageEl.length) {
        m.removeMessage($typingMessageEl);
      }
    }

    return m;
  }

  scrollWithEdgeCheck(animate) {
    const m = this;
    const {
      scrollBefore,
      scrollHeightBefore,
      heightBefore
    } = m.scrollData;

    if (m.params.scrollMessagesOnEdge) {
      let onEdge = false;

      if (m.params.newMessagesFirst && scrollBefore === 0) {
        onEdge = true;
      }

      if (!m.params.newMessagesFirst && scrollBefore - (scrollHeightBefore - heightBefore) >= -10) {
        onEdge = true;
      }

      if (onEdge) m.scroll(animate ? undefined : 0);
    } else {
      m.scroll(animate ? undefined : 0);
    }
  }

  scroll(duration, scrollTop) {
    if (duration === void 0) {
      duration = 300;
    }

    const m = this;
    const currentScroll = m.pageContentEl.scrollTop;
    let newScrollTop;
    if (typeof scrollTop !== 'undefined') newScrollTop = scrollTop;else {
      newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;
      if (newScrollTop === currentScroll) return m;
    }
    m.$pageContentEl.scrollTop(newScrollTop, duration);
    return m;
  }

  init() {
    const m = this;

    if (!m.messages || m.messages.length === 0) {
      m.messages = m.getMessagesData();
    }

    if (m.params.messages && m.params.messages.length) {
      m.renderMessages();
    }

    if (m.params.autoLayout) m.layout();
    if (m.params.scrollMessages) m.scroll(0);
  }

  destroy() {
    const m = this;
    m.emit('local::beforeDestroy messagesBeforeDestroy', m);
    m.$el.trigger('messages:beforedestroy');

    if (m.$el[0]) {
      m.$el[0].f7Messages = null;
      delete m.$el[0].f7Messages;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(m);
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Messages);

/***/ }),

/***/ "./node_modules/framework7/components/messages/messages.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/messages/messages.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _messages_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./messages-class.js */ "./node_modules/framework7/components/messages/messages-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'messages',
  static: {
    Messages: _messages_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.messages = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.messages',
      constructor: _messages_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7Messages',
      addMethods: 'renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages'.split(' ')
    });
  },

  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.messages-init').each(messagesEl => {
        app.messages.destroy(messagesEl);
      });
    },

    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.messages-init').each(messagesEl => {
        app.messages.create({
          el: messagesEl
        });
      });
    },

    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.messages-init').each(messagesEl => {
        app.messages.destroy(messagesEl);
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.messages-init').each(messagesEl => {
        app.messages.create({
          el: messagesEl
        });
      });
    }

  },
  vnode: {
    'messages-init': {
      insert(vnode) {
        const app = this;
        const messagesEl = vnode.elm;
        app.messages.create({
          el: messagesEl
        });
      },

      destroy(vnode) {
        const app = this;
        const messagesEl = vnode.elm;
        app.messages.destroy(messagesEl);
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/modal/custom-modal-class.js":
/*!************************************************************************!*\
  !*** ./node_modules/framework7/components/modal/custom-modal-class.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _modal_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");




class CustomModal extends _modal_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
      backdrop: true,
      closeByBackdropClick: true,
      on: {}
    }, params); // Extends with open/close Modal methods;

    super(app, extendedParams);
    const customModal = this;
    customModal.params = extendedParams; // Find Element

    let $el;

    if (!customModal.params.el) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(customModal.params.content);
    } else {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(customModal.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return customModal.destroy();
    }

    let $backdropEl;

    if (customModal.params.backdrop) {
      $backdropEl = app.$el.children('.custom-modal-backdrop');

      if ($backdropEl.length === 0) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="custom-modal-backdrop"></div>');
        app.$el.append($backdropEl);
      }
    }

    function handleClick(e) {
      if (!customModal || customModal.destroyed) return;

      if ($backdropEl && e.target === $backdropEl[0]) {
        customModal.close();
      }
    }

    customModal.on('customModalOpened', () => {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app.on('click', handleClick);
      }
    });
    customModal.on('customModalClose', () => {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app.off('click', handleClick);
      }
    });
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(customModal, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'customModal'
    });
    $el[0].f7Modal = customModal;
    return customModal;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CustomModal);

/***/ }),

/***/ "./node_modules/framework7/components/modal/modal-class.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/modal/modal-class.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");




const openedModals = [];
const dialogsQueue = [];

function clearDialogsQueue() {
  if (dialogsQueue.length === 0) return;
  const dialog = dialogsQueue.shift();
  dialog.open();
}

class Modal extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    super(params, [app]);
    const modal = this;
    const defaults = {}; // Extend defaults with modules params

    modal.useModulesParams(defaults);
    modal.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(defaults, params);
    modal.opened = false;
    let $containerEl = modal.params.containerEl ? (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(modal.params.containerEl).eq(0) : app.$el;
    if (!$containerEl.length) $containerEl = app.$el;
    modal.$containerEl = $containerEl;
    modal.containerEl = $containerEl[0]; // Install Modules

    modal.useModules();
    return this;
  }

  onOpen() {
    const modal = this;
    modal.opened = true;
    openedModals.push(modal);
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').addClass(`with-modal-${modal.type.toLowerCase()}`);
    modal.$el.trigger(`modal:open ${modal.type.toLowerCase()}:open`);
    modal.emit(`local::open modalOpen ${modal.type}Open`, modal);
  }

  onOpened() {
    const modal = this;
    modal.$el.trigger(`modal:opened ${modal.type.toLowerCase()}:opened`);
    modal.emit(`local::opened modalOpened ${modal.type}Opened`, modal);
  }

  onClose() {
    const modal = this;
    modal.opened = false;
    if (!modal.type || !modal.$el) return;
    openedModals.splice(openedModals.indexOf(modal), 1);
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').removeClass(`with-modal-${modal.type.toLowerCase()}`);
    modal.$el.trigger(`modal:close ${modal.type.toLowerCase()}:close`);
    modal.emit(`local::close modalClose ${modal.type}Close`, modal);
  }

  onClosed() {
    const modal = this;
    if (!modal.type || !modal.$el) return;
    modal.$el.removeClass('modal-out');
    modal.$el.hide();

    if (modal.params.backdrop && (modal.params.backdropUnique || modal.forceBackdropUnique) && modal.$backdropEl) {
      modal.$backdropEl.remove();
    }

    modal.$el.trigger(`modal:closed ${modal.type.toLowerCase()}:closed`);
    modal.emit(`local::closed modalClosed ${modal.type}Closed`, modal);
  }

  open(animateModal) {
    const modal = this;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const app = modal.app;
    const $el = modal.$el;
    const $backdropEl = modal.$backdropEl;
    const type = modal.type;
    let animate = true;
    if (typeof animateModal !== 'undefined') animate = animateModal;else if (typeof modal.params.animate !== 'undefined') {
      animate = modal.params.animate;
    }

    if (!$el || $el.hasClass('modal-in')) {
      if (animateModal === false && $el[0] && type !== 'dialog') {
        $el[0].style.display = 'block';
      }

      return modal;
    }

    if (type === 'dialog' && app.params.modal.queueDialogs) {
      let pushToQueue;

      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.dialog.modal-in').length > 0) {
        pushToQueue = true;
      } else if (openedModals.length > 0) {
        openedModals.forEach(openedModal => {
          if (openedModal.type === 'dialog') pushToQueue = true;
        });
      }

      if (pushToQueue) {
        dialogsQueue.push(modal);
        return modal;
      }
    }

    const $modalParentEl = $el.parent();
    const wasInDom = $el.parents(document).length > 0;

    if (!$modalParentEl.is(modal.$containerEl)) {
      modal.$containerEl.append($el);
      modal.once(`${type}Closed`, () => {
        if (wasInDom) {
          $modalParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    } // Show Modal


    $el.show();

    if (modal.params.backdrop && (modal.params.backdropUnique || modal.forceBackdropUnique) && modal.$backdropEl) {
      modal.$backdropEl.insertBefore($el);
    }
    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */


    modal._clientLeft = $el[0].clientLeft; // Modal

    function transitionEnd() {
      if ($el.hasClass('modal-out')) {
        modal.onClosed();
      } else if ($el.hasClass('modal-in')) {
        modal.onOpened();
      }
    }

    if (animate) {
      if ($backdropEl) {
        $backdropEl.removeClass('not-animated');
        $backdropEl.addClass('backdrop-in');
      }

      $el.animationEnd(() => {
        transitionEnd();
      });
      $el.transitionEnd(() => {
        transitionEnd();
      });
      $el.removeClass('modal-out not-animated').addClass('modal-in');
      modal.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass('backdrop-in not-animated');
      }

      $el.removeClass('modal-out').addClass('modal-in not-animated');
      modal.onOpen();
      modal.onOpened();
    }

    return modal;
  }

  close(animateModal) {
    const modal = this;
    const $el = modal.$el;
    const $backdropEl = modal.$backdropEl;
    let animate = true;
    if (typeof animateModal !== 'undefined') animate = animateModal;else if (typeof modal.params.animate !== 'undefined') {
      animate = modal.params.animate;
    }

    if (!$el || !$el.hasClass('modal-in')) {
      if (dialogsQueue.indexOf(modal) >= 0) {
        dialogsQueue.splice(dialogsQueue.indexOf(modal), 1);
      }

      return modal;
    } // backdrop


    if ($backdropEl) {
      let needToHideBackdrop = true;

      if (modal.type === 'popup') {
        modal.$el.prevAll('.popup.modal-in').add(modal.$el.nextAll('.popup.modal-in')).each(popupEl => {
          const popupInstance = popupEl.f7Modal;
          if (!popupInstance) return;

          if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === modal.backdropEl) {
            needToHideBackdrop = false;
          }
        });
      }

      if (needToHideBackdrop) {
        $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
        $backdropEl.removeClass('backdrop-in');
      }
    } // Modal


    $el[animate ? 'removeClass' : 'addClass']('not-animated');

    function transitionEnd() {
      if ($el.hasClass('modal-out')) {
        modal.onClosed();
      } else if ($el.hasClass('modal-in')) {
        modal.onOpened();
      }
    }

    if (animate) {
      $el.animationEnd(() => {
        transitionEnd();
      });
      $el.transitionEnd(() => {
        transitionEnd();
      });
      $el.removeClass('modal-in').addClass('modal-out'); // Emit close

      modal.onClose();
    } else {
      $el.addClass('not-animated').removeClass('modal-in').addClass('modal-out'); // Emit close

      modal.onClose();
      modal.onClosed();
    }

    if (modal.type === 'dialog') {
      clearDialogsQueue();
    }

    return modal;
  }

  destroy() {
    const modal = this;
    if (modal.destroyed) return;
    modal.emit(`local::beforeDestroy modalBeforeDestroy ${modal.type}BeforeDestroy`, modal);

    if (modal.$el) {
      modal.$el.trigger(`modal:beforedestroy ${modal.type.toLowerCase()}:beforedestroy`);

      if (modal.$el.length && modal.$el[0].f7Modal) {
        delete modal.$el[0].f7Modal;
      }
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.deleteProps)(modal);
    modal.destroyed = true;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Modal);

/***/ }),

/***/ "./node_modules/framework7/components/modal/modal.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7/components/modal/modal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _modal_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");
/* harmony import */ var _custom_modal_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./custom-modal-class.js */ "./node_modules/framework7/components/modal/custom-modal-class.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'modal',
  static: {
    Modal: _modal_class_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    CustomModal: _custom_modal_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.customModal = {
      create(params) {
        return new _custom_modal_class_js__WEBPACK_IMPORTED_MODULE_1__["default"](app, params);
      }

    };
  },

  params: {
    modal: {
      queueDialogs: true
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/navbar/navbar.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7/components/navbar/navbar.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");



const Navbar = {
  size(el) {
    const app = this;
    let $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);

    if ($el.hasClass('navbars')) {
      $el = $el.children('.navbar').each(navbarEl => {
        app.navbar.size(navbarEl);
      });
      return;
    }

    const $innerEl = $el.children('.navbar-inner');
    if (!$innerEl.length) return;
    const needCenterTitle = $innerEl.hasClass('navbar-inner-centered-title') || app.params.navbar[`${app.theme}CenterTitle`];
    const needLeftTitle = app.theme === 'ios' && !app.params.navbar[`${app.theme}CenterTitle`];
    if (!needCenterTitle && !needLeftTitle) return;

    if ($el.hasClass('stacked') || $el.parents('.stacked').length > 0 || $el.parents('.tab:not(.tab-active)').length > 0 || $el.parents('.popup:not(.modal-in)').length > 0) {
      return;
    }

    if (app.theme !== 'ios' && app.params.navbar[`${app.theme}CenterTitle`]) {
      $innerEl.addClass('navbar-inner-centered-title');
    }

    if (app.theme === 'ios' && !app.params.navbar.iosCenterTitle) {
      $innerEl.addClass('navbar-inner-left-title');
    }

    const $viewEl = $el.parents('.view').eq(0);
    const left = app.rtl ? $innerEl.children('.right') : $innerEl.children('.left');
    const right = app.rtl ? $innerEl.children('.left') : $innerEl.children('.right');
    const title = $innerEl.children('.title');
    const subnavbar = $innerEl.children('.subnavbar');
    const noLeft = left.length === 0;
    const noRight = right.length === 0;
    const leftWidth = noLeft ? 0 : left.outerWidth(true);
    const rightWidth = noRight ? 0 : right.outerWidth(true);
    const titleWidth = title.outerWidth(true);
    const navbarStyles = $innerEl.styles();
    const navbarWidth = $innerEl[0].offsetWidth;
    const navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
    const isPrevious = $el.hasClass('navbar-previous');
    const sliding = $innerEl.hasClass('sliding');
    let router;
    let dynamicNavbar;

    if ($viewEl.length > 0 && $viewEl[0].f7View) {
      router = $viewEl[0].f7View.router;
      dynamicNavbar = router && router.dynamicNavbar;
    }

    let currLeft;
    let diff;

    if (noRight) {
      currLeft = navbarInnerWidth - titleWidth;
    }

    if (noLeft) {
      currLeft = 0;
    }

    if (!noLeft && !noRight) {
      currLeft = (navbarInnerWidth - rightWidth - titleWidth + leftWidth) / 2;
    }

    let requiredLeft = (navbarInnerWidth - titleWidth) / 2;

    if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
      if (requiredLeft < leftWidth) {
        requiredLeft = leftWidth;
      }

      if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
        requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
      }

      diff = requiredLeft - currLeft;
    } else {
      diff = 0;
    } // RTL inverter


    const inverter = app.rtl ? -1 : 1;

    if (dynamicNavbar && app.theme === 'ios') {
      if (title.hasClass('sliding') || title.length > 0 && sliding) {
        let titleLeftOffset = -(currLeft + diff) * inverter;
        const titleRightOffset = (navbarInnerWidth - currLeft - diff - titleWidth) * inverter;

        if (isPrevious) {
          if (router && router.params.iosAnimateNavbarBackIcon) {
            const activeNavbarBackLink = $el.parent().find('.navbar-current').children('.left.sliding').find('.back .icon ~ span');

            if (activeNavbarBackLink.length > 0) {
              titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
            }
          }
        }

        title[0].f7NavbarLeftOffset = titleLeftOffset;
        title[0].f7NavbarRightOffset = titleRightOffset;
      }

      if (!noLeft && (left.hasClass('sliding') || sliding)) {
        if (app.rtl) {
          left[0].f7NavbarLeftOffset = -(navbarInnerWidth - left[0].offsetWidth) / 2 * inverter;
          left[0].f7NavbarRightOffset = leftWidth * inverter;
        } else {
          left[0].f7NavbarLeftOffset = -leftWidth;
          left[0].f7NavbarRightOffset = (navbarInnerWidth - left[0].offsetWidth) / 2;

          if (router && router.params.iosAnimateNavbarBackIcon && left.find('.back .icon').length > 0) {
            if (left.find('.back .icon ~ span').length) {
              const leftOffset = left[0].f7NavbarLeftOffset;
              const rightOffset = left[0].f7NavbarRightOffset;
              left[0].f7NavbarLeftOffset = 0;
              left[0].f7NavbarRightOffset = 0;
              left.find('.back .icon ~ span')[0].f7NavbarLeftOffset = leftOffset;
              left.find('.back .icon ~ span')[0].f7NavbarRightOffset = rightOffset - left.find('.back .icon')[0].offsetWidth;
            }
          }
        }
      }

      if (!noRight && (right.hasClass('sliding') || sliding)) {
        if (app.rtl) {
          right[0].f7NavbarLeftOffset = -rightWidth * inverter;
          right[0].f7NavbarRightOffset = (navbarInnerWidth - right[0].offsetWidth) / 2 * inverter;
        } else {
          right[0].f7NavbarLeftOffset = -(navbarInnerWidth - right[0].offsetWidth) / 2;
          right[0].f7NavbarRightOffset = rightWidth;
        }
      }

      if (subnavbar.length && (subnavbar.hasClass('sliding') || sliding)) {
        subnavbar[0].f7NavbarLeftOffset = app.rtl ? subnavbar[0].offsetWidth : -subnavbar[0].offsetWidth;
        subnavbar[0].f7NavbarRightOffset = -subnavbar[0].f7NavbarLeftOffset;
      }
    } // Center title


    if (needCenterTitle) {
      let titleLeft = diff;
      if (app.rtl && noLeft && noRight && title.length > 0) titleLeft = -titleLeft;
      title.css({
        left: `${titleLeft}px`
      });
    }
  },

  hide(el, animate, hideStatusbar, hideOnlyCurrent) {
    if (animate === void 0) {
      animate = true;
    }

    if (hideStatusbar === void 0) {
      hideStatusbar = false;
    }

    if (hideOnlyCurrent === void 0) {
      hideOnlyCurrent = false;
    }

    const app = this;
    let $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    const isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length && !hideOnlyCurrent;
    if (isDynamic) $el = $el.parents('.navbars');
    if (!$el.length) return;
    if ($el.hasClass('navbar-hidden')) return;
    let className = `navbar-hidden${animate ? ' navbar-transitioning' : ''}`;
    const currentIsLarge = isDynamic ? $el.find('.navbar-current .title-large').length : $el.find('.title-large').length;

    if (currentIsLarge) {
      className += ' navbar-large-hidden';
    }

    if (hideStatusbar) {
      className += ' navbar-hidden-statusbar';
    }

    $el.transitionEnd(() => {
      $el.removeClass('navbar-transitioning');
    });
    $el.addClass(className);

    if (isDynamic) {
      $el.children('.navbar').each(subEl => {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subEl).trigger('navbar:hide');
        app.emit('navbarHide', subEl);
      });
    } else {
      $el.trigger('navbar:hide');
      app.emit('navbarHide', $el[0]);
    }
  },

  show(el, animate, hideOnlyCurrent) {
    if (el === void 0) {
      el = '.navbar-hidden';
    }

    if (animate === void 0) {
      animate = true;
    }

    if (hideOnlyCurrent === void 0) {
      hideOnlyCurrent = false;
    }

    const app = this;
    let $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    const isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length && !hideOnlyCurrent;
    if (isDynamic) $el = $el.parents('.navbars');
    if (!$el.length) return;
    if (!$el.hasClass('navbar-hidden')) return;

    if (animate) {
      $el.addClass('navbar-transitioning');
      $el.transitionEnd(() => {
        $el.removeClass('navbar-transitioning');
      });
    }

    $el.removeClass('navbar-hidden navbar-large-hidden navbar-hidden-statusbar');

    if (isDynamic) {
      $el.children('.navbar').each(subEl => {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subEl).trigger('navbar:show');
        app.emit('navbarShow', subEl);
      });
    } else {
      $el.trigger('navbar:show');
      app.emit('navbarShow', $el[0]);
    }
  },

  getElByPage(page) {
    let $pageEl;
    let $navbarEl;
    let pageData;

    if (page.$navbarEl || page.$el) {
      pageData = page;
      $pageEl = page.$el;
    } else {
      $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(page);
      if ($pageEl.length > 0) pageData = $pageEl[0].f7Page;
    }

    if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
      $navbarEl = pageData.$navbarEl;
    } else if ($pageEl) {
      $navbarEl = $pageEl.children('.navbar');
    }

    if (!$navbarEl || $navbarEl && $navbarEl.length === 0) return undefined;
    return $navbarEl[0];
  },

  getPageByEl(navbarEl) {
    const $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarEl);

    if ($navbarEl.parents('.page').length) {
      return $navbarEl.parents('.page')[0];
    }

    let pageEl;
    $navbarEl.parents('.view').find('.page').each(el => {
      if (el && el.f7Page && el.f7Page.navbarEl && $navbarEl[0] === el.f7Page.navbarEl) {
        pageEl = el;
      }
    });
    return pageEl;
  },

  collapseLargeTitle(navbarEl) {
    const app = this;
    let $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarEl);

    if ($navbarEl.hasClass('navbars')) {
      $navbarEl = $navbarEl.find('.navbar');

      if ($navbarEl.length > 1) {
        $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarEl).find('.navbar-large.navbar-current');
      }

      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }

    const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(app.navbar.getPageByEl($navbarEl));
    $navbarEl.addClass('navbar-large-collapsed');
    $pageEl.eq(0).addClass('page-with-navbar-large-collapsed').trigger('page:navbarlargecollapsed');
    app.emit('pageNavbarLargeCollapsed', $pageEl[0]);
    $navbarEl.trigger('navbar:collapse');
    app.emit('navbarCollapse', $navbarEl[0]);
  },

  expandLargeTitle(navbarEl) {
    const app = this;
    let $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarEl);

    if ($navbarEl.hasClass('navbars')) {
      $navbarEl = $navbarEl.find('.navbar-large');

      if ($navbarEl.length > 1) {
        $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarEl).find('.navbar-large.navbar-current');
      }

      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }

    const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(app.navbar.getPageByEl($navbarEl));
    $navbarEl.removeClass('navbar-large-collapsed');
    $pageEl.eq(0).removeClass('page-with-navbar-large-collapsed').trigger('page:navbarlargeexpanded');
    app.emit('pageNavbarLargeExpanded', $pageEl[0]);
    $navbarEl.trigger('navbar:expand');
    app.emit('navbarExpand', $navbarEl[0]);
  },

  toggleLargeTitle(navbarEl) {
    const app = this;
    let $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarEl);

    if ($navbarEl.hasClass('navbars')) {
      $navbarEl = $navbarEl.find('.navbar-large');

      if ($navbarEl.length > 1) {
        $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarEl).find('.navbar-large.navbar-current');
      }

      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }

    if ($navbarEl.hasClass('navbar-large-collapsed')) {
      app.navbar.expandLargeTitle($navbarEl);
    } else {
      app.navbar.collapseLargeTitle($navbarEl);
    }
  },

  initNavbarOnScroll(pageEl, navbarEl, needHide, needCollapse, needTransparent) {
    const app = this;
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_1__.getSupport)();
    const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(pageEl);
    const $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarEl);
    const $titleLargeEl = $navbarEl.find('.title-large');
    const isLarge = $titleLargeEl.length || $navbarEl.hasClass('.navbar-large');
    let navbarHideHeight = 44;
    const snapPageScrollToLargeTitle = app.params.navbar.snapPageScrollToLargeTitle;
    const snapPageScrollToTransparentNavbar = app.params.navbar.snapPageScrollToTransparentNavbar;
    let previousScrollTop;
    let currentScrollTop;
    let scrollHeight;
    let offsetHeight;
    let reachEnd;
    let action;
    let navbarHidden;
    let navbarCollapsed;
    let navbarTitleLargeHeight;
    let navbarOffsetHeight;

    if (needCollapse || needHide && isLarge) {
      navbarTitleLargeHeight = $navbarEl.css('--f7-navbar-large-title-height');

      if (navbarTitleLargeHeight && navbarTitleLargeHeight.indexOf('px') >= 0) {
        navbarTitleLargeHeight = parseInt(navbarTitleLargeHeight, 10);

        if (Number.isNaN(navbarTitleLargeHeight) && $titleLargeEl.length) {
          navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
        } else if (Number.isNaN(navbarTitleLargeHeight)) {
          if (app.theme === 'ios') navbarTitleLargeHeight = 52;else if (app.theme === 'md') navbarTitleLargeHeight = 48;else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
        }
      } else if ($titleLargeEl.length) {
        navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
      } else {
        // eslint-disable-next-line
        if (app.theme === 'ios') navbarTitleLargeHeight = 52;else if (app.theme === 'md') navbarTitleLargeHeight = 48;else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
      }
    }

    if (needHide && isLarge) {
      navbarHideHeight += navbarTitleLargeHeight;
    }

    let scrollChanged;
    let scrollContent;
    let scrollTimeoutId;
    let touchEndTimeoutId;
    const touchSnapTimeout = 70;
    const desktopSnapTimeout = 300;

    function calcScrollableDistance() {
      $pageEl.find('.page-content').each(pageContentEl => {
        pageContentEl.f7ScrollableDistance = pageContentEl.scrollHeight - pageContentEl.offsetHeight;
      });
    }

    function snapLargeNavbar() {
      const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
      if (inSearchbarExpanded) return;
      if (!scrollContent || currentScrollTop < 0) return;

      if (currentScrollTop >= navbarTitleLargeHeight / 2 && currentScrollTop < navbarTitleLargeHeight) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(scrollContent).scrollTop(navbarTitleLargeHeight, 100);
      } else if (currentScrollTop < navbarTitleLargeHeight) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(scrollContent).scrollTop(0, 200);
      }
    }

    function snapTransparentNavbar() {
      const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
      if (inSearchbarExpanded) return;
      if (!scrollContent || currentScrollTop < 0) return;

      if (currentScrollTop >= navbarOffsetHeight / 2 && currentScrollTop < navbarOffsetHeight) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(scrollContent).scrollTop(navbarOffsetHeight, 100);
      } else if (currentScrollTop < navbarOffsetHeight) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(scrollContent).scrollTop(0, 200);
      }
    }

    function handleNavbarTransparent() {
      const isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
      const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
      if (inSearchbarExpanded || isHidden) return;

      if (!navbarOffsetHeight) {
        navbarOffsetHeight = navbarEl.offsetHeight;
      }

      let opacity = currentScrollTop / navbarOffsetHeight;
      const notTransparent = $navbarEl.hasClass('navbar-transparent-visible');
      opacity = Math.max(Math.min(opacity, 1), 0);

      if (notTransparent && opacity === 1 || !notTransparent && opacity === 0) {
        $navbarEl.find('.navbar-bg, .title').css('opacity', '');
        return;
      }

      if (notTransparent && opacity === 0) {
        $navbarEl.trigger('navbar:transparenthide');
        app.emit('navbarTransparentHide', $navbarEl[0]);
        $navbarEl.removeClass('navbar-transparent-visible');
        $navbarEl.find('.navbar-bg, .title').css('opacity', '');
        return;
      }

      if (!notTransparent && opacity === 1) {
        $navbarEl.trigger('navbar:transparentshow');
        app.emit('navbarTransparentShow', $navbarEl[0]);
        $navbarEl.addClass('navbar-transparent-visible');
        $navbarEl.find('.navbar-bg, .title').css('opacity', '');
        return;
      }

      $navbarEl.find('.navbar-bg, .title').css('opacity', opacity);

      if (snapPageScrollToTransparentNavbar) {
        if (!support.touch) {
          clearTimeout(scrollTimeoutId);
          scrollTimeoutId = setTimeout(() => {
            snapTransparentNavbar();
          }, desktopSnapTimeout);
        } else if (touchEndTimeoutId) {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(() => {
            snapTransparentNavbar();
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
          }, touchSnapTimeout);
        }
      }
    }

    let previousCollapseProgress = null;
    let collapseProgress = null;

    function handleLargeNavbarCollapse(pageContentEl) {
      const isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
      if (isHidden) return;
      const isLargeTransparent = $navbarEl.hasClass('navbar-large-transparent') || $navbarEl.hasClass('navbar-large') && $navbarEl.hasClass('navbar-transparent');
      previousCollapseProgress = collapseProgress;
      const scrollableDistance = Math.min(navbarTitleLargeHeight, pageContentEl.f7ScrollableDistance || navbarTitleLargeHeight);
      collapseProgress = Math.min(Math.max(currentScrollTop / scrollableDistance, 0), 1);
      const previousCollapseWasInMiddle = previousCollapseProgress > 0 && previousCollapseProgress < 1;
      const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
      if (inSearchbarExpanded) return;
      navbarCollapsed = $navbarEl.hasClass('navbar-large-collapsed');

      if (collapseProgress === 0 && navbarCollapsed) {
        app.navbar.expandLargeTitle($navbarEl[0]);
      } else if (collapseProgress === 1 && !navbarCollapsed) {
        app.navbar.collapseLargeTitle($navbarEl[0]);
      }

      if (collapseProgress === 0 && navbarCollapsed || collapseProgress === 0 && previousCollapseWasInMiddle || collapseProgress === 1 && !navbarCollapsed || collapseProgress === 1 && previousCollapseWasInMiddle) {
        if (app.theme === 'md') {
          $navbarEl.find('.navbar-inner').css('overflow', '');
        }

        $navbarEl.find('.title').css('opacity', '');
        $navbarEl.find('.title-large-text, .subnavbar').css('transform', '');

        if (isLargeTransparent) {
          $navbarEl.find('.navbar-bg').css('opacity', '');
        } else {
          $navbarEl.find('.navbar-bg').css('transform', '');
        }
      } else if (collapseProgress > 0 && collapseProgress < 1) {
        if (app.theme === 'md') {
          $navbarEl.find('.navbar-inner').css('overflow', 'visible');
        }

        $navbarEl.find('.title').css('opacity', collapseProgress);
        $navbarEl.find('.title-large-text, .subnavbar').css('transform', `translate3d(0px, ${-1 * collapseProgress * navbarTitleLargeHeight}px, 0)`);

        if (isLargeTransparent) {
          $navbarEl.find('.navbar-bg').css('opacity', collapseProgress);
        } else {
          $navbarEl.find('.navbar-bg').css('transform', `translate3d(0px, ${-1 * collapseProgress * navbarTitleLargeHeight}px, 0)`);
        }
      }

      if (snapPageScrollToLargeTitle) {
        if (!support.touch) {
          clearTimeout(scrollTimeoutId);
          scrollTimeoutId = setTimeout(() => {
            snapLargeNavbar();
          }, desktopSnapTimeout);
        } else if (touchEndTimeoutId) {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(() => {
            snapLargeNavbar();
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
          }, touchSnapTimeout);
        }
      }
    }

    function handleTitleHideShow() {
      if ($pageEl.hasClass('page-with-card-opened')) return;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      navbarHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');

      if (reachEnd) {
        if (app.params.navbar.showOnPageScrollEnd) {
          action = 'show';
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app.params.navbar.showOnPageScrollTop || currentScrollTop <= navbarHideHeight) {
          action = 'show';
        } else {
          action = 'hide';
        }
      } else if (currentScrollTop > navbarHideHeight) {
        action = 'hide';
      } else {
        action = 'show';
      }

      if (action === 'show' && navbarHidden) {
        app.navbar.show($navbarEl, true, true);
        navbarHidden = false;
      } else if (action === 'hide' && !navbarHidden) {
        app.navbar.hide($navbarEl, true, false, true);
        navbarHidden = true;
      }

      previousScrollTop = currentScrollTop;
    }

    function handleScroll(e) {
      scrollContent = this;

      if (e && e.target && e.target !== scrollContent) {
        return;
      }

      currentScrollTop = scrollContent.scrollTop;
      scrollChanged = currentScrollTop;

      if (needCollapse) {
        handleLargeNavbarCollapse(scrollContent);
      } else if (needTransparent) {
        handleNavbarTransparent();
      }

      if ($pageEl.hasClass('page-previous')) return;

      if (needHide) {
        handleTitleHideShow();
      }
    }

    function handeTouchStart() {
      scrollChanged = false;
    }

    function handleTouchEnd() {
      clearTimeout(touchEndTimeoutId);
      touchEndTimeoutId = null;
      touchEndTimeoutId = setTimeout(() => {
        if (scrollChanged !== false) {
          if (needTransparent && !needCollapse) {
            snapTransparentNavbar();
          } else {
            snapLargeNavbar();
          }

          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
        }
      }, touchSnapTimeout);
    }

    $pageEl.on('scroll', '.page-content', handleScroll, true);

    if (support.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
      app.on('touchstart:passive', handeTouchStart);
      app.on('touchend:passive', handleTouchEnd);
    }

    calcScrollableDistance();

    if (needCollapse || needTransparent) {
      $pageEl.find('.page-content').each(pageContentEl => {
        if (pageContentEl.scrollTop > 0) handleScroll.call(pageContentEl);
      });
    }

    app.on('resize', calcScrollableDistance);

    $pageEl[0].f7DetachNavbarScrollHandlers = function f7DetachNavbarScrollHandlers() {
      app.off('resize', calcScrollableDistance);
      delete $pageEl[0].f7DetachNavbarScrollHandlers;
      $pageEl.off('scroll', '.page-content', handleScroll, true);

      if (support.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
        app.off('touchstart:passive', handeTouchStart);
        app.off('touchend:passive', handleTouchEnd);
      }
    };
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'navbar',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.bindMethods)(app, {
      navbar: Navbar
    });
  },

  params: {
    navbar: {
      scrollTopOnTitleClick: true,
      iosCenterTitle: true,
      mdCenterTitle: false,
      auroraCenterTitle: true,
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true,
      collapseLargeTitleOnScroll: true,
      snapPageScrollToLargeTitle: true,
      snapPageScrollToTransparentNavbar: true
    }
  },
  on: {
    'panelBreakpoint panelCollapsedBreakpoint panelResize viewResize resize viewMasterDetailBreakpoint': function onPanelResize() {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.navbar').each(navbarEl => {
        app.navbar.size(navbarEl);
      });
    },

    pageBeforeRemove(page) {
      if (page.$el[0].f7DetachNavbarScrollHandlers) {
        page.$el[0].f7DetachNavbarScrollHandlers();
      }
    },

    pageBeforeIn(page) {
      const app = this;
      if (app.theme !== 'ios') return;
      let $navbarsEl;
      const view = page.$el.parents('.view')[0].f7View;
      const navbarEl = app.navbar.getElByPage(page);

      if (!navbarEl) {
        $navbarsEl = page.$el.parents('.view').children('.navbars');
      } else {
        $navbarsEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navbarEl).parents('.navbars');
      }

      if (page.$el.hasClass('no-navbar') || view.router.dynamicNavbar && !navbarEl) {
        const animate = !!(page.pageFrom && page.router.history.length > 0);
        app.navbar.hide($navbarsEl, animate);
      } else {
        app.navbar.show($navbarsEl);
      }
    },

    pageReinit(page) {
      const app = this;
      const $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(app.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0) return;
      app.navbar.size($navbarEl);
    },

    pageInit(page) {
      const app = this;
      const $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(app.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0) return; // Size

      app.navbar.size($navbarEl); // Need Collapse On Scroll

      let needCollapseOnScrollHandler;

      if ($navbarEl.find('.title-large').length > 0) {
        $navbarEl.addClass('navbar-large');
      }

      if ($navbarEl.hasClass('navbar-large')) {
        if (app.params.navbar.collapseLargeTitleOnScroll) needCollapseOnScrollHandler = true;
        page.$el.addClass('page-with-navbar-large');
      } // Need transparent on scroll


      let needTransparentOnScroll;

      if (!needCollapseOnScrollHandler && $navbarEl.hasClass('navbar-transparent')) {
        needTransparentOnScroll = true;
      } // Need Hide On Scroll


      let needHideOnScrollHandler;

      if (app.params.navbar.hideOnPageScroll || page.$el.find('.hide-navbar-on-scroll').length || page.$el.hasClass('hide-navbar-on-scroll') || page.$el.find('.hide-bars-on-scroll').length || page.$el.hasClass('hide-bars-on-scroll')) {
        if (page.$el.find('.keep-navbar-on-scroll').length || page.$el.hasClass('keep-navbar-on-scroll') || page.$el.find('.keep-bars-on-scroll').length || page.$el.hasClass('keep-bars-on-scroll')) {
          needHideOnScrollHandler = false;
        } else {
          needHideOnScrollHandler = true;
        }
      }

      if (needCollapseOnScrollHandler || needHideOnScrollHandler || needTransparentOnScroll) {
        app.navbar.initNavbarOnScroll(page.el, $navbarEl[0], needHideOnScrollHandler, needCollapseOnScrollHandler, needTransparentOnScroll);
      }
    },

    'panelOpen panelSwipeOpen modalOpen': function onPanelModalOpen(instance) {
      const app = this;
      instance.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each(navbarEl => {
        app.navbar.size(navbarEl);
      });
    },

    tabShow(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.navbar:not(.navbar-previous):not(.stacked)').each(navbarEl => {
        app.navbar.size(navbarEl);
      });
    }

  },
  clicks: {
    '.navbar .title': function onTitleClick($clickedEl, clickedData, e) {
      const app = this;
      if (!app.params.navbar.scrollTopOnTitleClick) return;

      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('a, button').length > 0) {
        return;
      }

      let $pageContentEl; // Find active page

      const $navbarEl = $clickedEl.parents('.navbar');
      const $navbarsEl = $navbarEl.parents('.navbars'); // Static Layout

      $pageContentEl = $navbarEl.parents('.page-content');

      if ($pageContentEl.length === 0) {
        // Fixed Layout
        if ($navbarEl.parents('.page').length > 0) {
          $pageContentEl = $navbarEl.parents('.page').find('.page-content');
        } // Through Layout iOS


        if ($pageContentEl.length === 0 && $navbarsEl.length) {
          if ($navbarsEl.nextAll('.page-current:not(.stacked)').length > 0) {
            $pageContentEl = $navbarsEl.nextAll('.page-current:not(.stacked)').find('.page-content');
          }
        } // Through Layout


        if ($pageContentEl.length === 0) {
          if ($navbarEl.nextAll('.page-current:not(.stacked)').length > 0) {
            $pageContentEl = $navbarEl.nextAll('.page-current:not(.stacked)').find('.page-content');
          }
        }
      }

      if ($pageContentEl && $pageContentEl.length > 0) {
        // Check for tab
        if ($pageContentEl.hasClass('tab')) {
          $pageContentEl = $pageContentEl.parent('.tabs').children('.page-content.tab-active');
        }

        if ($pageContentEl.length > 0) $pageContentEl.scrollTop(0, 300);
      }
    }
  },
  vnode: {
    navbar: {
      postpatch(vnode) {
        const app = this;
        app.navbar.size(vnode.elm);
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/notification/notification-class.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/notification/notification-class.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modal/modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");



/** @jsx $jsx */



class Notification extends _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
      on: {}
    }, app.params.notification, params); // Extends with open/close Modal methods;

    super(app, extendedParams);
    const notification = this;
    notification.app = app;
    notification.params = extendedParams;
    const {
      icon,
      title,
      titleRightText,
      subtitle,
      text,
      closeButton,
      closeTimeout,
      cssClass,
      closeOnClick
    } = notification.params;
    let $el;

    if (!notification.params.el) {
      // Find Element
      const notificationHtml = notification.render({
        icon,
        title,
        titleRightText,
        subtitle,
        text,
        closeButton,
        cssClass
      });
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(notificationHtml);
    } else {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(notification.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return notification.destroy();
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(notification, {
      $el,
      el: $el[0],
      type: 'notification'
    });
    $el[0].f7Modal = notification;

    if (closeButton) {
      $el.find('.notification-close-button').on('click', () => {
        notification.close();
      });
    }

    $el.on('click', e => {
      if (closeButton && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.notification-close-button').length) {
        return;
      }

      notification.emit('local::click notificationClick', notification);
      if (closeOnClick) notification.close();
    });
    notification.on('beforeDestroy', () => {
      $el.off('click');
    });
    /* Touch Events */

    let isTouched;
    let isMoved;
    let isScrolling;
    let touchesDiff;
    let touchStartTime;
    let notificationHeight;
    const touchesStart = {};

    function handleTouchStart(e) {
      if (isTouched) return;
      isTouched = true;
      isMoved = false;
      isScrolling = undefined;
      touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)();
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) < Math.abs(pageX - touchesStart.x));
      }

      if (isScrolling) {
        isTouched = false;
        return;
      }

      e.preventDefault();

      if (!isMoved) {
        notification.$el.removeClass('notification-transitioning');
        notification.$el.transition(0);
        notificationHeight = notification.$el[0].offsetHeight / 2;
      }

      isMoved = true;
      touchesDiff = pageY - touchesStart.y;
      let newTranslate = touchesDiff;

      if (touchesDiff > 0) {
        newTranslate = touchesDiff ** 0.8;
      }

      notification.$el.transform(`translate3d(0, ${newTranslate}px, 0)`);
    }

    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }

      isTouched = false;
      isMoved = false;

      if (touchesDiff === 0) {
        return;
      }

      const timeDiff = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)() - touchStartTime;
      notification.$el.transition('');
      notification.$el.addClass('notification-transitioning');
      notification.$el.transform('');

      if (touchesDiff < -10 && timeDiff < 300 || -touchesDiff >= notificationHeight / 1) {
        notification.close();
      }
    }

    function attachTouchEvents() {
      notification.$el.on(app.touchEvents.start, handleTouchStart, {
        passive: true
      });
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
    }

    function detachTouchEvents() {
      notification.$el.off(app.touchEvents.start, handleTouchStart, {
        passive: true
      });
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
    }

    let timeoutId;

    function closeOnTimeout() {
      timeoutId = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
        if (isTouched && isMoved) {
          closeOnTimeout();
          return;
        }

        notification.close();
      }, closeTimeout);
    }

    notification.on('open', () => {
      if (notification.params.swipeToClose) {
        attachTouchEvents();
      }

      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.notification.modal-in').each(openedEl => {
        const notificationInstance = app.notification.get(openedEl);

        if (openedEl !== notification.el && notificationInstance) {
          notificationInstance.close();
        }
      });

      if (closeTimeout) {
        closeOnTimeout();
      }
    });
    notification.on('close beforeDestroy', () => {
      if (notification.params.swipeToClose) {
        detachTouchEvents();
      }

      clearTimeout(timeoutId);
    });
    return notification;
  }

  render() {
    const notification = this;
    if (notification.params.render) return notification.params.render.call(notification, notification);
    const {
      icon,
      title,
      titleRightText,
      subtitle,
      text,
      closeButton,
      cssClass
    } = notification.params;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `notification ${cssClass || ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "notification-header"
    }, icon && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "notification-icon"
    }, icon), title && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "notification-title"
    }, title), titleRightText && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "notification-title-right-text"
    }, titleRightText), closeButton && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("span", {
      class: "notification-close-button"
    })), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "notification-content"
    }, subtitle && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "notification-subtitle"
    }, subtitle), text && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "notification-text"
    }, text)));
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Notification);

/***/ }),

/***/ "./node_modules/framework7/components/notification/notification.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7/components/notification/notification.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _notification_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./notification-class.js */ "./node_modules/framework7/components/notification/notification-class.js");
/* harmony import */ var _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/modal-methods.js */ "./node_modules/framework7/shared/modal-methods.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'notification',
  static: {
    Notification: _notification_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;
    app.notification = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, (0,_shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      app,
      constructor: _notification_class_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      defaultSelector: '.notification.modal-in'
    }));
  },

  params: {
    notification: {
      icon: null,
      title: null,
      titleRightText: null,
      subtitle: null,
      text: null,
      closeButton: false,
      closeTimeout: null,
      closeOnClick: false,
      swipeToClose: true,
      cssClass: null,
      render: null,
      containerEl: null
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/panel/panel-class.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/panel/panel-class.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _swipe_panel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./swipe-panel.js */ "./node_modules/framework7/components/panel/swipe-panel.js");
/* harmony import */ var _resizable_panel_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resizable-panel.js */ "./node_modules/framework7/components/panel/resizable-panel.js");







class Panel extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
      on: {}
    }, app.params.panel, params);
    super(extendedParams, [app]);
    const panel = this;
    panel.params = extendedParams;
    panel.$containerEl = panel.params.containerEl ? (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(panel.params.containerEl).eq(0) : app.$el;
    panel.containerEl = panel.$containerEl[0];

    if (!panel.containerEl) {
      panel.$containerEl = app.$el;
      panel.containerEl = app.$el[0];
    }

    let $el;

    if (panel.params.el) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(panel.params.el).eq(0);
    } else if (panel.params.content) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(panel.params.content).filter(node => node.nodeType === 1).eq(0);
    }

    if ($el.length === 0) return panel;
    if ($el[0].f7Panel) return $el[0].f7Panel;
    $el[0].f7Panel = panel;
    let {
      side,
      effect,
      resizable
    } = panel.params;
    if (typeof side === 'undefined') side = $el.hasClass('panel-left') ? 'left' : 'right';
    if (typeof effect === 'undefined') // eslint-disable-next-line
      effect = $el.hasClass('panel-cover') ? 'cover' : $el.hasClass('panel-push') ? 'push' : 'reveal';
    if (typeof resizable === 'undefined') resizable = $el.hasClass('panel-resizable');
    let $backdropEl;

    if (panel.params.backdrop && panel.params.backdropEl) {
      $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(panel.params.backdropEl);
    } else if (panel.params.backdrop) {
      $backdropEl = panel.$containerEl.children('.panel-backdrop');

      if ($backdropEl.length === 0) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="panel-backdrop"></div>');
        panel.$containerEl.prepend($backdropEl);
      }
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(panel, {
      app,
      side,
      effect,
      resizable,
      $el,
      el: $el[0],
      opened: false,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0]
    }); // Install Modules

    panel.useModules(); // Init

    panel.init();
    return panel;
  }

  getViewEl() {
    const panel = this;
    let viewEl;

    if (panel.$containerEl.children('.views').length > 0) {
      viewEl = panel.$containerEl.children('.views')[0];
    } else {
      viewEl = panel.$containerEl.children('.view')[0];
    }

    return viewEl;
  }

  setStateClasses(state) {
    const panel = this;
    const {
      side,
      el
    } = panel;
    const viewEl = panel.getViewEl();
    const panelInView = viewEl && viewEl.contains(el);
    const $targetEl = !viewEl || panelInView ? panel.$containerEl : (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html');

    if (state === 'open') {
      $targetEl.addClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }

    if (state === 'before-closing') {
      $targetEl.addClass('with-panel-closing');
    }

    if (state === 'closing') {
      $targetEl.addClass('with-panel-closing');
      $targetEl.removeClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }

    if (state === 'after-closing') {
      $targetEl.removeClass('with-panel-closing');
    }

    if (state === 'closed') {
      $targetEl.removeClass(`with-panel-${side}-reveal with-panel-${side}-cover with-panel-${side}-push with-panel`);
    }
  }

  enableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = false;
    panel.setVisibleBreakpoint();
    return panel;
  }

  disableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = true;
    panel.setVisibleBreakpoint();
    return panel;
  }

  toggleVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = !panel.visibleBreakpointDisabled;
    panel.setVisibleBreakpoint();
    return panel;
  }

  setVisibleBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }

    const panel = this;
    const app = panel.app;

    if (!panel.visibleBreakpointResizeHandler) {
      panel.visibleBreakpointResizeHandler = function visibleBreakpointResizeHandler() {
        panel.setVisibleBreakpoint();
      };

      app.on('resize', panel.visibleBreakpointResizeHandler);
    }

    const {
      side,
      $el,
      $containerEl,
      params,
      visibleBreakpointDisabled
    } = panel;
    const breakpoint = params.visibleBreakpoint;
    const $viewEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(panel.getViewEl());
    const wasVisible = $el.hasClass('panel-in-breakpoint');

    if ($containerEl && $containerEl.hasClass('page')) {
      $viewEl.add($containerEl.children('.page-content, .tabs, .fab'));
    }

    if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null && !visibleBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses('closed');
        $el.addClass('panel-in-breakpoint').removeClass('panel-in panel-in-collapsed');
        panel.onOpen(false);
        panel.onOpened();
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
        app.allowPanelOpen = true;

        if (emitEvents) {
          panel.emit('local::breakpoint panelBreakpoint', panel);
          panel.$el.trigger('panel:breakpoint');
        }
      } else {
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
      }
    } else if (wasVisible) {
      $el.removeClass('panel-in-breakpoint panel-in');
      panel.onClose();
      panel.onClosed();
      $viewEl.css({
        [`margin-${side}`]: ''
      });

      if (emitEvents) {
        panel.emit('local::breakpoint panelBreakpoint', panel);
        panel.$el.trigger('panel:breakpoint');
      }
    }
  }

  enableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = false;
    panel.setCollapsedBreakpoint();
    return panel;
  }

  disableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = true;
    panel.setCollapsedBreakpoint();
    return panel;
  }

  toggleCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = !panel.collapsedBreakpointDisabled;
    panel.setCollapsedBreakpoint();
    return panel;
  }

  setCollapsedBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }

    const panel = this;
    const app = panel.app;

    if (!panel.collapsedBreakpointResizeHandler) {
      panel.collapsedBreakpointResizeHandler = function collapsedBreakpointResizeHandler() {
        panel.setCollapsedBreakpoint();
      };

      app.on('resize', panel.collapsedBreakpointResizeHandler);
    }

    const {
      $el,
      params,
      collapsedBreakpointDisabled
    } = panel;
    if ($el.hasClass('panel-in-breakpoint')) return;
    const breakpoint = params.collapsedBreakpoint;
    const wasVisible = $el.hasClass('panel-in-collapsed');

    if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null && !collapsedBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses('closed');
        $el.addClass('panel-in-collapsed').removeClass('panel-in');
        panel.collapsed = true;
        app.allowPanelOpen = true;

        if (emitEvents) {
          panel.emit('local::collapsedBreakpoint panelCollapsedBreakpoint', panel);
          panel.$el.trigger('panel:collapsedbreakpoint');
        }
      }
    } else if (wasVisible) {
      $el.removeClass('panel-in-collapsed panel-in');
      panel.collapsed = false;

      if (emitEvents) {
        panel.emit('local::collapsedBreakpoint panelCollapsedBreakpoint', panel);
        panel.$el.trigger('panel:collapsedbreakpoint');
      }
    }
  }

  enableResizable() {
    const panel = this;

    if (panel.resizableInitialized) {
      panel.resizable = true;
      panel.$el.addClass('panel-resizable');
    } else {
      (0,_resizable_panel_js__WEBPACK_IMPORTED_MODULE_4__["default"])(panel);
    }

    return panel;
  }

  disableResizable() {
    const panel = this;
    panel.resizable = false;
    panel.$el.removeClass('panel-resizable');
    return panel;
  }

  enableSwipe() {
    const panel = this;

    if (panel.swipeInitialized) {
      panel.swipeable = true;
    } else {
      (0,_swipe_panel_js__WEBPACK_IMPORTED_MODULE_5__["default"])(panel);
    }

    return panel;
  }

  disableSwipe() {
    const panel = this;
    panel.swipeable = false;
    return panel;
  }

  onOpen(modifyHtmlClasses) {
    if (modifyHtmlClasses === void 0) {
      modifyHtmlClasses = true;
    }

    const panel = this;
    const app = panel.app;
    panel.opened = true;
    app.panel.allowOpen = false;
    panel.$el.trigger('panel:beforeopen');
    panel.emit('local::beforeOpen panelBeforeOpen', panel);

    if (modifyHtmlClasses) {
      panel.setStateClasses('open');
    }

    panel.$el.trigger('panel:open');
    panel.emit('local::open panelOpen', panel);
  }

  onOpened() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    panel.$el.trigger('panel:opened');
    panel.emit('local::opened panelOpened', panel);
  }

  onClose() {
    const panel = this;
    const app = panel.app;
    panel.opened = false;
    app.panel.allowOpen = false;
    panel.$el.trigger('panel:beforeclose');
    panel.emit('local::beforeClose panelBeforeClose', panel);
    panel.setStateClasses('closing');
    panel.$el.trigger('panel:close');
    panel.emit('local::close panelClose', panel);
  }

  onClosed() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    panel.setStateClasses('after-closing');
    panel.$el.removeClass('panel-out');

    if (panel.$backdropEl) {
      const otherPanel = app.panel.get('.panel-in');
      const shouldHideBackdrop = !otherPanel || otherPanel && !otherPanel.$backdropEl;

      if (shouldHideBackdrop) {
        panel.$backdropEl.removeClass('panel-backdrop-in');
      }
    }

    panel.$el.trigger('panel:closed');
    panel.emit('local::closed panelClosed', panel);
  }

  toggle(animate) {
    if (animate === void 0) {
      animate = true;
    }

    const panel = this;
    const breakpoint = panel.params.visibleBreakpoint;
    const app = panel.app;

    if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null) {
      return panel.toggleVisibleBreakpoint();
    }

    if (panel.opened) panel.close(animate);else panel.open(animate);
    return panel;
  }

  insertToRoot() {
    const panel = this;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const {
      $el,
      $backdropEl,
      $containerEl
    } = panel;
    const $panelParentEl = $el.parent();
    const wasInDom = $el.parents(document).length > 0;

    if (!$panelParentEl.is($containerEl) || $el.prevAll('.views, .view').length) {
      const $insertBeforeEl = $containerEl.children('.panel, .views, .view').eq(0);
      const $insertAfterEl = $containerEl.children('.panel-backdrop').eq(0);

      if ($insertBeforeEl.length) {
        $el.insertBefore($insertBeforeEl);
      } else if ($insertAfterEl) {
        $el.insertBefore($insertAfterEl);
      } else {
        $containerEl.prepend($el);
      }

      if ($backdropEl && $backdropEl.length && (!$backdropEl.parent().is($containerEl) && $backdropEl.nextAll('.panel').length === 0 || $backdropEl.parent().is($containerEl) && $backdropEl.nextAll('.panel').length === 0)) {
        $backdropEl.insertBefore($el);
      }

      panel.once('panelClosed', () => {
        if (wasInDom) {
          $panelParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
  }

  open(animate) {
    if (animate === void 0) {
      animate = true;
    }

    const panel = this;
    const app = panel.app;
    if (!app.panel.allowOpen) return false;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;

    if (!$el || $el.hasClass('panel-in')) {
      return panel;
    }

    panel.insertToRoot(); // Ignore if opened

    if (opened || $el.hasClass('panel-in-breakpoint') || $el.hasClass('panel-in')) return false; // Close if some panel is opened

    const otherOpenedPanel = app.panel.get('.panel-in');

    if (otherOpenedPanel && otherOpenedPanel !== panel) {
      otherOpenedPanel.close(animate);
    }

    $el[animate ? 'removeClass' : 'addClass']('not-animated');
    $el.addClass('panel-in');

    if ($backdropEl) {
      $backdropEl.addClass('panel-backdrop-in');
      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
    }

    if (panel.effect === 'cover' || panel.effect === 'push') {
      /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
      panel._clientLeft = $el[0].clientLeft;
    } // Transitionend


    const $viewEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(panel.getViewEl());

    if ($containerEl && $containerEl.hasClass('page')) {
      $viewEl.add($containerEl.children('.page-content, .tabs'));
    }

    const transitionEndTarget = effect === 'reveal' ? $viewEl : $el;

    function panelTransitionEnd() {
      transitionEndTarget.transitionEnd(e => {
        if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).is(transitionEndTarget)) {
          if ($el.hasClass('panel-out')) {
            panel.onClosed();
          } else {
            panel.onOpened();
          }
        } else panelTransitionEnd();
      });
    }

    if (animate) {
      if ($backdropEl) {
        $backdropEl.removeClass('not-animated');
      }

      panelTransitionEnd();
      $el.removeClass('panel-out not-animated').addClass('panel-in');
      panel.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass('not-animated');
      }

      $el.removeClass('panel-out').addClass('panel-in not-animated');
      panel.onOpen();
      panel.onOpened();
    }

    return true;
  }

  close(animate) {
    if (animate === void 0) {
      animate = true;
    }

    const panel = this;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;
    if (!opened || $el.hasClass('panel-in-breakpoint') || !$el.hasClass('panel-in')) return panel;
    $el[animate ? 'removeClass' : 'addClass']('not-animated');

    if ($backdropEl) {
      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
    }

    const $viewEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(panel.getViewEl());

    if ($containerEl && $containerEl.hasClass('page')) {
      $viewEl.add($containerEl.children('.page-content, .tabs'));
    }

    const transitionEndTarget = effect === 'reveal' ? $viewEl : $el;

    function transitionEnd() {
      if ($el.hasClass('panel-out')) {
        panel.onClosed();
      } else if ($el.hasClass('panel-in')) {
        panel.onOpened();
      }

      panel.setStateClasses('after-closing');
    }

    if (animate) {
      transitionEndTarget.transitionEnd(() => {
        transitionEnd();
      });
      $el.removeClass('panel-in').addClass('panel-out'); // Emit close

      panel.onClose();
    } else {
      $el.addClass('not-animated').removeClass('panel-in').addClass('panel-out'); // Emit close

      panel.onClose();
      panel.onClosed();
    }

    return panel;
  }

  init() {
    const panel = this; // const app = panel.app;

    if (typeof panel.params.visibleBreakpoint !== 'undefined') {
      panel.setVisibleBreakpoint();
    }

    if (typeof panel.params.collapsedBreakpoint !== 'undefined') {
      panel.setCollapsedBreakpoint();
    }

    if (panel.params.swipe) {
      panel.enableSwipe();
    }

    if (panel.resizable) {
      panel.enableResizable();
    }
  }

  destroy() {
    let panel = this;
    const app = panel.app;
    const {
      $containerEl
    } = panel;

    if (!panel.$el) {
      // Panel already destroyed
      return;
    }

    panel.emit('local::beforeDestroy panelBeforeDestroy', panel);
    panel.$el.trigger('panel:beforedestroy');

    if (panel.visibleBreakpointResizeHandler) {
      app.off('resize', panel.visibleBreakpointResizeHandler);
    }

    if (panel.collapsedBreakpointResizeHandler) {
      app.off('resize', panel.collapsedBreakpointResizeHandler);
    }

    if (panel.$el.hasClass('panel-in-breakpoint') || panel.$el.hasClass('panel-in-collapsed')) {
      const $viewEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(panel.getViewEl());

      if ($containerEl && $containerEl.hasClass('page')) {
        $viewEl.add($containerEl.children('.page-content, .tabs'));
      }

      panel.$el.removeClass('panel-in-breakpoint panel-in-collapsed panel-in');
      $viewEl.css({
        [`margin-${panel.side}`]: ''
      });
      panel.emit('local::breakpoint panelBreakpoint', panel);
      panel.$el.trigger('panel:breakpoint');
    }

    panel.$el.trigger('panel:destroy');
    panel.emit('local::destroy panelDestroy', panel);

    if (panel.el) {
      panel.el.f7Panel = null;
      delete panel.el.f7Panel;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.deleteProps)(panel);
    panel = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Panel);

/***/ }),

/***/ "./node_modules/framework7/components/panel/panel.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7/components/panel/panel.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _panel_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./panel-class.js */ "./node_modules/framework7/components/panel/panel-class.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'panel',
  params: {
    panel: {
      opened: undefined,
      // default based on panel-in class
      side: undefined,
      // default based on panel class
      effect: undefined,
      // default based on panel class
      resizable: undefined,
      // default based on panel-resizable class
      backdrop: true,
      backdropEl: undefined,
      visibleBreakpoint: undefined,
      collapsedBreakpoint: undefined,
      swipe: false,
      // or true
      swipeNoFollow: false,
      // or true
      swipeOnlyClose: false,
      swipeActiveArea: 0,
      swipeThreshold: 0,
      closeByBackdropClick: true,
      containerEl: undefined
    }
  },
  static: {
    Panel: _panel_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(app, {
      panel: {
        allowOpen: true,

        create(params) {
          return new _panel_class_js__WEBPACK_IMPORTED_MODULE_1__["default"](app, params);
        },

        get(el) {
          if (el === void 0) {
            el = '.panel';
          }

          if (el instanceof _panel_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]) return el;
          if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line

          const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
          if ($el.length === 0 || $el.length > 1) return undefined;
          return $el[0].f7Panel;
        },

        destroy(el) {
          if (el === void 0) {
            el = '.panel';
          }

          const panel = app.panel.get(el);
          if (panel && panel.destroy) return panel.destroy();
          return undefined;
        },

        open(el, animate) {
          if (el === void 0) {
            el = '.panel';
          }

          if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line

          let panel = app.panel.get(el);
          if (panel && panel.open) return panel.open(animate);

          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.open(animate);
          }

          return undefined;
        },

        close(el, animate) {
          if (el === void 0) {
            el = '.panel-in';
          }

          if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line

          let panel = app.panel.get(el);
          if (panel && panel.open) return panel.close(animate);

          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.close(animate);
          }

          return undefined;
        },

        toggle(el, animate) {
          if (el === void 0) {
            el = '.panel';
          }

          if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line

          let panel = app.panel.get(el);
          if (panel && panel.toggle) return panel.toggle(animate);

          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.toggle(animate);
          }

          return undefined;
        }

      }
    });
  },

  on: {
    init() {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.panel-init').each(panelEl => {
        const params = Object.assign({
          el: panelEl
        }, (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(panelEl).dataset() || {});
        app.panel.create(params);
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.panel-init').each(panelEl => {
        const params = Object.assign({
          el: panelEl
        }, (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(panelEl).dataset() || {});
        app.panel.create(params);
      });
    },

    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.panel-init').each(panelEl => {
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy) panel.destroy();
      });
    }

  },
  vnode: {
    'panel-init': {
      insert(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const params = Object.assign({
          el: panelEl
        }, (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(panelEl).dataset() || {});
        app.panel.create(params);
      },

      destroy(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy) panel.destroy();
      }

    }
  },
  clicks: {
    '.panel-open': function open(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.panel.open(data.panel, data.animate);
    },
    '.panel-close': function close(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.panel.close(data.panel, data.animate);
    },
    '.panel-toggle': function close(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.panel.toggle(data.panel, data.animate);
    },
    '.panel-backdrop': function close() {
      const app = this;
      const $panelEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.panel-in:not(.panel-out)');
      if (!$panelEl.length) return;
      const instance = $panelEl[0] && $panelEl[0].f7Panel;
      $panelEl.trigger('panel:backdrop-click');

      if (instance) {
        instance.emit('backdropClick', instance);
      }

      app.emit('panelBackdropClick', instance || $panelEl[0]);
      if (instance && instance.params.closeByBackdropClick === false) return;
      if (app.params.panel.closeByBackdropClick) app.panel.close();
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/panel/resizable-panel.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7/components/panel/resizable-panel.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");




function resizablePanel(panel) {
  const app = panel.app;
  const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_1__.getSupport)();
  if (panel.resizableInitialized) return;
  (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(panel, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true
  });
  const $htmlEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('html');
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  if (!$el) return;
  let isTouched;
  let isMoved;
  const touchesStart = {};
  let touchesDiff;
  let panelWidth;
  let $viewEl;
  let panelMinWidth;
  let panelMaxWidth;
  let visibleByBreakpoint;

  function transformCSSWidth(v) {
    if (!v) return null;

    if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
      return parseInt(v, 10) / 100 * app.width;
    }

    const newV = parseInt(v, 10);
    if (Number.isNaN(newV)) return null;
    return newV;
  }

  function isResizable() {
    return panel.resizable && $el.hasClass('panel-resizable');
  }

  function handleTouchStart(e) {
    if (!isResizable()) return;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    panelMinWidth = transformCSSWidth($el.css('min-width'));
    panelMaxWidth = transformCSSWidth($el.css('max-width'));
    visibleByBreakpoint = $el.hasClass('panel-in-breakpoint');
  }

  function handleTouchMove(e) {
    if (!isTouched) return;
    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

    if (!isMoved) {
      panelWidth = $el[0].offsetWidth;
      $el.transition(0);
      $el.addClass('panel-resizing');
      $htmlEl.css('cursor', 'col-resize');

      if (effect !== 'cover' || visibleByBreakpoint) {
        $viewEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(panel.getViewEl());

        if (panel.$containerEl && panel.$containerEl.hasClass('page')) {
          $viewEl.add(panel.$containerEl.children('.page-content, .tabs, .fab'));
        }
      }

      if (effect !== 'cover' && !visibleByBreakpoint) {
        $backdropEl.transition(0);
        $viewEl.transition(0);
      }
    }

    isMoved = true;
    e.preventDefault();
    touchesDiff = pageX - touchesStart.x;
    let newPanelWidth = side === 'left' ? panelWidth + touchesDiff : panelWidth - touchesDiff;

    if (panelMinWidth && !Number.isNaN(panelMinWidth)) {
      newPanelWidth = Math.max(newPanelWidth, panelMinWidth);
    }

    if (panelMaxWidth && !Number.isNaN(panelMaxWidth)) {
      newPanelWidth = Math.min(newPanelWidth, panelMaxWidth);
    }

    newPanelWidth = Math.min(Math.max(newPanelWidth, 0), app.width);
    panel.resizableWidth = newPanelWidth;
    $el[0].style.width = `${newPanelWidth}px`;

    if (effect !== 'cover' && !visibleByBreakpoint) {
      if ($viewEl) {
        $viewEl.transform(`translate3d(${side === 'left' ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }

      if ($backdropEl) {
        $backdropEl.transform(`translate3d(${side === 'left' ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
    } else if (visibleByBreakpoint && $viewEl) {
      $viewEl.css(`margin-${side}`, `${newPanelWidth}px`);
    }

    $el.trigger('panel:resize', newPanelWidth);
    panel.emit('local::resize panelResize', panel, newPanelWidth);
  }

  function handleTouchEnd() {
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('html').css('cursor', '');

    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }

    isTouched = false;
    isMoved = false;
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
    $el[0].style.width = '';

    if (effect !== 'cover' && !visibleByBreakpoint) {
      $viewEl.transform('');
      $backdropEl.transform('');
    }

    $el.removeClass('panel-resizing');
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)(() => {
      $el.transition('');

      if (effect !== 'cover') {
        $backdropEl.transition('');
        if ($viewEl) $viewEl.transition('');
      }
    });
  }

  function handleResize() {
    if (!panel.opened || !panel.resizableWidth) return;
    panelMinWidth = transformCSSWidth($el.css('min-width'));
    panelMaxWidth = transformCSSWidth($el.css('max-width'));

    if (panelMinWidth && !Number.isNaN(panelMinWidth) && panel.resizableWidth < panelMinWidth) {
      panel.resizableWidth = Math.max(panel.resizableWidth, panelMinWidth);
    }

    if (panelMaxWidth && !Number.isNaN(panelMaxWidth) && panel.resizableWidth > panelMaxWidth) {
      panel.resizableWidth = Math.min(panel.resizableWidth, panelMaxWidth);
    }

    panel.resizableWidth = Math.min(Math.max(panel.resizableWidth, 0), app.width);
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
  }

  if (panel.$el.find('.panel-resize-handler').length === 0) {
    panel.$el.append('<div class="panel-resize-handler"></div>');
  }

  panel.$resizeHandlerEl = panel.$el.children('.panel-resize-handler');
  $el.addClass('panel-resizable'); // Add Events

  const passive = support.passiveListener ? {
    passive: true
  } : false;
  panel.$el.on(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
  app.on('touchmove:active', handleTouchMove);
  app.on('touchend:passive', handleTouchEnd);
  app.on('resize', handleResize);
  panel.on('beforeOpen', handleResize);
  panel.once('panelDestroy', () => {
    $el.removeClass('panel-resizable');
    panel.$resizeHandlerEl.remove();
    panel.$el.off(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
    app.off('resize', handleResize);
    panel.off('beforeOpen', handleResize);
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resizablePanel);

/***/ }),

/***/ "./node_modules/framework7/components/panel/swipe-panel.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/panel/swipe-panel.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");



function swipePanel(panel) {
  const app = panel.app;

  if (panel.swipeInitialized) {
    return;
  }

  (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(panel, {
    swipeable: true,
    swipeInitialized: true
  });
  const params = panel.params;
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  let otherPanel;
  let isTouched;
  let isGestureStarted;
  let isMoved;
  let isScrolling;
  let isInterrupted;
  const touchesStart = {};
  let touchStartTime;
  let touchesDiff;
  let translate;
  let backdropOpacity;
  let panelWidth;
  let direction;
  let $viewEl;
  let touchMoves = 0;

  function handleTouchStart(e) {
    if (!panel.swipeable || isGestureStarted) return;
    if (!app.panel.allowOpen || !params.swipe && !params.swipeOnlyClose || isTouched) return;
    if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.modal-in:not(.toast):not(.notification), .photo-browser-in').length > 0) return;
    otherPanel = app.panel.get(side === 'left' ? 'right' : 'left') || {};
    const otherPanelOpened = otherPanel.opened && otherPanel.$el && !otherPanel.$el.hasClass('panel-in-breakpoint');

    if (!panel.opened && otherPanelOpened) {
      return;
    }

    if (!params.swipeOnlyClose) {
      if (otherPanelOpened) return;
    }

    if (e.target && e.target.nodeName.toLowerCase() === 'input' && e.target.type === 'range') return;
    if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel, .card-opened').length > 0) return;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;

    if (params.swipeOnlyClose && !panel.opened) {
      return;
    }

    if (params.swipeActiveArea && !panel.opened) {
      if (side === 'left') {
        if (touchesStart.x > params.swipeActiveArea) return;
      }

      if (side === 'right') {
        if (touchesStart.x < app.width - params.swipeActiveArea) return;
      }
    }

    touchMoves = 0;
    $viewEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(panel.getViewEl());
    isMoved = false;
    isTouched = true;
    isScrolling = undefined;
    isInterrupted = false;
    touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.now)();
    direction = undefined;
  }

  function handleTouchMove(e) {
    if (!isTouched || isGestureStarted || isInterrupted) return;
    touchMoves += 1;
    if (touchMoves < 2) return;

    if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
      isTouched = false;
      return;
    }

    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (typeof isScrolling === 'undefined') {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
    }

    if (isScrolling) {
      isTouched = false;
      return;
    }

    if (!direction) {
      if (pageX > touchesStart.x) {
        direction = 'to-right';
      } else {
        direction = 'to-left';
      }

      if (params.swipeActiveArea > 0 && !panel.opened) {
        if (side === 'left' && touchesStart.x > params.swipeActiveArea) {
          isTouched = false;
          return;
        }

        if (side === 'right' && touchesStart.x < app.width - params.swipeActiveArea) {
          isTouched = false;
          return;
        }
      }

      if ($el.hasClass('panel-in-breakpoint')) {
        isTouched = false;
        return;
      }

      if (side === 'left' && direction === 'to-left' && !$el.hasClass('panel-in') || side === 'right' && direction === 'to-right' && !$el.hasClass('panel-in')) {
        isTouched = false;
        return;
      }
    }

    let threshold = panel.opened ? 0 : -params.swipeThreshold;
    if (side === 'right') threshold = -threshold;

    if (!isMoved) {
      if (!panel.opened) {
        panel.insertToRoot();
        $el.addClass('panel-in-swipe');
        if ($backdropEl) $backdropEl.css('visibility', 'visible');
        $el.trigger('panel:swipeopen');
        panel.emit('local::swipeOpen panelSwipeOpen', panel);
      }

      panelWidth = $el[0].offsetWidth;

      if (effect === 'reveal' && $el.hasClass('panel-in-collapsed')) {
        panelWidth -= parseFloat($viewEl.css(`margin-${side}`));
      }

      $el.transition(0);
    }

    isMoved = true;

    if (e.cancelable) {
      e.preventDefault();
    }

    touchesDiff = pageX - touchesStart.x + threshold;

    if (side === 'right') {
      if (effect === 'cover' || effect === 'push') {
        translate = touchesDiff + (panel.opened ? 0 : panelWidth);
        if (translate < 0) translate = 0;

        if (translate > panelWidth) {
          translate = panelWidth;
        }
      } else {
        translate = touchesDiff - (panel.opened ? panelWidth : 0);
        if (translate > 0) translate = 0;

        if (translate < -panelWidth) {
          translate = -panelWidth;
        }
      }
    } else {
      translate = touchesDiff + (panel.opened ? panelWidth : 0);
      if (translate < 0) translate = 0;

      if (translate > panelWidth) {
        translate = panelWidth;
      }
    }

    const noFollowProgress = Math.abs(translate / panelWidth);

    if (effect === 'reveal') {
      if (!params.swipeNoFollow) {
        $viewEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
        if ($backdropEl) $backdropEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
      }

      $el.trigger('panel:swipe', Math.abs(translate / panelWidth));
      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
    } else {
      if (side === 'left') translate -= panelWidth;

      if (!params.swipeNoFollow) {
        backdropOpacity = 1 - Math.abs(translate / panelWidth);

        if ($backdropEl) {
          $backdropEl.transition(0);
          $backdropEl.css({
            opacity: backdropOpacity
          });
        }

        $el.transform(`translate3d(${translate}px,0,0)`).transition(0);

        if (effect === 'push') {
          const viewTranslate = side === 'left' ? translate + panelWidth : translate - panelWidth;
          $viewEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);

          if ($backdropEl) {
            $backdropEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);
          }
        }
      }

      $el.trigger('panel:swipe', Math.abs(translate / panelWidth));
      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
    }

    if (params.swipeNoFollow) {
      const stateChanged = panel.opened && noFollowProgress === 0 || !panel.opened && noFollowProgress === 1;

      if (stateChanged) {
        isInterrupted = true; // eslint-disable-next-line

        handleTouchEnd(e);
      }
    }
  }

  function handleTouchEnd(e) {
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }

    const isGesture = e.type === 'gesturestart' || isGestureStarted;
    isTouched = false;
    isMoved = false;
    const timeDiff = new Date().getTime() - touchStartTime;
    let action;
    const edge = (translate === 0 || Math.abs(translate) === panelWidth) && !params.swipeNoFollow;
    const threshold = params.swipeThreshold || 0;

    if (isGesture) {
      action = 'reset';
    } else if (!panel.opened) {
      if (Math.abs(touchesDiff) < threshold) {
        action = 'reset';
      } else if (effect === 'cover' || effect === 'push') {
        if (translate === 0) {
          action = 'swap'; // open
        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
          action = 'swap'; // open
        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
          action = 'swap'; // open
        } else {
          action = 'reset'; // close
        }
      } else if (translate === 0) {
        action = 'reset';
      } else if (timeDiff < 300 && Math.abs(translate) > 0 || timeDiff >= 300 && Math.abs(translate) >= panelWidth / 2) {
        action = 'swap';
      } else {
        action = 'reset';
      }
    } else if (effect === 'cover' || effect === 'push') {
      if (translate === 0) {
        action = 'reset'; // open
      } else if (timeDiff < 300 && Math.abs(translate) > 0) {
        action = 'swap'; // open
      } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
        action = 'reset'; // open
      } else {
        action = 'swap'; // close
      }
    } else if (translate === -panelWidth) {
      action = 'reset';
    } else if (timeDiff < 300 && Math.abs(translate) >= 0 || timeDiff >= 300 && Math.abs(translate) <= panelWidth / 2) {
      if (side === 'left' && translate === panelWidth) action = 'reset';else action = 'swap';
    } else {
      action = 'reset';
    }

    if (action === 'swap') {
      if (panel.opened) {
        panel.close(!edge);
      } else {
        panel.open(!edge);
      }
    }

    let removePanelInClass = true;

    if (action === 'reset') {
      if (!panel.opened) {
        if (edge) {
          // edge position
          $el.removeClass('panel-in-swipe');
        } else {
          removePanelInClass = false;
          const target = effect === 'reveal' ? $viewEl : $el;
          panel.setStateClasses('before-closing');
          target.transitionEnd(() => {
            if ($el.hasClass('panel-in')) return;
            $el.removeClass('panel-in-swipe');
            panel.setStateClasses('after-closing');
          });
        }
      }
    }

    if (effect === 'reveal' || effect === 'push') {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextFrame)(() => {
        $viewEl.transition('');
        $viewEl.transform('');
      });
    }

    if (removePanelInClass) {
      $el.removeClass('panel-in-swipe');
    }

    $el.transition('').transform('');

    if ($backdropEl) {
      $backdropEl.transform('').transition('').css({
        opacity: '',
        visibility: ''
      });
    }
  }

  function handleGestureStart(e) {
    isGestureStarted = true;
    handleTouchEnd(e);
  }

  function handleGestureEnd() {
    isGestureStarted = false;
  } // Add Events


  app.on('touchstart:passive', handleTouchStart);
  app.on('touchmove:active', handleTouchMove);
  app.on('touchend:passive', handleTouchEnd);
  app.on('gesturestart', handleGestureStart);
  app.on('gestureend', handleGestureEnd);
  panel.on('panelDestroy', () => {
    app.off('touchstart:passive', handleTouchStart);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
    app.off('gesturestart', handleGestureStart);
    app.off('gestureend', handleGestureEnd);
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (swipePanel);

/***/ }),

/***/ "./node_modules/framework7/components/photo-browser/photo-browser-class.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/framework7/components/photo-browser/photo-browser-class.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");
/* eslint indent: ["off"] */




/** @jsx $jsx */



class PhotoBrowser extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const pb = this;
    pb.app = app;
    const defaults = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
      on: {}
    }, app.params.photoBrowser); // Extend defaults with modules params

    pb.useModulesParams(defaults);
    pb.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(defaults, params);
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(pb, {
      exposed: false,
      opened: false,
      activeIndex: pb.params.swiper.initialSlide,
      url: pb.params.url,
      swipeToClose: {
        allow: true,
        isTouched: false,
        diff: undefined,
        start: undefined,
        current: undefined,
        started: false,
        activeSlide: undefined,
        timeStart: undefined
      }
    }); // Install Modules

    pb.useModules(); // Init

    pb.init();
  }

  get view() {
    const {
      params,
      app
    } = this;
    return params.view || app.views.main;
  }

  onSlideChange(swiper) {
    const pb = this;
    pb.activeIndex = swiper.activeIndex;
    let current = swiper.activeIndex + 1;
    let total = pb.params.virtualSlides ? pb.params.photos.length : swiper.slides.length;

    if (swiper.params.loop) {
      total -= 2;
      current -= swiper.loopedSlides;
      if (current < 1) current = total + current;
      if (current > total) current -= total;
    }

    const $activeSlideEl = pb.params.virtualSlides ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides.eq(swiper.activeIndex);
    const $previousSlideEl = pb.params.virtualSlides ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.previousIndex}"]`) : swiper.slides.eq(swiper.previousIndex);
    let $currentEl = pb.$el.find('.photo-browser-current');
    let $totalEl = pb.$el.find('.photo-browser-total');
    let navbarEl;

    if (pb.params.type === 'page' && pb.params.navbar && $currentEl.length === 0 && pb.app.theme === 'ios') {
      navbarEl = pb.app.navbar.getElByPage(pb.$el);

      if (navbarEl) {
        $currentEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(navbarEl).find('.photo-browser-current');
        $totalEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(navbarEl).find('.photo-browser-total');
      }
    }

    if ($currentEl.length && $totalEl.length) {
      $currentEl.text(current);
      $totalEl.text(total);
      if (!navbarEl) navbarEl = $currentEl.parents('.navbar')[0];

      if (navbarEl) {
        pb.app.navbar.size(navbarEl);
      }
    } // Update captions


    if (pb.captions.length > 0) {
      const captionIndex = swiper.params.loop ? $activeSlideEl.attr('data-swiper-slide-index') : pb.activeIndex;
      pb.$captionsContainerEl.find('.photo-browser-caption-active').removeClass('photo-browser-caption-active');
      pb.$captionsContainerEl.find(`[data-caption-index="${captionIndex}"]`).addClass('photo-browser-caption-active');
    } // Stop Video


    const previousSlideVideo = $previousSlideEl.find('video');

    if (previousSlideVideo.length > 0) {
      if ('pause' in previousSlideVideo[0]) previousSlideVideo[0].pause();
    }
  }

  onTouchStart() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    if (!swipeToClose.allow) return;
    swipeToClose.isTouched = true;
  }

  onTouchMove(e) {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    if (!swipeToClose.isTouched) return;

    if (!swipeToClose.started) {
      swipeToClose.started = true;
      swipeToClose.start = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (pb.params.virtualSlides) {
        swipeToClose.activeSlide = pb.swiper.$wrapperEl.children('.swiper-slide-active');
      } else {
        swipeToClose.activeSlide = pb.swiper.slides.eq(pb.swiper.activeIndex);
      }

      swipeToClose.timeStart = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.now)();
    }

    e.preventDefault();
    swipeToClose.current = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    swipeToClose.diff = swipeToClose.start - swipeToClose.current;
    pb.$el.transition(0).transform(`translate3d(0,${-swipeToClose.diff}px,0)`);
  }

  onTouchEnd() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    swipeToClose.isTouched = false;

    if (!swipeToClose.started) {
      swipeToClose.started = false;
      return;
    }

    swipeToClose.started = false;
    swipeToClose.allow = false;
    const diff = Math.abs(swipeToClose.diff);
    const timeDiff = new Date().getTime() - swipeToClose.timeStart;

    if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > 100) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
        if (pb.$el) {
          if (swipeToClose.diff < 0) pb.$el.addClass('swipe-close-to-bottom');else pb.$el.addClass('swipe-close-to-top');
        }

        pb.emit('local::swipeToClose', pb);
        pb.$el.transform('').transition('');
        pb.close();
        swipeToClose.allow = true;
      });
      return;
    }

    if (diff !== 0) {
      pb.$el.addClass('photo-browser-transitioning').transitionEnd(() => {
        swipeToClose.allow = true;
        pb.$el.removeClass('photo-browser-transitioning');
      });
    } else {
      swipeToClose.allow = true;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
      pb.$el.transform('').transition('');
    });
  } // Render Functions


  renderNavbar() {
    const pb = this;
    if (pb.params.renderNavbar) return pb.params.renderNavbar.call(pb);
    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';
    const pageBackLinkText = (pb.app.theme === 'ios' || pb.app.theme === 'aurora') && pb.params.pageBackLinkText ? pb.params.pageBackLinkText : '';
    const renderNavbarCount = typeof pb.params.navbarShowCount === 'undefined' ? pb.params.photos.length > 1 : pb.params.navbarShowCount;
    const isPopup = pb.params.type !== 'page';
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `navbar navbar-photo-browser ${pb.params.theme === 'dark' ? 'navbar-photo-browser-dark' : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "navbar-bg"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "navbar-inner navbar-inner-centered-title sliding"
    }, !isPopup && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "left"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("a", {
      class: `link ${!pageBackLinkText ? 'icon-only' : ''} back`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("i", {
      class: `icon icon-back ${iconsColor ? `color-${iconsColor}` : ''}`
    }), pageBackLinkText && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", null, pageBackLinkText))), renderNavbarCount && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "title"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", {
      class: "photo-browser-current"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", {
      class: "photo-browser-of"
    }, pb.params.navbarOfText), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", {
      class: "photo-browser-total"
    })), isPopup && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "right"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("a", {
      class: "link popup-close",
      "data-popup": ".photo-browser-popup"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", null, pb.params.popupCloseLinkText)))));
  }

  renderToolbar() {
    const pb = this;
    if (pb.params.renderToolbar) return pb.params.renderToolbar.call(pb);
    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "toolbar toolbar-bottom tabbar"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "toolbar-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("a", {
      class: "link photo-browser-prev"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("i", {
      class: `icon icon-back ${iconsColor ? `color-${iconsColor}` : ''}`
    })), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("a", {
      class: "link photo-browser-next"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("i", {
      class: `icon icon-forward ${iconsColor ? `color-${iconsColor}` : ''}`
    }))));
  }

  renderCaption(caption, index) {
    const pb = this;
    if (pb.params.renderCaption) return pb.params.renderCaption.call(pb, caption, index);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "photo-browser-caption",
      "data-caption-index": index
    }, caption);
  }

  renderObject(photo, index) {
    const pb = this;
    if (pb.params.renderObject) return pb.params.renderObject.call(pb, photo, index);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "photo-browser-slide photo-browser-object-slide swiper-slide",
      "data-swiper-slide-index": index
    }, photo.html ? photo.html : photo);
  }

  renderLazyPhoto(photo, index) {
    const pb = this;
    if (pb.params.renderLazyPhoto) return pb.params.renderLazyPhoto.call(pb, photo, index);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "photo-browser-slide photo-browser-slide-lazy swiper-slide",
      "data-swiper-slide-index": index
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "swiper-lazy-preloader"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", {
      class: "swiper-zoom-container"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("img", {
      "data-src": photo.url ? photo.url : photo,
      class: "swiper-lazy"
    })));
  }

  renderPhoto(photo, index) {
    const pb = this;
    if (pb.params.renderPhoto) return pb.params.renderPhoto.call(pb, photo, index);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "photo-browser-slide swiper-slide",
      "data-swiper-slide-index": index
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("span", {
      class: "swiper-zoom-container"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("img", {
      src: photo.url ? photo.url : photo
    })));
  }

  render() {
    const pb = this;
    if (pb.params.render) return pb.params.render.call(pb, pb.params);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `photo-browser photo-browser-${pb.params.theme}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "view"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `page photo-browser-page photo-browser-page-${pb.params.theme} no-toolbar ${!pb.params.navbar ? 'no-navbar' : ''}`,
      "data-name": "photo-browser-page"
    }, pb.params.navbar && pb.renderNavbar(), pb.params.toolbar && pb.renderToolbar(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `photo-browser-captions photo-browser-captions-${pb.params.captionsTheme || pb.params.theme}`
    }, pb.params.photos.map((photo, index) => {
      if (photo.caption) return pb.renderCaption(photo.caption, index);
      return '';
    })), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "photo-browser-swiper-container swiper"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "photo-browser-swiper-wrapper swiper-wrapper"
    }, !pb.params.virtualSlides && pb.params.photos.map((photo, index) => {
      if (photo.html || (typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0) {
        return pb.renderObject(photo, index);
      }

      if (pb.params.swiper.lazy === true || pb.params.swiper.lazy && pb.params.swiper.lazy.enabled) {
        return pb.renderLazyPhoto(photo, index);
      }

      return pb.renderPhoto(photo, index);
    }))))));
  }

  renderStandalone() {
    const pb = this;
    if (pb.params.renderStandalone) return pb.params.renderStandalone.call(pb);
    const standaloneHtml = `<div class="popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen">${pb.render()}</div>`;
    return standaloneHtml;
  }

  renderPage() {
    const pb = this;
    if (pb.params.renderPage) return pb.params.renderPage.call(pb);
    const pageHtml = pb.render();
    return pageHtml;
  }

  renderPopup() {
    const pb = this;
    if (pb.params.renderPopup) return pb.params.renderPopup.call(pb);
    const popupHtml = `<div class="popup photo-browser-popup">${pb.render()}</div>`;
    return popupHtml;
  } // Callbacks


  onOpen(type, el) {
    const pb = this;
    const app = pb.app;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
    $el[0].f7PhotoBrowser = pb;
    pb.$el = $el;
    pb.el = $el[0];
    pb.openedIn = type;
    pb.opened = true;
    pb.$swiperContainerEl = pb.$el.find('.photo-browser-swiper-container');
    pb.$swiperWrapperEl = pb.$el.find('.photo-browser-swiper-wrapper');
    pb.slides = pb.$el.find('.photo-browser-slide');
    pb.$captionsContainerEl = pb.$el.find('.photo-browser-captions');
    pb.captions = pb.$el.find('.photo-browser-caption'); // Init Swiper

    let clickTimeout;
    const swiperParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, pb.params.swiper, {
      initialSlide: pb.activeIndex,
      cssMode: typeof pb.params.swiper.cssMode === 'undefined' && (app.device.ios || app.device.android) ? true : pb.params.swiper.cssMode,
      on: {
        click(e) {
          clearTimeout(clickTimeout);

          if (pb.params.exposition) {
            clickTimeout = setTimeout(() => {
              pb.expositionToggle();
            }, 350);
          }

          pb.emit('local::tap', e);
          pb.emit('local::click', e);
        },

        doubleClick(e) {
          clearTimeout(clickTimeout);
          pb.emit('local::doubleTap', e);
          pb.emit('local::doubleClick', e);
        },

        slideChange() {
          const swiper = this;
          pb.onSlideChange(swiper);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          pb.emit('local::slideChange', ...args);
        },

        transitionStart() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          pb.emit('local::transitionStart', ...args);
        },

        transitionEnd() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          pb.emit('local::transitionEnd', ...args);
        },

        slideChangeTransitionStart() {
          const swiper = this;
          pb.onSlideChange(swiper);

          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          pb.emit('local::slideChangeTransitionStart', ...args);
        },

        slideChangeTransitionEnd() {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }

          pb.emit('local::slideChangeTransitionEnd', ...args);
        },

        lazyImageLoad() {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }

          pb.emit('local::lazyImageLoad', ...args);
        },

        lazyImageReady() {
          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }

          const slideEl = args[0];
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl).removeClass('photo-browser-slide-lazy');
          pb.emit('local::lazyImageReady', ...args);
        }

      }
    });

    if (pb.params.swipeToClose && pb.params.type !== 'page') {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(swiperParams.on, {
        touchStart(swiper, e) {
          pb.onTouchStart(e);
          pb.emit('local::touchStart', e);
        },

        touchMoveOpposite(swiper, e) {
          pb.onTouchMove(e);
          pb.emit('local::touchMoveOpposite', e);
        },

        touchEnd(swiper, e) {
          pb.onTouchEnd(e);
          pb.emit('local::touchEnd', e);
        }

      });
    }

    if (pb.params.virtualSlides) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(swiperParams, {
        virtual: {
          slides: pb.params.photos,

          renderSlide(photo, index) {
            if (photo.html || (typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0) {
              return pb.renderObject(photo, index);
            }

            if (pb.params.swiper.lazy === true || pb.params.swiper.lazy && pb.params.swiper.lazy.enabled) {
              return pb.renderLazyPhoto(photo, index);
            }

            return pb.renderPhoto(photo, index);
          }

        }
      });
    }

    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    pb.swiper = app.swiper ? app.swiper.create(pb.$swiperContainerEl, swiperParams) : new window.Swiper(pb.$swiperContainerEl, swiperParams);

    if (pb.activeIndex === 0) {
      pb.onSlideChange(pb.swiper);
    }

    if (pb.$el) {
      pb.$el.trigger('photobrowser:open');
    }

    pb.emit('local::open photoBrowserOpen', pb);
  }

  onOpened() {
    const pb = this;

    if (pb.$el && pb.params.type === 'standalone') {
      pb.$el.css('animation', 'none');
    }

    if (pb.$el) {
      pb.$el.trigger('photobrowser:opened');
    }

    pb.emit('local::opened photoBrowserOpened', pb);
  }

  onClose() {
    const pb = this;
    if (pb.destroyed) return; // Destroy Swiper

    if (pb.swiper && pb.swiper.destroy) {
      pb.swiper.destroy(true, false);
      pb.swiper = null;
      delete pb.swiper;
    }

    if (pb.$el) {
      pb.$el.trigger('photobrowser:close');
    }

    pb.emit('local::close photoBrowserClose', pb);
  }

  onClosed() {
    const pb = this;
    if (pb.destroyed) return;
    pb.opened = false;
    pb.$el = null;
    pb.el = null;
    delete pb.$el;
    delete pb.el;

    if (pb.$el) {
      pb.$el.trigger('photobrowser:closed');
    }

    pb.emit('local::closed photoBrowserClosed', pb);
  } // Open


  openPage() {
    const pb = this;
    if (pb.opened) return pb;
    const pageHtml = pb.renderPage();
    pb.view.router.navigate({
      url: pb.url,
      route: {
        content: pageHtml,
        path: pb.url,
        on: {
          pageBeforeIn(e, page) {
            pb.view.$el.addClass(`with-photo-browser-page with-photo-browser-page-${pb.params.theme}`);
            pb.onOpen('page', page.el);
          },

          pageAfterIn(e, page) {
            pb.onOpened('page', page.el);
          },

          pageBeforeOut(e, page) {
            pb.view.$el.removeClass(`with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-${pb.params.theme}`);
            pb.onClose('page', page.el);
          },

          pageAfterOut(e, page) {
            pb.onClosed('page', page.el);
          }

        }
      }
    });
    return pb;
  }

  openStandalone() {
    const pb = this;
    if (pb.opened) return pb;
    const standaloneHtml = pb.renderStandalone();
    const popupParams = {
      backdrop: false,
      content: standaloneHtml,
      on: {
        popupOpen(popup) {
          pb.onOpen('popup', popup.el);
        },

        popupOpened(popup) {
          pb.onOpened('popup', popup.el);
        },

        popupClose(popup) {
          pb.onClose('popup', popup.el);
        },

        popupClosed(popup) {
          pb.onClosed('popup', popup.el);
        }

      }
    };

    if (pb.params.routableModals && pb.view) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams
        }
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }

    return pb;
  }

  openPopup() {
    const pb = this;
    if (pb.opened) return pb;
    const popupHtml = pb.renderPopup();
    const popupParams = {
      content: popupHtml,
      push: pb.params.popupPush,
      on: {
        popupOpen(popup) {
          pb.onOpen('popup', popup.el);
        },

        popupOpened(popup) {
          pb.onOpened('popup', popup.el);
        },

        popupClose(popup) {
          pb.onClose('popup', popup.el);
        },

        popupClosed(popup) {
          pb.onClosed('popup', popup.el);
        }

      }
    };

    if (pb.params.routableModals && pb.view) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams
        }
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }

    return pb;
  } // Exposition


  expositionEnable() {
    const pb = this;

    if (pb.params.type === 'page') {
      pb.view.$el.addClass('with-photo-browser-page-exposed');
    }

    if (pb.$el) pb.$el.addClass('photo-browser-exposed');
    if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.addClass('photo-browser-captions-exposed');
    pb.exposed = true;
    return pb;
  }

  expositionDisable() {
    const pb = this;

    if (pb.params.type === 'page') {
      pb.view.$el.removeClass('with-photo-browser-page-exposed');
    }

    if (pb.$el) pb.$el.removeClass('photo-browser-exposed');
    if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.removeClass('photo-browser-captions-exposed');
    pb.exposed = false;
    return pb;
  }

  expositionToggle() {
    const pb = this;

    if (pb.params.type === 'page') {
      pb.view.$el.toggleClass('with-photo-browser-page-exposed');
    }

    if (pb.$el) pb.$el.toggleClass('photo-browser-exposed');
    if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.toggleClass('photo-browser-captions-exposed');
    pb.exposed = !pb.exposed;
    return pb;
  }

  open(index) {
    const pb = this;
    const type = pb.params.type;

    if (pb.opened) {
      if (pb.swiper && typeof index !== 'undefined') {
        pb.swiper.slideTo(parseInt(index, 10));
      }

      return pb;
    }

    if (typeof index !== 'undefined') {
      pb.activeIndex = index;
    }

    if (type === 'standalone') {
      pb.openStandalone();
    }

    if (type === 'page') {
      pb.openPage();
    }

    if (type === 'popup') {
      pb.openPopup();
    }

    return pb;
  }

  close() {
    const pb = this;
    if (!pb.opened) return pb;

    if (pb.params.routableModals && pb.view || pb.openedIn === 'page') {
      pb.view.router.back();
    } else {
      pb.modal.once('modalClosed', () => {
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
          if (pb.destroyed) return;
          pb.modal.destroy();
          delete pb.modal;
        });
      });
      pb.modal.close();
    }

    return pb;
  } // eslint-disable-next-line


  init() {}

  destroy() {
    let pb = this;
    pb.emit('local::beforeDestroy photoBrowserBeforeDestroy', pb);

    if (pb.$el) {
      pb.$el.trigger('photobrowser:beforedestroy');
      pb.$el[0].f7PhotoBrowser = null;
      delete pb.$el[0].f7PhotoBrowser;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.deleteProps)(pb);
    pb.destroyed = true;
    pb = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PhotoBrowser);

/***/ }),

/***/ "./node_modules/framework7/components/photo-browser/photo-browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/framework7/components/photo-browser/photo-browser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _photo_browser_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./photo-browser-class.js */ "./node_modules/framework7/components/photo-browser/photo-browser-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'photoBrowser',
  params: {
    photoBrowser: {
      photos: [],
      exposition: true,
      expositionHideCaptions: false,
      type: 'standalone',
      navbar: true,
      toolbar: true,
      theme: 'light',
      captionsTheme: undefined,
      iconsColor: undefined,
      popupPush: false,
      swipeToClose: true,
      pageBackLinkText: 'Back',
      popupCloseLinkText: 'Close',
      navbarOfText: 'of',
      navbarShowCount: undefined,
      view: undefined,
      url: 'photos/',
      routableModals: false,
      virtualSlides: true,
      renderNavbar: undefined,
      renderToolbar: undefined,
      renderCaption: undefined,
      renderObject: undefined,
      renderLazyPhoto: undefined,
      renderPhoto: undefined,
      renderPage: undefined,
      renderPopup: undefined,
      renderStandalone: undefined,
      swiper: {
        initialSlide: 0,
        spaceBetween: 20,
        speed: 300,
        loop: false,
        preloadImages: true,
        keyboard: {
          enabled: true
        },
        navigation: {
          nextEl: '.photo-browser-next',
          prevEl: '.photo-browser-prev'
        },
        zoom: {
          enabled: true,
          maxRatio: 3,
          minRatio: 1
        },
        lazy: {
          enabled: true
        }
      }
    }
  },

  create() {
    const app = this;
    app.photoBrowser = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
      defaultSelector: '.photo-browser-popup, .photo-browser-page',
      constructor: _photo_browser_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7PhotoBrowser'
    });
  },

  static: {
    PhotoBrowser: _photo_browser_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/picker/picker-class.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/picker/picker-class.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _picker_column_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./picker-column.js */ "./node_modules/framework7/components/picker/picker-column.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");






/** @jsx $jsx */



class Picker extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const picker = this;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__.getDevice)();
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    picker.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)({}, app.params.picker, params);
    let $containerEl;

    if (picker.params.containerEl) {
      $containerEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(picker.params.containerEl);
      if ($containerEl.length === 0) return picker;
    }

    let $inputEl;

    if (picker.params.inputEl) {
      $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(picker.params.inputEl);
    }

    let $scrollToEl = picker.params.scrollToInput ? $inputEl : undefined;

    if (picker.params.scrollToEl) {
      const scrollToEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(picker.params.scrollToEl);

      if (scrollToEl.length > 0) {
        $scrollToEl = scrollToEl;
      }
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)(picker, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      needsOriginFix: device.ios || window.navigator.userAgent.toLowerCase().indexOf('safari') >= 0 && window.navigator.userAgent.toLowerCase().indexOf('chrome') < 0 && !device.android,
      cols: [],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      $scrollToEl,
      initialized: false,
      opened: false,
      url: picker.params.url
    });

    function onResize() {
      picker.resizeCols();
    }

    function onInputClick() {
      picker.open();
    }

    function onInputFocus(e) {
      e.preventDefault();
    }

    let htmlTouchStartTarget = null;

    function onHtmlTouchStart(e) {
      htmlTouchStartTarget = e.target;
    }

    function onHtmlClick(e) {
      if (picker.destroyed || !picker.params) return;
      const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target);
      if (picker.isPopover()) return;
      if (!picker.opened || picker.closing) return;
      if ($targetEl.closest('[class*="backdrop"]').length) return;

      if ($inputEl && $inputEl.length > 0) {
        if (htmlTouchStartTarget === e.target && $targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal').length === 0) {
          picker.close();
        }
      } else if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest('.sheet-modal').length === 0) {
        picker.close();
      }
    } // Events


    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)(picker, {
      attachResizeEvent() {
        app.on('resize', onResize);
      },

      detachResizeEvent() {
        app.off('resize', onResize);
      },

      attachInputEvents() {
        picker.$inputEl.on('click', onInputClick);

        if (picker.params.inputReadOnly) {
          picker.$inputEl.on('focus mousedown', onInputFocus);

          if (picker.$inputEl[0]) {
            picker.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },

      detachInputEvents() {
        picker.$inputEl.off('click', onInputClick);

        if (picker.params.inputReadOnly) {
          picker.$inputEl.off('focus mousedown', onInputFocus);

          if (picker.$inputEl[0]) {
            delete picker.$inputEl[0].f7ValidateReadonly;
          }
        }
      },

      attachHtmlEvents() {
        app.on('click', onHtmlClick);
        app.on('touchstart', onHtmlTouchStart);
      },

      detachHtmlEvents() {
        app.off('click', onHtmlClick);
        app.off('touchstart', onHtmlTouchStart);
      }

    });
    picker.init();
    return picker;
  }

  get view() {
    const {
      app,
      params,
      $inputEl
    } = this;
    let view;

    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
    }

    if (!view) view = app.views.main;
    return view;
  }

  initInput() {
    const picker = this;
    if (!picker.$inputEl) return;
    if (picker.params.inputReadOnly) picker.$inputEl.prop('readOnly', true);
  }

  resizeCols() {
    const picker = this;
    if (!picker.opened) return;

    for (let i = 0; i < picker.cols.length; i += 1) {
      if (!picker.cols[i].divider) {
        picker.cols[i].calcSize();
        picker.cols[i].setValue(picker.cols[i].value, false);
      }
    }
  }

  isPopover() {
    const picker = this;
    const {
      app,
      modal,
      params
    } = picker;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__.getDevice)();
    if (params.openIn === 'sheet') return false;
    if (modal && modal.type !== 'popover') return false;

    if (!picker.inline && picker.inputEl) {
      if (params.openIn === 'popover') return true;

      if (device.ios) {
        return !!device.ipad;
      }

      if (app.width >= 768) {
        return true;
      }

      if (device.desktop && app.theme === 'aurora') {
        return true;
      }
    }

    return false;
  }

  formatValue() {
    const picker = this;
    const {
      value,
      displayValue
    } = picker;

    if (picker.params.formatValue) {
      return picker.params.formatValue.call(picker, value, displayValue);
    }

    return value.join(' ');
  }

  setValue(values) {
    const picker = this;
    let valueIndex = 0;

    if (picker.cols.length === 0) {
      picker.value = values;
      picker.updateValue(values);
      return;
    }

    for (let i = 0; i < picker.cols.length; i += 1) {
      if (picker.cols[i] && !picker.cols[i].divider) {
        picker.cols[i].setValue(values[valueIndex]);
        valueIndex += 1;
      }
    }
  }

  getValue() {
    const picker = this;
    return picker.value;
  }

  updateValue(forceValues) {
    const picker = this;
    const newValue = forceValues || [];
    const newDisplayValue = [];
    let column;

    if (picker.cols.length === 0) {
      const noDividerColumns = picker.params.cols.filter(c => !c.divider);

      for (let i = 0; i < noDividerColumns.length; i += 1) {
        column = noDividerColumns[i];

        if (column.displayValues !== undefined && column.values !== undefined && column.values.indexOf(newValue[i]) !== -1) {
          newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
        } else {
          newDisplayValue.push(newValue[i]);
        }
      }
    } else {
      for (let i = 0; i < picker.cols.length; i += 1) {
        if (!picker.cols[i].divider) {
          newValue.push(picker.cols[i].value);
          newDisplayValue.push(picker.cols[i].displayValue);
        }
      }
    }

    if (newValue.indexOf(undefined) >= 0) {
      return;
    }

    picker.value = newValue;
    picker.displayValue = newDisplayValue;
    picker.emit('local::change pickerChange', picker, picker.value, picker.displayValue);

    if (picker.inputEl) {
      picker.$inputEl.val(picker.formatValue());
      picker.$inputEl.trigger('change');
    }
  }

  initColumn(colEl, updateItems) {
    const picker = this;
    _picker_column_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(picker, colEl, updateItems);
  } // eslint-disable-next-line


  destroyColumn(colEl) {
    const picker = this;
    const $colEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(colEl);
    const index = $colEl.index();

    if (picker.cols[index] && picker.cols[index].destroy) {
      picker.cols[index].destroy();
    }
  }

  renderToolbar() {
    const picker = this;
    if (picker.params.renderToolbar) return picker.params.renderToolbar.call(picker, picker);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "toolbar toolbar-top no-shadow"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "toolbar-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "left"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "right"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("a", {
      class: "link sheet-close popover-close"
    }, picker.params.toolbarCloseText))));
  } // eslint-disable-next-line


  renderColumn(col, onlyItems) {
    const colClasses = `picker-column ${col.textAlign ? `picker-column-${col.textAlign}` : ''} ${col.cssClass || ''}`;
    let columnHtml;
    let columnItemsHtml;

    if (col.divider) {
      // prettier-ignore
      columnHtml = `
        <div class="${colClasses} picker-column-divider">${col.content}</div>
      `;
    } else {
      // prettier-ignore
      columnItemsHtml = col.values.map((value, index) => `
        <div class="picker-item" data-picker-value="${value}">
          <span>${col.displayValues ? col.displayValues[index] : value}</span>
        </div>
      `).join(''); // prettier-ignore

      columnHtml = `
        <div class="${colClasses}">
          <div class="picker-items">${columnItemsHtml}</div>
        </div>
      `;
    }

    return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
  }

  renderInline() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const inlineHtml = (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: `picker picker-inline ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}`
    }, toolbar && picker.renderToolbar(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "picker-columns"
    }, picker.cols.map(col => picker.renderColumn(col)), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "picker-center-highlight"
    })));
    return inlineHtml;
  }

  renderSheet() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const sheetHtml = (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: `sheet-modal picker picker-sheet ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}`
    }, toolbar && picker.renderToolbar(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "sheet-modal-inner picker-columns"
    }, picker.cols.map(col => picker.renderColumn(col)), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "picker-center-highlight"
    })));
    return sheetHtml;
  }

  renderPopover() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const popoverHtml = (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "popover picker-popover"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "popover-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: `picker ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}`
    }, toolbar && picker.renderToolbar(), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "picker-columns"
    }, picker.cols.map(col => picker.renderColumn(col)), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_6__["default"])("div", {
      class: "picker-center-highlight"
    })))));
    return popoverHtml;
  }

  render() {
    const picker = this;
    if (picker.params.render) return picker.params.render.call(picker);

    if (!picker.inline) {
      if (picker.isPopover()) return picker.renderPopover();
      return picker.renderSheet();
    }

    return picker.renderInline();
  }

  onOpen() {
    const picker = this;
    const {
      initialized,
      $el,
      app,
      $inputEl,
      inline,
      value,
      params
    } = picker;
    picker.opened = true;
    picker.closing = false;
    picker.opening = true; // Init main events

    picker.attachResizeEvent(); // Init cols

    $el.find('.picker-column').each(colEl => {
      let updateItems = true;

      if (!initialized && params.value || initialized && value) {
        updateItems = false;
      }

      picker.initColumn(colEl, updateItems);
    }); // Set value

    if (!initialized) {
      if (value) picker.setValue(value);else if (params.value) {
        picker.setValue(params.value);
      }
    } else if (value) {
      picker.setValue(value);
    } // Extra focus


    if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
      $inputEl.trigger('focus');
    }

    picker.initialized = true; // Trigger events

    if ($el) {
      $el.trigger('picker:open');
    }

    if ($inputEl) {
      $inputEl.trigger('picker:open');
    }

    picker.emit('local::open pickerOpen', picker);
  }

  onOpened() {
    const picker = this;
    picker.opening = false;

    if (picker.$el) {
      picker.$el.trigger('picker:opened');
    }

    if (picker.$inputEl) {
      picker.$inputEl.trigger('picker:opened');
    }

    picker.emit('local::opened pickerOpened', picker);
  }

  onClose() {
    const picker = this;
    const app = picker.app;
    picker.opening = false;
    picker.closing = true; // Detach events

    picker.detachResizeEvent();
    picker.cols.forEach(col => {
      if (col.destroy) col.destroy();
    });

    if (picker.$inputEl) {
      if (app.theme === 'md') {
        picker.$inputEl.trigger('blur');
      } else {
        const validate = picker.$inputEl.attr('validate');
        const required = picker.$inputEl.attr('required');

        if (validate && required) {
          app.input.validate(picker.$inputEl);
        }
      }
    }

    if (picker.$el) {
      picker.$el.trigger('picker:close');
    }

    if (picker.$inputEl) {
      picker.$inputEl.trigger('picker:close');
    }

    picker.emit('local::close pickerClose', picker);
  }

  onClosed() {
    const picker = this;
    picker.opened = false;
    picker.closing = false;

    if (!picker.inline) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.nextTick)(() => {
        if (picker.modal && picker.modal.el && picker.modal.destroy) {
          if (!picker.params.routableModals) {
            picker.modal.destroy();
          }
        }

        delete picker.modal;
      });
    }

    if (picker.$el) {
      picker.$el.trigger('picker:closed');
    }

    if (picker.$inputEl) {
      picker.$inputEl.trigger('picker:closed');
    }

    picker.emit('local::closed pickerClosed', picker);
  }

  open() {
    const picker = this;
    const {
      app,
      opened,
      inline,
      $inputEl,
      $scrollToEl,
      params
    } = picker;
    if (opened) return;

    if (picker.cols.length === 0 && params.cols.length) {
      params.cols.forEach(col => {
        picker.cols.push(col);
      });
    }

    if (inline) {
      picker.$el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(picker.render());
      picker.$el[0].f7Picker = picker;
      picker.$containerEl.append(picker.$el);
      picker.onOpen();
      picker.onOpened();
      return;
    }

    const isPopover = picker.isPopover();
    const modalType = isPopover ? 'popover' : 'sheet';
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: $scrollToEl,
      content: picker.render(),
      backdrop: typeof params.backdrop !== 'undefined' ? params.backdrop : isPopover,
      on: {
        open() {
          const modal = this;
          picker.modal = modal;
          picker.$el = isPopover ? modal.$el.find('.picker') : modal.$el;
          picker.$el[0].f7Picker = picker;
          picker.onOpen();
        },

        opened() {
          picker.onOpened();
        },

        close() {
          picker.onClose();
        },

        closed() {
          picker.onClosed();
        }

      }
    };

    if (modalType === 'sheet') {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }

    if (params.routableModals && picker.view) {
      picker.view.router.navigate({
        url: picker.url,
        route: {
          path: picker.url,
          [modalType]: modalParams
        }
      });
    } else {
      picker.modal = app[modalType].create(modalParams);
      picker.modal.open();
    }
  }

  close() {
    const picker = this;
    const {
      opened,
      inline
    } = picker;
    if (!opened) return;

    if (inline) {
      picker.onClose();
      picker.onClosed();
      return;
    }

    if (picker.params.routableModals && picker.view) {
      picker.view.router.back();
    } else {
      picker.modal.close();
    }
  }

  init() {
    const picker = this;
    picker.initInput();

    if (picker.inline) {
      picker.open();
      picker.emit('local::init pickerInit', picker);
      return;
    }

    if (!picker.initialized && picker.params.value) {
      picker.setValue(picker.params.value);
    } // Attach input Events


    if (picker.$inputEl) {
      picker.attachInputEvents();
    }

    if (picker.params.closeByOutsideClick) {
      picker.attachHtmlEvents();
    }

    picker.emit('local::init pickerInit', picker);
  }

  destroy() {
    const picker = this;
    if (picker.destroyed) return;
    const {
      $el
    } = picker;
    picker.emit('local::beforeDestroy pickerBeforeDestroy', picker);
    if ($el) $el.trigger('picker:beforedestroy');
    picker.close(); // Detach Events

    if (picker.$inputEl) {
      picker.detachInputEvents();
    }

    if (picker.params.closeByOutsideClick) {
      picker.detachHtmlEvents();
    }

    if ($el && $el.length) delete picker.$el[0].f7Picker;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.deleteProps)(picker);
    picker.destroyed = true;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Picker);

/***/ }),

/***/ "./node_modules/framework7/components/picker/picker-column.js":
/*!********************************************************************!*\
  !*** ./node_modules/framework7/components/picker/picker-column.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pickerColumn)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");

function pickerColumn(colEl, updateItems) {
  const picker = this; // const app = picker.app;

  const $colEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(colEl);
  const colIndex = $colEl.index();
  const col = picker.cols[colIndex];
  if (col.divider) return;
  col.$el = $colEl;
  col.el = $colEl[0];
  col.$itemsEl = col.$el.find('.picker-items');
  col.items = col.$itemsEl.find('.picker-item');
  let itemHeight;
  let colHeight;

  col.replaceValues = function replaceColValues(values, displayValues) {
    col.detachEvents();
    col.values = values;
    col.displayValues = displayValues;
    col.$itemsEl.html(picker.renderColumn(col, true));
    col.items = col.$itemsEl.find('.picker-item');
    col.calcSize();
    col.setValue(col.values[0], true);
    col.attachEvents();
  };

  col.calcSize = function calcColSize() {
    colHeight = col.$el[0].offsetHeight;
    itemHeight = col.items[0].offsetHeight;
    const hadPadding = col.el.style.getPropertyValue('--f7-picker-scroll-padding');
    col.el.style.setProperty('--f7-picker-scroll-padding', `${(colHeight - itemHeight) / 2}px`);

    if (!hadPadding) {
      col.$itemsEl[0].scrollTop = 0;
    }
  };

  col.setValue = function setColValue(newValue, valueCallbacks) {
    const newActiveIndex = col.$itemsEl.find(`.picker-item[data-picker-value="${newValue}"]`).index();

    if (typeof newActiveIndex === 'undefined' || newActiveIndex === -1) {
      return;
    }

    const newScrollTop = newActiveIndex * itemHeight;
    col.$itemsEl[0].scrollTop = newScrollTop; // Update items

    col.updateItems(newActiveIndex, newScrollTop, valueCallbacks);
  };

  col.updateItems = function updateColItems(activeIndex, scrollTop, valueCallbacks) {
    if (typeof scrollTop === 'undefined') {
      // eslint-disable-next-line
      scrollTop = col.$itemsEl[0].scrollTop;
    }
    /* eslint-disable no-param-reassign */


    if (typeof activeIndex === 'undefined') {
      activeIndex = Math.round(scrollTop / itemHeight);
    }

    if (activeIndex < 0) activeIndex = 0;
    if (activeIndex >= col.items.length) activeIndex = col.items.length - 1;
    /* eslint-enable no-param-reassign */

    const previousActiveIndex = col.activeIndex;
    col.activeIndex = activeIndex;
    col.$itemsEl.find('.picker-item-selected').removeClass('picker-item-selected');
    const selectedItem = col.items.eq(activeIndex);
    selectedItem.addClass('picker-item-selected').children().transform(''); // Set 3D rotate effect

    if (picker.params.rotateEffect) {
      col.items.each(itemEl => {
        const $itemEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(itemEl);
        const itemOffset = itemEl.offsetTop - (colHeight - itemHeight) / 2 - scrollTop;
        const percentage = itemOffset / itemHeight;
        const itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;
        let angle = -24 * percentage;
        if (angle > 180) angle = 180;
        if (angle < -180) angle = -180;

        if (Math.abs(percentage) > itemsFit) {
          $itemEl.addClass('picker-item-far');
        } else {
          $itemEl.removeClass('picker-item-far');
        }

        $itemEl.children('span').transform(`translate3d(0, ${-percentage * itemHeight}px, -100px) rotateX(${angle}deg)`);
      });
    }

    if (valueCallbacks || typeof valueCallbacks === 'undefined') {
      // Update values
      col.value = selectedItem.attr('data-picker-value');
      col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value; // On change callback

      if (previousActiveIndex !== activeIndex) {
        if (col.onChange) {
          col.onChange(picker, col.value, col.displayValue);
        }

        picker.updateValue();
      }
    }
  };

  function handleScroll() {
    col.updateItems();
  }

  function handleClick() {
    const value = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).attr('data-picker-value');
    col.setValue(value);
  }

  col.attachEvents = function attachColEvents() {
    col.$itemsEl.on('scroll', handleScroll);
    col.items.on('click', handleClick);
  };

  col.detachEvents = function detachColEvents() {
    col.items.off('click', handleClick);
  };

  col.init = function initCol() {
    col.calcSize();
    if (colIndex === 0) col.$el.addClass('picker-column-first');
    if (colIndex === picker.cols.length - 1) col.$el.addClass('picker-column-last');
    if (picker.params.freeMode) col.$el.addClass('picker-column-free-mode'); // Update items on init

    if (updateItems) col.updateItems(0);
    col.attachEvents();
  };

  col.destroy = function destroyCol() {
    col.detachEvents();
  };

  col.init();
}

/***/ }),

/***/ "./node_modules/framework7/components/picker/picker.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7/components/picker/picker.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");
/* harmony import */ var _picker_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./picker-class.js */ "./node_modules/framework7/components/picker/picker-class.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'picker',
  static: {
    Picker: _picker_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.picker = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.picker',
      constructor: _picker_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7Picker'
    });

    app.picker.close = function close(el) {
      if (el === void 0) {
        el = '.picker';
      }

      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
      if ($el.length === 0) return;
      const picker = $el[0].f7Picker;
      if (!picker || picker && !picker.opened) return;
      picker.close();
    };
  },

  params: {
    picker: {
      // Picker settings
      rotateEffect: false,
      freeMode: false,
      cols: [],
      // Common opener settings
      containerEl: null,
      openIn: 'auto',
      // or 'popover' or 'sheet'
      sheetPush: false,
      sheetSwipeToClose: undefined,
      backdrop: undefined,
      // uses Popover or Sheet defaults
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      scrollToEl: undefined,
      toolbar: true,
      toolbarCloseText: 'Done',
      cssClass: null,
      routableModals: false,
      view: null,
      url: 'select/',
      // Render functions
      renderToolbar: null,
      render: null
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/popover/popover-class.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7/components/popover/popover-class.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modal/modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");






class Popover extends _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
      on: {}
    }, app.params.popover, params); // Extends with open/close Modal methods;

    super(app, extendedParams);
    const popover = this;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__.getDevice)();
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    popover.params = extendedParams; // Find Element

    let $el;

    if (!popover.params.el) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popover.params.content).filter(node => node.nodeType === 1).eq(0);
    } else {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popover.params.el).eq(0);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    } // Find Target


    const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popover.params.targetEl).eq(0);

    if ($el.length === 0) {
      return popover.destroy();
    } // Backdrop


    let $backdropEl;
    const forceBackdropUnique = popover.params.backdrop && app.$el.find('.popover.modal-in').filter(anotherPopoverEl => anotherPopoverEl !== $el[0]).length > 0;

    if (popover.params.backdrop && popover.params.backdropEl) {
      $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popover.params.backdropEl);
    } else if (popover.params.backdrop) {
      if (popover.params.backdropUnique || forceBackdropUnique) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="popover-backdrop popover-backdrop-unique"></div>');
        $backdropEl[0].f7PopoverRef = popover;
        popover.$containerEl.append($backdropEl);
      } else {
        $backdropEl = popover.$containerEl.children('.popover-backdrop');
      }

      if ($backdropEl.length === 0) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="popover-backdrop"></div>');
        popover.$containerEl.append($backdropEl);
      }
    } // Find Angle


    let $angleEl;

    if ($el.find('.popover-angle').length === 0) {
      $angleEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="popover-angle"></div>');
      $el.prepend($angleEl);
    } else {
      $angleEl = $el.find('.popover-angle');
    } // Open


    const originalOpen = popover.open;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(popover, {
      app,
      $el,
      el: $el[0],
      $targetEl,
      targetEl: $targetEl[0],
      $angleEl,
      angleEl: $angleEl[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'popover',
      forceBackdropUnique,

      open() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        let [targetEl, animate] = args;
        if (typeof args[0] === 'boolean') [animate, targetEl] = args;

        if (targetEl) {
          popover.$targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(targetEl);
          popover.targetEl = popover.$targetEl[0];
        }

        return originalOpen.call(popover, animate);
      }

    });

    function handleResize() {
      popover.resize();
    }

    popover.on('popoverOpen', () => {
      popover.resize();
      app.on('resize', handleResize);
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).on('keyboardDidShow keyboardDidHide', handleResize);
      popover.on('popoverClose popoverBeforeDestroy', () => {
        app.off('resize', handleResize);
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).off('keyboardDidShow keyboardDidHide', handleResize);
      });
    });
    let touchStartTarget = null;

    function handleTouchStart(e) {
      touchStartTarget = e.target;
    }

    function handleClick(e) {
      const target = e.target;
      const $target = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target);
      const keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened) return;

      if ($target.closest(popover.el).length === 0) {
        if (popover.params.closeByBackdropClick && popover.params.backdrop && popover.backdropEl && popover.backdropEl === target && touchStartTarget === target) {
          popover.close();
        } else if (popover.params.closeByOutsideClick && touchStartTarget === target) {
          const isAnotherPopoverBackdrop = $target.hasClass('popover-backdrop-unique') && target.f7PopoverRef !== popover || $target.hasClass('popover-backdrop') && target !== popover.backdropEl;
          const isAnotherPopoverTarget = target.closest('.popover') && target.closest('.popover') !== popover.$el[0];

          if (!isAnotherPopoverBackdrop && !isAnotherPopoverTarget) {
            popover.close();
          }
        }
      }
    }

    function onKeyDown(e) {
      const keyCode = e.keyCode;

      if (keyCode === 27 && popover.params.closeOnEscape) {
        popover.close();
      }
    }

    if (popover.params.closeOnEscape) {
      popover.on('popoverOpen', () => {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('keydown', onKeyDown);
      });
      popover.on('popoverClose', () => {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off('keydown', onKeyDown);
      });
    }

    popover.on('popoverOpened', () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.on('touchstart', handleTouchStart);
        app.on('click', handleClick);
      }
    });
    popover.on('popoverClose', () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.off('touchstart', handleTouchStart);
        app.off('click', handleClick);
      }
    });
    $el[0].f7Modal = popover;
    return popover;
  }

  resize() {
    const popover = this;
    const {
      app,
      $el,
      $targetEl,
      $angleEl
    } = popover;
    const {
      targetX,
      targetY,
      verticalPosition
    } = popover.params;
    $el.css({
      left: '',
      top: ''
    });
    const [width, height] = [$el.width(), $el.height()];
    let angleSize = 0;
    let angleLeft;
    let angleTop;

    if (app.theme === 'ios' || app.theme === 'aurora') {
      $angleEl.removeClass('on-left on-right on-top on-bottom').css({
        left: '',
        top: ''
      });
      angleSize = $angleEl.width() / 2;
    } else {
      $el.removeClass('popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle').css({
        left: '',
        top: ''
      });
    }

    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    let safeAreaTop = parseInt((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').css('--f7-safe-area-top'), 10);
    let safeAreaLeft = parseInt((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').css('--f7-safe-area-left'), 10);
    let safeAreaRight = parseInt((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').css('--f7-safe-area-right'), 10);
    if (Number.isNaN(safeAreaTop)) safeAreaTop = 0;
    if (Number.isNaN(safeAreaLeft)) safeAreaLeft = 0;
    if (Number.isNaN(safeAreaRight)) safeAreaRight = 0;

    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();
      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - app.left;
      targetOffsetTop = targetOffset.top - app.top;
      const targetParentPage = $targetEl.parents('.page');

      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    } else if (typeof targetX !== 'undefined' && targetY !== 'undefined') {
      targetOffsetLeft = targetX;
      targetOffsetTop = targetY;
      targetWidth = popover.params.targetWidth || 0;
      targetHeight = popover.params.targetHeight || 0;
    }

    let [left, top, diff] = [0, 0, 0]; // Top Position

    const forcedPosition = verticalPosition === 'auto' ? false : verticalPosition;
    let position = forcedPosition || (app.theme === 'md' ? 'bottom' : 'top');

    if (app.theme === 'md') {
      if (forcedPosition === 'bottom' || !forcedPosition && height < app.height - targetOffsetTop - targetHeight) {
        // On bottom
        position = 'bottom';
        top = targetOffsetTop + targetHeight;
      } else if (forcedPosition === 'top' || !forcedPosition && height < targetOffsetTop - safeAreaTop) {
        // On top
        top = targetOffsetTop - height;
        position = 'top';
      } else {
        // On middle
        position = 'middle';
        top = targetHeight / 2 + targetOffsetTop - height / 2;
      }

      top = Math.max(8, Math.min(top, app.height - height - 8)); // Horizontal Position

      let hPosition;

      if (targetOffsetLeft < app.width / 2) {
        hPosition = 'right';
        left = position === 'middle' ? targetOffsetLeft + targetWidth : targetOffsetLeft;
      } else {
        hPosition = 'left';
        left = position === 'middle' ? targetOffsetLeft - width : targetOffsetLeft + targetWidth - width;
      }

      left = Math.max(8, Math.min(left, app.width - width - 8 - safeAreaRight), safeAreaLeft);
      $el.addClass(`popover-on-${position} popover-on-${hPosition}`);
    } else {
      // ios and aurora
      if (forcedPosition === 'top' || !forcedPosition && height + angleSize < targetOffsetTop - safeAreaTop) {
        // On top
        top = targetOffsetTop - height - angleSize;
      } else if (forcedPosition === 'bottom' || !forcedPosition && height + angleSize < app.height - targetOffsetTop - targetHeight) {
        // On bottom
        position = 'bottom';
        top = targetOffsetTop + targetHeight + angleSize;
      } else {
        // On middle
        position = 'middle';
        top = targetHeight / 2 + targetOffsetTop - height / 2;
        diff = top;
        top = Math.max(5, Math.min(top, app.height - height - 5));
        diff -= top;
      } // Horizontal Position


      if (position === 'top' || position === 'bottom') {
        left = targetWidth / 2 + targetOffsetLeft - width / 2;
        diff = left;
        left = Math.max(5, Math.min(left, app.width - width - 5));

        if (safeAreaLeft) {
          left = Math.max(left, safeAreaLeft);
        }

        if (safeAreaRight && left + width > app.width - 5 - safeAreaRight) {
          left = app.width - 5 - safeAreaRight - width;
        }

        if (position === 'top') {
          $angleEl.addClass('on-bottom');
        }

        if (position === 'bottom') {
          $angleEl.addClass('on-top');
        }

        diff -= left;
        angleLeft = width / 2 - angleSize + diff;
        angleLeft = Math.max(Math.min(angleLeft, width - angleSize * 2 - 13), 13);
        $angleEl.css({
          left: `${angleLeft}px`
        });
      } else if (position === 'middle') {
        left = targetOffsetLeft - width - angleSize;
        $angleEl.addClass('on-right');

        if (left < 5 || left + width + safeAreaRight > app.width || left < safeAreaLeft) {
          if (left < 5) left = targetOffsetLeft + targetWidth + angleSize;
          if (left + width + safeAreaRight > app.width) left = app.width - width - 5 - safeAreaRight;
          if (left < safeAreaLeft) left = safeAreaLeft;
          $angleEl.removeClass('on-right').addClass('on-left');
        }

        angleTop = height / 2 - angleSize + diff;
        angleTop = Math.max(Math.min(angleTop, height - angleSize * 2 - 13), 13);
        $angleEl.css({
          top: `${angleTop}px`
        });
      }
    } // Apply Styles


    $el.css({
      top: `${top}px`,
      left: `${left}px`
    });
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Popover);

/***/ }),

/***/ "./node_modules/framework7/components/popover/popover.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/components/popover/popover.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _popover_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./popover-class.js */ "./node_modules/framework7/components/popover/popover-class.js");
/* harmony import */ var _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/modal-methods.js */ "./node_modules/framework7/shared/modal-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'popover',
  params: {
    popover: {
      verticalPosition: 'auto',
      backdrop: true,
      backdropEl: undefined,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeByOutsideClick: true,
      closeOnEscape: false,
      containerEl: null
    }
  },
  static: {
    Popover: _popover_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.popover = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)((0,_shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
      app,
      constructor: _popover_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      defaultSelector: '.popover.modal-in'
    }), {
      open(popoverEl, targetEl, animate) {
        let $popoverEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(popoverEl);

        if ($popoverEl.length > 1) {
          // check if same popover in other page
          const $targetPage = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(targetEl).parents('.page');

          if ($targetPage.length) {
            $popoverEl.each(el => {
              const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);

              if ($el.parents($targetPage)[0] === $targetPage[0]) {
                $popoverEl = $el;
              }
            });
          }
        }

        if ($popoverEl.length > 1) {
          $popoverEl = $popoverEl.eq($popoverEl.length - 1);
        }

        let popover = $popoverEl[0].f7Modal;
        const data = $popoverEl.dataset();

        if (!popover) {
          popover = new _popover_class_js__WEBPACK_IMPORTED_MODULE_1__["default"](app, Object.assign({
            el: $popoverEl,
            targetEl
          }, data));
        }

        return popover.open(targetEl, animate);
      }

    });
  },

  clicks: {
    '.popover-open': function openPopover($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.popover.open(data.popover, $clickedEl, data.animate);
    },
    '.popover-close': function closePopover($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.popover.close(data.popover, data.animate, $clickedEl);
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/popup/popup-class.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/popup/popup-class.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modal/modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");







class Popup extends _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
      on: {}
    }, app.params.popup, params); // Extends with open/close Modal methods;

    super(app, extendedParams);
    const popup = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_4__.getSupport)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_5__.getDevice)();
    popup.params = extendedParams; // Find Element

    let $el;

    if (!popup.params.el) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popup.params.content).filter(node => node.nodeType === 1).eq(0);
    } else {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popup.params.el).eq(0);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return popup.destroy();
    }

    let $backdropEl;

    if (popup.params.backdrop && popup.params.backdropEl) {
      $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popup.params.backdropEl);
    } else if (popup.params.backdrop) {
      if (popup.params.backdropUnique) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="popup-backdrop popup-backdrop-unique"></div>');
        popup.$containerEl.append($backdropEl);
      } else {
        $backdropEl = popup.$containerEl.children('.popup-backdrop');
      }

      if ($backdropEl.length === 0) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="popup-backdrop"></div>');
        popup.$containerEl.append($backdropEl);
      }
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(popup, {
      app,
      push: $el.hasClass('popup-push') || popup.params.push,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'popup',
      $htmlEl: (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html')
    });

    if (popup.params.push) {
      $el.addClass('popup-push');
    }

    function handleClick(e) {
      const target = e.target;
      const $target = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target);
      const keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened) return;

      if ($target.closest(popup.el).length === 0) {
        if (popup.params && popup.params.closeByBackdropClick && popup.params.backdrop && popup.backdropEl && popup.backdropEl === target) {
          let needToClose = true;
          popup.$el.nextAll('.popup.modal-in').each(popupEl => {
            const popupInstance = popupEl.f7Modal;
            if (!popupInstance) return;

            if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === popup.backdropEl) {
              needToClose = false;
            }
          });

          if (needToClose) {
            popup.close();
          }
        }
      }
    }

    function onKeyDown(e) {
      const keyCode = e.keyCode;

      if (keyCode === 27 && popup.params.closeOnEscape) {
        popup.close();
      }
    }

    let pushOffset;
    let isPush;

    function pushViewScale(offset) {
      return (app.height - offset * 2) / app.height;
    }

    let allowSwipeToClose = true;
    let isTouched = false;
    let startTouch;
    let currentTouch;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let isMoved = false;
    let pageContentEl;
    let pageContentScrollTop;
    let pageContentOffsetHeight;
    let pageContentScrollHeight;
    let popupHeight;
    let $pushEl;

    function handleTouchStart(e) {
      if (isTouched || !allowSwipeToClose || !popup.params.swipeToClose) return;

      if (popup.params.swipeHandler && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest(popup.params.swipeHandler).length === 0) {
        return;
      }

      isTouched = true;
      isMoved = false;
      startTouch = {
        x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY
      };
      touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.now)();
      isScrolling = undefined;

      if (!popup.params.swipeHandler && e.type === 'touchstart') {
        pageContentEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest('.page-content')[0];
      }
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      currentTouch = {
        x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY
      };

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
      }

      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }

      touchesDiff = startTouch.y - currentTouch.y;

      if (isPush && pushOffset && touchesDiff > 0) {
        touchesDiff = 0;
      }

      const direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';
      $el.transition(0);

      if (typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose) {
        $el.transform('');
        $el.transition('');
        return;
      }

      if (!isMoved) {
        if (isPush && pushOffset) {
          popupHeight = $el[0].offsetHeight;
          $pushEl = $el.prevAll('.popup.modal-in').eq(0);

          if ($pushEl.length === 0) {
            $pushEl = app.$el.children('.view, .views');
          }
        }

        if (pageContentEl) {
          pageContentScrollTop = pageContentEl.scrollTop;
          pageContentScrollHeight = pageContentEl.scrollHeight;
          pageContentOffsetHeight = pageContentEl.offsetHeight;

          if (!(pageContentScrollHeight === pageContentOffsetHeight) && !(direction === 'to-bottom' && pageContentScrollTop === 0) && !(direction === 'to-top' && pageContentScrollTop === pageContentScrollHeight - pageContentOffsetHeight)) {
            $el.transform('');
            $el.transition('');
            isTouched = false;
            isMoved = false;
            return;
          }
        }

        isMoved = true;
        popup.emit('local::swipeStart popupSwipeStart', popup);
        popup.$el.trigger('popup:swipestart');
      } else {
        popup.emit('local::swipeMove popupSwipeMove', popup);
        popup.$el.trigger('popup:swipemove');
      }

      e.preventDefault();

      if (isPush && pushOffset) {
        const pushProgress = 1 - Math.abs(touchesDiff / popupHeight);
        const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;

        if ($pushEl.hasClass('popup')) {
          if ($pushEl.hasClass('popup-push')) {
            $pushEl.transition(0).forEach(el => {
              el.style.setProperty('transform', `translate3d(0, calc(-1 * ${pushProgress} * (var(--f7-popup-push-offset) + 10px)) , 0px) scale(${scale})`, 'important');
            });
          } else {
            $pushEl.transition(0).forEach(el => {
              el.style.setProperty('transform', `translate3d(0, 0px , 0px) scale(${scale})`, 'important');
            });
          }
        } else {
          $pushEl.transition(0).forEach(el => {
            el.style.setProperty('transform', `translate3d(0,0,0) scale(${scale})`, 'important');
          });
        }
      }

      $el.transition(0).transform(`translate3d(0,${-touchesDiff}px,0)`);
    }

    function handleTouchEnd() {
      isTouched = false;

      if (!isMoved) {
        return;
      }

      popup.emit('local::swipeEnd popupSwipeEnd', popup);
      popup.$el.trigger('popup:swipeend');
      isMoved = false;
      allowSwipeToClose = false;
      $el.transition('');

      if (isPush && pushOffset) {
        $pushEl.transition('').transform('');
      }

      const direction = touchesDiff <= 0 ? 'to-bottom' : 'to-top';

      if (typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose) {
        $el.transform('');
        allowSwipeToClose = true;
        return;
      }

      const diff = Math.abs(touchesDiff);
      const timeDiff = new Date().getTime() - touchStartTime;

      if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > 100) {
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
          if (direction === 'to-bottom') {
            $el.addClass('swipe-close-to-bottom');
          } else {
            $el.addClass('swipe-close-to-top');
          }

          $el.transform('');
          popup.emit('local::swipeclose popupSwipeClose', popup);
          popup.$el.trigger('popup:swipeclose');
          popup.close();
          allowSwipeToClose = true;
        });
        return;
      }

      allowSwipeToClose = true;
      $el.transform('');
    }

    const passive = support.passiveListener ? {
      passive: true
    } : false;

    if (popup.params.swipeToClose) {
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      popup.once('popupDestroy', () => {
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off('touchmove', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      });
    }

    let hasPreviousPushPopup;

    const updatePushOffset = () => {
      const wasPush = isPush;

      if (popup.push) {
        isPush = popup.push && (app.width < 630 || app.height < 630 || $el.hasClass('popup-tablet-fullscreen'));
      }

      if (isPush && !wasPush) {
        // eslint-disable-next-line
        setPushOffset();
      } else if (isPush && wasPush) {
        popup.$htmlEl[0].style.setProperty('--f7-popup-push-scale', pushViewScale(pushOffset));
      } else if (!isPush && wasPush) {
        popup.$htmlEl.removeClass('with-modal-popup-push');
        popup.$htmlEl[0].style.removeProperty('--f7-popup-push-scale');
      }
    };

    const setPushOffset = () => {
      app.off('resize', updatePushOffset);

      if (popup.push) {
        isPush = popup.push && (app.width < 630 || app.height < 630 || $el.hasClass('popup-tablet-fullscreen'));
      }

      if (isPush) {
        pushOffset = parseInt($el.css('--f7-popup-push-offset'), 10);
        if (Number.isNaN(pushOffset)) pushOffset = 0;

        if (pushOffset) {
          $el.addClass('popup-push');
          popup.$htmlEl.addClass('with-modal-popup-push');
          popup.$htmlEl[0].style.setProperty('--f7-popup-push-scale', pushViewScale(pushOffset));
        }
      }

      app.on('resize', updatePushOffset);
    };

    popup.on('open', () => {
      hasPreviousPushPopup = false;

      if (popup.params.closeOnEscape) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('keydown', onKeyDown);
      }

      $el.prevAll('.popup.modal-in').addClass('popup-behind');
      setPushOffset();
    });
    popup.on('opened', () => {
      $el.removeClass('swipe-close-to-bottom swipe-close-to-top');

      if (popup.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    popup.on('close', () => {
      hasPreviousPushPopup = popup.$el.prevAll('.popup-push.modal-in').length > 0;

      if (popup.params.closeOnEscape) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off('keydown', onKeyDown);
      }

      if (popup.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }

      $el.prevAll('.popup.modal-in').eq(0).removeClass('popup-behind');

      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass('with-modal-popup-push');
        popup.$htmlEl.addClass('with-modal-popup-push-closing');
      }

      app.off('resize', updatePushOffset);
    });
    popup.on('closed', () => {
      $el.removeClass('popup-behind');

      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass('with-modal-popup-push-closing');
        popup.$htmlEl[0].style.removeProperty('--f7-popup-push-scale');
      }
    });
    $el[0].f7Modal = popup;
    return popup;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Popup);

/***/ }),

/***/ "./node_modules/framework7/components/popup/popup.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7/components/popup/popup.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _popup_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./popup-class.js */ "./node_modules/framework7/components/popup/popup-class.js");
/* harmony import */ var _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/modal-methods.js */ "./node_modules/framework7/shared/modal-methods.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'popup',
  params: {
    popup: {
      backdrop: true,
      backdropEl: undefined,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeOnEscape: false,
      swipeToClose: false,
      swipeHandler: null,
      push: false,
      containerEl: null
    }
  },
  static: {
    Popup: _popup_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;
    app.popup = (0,_shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
      app,
      constructor: _popup_class_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      defaultSelector: '.popup.modal-in',
      parentSelector: '.popup'
    });
  },

  clicks: {
    '.popup-open': function openPopup($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.popup.open(data.popup, data.animate, $clickedEl);
    },
    '.popup-close': function closePopup($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.popup.close(data.popup, data.animate, $clickedEl);
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/preloader/preloader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/preloader/preloader.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const Preloader = {
  init(el) {
    const app = this;
    const preloaders = {
      iosPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.iosPreloaderContent,
      mdPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.mdPreloaderContent,
      auroraPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.auroraPreloaderContent
    };
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    if ($el.length === 0 || $el.children('.preloader-inner').length > 0 || $el.children('.preloader-inner-line').length > 0) return;
    $el.append(preloaders[`${app.theme}PreloaderContent`]);
  },

  // Modal
  visible: false,

  show(color) {
    if (color === void 0) {
      color = 'white';
    }

    const app = this;
    if (Preloader.visible) return;
    const preloaders = {
      iosPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.iosPreloaderContent,
      mdPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.mdPreloaderContent,
      auroraPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.auroraPreloaderContent
    };
    const preloaderInner = preloaders[`${app.theme}PreloaderContent`] || '';
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('html').addClass('with-modal-preloader'); // prettier-ignore

    app.$el.append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
    Preloader.visible = true;
  },

  showIn(el, color) {
    if (color === void 0) {
      color = 'white';
    }

    const app = this;
    const preloaders = {
      iosPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.iosPreloaderContent,
      mdPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.mdPreloaderContent,
      auroraPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.auroraPreloaderContent
    };
    const preloaderInner = preloaders[`${app.theme}PreloaderContent`] || '';
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el || 'html').addClass('with-modal-preloader'); // prettier-ignore

    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el || app.$el).append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
  },

  hide() {
    const app = this;
    if (!Preloader.visible) return;
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('html').removeClass('with-modal-preloader');
    app.$el.find('.preloader-backdrop, .preloader-modal').remove();
    Preloader.visible = false;
  },

  hideIn(el) {
    const app = this;
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el || 'html').removeClass('with-modal-preloader');
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el || app.$el).find('.preloader-backdrop, .preloader-modal').remove();
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'preloader',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.bindMethods)(app, {
      preloader: Preloader
    });
  },

  on: {
    photoBrowserOpen(pb) {
      const app = this;
      pb.$el.find('.preloader').each(preloaderEl => {
        app.preloader.init(preloaderEl);
      });
    },

    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.preloader').each(preloaderEl => {
        app.preloader.init(preloaderEl);
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.preloader').each(preloaderEl => {
        app.preloader.init(preloaderEl);
      });
    }

  },
  vnode: {
    preloader: {
      insert(vnode) {
        const app = this;
        const preloaderEl = vnode.elm;
        app.preloader.init(preloaderEl);
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/progressbar/progressbar.js":
/*!***********************************************************************!*\
  !*** ./node_modules/framework7/components/progressbar/progressbar.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const Progressbar = {
  set() {
    const app = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    let [el, progress, duration] = args;

    if (typeof args[0] === 'number') {
      [progress, duration] = args;
      el = app.$el;
    }

    if (typeof progress === 'undefined' || progress === null) return el;
    if (!progress) progress = 0;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el || app.$el);

    if ($el.length === 0) {
      return el;
    }

    const progressNormalized = Math.min(Math.max(progress, 0), 100);
    let $progressbarEl;
    if ($el.hasClass('progressbar')) $progressbarEl = $el.eq(0);else {
      $progressbarEl = $el.children('.progressbar');
    }

    if ($progressbarEl.length === 0 || $progressbarEl.hasClass('progressbar-infinite')) {
      return $progressbarEl;
    }

    let $progressbarLine = $progressbarEl.children('span');

    if ($progressbarLine.length === 0) {
      $progressbarLine = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<span></span>');
      $progressbarEl.append($progressbarLine);
    }

    $progressbarLine.transition(typeof duration !== 'undefined' ? duration : '').transform(`translate3d(${(-100 + progressNormalized) * (app.rtl ? -1 : 1)}%,0,0)`);
    return $progressbarEl[0];
  },

  show() {
    const app = this; // '.page', 50, 'multi'

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    let [el, progress, color] = args;
    let type = 'determined';

    if (args.length === 2) {
      if ((typeof args[0] === 'string' || typeof args[0] === 'object') && typeof args[1] === 'string') {
        // '.page', 'multi'
        [el, color, progress] = args;
        type = 'infinite';
      } else if (typeof args[0] === 'number' && typeof args[1] === 'string') {
        // 50, 'multi'
        [progress, color] = args;
        el = app.$el;
      }
    } else if (args.length === 1) {
      if (typeof args[0] === 'number') {
        el = app.$el;
        progress = args[0];
      } else if (typeof args[0] === 'string') {
        type = 'infinite';
        el = app.$el;
        color = args[0];
      }
    } else if (args.length === 0) {
      type = 'infinite';
      el = app.$el;
    }

    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    if ($el.length === 0) return undefined;
    let $progressbarEl;

    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children('.progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)');

      if ($progressbarEl.length === 0) {
        $progressbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`
          <span class="progressbar${type === 'infinite' ? '-infinite' : ''}${color ? ` color-${color}` : ''} progressbar-in">
            ${type === 'infinite' ? '' : '<span></span>'}
          </span>`);
        $el.append($progressbarEl);
      }
    }

    if (typeof progress !== 'undefined') {
      app.progressbar.set($progressbarEl, progress);
    }

    return $progressbarEl[0];
  },

  hide(el, removeAfterHide) {
    if (removeAfterHide === void 0) {
      removeAfterHide = true;
    }

    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el || app.$el);
    if ($el.length === 0) return undefined;
    let $progressbarEl;

    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children('.progressbar, .progressbar-infinite');
    }

    if ($progressbarEl.length === 0 || !$progressbarEl.hasClass('progressbar-in') || $progressbarEl.hasClass('progressbar-out')) {
      return $progressbarEl;
    }

    $progressbarEl.removeClass('progressbar-in').addClass('progressbar-out').animationEnd(() => {
      if (removeAfterHide) {
        $progressbarEl.remove();
      }
    });
    return $progressbarEl;
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'progressbar',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.bindMethods)(app, {
      progressbar: Progressbar
    });
  },

  on: {
    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.progressbar').each(progressbarEl => {
        const $progressbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(progressbarEl);
        app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.progressbar').each(progressbarEl => {
        const $progressbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(progressbarEl);
        app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
      });
    }

  },
  vnode: {
    progressbar: {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        app.progressbar.set(el, el.getAttribute('data-progress'));
      },

      update(vnode) {
        const app = this;
        const el = vnode.elm;
        app.progressbar.set(el, el.getAttribute('data-progress'));
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/pull-to-refresh/pull-to-refresh-class.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/framework7/components/pull-to-refresh/pull-to-refresh-class.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");






class PullToRefresh extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, el) {
    super({}, [app]);
    const ptr = this;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__.getSupport)();
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    const $preloaderEl = $el.find('.ptr-preloader');
    ptr.$el = $el;
    ptr.el = $el[0];
    ptr.app = app;
    ptr.bottom = ptr.$el.hasClass('ptr-bottom'); // Extend defaults with modules params

    ptr.useModulesParams({});
    const isMaterial = app.theme === 'md';
    const isIos = app.theme === 'ios';
    const isAurora = app.theme === 'aurora'; // Done

    ptr.done = function done() {
      const $transitionTarget = isMaterial ? $preloaderEl : $el;

      const onTranstionEnd = e => {
        if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest($preloaderEl).length) return;
        $el.removeClass('ptr-transitioning ptr-pull-up ptr-pull-down ptr-closing');
        $el.trigger('ptr:done');
        ptr.emit('local::done ptrDone', $el[0]);
        $transitionTarget.off('transitionend', onTranstionEnd);
      };

      $transitionTarget.on('transitionend', onTranstionEnd);
      $el.removeClass('ptr-refreshing').addClass('ptr-transitioning ptr-closing');
      return ptr;
    };

    ptr.refresh = function refresh() {
      if ($el.hasClass('ptr-refreshing')) return ptr;
      $el.addClass('ptr-transitioning ptr-refreshing');
      $el.trigger('ptr:refresh', ptr.done);
      ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
      return ptr;
    }; // Mousewheel


    ptr.mousewheel = $el.attr('data-ptr-mousewheel') === 'true'; // Events handling

    let touchId;
    let isTouched;
    let isMoved;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let refresh = false;
    let useTranslate = false;
    let forceUseTranslate = false;
    let startTranslate = 0;
    let translate;
    let scrollTop;
    let wasScrolled;
    let triggerDistance;
    let dynamicTriggerDistance;
    let pullStarted;
    let hasNavbar = false;
    let scrollHeight;
    let offsetHeight;
    let maxScrollTop;
    const $pageEl = $el.parents('.page');
    if ($pageEl.find('.navbar').length > 0 || $pageEl.parents('.view').children('.navbars').length > 0) hasNavbar = true;
    if ($pageEl.hasClass('no-navbar')) hasNavbar = false;

    if (!ptr.bottom) {
      const pageNavbarEl = app.navbar.getElByPage($pageEl[0]);

      if (pageNavbarEl) {
        const $pageNavbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(pageNavbarEl);
        const isLargeTransparent = $pageNavbarEl.hasClass('navbar-large-transparent') || $pageNavbarEl.hasClass('navbar-large') && $pageNavbarEl.hasClass('navbar-transparent');
        const isTransparent = $pageNavbarEl.hasClass('navbar-transparent') && !$pageNavbarEl.hasClass('navbar-large');

        if (isLargeTransparent) {
          $el.addClass('ptr-with-navbar-large-transparent');
        } else if (isTransparent) {
          $el.addClass('ptr-with-navbar-transparent');
        }
      }
    }

    if (!hasNavbar && !ptr.bottom) $el.addClass('ptr-no-navbar'); // Define trigger distance

    if ($el.attr('data-ptr-distance')) {
      dynamicTriggerDistance = true;
    } else if (isMaterial) {
      triggerDistance = 66;
    } else if (isIos) {
      triggerDistance = 44;
    } else if (isAurora) {
      triggerDistance = 38;
    }

    function setPreloaderProgress(progress) {
      if (progress === void 0) {
        progress = 0;
      }

      const $bars = $preloaderEl.find('.preloader-inner-line');
      const perBarProgress = 1 / $bars.length;
      $bars.forEach((barEl, barIndex) => {
        const barProgress = (progress - barIndex * perBarProgress) / perBarProgress;
        barEl.style.opacity = Math.max(Math.min(barProgress, 1), 0) * 0.27;
      });
    }

    function unsetPreloaderProgress() {
      $preloaderEl.find('.preloader-inner-line').css('opacity', '');
    }

    function handleTouchStart(e) {
      if (isTouched) {
        if (device.os === 'android') {
          if ('targetTouches' in e && e.targetTouches.length > 1) return;
        } else return;
      }

      if ($el.hasClass('ptr-refreshing')) {
        return;
      }

      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) return;
      isMoved = false;
      pullStarted = false;
      isTouched = true;
      isScrolling = undefined;
      wasScrolled = undefined;
      if (e.type === 'touchstart') touchId = e.targetTouches[0].identifier;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      let pageX;
      let pageY;
      let touch;

      if (e.type === 'touchmove') {
        if (touchId && e.touches) {
          for (let i = 0; i < e.touches.length; i += 1) {
            if (e.touches[i].identifier === touchId) {
              touch = e.touches[i];
            }
          }
        }

        if (!touch) touch = e.targetTouches[0];
        pageX = touch.pageX;
        pageY = touch.pageY;
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      }

      if (!pageX || !pageY) return;

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }

      if (!isScrolling) {
        isTouched = false;
        return;
      }

      scrollTop = $el[0].scrollTop;

      if (!isMoved) {
        $el.removeClass('ptr-transitioning');

        if (isIos) {
          setPreloaderProgress(0);
        }

        let targetIsScrollable;
        scrollHeight = $el[0].scrollHeight;
        offsetHeight = $el[0].offsetHeight;

        if (ptr.bottom) {
          maxScrollTop = scrollHeight - offsetHeight;
        }

        if (scrollTop > scrollHeight) {
          isTouched = false;
          return;
        }

        const $ptrWatchScrollable = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.ptr-watch-scroll');

        if ($ptrWatchScrollable.length) {
          $ptrWatchScrollable.each(ptrScrollableEl => {
            if (ptrScrollableEl === el) return;

            if (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ptrScrollableEl).css('overflow') === 'auto' && (!ptr.bottom && ptrScrollableEl.scrollTop > 0 || ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)) {
              targetIsScrollable = true;
            }
          });
        }

        if (targetIsScrollable) {
          isTouched = false;
          return;
        }

        if (dynamicTriggerDistance) {
          triggerDistance = $el.attr('data-ptr-distance');
          if (triggerDistance.indexOf('%') >= 0) triggerDistance = scrollHeight * parseInt(triggerDistance, 10) / 100;
        }

        startTranslate = $el.hasClass('ptr-refreshing') ? triggerDistance : 0;

        if (scrollHeight === offsetHeight || device.os !== 'ios' || isMaterial) {
          useTranslate = true;
        } else {
          useTranslate = false;
        }

        forceUseTranslate = false;
      }

      isMoved = true;
      touchesDiff = pageY - touchesStart.y;
      if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) wasScrolled = true;
      const ptrStarted = ptr.bottom ? touchesDiff < 0 && scrollTop >= maxScrollTop || scrollTop > maxScrollTop : touchesDiff > 0 && scrollTop <= 0 || scrollTop < 0;

      if (ptrStarted) {
        // iOS 8 fix
        if (device.os === 'ios' && parseInt(device.osVersion.split('.')[0], 10) > 7) {
          if (!ptr.bottom && scrollTop === 0 && !wasScrolled) useTranslate = true;
          if (ptr.bottom && scrollTop === maxScrollTop && !wasScrolled) useTranslate = true;
        }

        if (!useTranslate && ptr.bottom && !isMaterial) {
          $el.css('-webkit-overflow-scrolling', 'auto');
          $el.scrollTop(maxScrollTop);
          forceUseTranslate = true;
        }

        if (useTranslate || forceUseTranslate) {
          if (e.cancelable) {
            e.preventDefault();
          }

          translate = (ptr.bottom ? -1 * Math.abs(touchesDiff) ** 0.85 : touchesDiff ** 0.85) + startTranslate;

          if (isMaterial) {
            $preloaderEl.transform(`translate3d(0,${translate}px,0)`).find('.ptr-arrow').transform(`rotate(${180 * (Math.abs(touchesDiff) / 66) + 100}deg)`);
          } else {
            // eslint-disable-next-line
            if (ptr.bottom || isIos) {
              $el.children().transform(`translate3d(0,${translate}px,0)`);
            } else {
              // eslint-disable-next-line
              $el.transform(`translate3d(0,${translate}px,0)`);
            }

            if (isIos) {
              $preloaderEl.transform(`translate3d(0,0px,0)`);
            }
          }
        } else if (isIos && !ptr.bottom) {
          $preloaderEl.transform(`translate3d(0,${scrollTop}px,0)`);
        }

        let progress;

        if (isIos && !refresh) {
          progress = useTranslate || forceUseTranslate ? Math.abs(touchesDiff) ** 0.85 / triggerDistance : Math.abs(touchesDiff) / (triggerDistance * 2);
          setPreloaderProgress(progress);
        }

        if ((useTranslate || forceUseTranslate) && Math.abs(touchesDiff) ** 0.85 > triggerDistance || !useTranslate && Math.abs(touchesDiff) >= triggerDistance * 2) {
          refresh = true;
          $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
          unsetPreloaderProgress();
        } else {
          refresh = false;
          $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
        }

        if (!pullStarted) {
          $el.trigger('ptr:pullstart');
          ptr.emit('local::pullStart ptrPullStart', $el[0]);
          pullStarted = true;
        }

        $el.trigger('ptr:pullmove', {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
        ptr.emit('local::pullMove ptrPullMove', $el[0], {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
      } else {
        pullStarted = false;
        $el.removeClass('ptr-pull-up ptr-pull-down');
        refresh = false;
      }
    }

    function handleTouchEnd(e) {
      if (e.type === 'touchend' && e.changedTouches && e.changedTouches.length > 0 && touchId) {
        if (e.changedTouches[0].identifier !== touchId) {
          isTouched = false;
          isScrolling = false;
          isMoved = false;
          touchId = null;
          return;
        }
      }

      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }

      if (translate) {
        $el.addClass('ptr-transitioning');
        translate = 0;
      }

      if (isMaterial) {
        $preloaderEl.transform('').find('.ptr-arrow').transform('');
      } else {
        $preloaderEl.transform('');

        if (ptr.bottom || isIos) {
          $el.children().transform('');
        } else {
          $el.transform('');
        }
      }

      if (!useTranslate && ptr.bottom && !isMaterial) {
        $el.css('-webkit-overflow-scrolling', '');
      }

      if (refresh) {
        $el.addClass('ptr-refreshing');
        $el.trigger('ptr:refresh', ptr.done);
        ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
      } else {
        $el.removeClass('ptr-pull-down');
      }

      isTouched = false;
      isMoved = false;

      if (pullStarted) {
        $el.trigger('ptr:pullend');
        ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
      }
    }

    let mousewheelTimeout;
    let mousewheelMoved;
    let mousewheelAllow = true;
    let mousewheelTranslate = 0;

    function handleMouseWheelRelease() {
      mousewheelAllow = true;
      mousewheelMoved = false;
      mousewheelTranslate = 0;

      if (translate) {
        $el.addClass('ptr-transitioning');
        translate = 0;
      }

      if (isMaterial) {
        $preloaderEl.transform('').find('.ptr-arrow').transform('');
      } else {
        $preloaderEl.transform('');

        if (ptr.bottom) {
          $el.children().transform('');
        } else {
          $el.transform('');
        }
      }

      if (refresh) {
        $el.addClass('ptr-refreshing');
        $el.trigger('ptr:refresh', ptr.done);
        ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
      } else {
        $el.removeClass('ptr-pull-down');
      }

      if (pullStarted) {
        $el.trigger('ptr:pullend');
        ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
      }
    }

    function handleMouseWheel(e) {
      if (!mousewheelAllow) return;
      const {
        deltaX,
        deltaY
      } = e;
      if (Math.abs(deltaX) > Math.abs(deltaY)) return;

      if ($el.hasClass('ptr-refreshing')) {
        return;
      }

      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) return;
      clearTimeout(mousewheelTimeout);
      scrollTop = $el[0].scrollTop;

      if (!mousewheelMoved) {
        $el.removeClass('ptr-transitioning');

        if (isIos) {
          setPreloaderProgress(0);
        }

        let targetIsScrollable;
        scrollHeight = $el[0].scrollHeight;
        offsetHeight = $el[0].offsetHeight;

        if (ptr.bottom) {
          maxScrollTop = scrollHeight - offsetHeight;
        }

        if (scrollTop > scrollHeight) {
          mousewheelAllow = false;
          return;
        }

        const $ptrWatchScrollable = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.ptr-watch-scroll');

        if ($ptrWatchScrollable.length) {
          $ptrWatchScrollable.each(ptrScrollableEl => {
            if (ptrScrollableEl === el) return;

            if (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ptrScrollableEl).css('overflow') === 'auto' && (!ptr.bottom && ptrScrollableEl.scrollTop > 0 || ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)) {
              targetIsScrollable = true;
            }
          });
        }

        if (targetIsScrollable) {
          mousewheelAllow = false;
          return;
        }

        if (dynamicTriggerDistance) {
          triggerDistance = $el.attr('data-ptr-distance');
          if (triggerDistance.indexOf('%') >= 0) triggerDistance = scrollHeight * parseInt(triggerDistance, 10) / 100;
        }
      }

      isMoved = true;
      mousewheelTranslate -= deltaY;
      touchesDiff = mousewheelTranslate; // pageY - touchesStart.y;

      if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) wasScrolled = true;
      const ptrStarted = ptr.bottom ? touchesDiff < 0 && scrollTop >= maxScrollTop || scrollTop > maxScrollTop : touchesDiff > 0 && scrollTop <= 0 || scrollTop < 0;

      if (ptrStarted) {
        if (e.cancelable) {
          e.preventDefault();
        }

        translate = touchesDiff;

        if (Math.abs(translate) > triggerDistance) {
          translate = triggerDistance + (Math.abs(translate) - triggerDistance) ** 0.7;
          if (ptr.bottom) translate = -translate;
        }

        if (isMaterial) {
          $preloaderEl.transform(`translate3d(0,${translate}px,0)`).find('.ptr-arrow').transform(`rotate(${180 * (Math.abs(touchesDiff) / 66) + 100}deg)`);
        } else {
          // eslint-disable-next-line
          if (ptr.bottom) {
            $el.children().transform(`translate3d(0,${translate}px,0)`);
          } else {
            $el.transform(`translate3d(0,${translate}px,0)`);

            if (isIos) {
              $preloaderEl.transform(`translate3d(0,${-translate}px,0)`);
            }
          }
        }

        let progress;

        if (isIos && !refresh) {
          progress = Math.abs(translate) / triggerDistance;
          setPreloaderProgress(progress);
        }

        if (Math.abs(translate) > triggerDistance) {
          refresh = true;
          $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
          unsetPreloaderProgress();
        } else {
          refresh = false;
          $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
        }

        if (!pullStarted) {
          $el.trigger('ptr:pullstart');
          ptr.emit('local::pullStart ptrPullStart', $el[0]);
          pullStarted = true;
        }

        $el.trigger('ptr:pullmove', {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
        ptr.emit('local::pullMove ptrPullMove', $el[0], {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
      } else {
        pullStarted = false;
        $el.removeClass('ptr-pull-up ptr-pull-down');
        refresh = false;
      }

      mousewheelTimeout = setTimeout(handleMouseWheelRelease, 300);
    }

    if (!$pageEl.length || !$el.length) return ptr;
    $el[0].f7PullToRefresh = ptr; // Events

    ptr.attachEvents = function attachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);

      if (ptr.mousewheel && !ptr.bottom) {
        $el.on('wheel', handleMouseWheel);
      }
    };

    ptr.detachEvents = function detachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);

      if (ptr.mousewheel && !ptr.bottom) {
        $el.off('wheel', handleMouseWheel);
      }
    }; // Install Modules


    ptr.useModules(); // Init

    ptr.init();
    return ptr;
  }

  init() {
    const ptr = this;
    ptr.attachEvents();
  }

  destroy() {
    let ptr = this;
    ptr.emit('local::beforeDestroy ptrBeforeDestroy', ptr);
    ptr.$el.trigger('ptr:beforedestroy');
    delete ptr.el.f7PullToRefresh;
    ptr.detachEvents();
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.deleteProps)(ptr);
    ptr = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PullToRefresh);

/***/ }),

/***/ "./node_modules/framework7/components/pull-to-refresh/pull-to-refresh.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/pull-to-refresh/pull-to-refresh.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _pull_to_refresh_class_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pull-to-refresh-class.js */ "./node_modules/framework7/components/pull-to-refresh/pull-to-refresh-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'pullToRefresh',

  create() {
    const app = this;
    app.ptr = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.ptr-content',
      constructor: _pull_to_refresh_class_js__WEBPACK_IMPORTED_MODULE_3__["default"],
      app,
      domProp: 'f7PullToRefresh'
    }), {
      done(el) {
        const ptr = app.ptr.get(el);
        if (ptr) return ptr.done();
        return undefined;
      },

      refresh(el) {
        const ptr = app.ptr.get(el);
        if (ptr) return ptr.refresh();
        return undefined;
      }

    });
  },

  static: {
    PullToRefresh: _pull_to_refresh_class_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl);
      const $ptrEls = $tabEl.find('.ptr-content');
      if ($tabEl.is('.ptr-content')) $ptrEls.add($tabEl);
      $ptrEls.each(el => {
        app.ptr.create(el);
      });
    },

    tabBeforeRemove(tabEl) {
      const $tabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl);
      const app = this;
      const $ptrEls = $tabEl.find('.ptr-content');
      if ($tabEl.is('.ptr-content')) $ptrEls.add($tabEl);
      $ptrEls.each(el => {
        app.ptr.destroy(el);
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.ptr-content').each(el => {
        app.ptr.create(el);
      });
    },

    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.ptr-content').each(el => {
        app.ptr.destroy(el);
      });
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/components/radio/radio.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7/components/radio/radio.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'radio'
});

/***/ }),

/***/ "./node_modules/framework7/components/range/range-class.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/range/range-class.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");





class Range extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    super(params, [app]);
    const range = this;
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)();
    const defaults = {
      el: null,
      inputEl: null,
      dual: false,
      step: 1,
      label: false,
      min: 0,
      max: 100,
      value: 0,
      draggableBar: true,
      vertical: false,
      verticalReversed: false,
      formatLabel: null,
      scale: false,
      scaleSteps: 5,
      scaleSubSteps: 0,
      formatScaleLabel: null,
      limitKnobPosition: app.theme === 'ios'
    }; // Extend defaults with modules params

    range.useModulesParams(defaults);
    range.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(defaults, params);
    const el = range.params.el;
    if (!el) return range;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    if ($el.length === 0) return range;
    if ($el[0].f7Range) return $el[0].f7Range;
    const dataset = $el.dataset();
    'step min max value scaleSteps scaleSubSteps'.split(' ').forEach(paramName => {
      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
        range.params[paramName] = parseFloat(dataset[paramName]);
      }
    });
    'dual label vertical verticalReversed scale'.split(' ').forEach(paramName => {
      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
        range.params[paramName] = dataset[paramName];
      }
    });

    if (!range.params.value) {
      if (typeof dataset.value !== 'undefined') range.params.value = dataset.value;

      if (typeof dataset.valueLeft !== 'undefined' && typeof dataset.valueRight !== 'undefined') {
        range.params.value = [parseFloat(dataset.valueLeft), parseFloat(dataset.valueRight)];
      }
    }

    let $inputEl;

    if (!range.params.dual) {
      if (range.params.inputEl) {
        $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(range.params.inputEl);
      } else if ($el.find('input[type="range"]').length) {
        $inputEl = $el.find('input[type="range"]').eq(0);
      }
    }

    const {
      dual,
      step,
      label,
      min,
      max,
      value,
      vertical,
      verticalReversed,
      scale,
      scaleSteps,
      scaleSubSteps,
      limitKnobPosition
    } = range.params;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(range, {
      app,
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : undefined,
      dual,
      step,
      label,
      min,
      max,
      value,
      previousValue: value,
      vertical,
      verticalReversed,
      scale,
      scaleSteps,
      scaleSubSteps,
      limitKnobPosition
    });

    if ($inputEl) {
      'step min max'.split(' ').forEach(paramName => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          range.params[paramName] = parseFloat($inputEl.attr(paramName));
          range[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });

      if (typeof $inputEl.val() !== 'undefined') {
        range.params.value = parseFloat($inputEl.val());
        range.value = parseFloat($inputEl.val());
      }
    } // Dual


    if (range.dual) {
      $el.addClass('range-slider-dual');
    }

    if (range.label) {
      $el.addClass('range-slider-label');
    } // Vertical


    if (range.vertical) {
      $el.addClass('range-slider-vertical');

      if (range.verticalReversed) {
        $el.addClass('range-slider-vertical-reversed');
      }
    } else {
      $el.addClass('range-slider-horizontal');
    } // Check for layout


    const $barEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="range-bar"></div>');
    const $barActiveEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="range-bar-active"></div>');
    $barEl.append($barActiveEl); // Create Knobs
    // prettier-ignore

    const knobHTML = `
      <div class="range-knob-wrap">
        <div class="range-knob"></div>
        ${range.label ? '<div class="range-knob-label"></div>' : ''}
      </div>
    `;
    const knobs = [(0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(knobHTML)];

    if (range.dual) {
      knobs.push((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(knobHTML));
    }

    $el.append($barEl);
    knobs.forEach($knobEl => {
      $el.append($knobEl);
    }); // Labels

    const labels = [];

    if (range.label) {
      labels.push(knobs[0].find('.range-knob-label'));

      if (range.dual) {
        labels.push(knobs[1].find('.range-knob-label'));
      }
    } // Scale


    let $scaleEl;

    if (range.scale && range.scaleSteps >= 1) {
      $scaleEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`
        <div class="range-scale">
          ${range.renderScale()}
        </div>
      `);
      $el.append($scaleEl);
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(range, {
      knobs,
      labels,
      $barEl,
      $barActiveEl,
      $scaleEl
    });
    $el[0].f7Range = range; // Touch Events

    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let rangeOffset;
    let rangeOffsetLeft;
    let rangeOffsetTop;
    let $touchedKnobEl;
    let dualValueIndex;
    let valueChangedByTouch;
    let targetTouchIdentifier;

    function onTouchChange() {
      valueChangedByTouch = true;
    }

    function handleTouchStart(e) {
      if (isTouched) return;

      if (!range.params.draggableBar) {
        if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.range-knob').length === 0) {
          return;
        }
      }

      valueChangedByTouch = false;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;

      if (e.type === 'touchstart') {
        targetTouchIdentifier = e.targetTouches[0].identifier;
      }

      isTouched = true;
      isScrolling = undefined;
      rangeOffset = $el.offset();
      rangeOffsetLeft = rangeOffset.left;
      rangeOffsetTop = rangeOffset.top;
      let progress;

      if (range.vertical) {
        progress = (touchesStart.y - rangeOffsetTop) / range.rangeHeight;
        if (!range.verticalReversed) progress = 1 - progress;
      } else if (range.app.rtl) {
        progress = (rangeOffsetLeft + range.rangeWidth - touchesStart.x) / range.rangeWidth;
      } else {
        progress = (touchesStart.x - rangeOffsetLeft) / range.rangeWidth;
      }

      let newValue = progress * (range.max - range.min) + range.min;

      if (range.dual) {
        if (Math.abs(range.value[0] - newValue) < Math.abs(range.value[1] - newValue)) {
          dualValueIndex = 0;
          $touchedKnobEl = range.knobs[0];
          newValue = [newValue, range.value[1]];
        } else {
          dualValueIndex = 1;
          $touchedKnobEl = range.knobs[1];
          newValue = [range.value[0], newValue];
        }
      } else {
        $touchedKnobEl = range.knobs[0];
        newValue = progress * (range.max - range.min) + range.min;
      }

      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
        if (isTouched) $touchedKnobEl.addClass('range-knob-active-state');
      }, 70);
      range.on('change', onTouchChange);
      range.setValue(newValue, true);
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      let pageX;
      let pageY;

      if (e.type === 'touchmove') {
        for (let i = 0; i < e.targetTouches.length; i += 1) {
          if (e.targetTouches[i].identifier === targetTouchIdentifier) {
            pageX = e.targetTouches[i].pageX;
            pageY = e.targetTouches[i].pageY;
          }
        }
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      }

      if (typeof pageX === 'undefined' && typeof pageY === 'undefined') return;

      if (typeof isScrolling === 'undefined' && !range.vertical) {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }

      if (isScrolling) {
        isTouched = false;
        return;
      }

      e.preventDefault();
      let progress;

      if (range.vertical) {
        progress = (pageY - rangeOffsetTop) / range.rangeHeight;
        if (!range.verticalReversed) progress = 1 - progress;
      } else if (range.app.rtl) {
        progress = (rangeOffsetLeft + range.rangeWidth - pageX) / range.rangeWidth;
      } else {
        progress = (pageX - rangeOffsetLeft) / range.rangeWidth;
      }

      let newValue = progress * (range.max - range.min) + range.min;

      if (range.dual) {
        let leftValue;
        let rightValue;

        if (dualValueIndex === 0) {
          leftValue = newValue;
          rightValue = range.value[1];

          if (leftValue > rightValue) {
            rightValue = leftValue;
          }
        } else {
          leftValue = range.value[0];
          rightValue = newValue;

          if (rightValue < leftValue) {
            leftValue = rightValue;
          }
        }

        newValue = [leftValue, rightValue];
      }

      range.setValue(newValue, true);
    }

    function handleTouchEnd(e) {
      if (e.type === 'touchend') {
        let touchEnded;

        for (let i = 0; i < e.changedTouches.length; i += 1) {
          if (e.changedTouches[i].identifier === targetTouchIdentifier) touchEnded = true;
        }

        if (!touchEnded) return;
      }

      if (!isTouched) {
        if (isScrolling) $touchedKnobEl.removeClass('range-knob-active-state');
        isTouched = false;
        return;
      }

      range.off('change', onTouchChange);
      isTouched = false;
      $touchedKnobEl.removeClass('range-knob-active-state');

      if (valueChangedByTouch && range.$inputEl && !range.dual) {
        range.$inputEl.trigger('change');
      }

      valueChangedByTouch = false;

      if (typeof range.previousValue !== 'undefined') {
        if (range.dual && (range.previousValue[0] !== range.value[0] || range.previousValue[1] !== range.value[1]) || !range.dual && range.previousValue !== range.value) {
          range.$el.trigger('range:changed', range.value);
          range.emit('local::changed rangeChanged', range, range.value);
        }
      }
    }

    function handleResize() {
      range.calcSize();
      range.layout();
    }

    let parentModals;
    let parentPanel;
    let parentPage;

    range.attachEvents = function attachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      range.$el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('tabShow', handleResize);
      app.on('resize', handleResize);
      parentModals = range.$el.parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast');
      parentModals.on('modal:open', handleResize);
      parentPanel = range.$el.parents('.panel');
      parentPanel.on('panel:open panel:resize', handleResize);
      parentPage = range.$el.parents('.page').eq(0);
      parentPage.on('page:reinit', handleResize);
    };

    range.detachEvents = function detachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      range.$el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off('touchmove', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('tabShow', handleResize);
      app.off('resize', handleResize);

      if (parentModals) {
        parentModals.off('modal:open', handleResize);
      }

      if (parentPanel) {
        parentPanel.off('panel:open panel:resize', handleResize);
      }

      if (parentPage) {
        parentPage.off('page:reinit', handleResize);
      }

      parentModals = null;
      parentPanel = null;
      parentPage = null;
    }; // Install Modules


    range.useModules(); // Init

    range.init();
    return range;
  }

  calcSize() {
    const range = this;

    if (range.vertical) {
      const height = range.$el.outerHeight();
      if (height === 0) return;
      range.rangeHeight = height;
      range.knobHeight = range.knobs[0].outerHeight();
    } else {
      const width = range.$el.outerWidth();
      if (width === 0) return;
      range.rangeWidth = width;
      range.knobWidth = range.knobs[0].outerWidth();
    }
  }

  layout() {
    const range = this;
    const {
      app,
      knobWidth,
      knobHeight,
      rangeWidth,
      rangeHeight,
      min,
      max,
      knobs,
      $barActiveEl,
      value,
      label,
      labels,
      vertical,
      verticalReversed,
      limitKnobPosition
    } = range;
    const knobSize = vertical ? knobHeight : knobWidth;
    const rangeSize = vertical ? rangeHeight : rangeWidth; // eslint-disable-next-line

    const positionProperty = vertical ? verticalReversed ? 'top' : 'bottom' : app.rtl ? 'right' : 'left';

    if (range.dual) {
      const progress = [(value[0] - min) / (max - min), (value[1] - min) / (max - min)];
      $barActiveEl.css({
        [positionProperty]: `${progress[0] * 100}%`,
        [vertical ? 'height' : 'width']: `${(progress[1] - progress[0]) * 100}%`
      });
      knobs.forEach(($knobEl, knobIndex) => {
        let startPos = rangeSize * progress[knobIndex];

        if (limitKnobPosition) {
          const realStartPos = rangeSize * progress[knobIndex] - knobSize / 2;
          if (realStartPos < 0) startPos = knobSize / 2;
          if (realStartPos + knobSize > rangeSize) startPos = rangeSize - knobSize / 2;
        }

        $knobEl.css(positionProperty, `${startPos}px`);
        if (label) labels[knobIndex].text(range.formatLabel(value[knobIndex], labels[knobIndex][0]));
      });
    } else {
      const progress = (value - min) / (max - min);
      $barActiveEl.css(vertical ? 'height' : 'width', `${progress * 100}%`);
      let startPos = rangeSize * progress;

      if (limitKnobPosition) {
        const realStartPos = rangeSize * progress - knobSize / 2;
        if (realStartPos < 0) startPos = knobSize / 2;
        if (realStartPos + knobSize > rangeSize) startPos = rangeSize - knobSize / 2;
      }

      knobs[0].css(positionProperty, `${startPos}px`);
      if (label) labels[0].text(range.formatLabel(value, labels[0][0]));
    }

    if (range.dual && value.indexOf(min) >= 0 || !range.dual && value === min) {
      range.$el.addClass('range-slider-min');
    } else {
      range.$el.removeClass('range-slider-min');
    }

    if (range.dual && value.indexOf(max) >= 0 || !range.dual && value === max) {
      range.$el.addClass('range-slider-max');
    } else {
      range.$el.removeClass('range-slider-max');
    }
  }

  setValue(newValue, byTouchMove) {
    const range = this;
    const {
      step,
      min,
      max
    } = range;
    let valueChanged;
    let oldValue;

    if (range.dual) {
      oldValue = [range.value[0], range.value[1]];
      let newValues = newValue;
      if (!Array.isArray(newValues)) newValues = [newValue, newValue];

      if (newValue[0] > newValue[1]) {
        newValues = [newValues[0], newValues[0]];
      }

      newValues = newValues.map(value => Math.max(Math.min(Math.round(value / step) * step, max), min));

      if (newValues[0] === range.value[0] && newValues[1] === range.value[1]) {
        return range;
      }

      newValues.forEach((value, valueIndex) => {
        range.value[valueIndex] = value;
      });
      valueChanged = oldValue[0] !== newValues[0] || oldValue[1] !== newValues[1];
      range.layout();
    } else {
      oldValue = range.value;
      const value = Math.max(Math.min(Math.round(newValue / step) * step, max), min);
      range.value = value;
      range.layout();
      valueChanged = oldValue !== value;
    }

    if (valueChanged) {
      range.previousValue = oldValue;
    } // Events


    if (!valueChanged) return range;
    range.$el.trigger('range:change', range.value);

    if (range.$inputEl && !range.dual) {
      range.$inputEl.val(range.value);

      if (!byTouchMove) {
        range.$inputEl.trigger('input change');
      } else {
        range.$inputEl.trigger('input');
      }
    }

    if (!byTouchMove) {
      range.$el.trigger('range:changed', range.value);
      range.emit('local::changed rangeChanged', range, range.value);
    }

    range.emit('local::change rangeChange', range, range.value);
    return range;
  }

  getValue() {
    return this.value;
  }

  formatLabel(value, labelEl) {
    const range = this;
    if (range.params.formatLabel) return range.params.formatLabel.call(range, value, labelEl);
    return value;
  }

  formatScaleLabel(value) {
    const range = this;
    if (range.params.formatScaleLabel) return range.params.formatScaleLabel.call(range, value);
    return value;
  }

  renderScale() {
    const range = this;
    const {
      app,
      verticalReversed,
      vertical
    } = range; // eslint-disable-next-line

    const positionProperty = vertical ? verticalReversed ? 'top' : 'bottom' : app.rtl ? 'right' : 'left';
    let html = '';
    Array.from({
      length: range.scaleSteps + 1
    }).forEach((scaleEl, index) => {
      const scaleStepValue = (range.max - range.min) / range.scaleSteps;
      const scaleValue = range.min + scaleStepValue * index;
      const progress = (scaleValue - range.min) / (range.max - range.min);
      html += `<div class="range-scale-step" style="${positionProperty}: ${progress * 100}%">${range.formatScaleLabel(scaleValue)}</div>`;

      if (range.scaleSubSteps && range.scaleSubSteps > 1 && index < range.scaleSteps) {
        Array.from({
          length: range.scaleSubSteps - 1
        }).forEach((subStepEl, subIndex) => {
          const subStep = scaleStepValue / range.scaleSubSteps;
          const scaleSubValue = scaleValue + subStep * (subIndex + 1);
          const subProgress = (scaleSubValue - range.min) / (range.max - range.min);
          html += `<div class="range-scale-step range-scale-substep" style="${positionProperty}: ${subProgress * 100}%"></div>`;
        });
      }
    });
    return html;
  }

  updateScale() {
    const range = this;

    if (!range.scale || range.scaleSteps < 1) {
      if (range.$scaleEl) range.$scaleEl.remove();
      delete range.$scaleEl;
      return;
    }

    if (!range.$scaleEl) {
      range.$scaleEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="range-scale"></div>');
      range.$el.append(range.$scaleEl);
    }

    range.$scaleEl.html(range.renderScale());
  }

  init() {
    const range = this;
    range.calcSize();
    range.layout();
    range.attachEvents();
    return range;
  }

  destroy() {
    let range = this;
    range.$el.trigger('range:beforedestroy');
    range.emit('local::beforeDestroy rangeBeforeDestroy', range);
    delete range.$el[0].f7Range;
    range.detachEvents();
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.deleteProps)(range);
    range = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Range);

/***/ }),

/***/ "./node_modules/framework7/components/range/range.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7/components/range/range.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _range_class_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./range-class.js */ "./node_modules/framework7/components/range/range-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'range',

  create() {
    const app = this;
    app.range = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.range-slider',
      constructor: _range_class_js__WEBPACK_IMPORTED_MODULE_3__["default"],
      app,
      domProp: 'f7Range'
    }), {
      getValue(el) {
        if (el === void 0) {
          el = '.range-slider';
        }

        const range = app.range.get(el);
        if (range) return range.getValue();
        return undefined;
      },

      setValue(el, value) {
        if (el === void 0) {
          el = '.range-slider';
        }

        const range = app.range.get(el);
        if (range) return range.setValue(value);
        return undefined;
      }

    });
  },

  static: {
    Range: _range_class_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.range-slider-init').each(rangeEl => new _range_class_js__WEBPACK_IMPORTED_MODULE_3__["default"](app, {
        el: rangeEl
      }));
    },

    tabBeforeRemove(tabEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.range-slider-init').each(rangeEl => {
        if (rangeEl.f7Range) rangeEl.f7Range.destroy();
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.range-slider-init').each(rangeEl => new _range_class_js__WEBPACK_IMPORTED_MODULE_3__["default"](app, {
        el: rangeEl
      }));
    },

    pageBeforeRemove(page) {
      page.$el.find('.range-slider-init').each(rangeEl => {
        if (rangeEl.f7Range) rangeEl.f7Range.destroy();
      });
    }

  },
  vnode: {
    'range-slider-init': {
      insert(vnode) {
        const rangeEl = vnode.elm;
        const app = this;
        app.range.create({
          el: rangeEl
        });
      },

      destroy(vnode) {
        const rangeEl = vnode.elm;
        if (rangeEl.f7Range) rangeEl.f7Range.destroy();
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/searchbar/remove-diacritics.js":
/*!***************************************************************************!*\
  !*** ./node_modules/framework7/components/searchbar/remove-diacritics.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint no-control-regex: "off" */
const defaultDiacriticsRemovalap = [{
  base: 'A',
  letters: '\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F'
}, {
  base: 'AA',
  letters: '\uA732'
}, {
  base: 'AE',
  letters: '\u00C6\u01FC\u01E2'
}, {
  base: 'AO',
  letters: '\uA734'
}, {
  base: 'AU',
  letters: '\uA736'
}, {
  base: 'AV',
  letters: '\uA738\uA73A'
}, {
  base: 'AY',
  letters: '\uA73C'
}, {
  base: 'B',
  letters: '\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181'
}, {
  base: 'C',
  letters: '\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E'
}, {
  base: 'D',
  letters: '\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779'
}, {
  base: 'DZ',
  letters: '\u01F1\u01C4'
}, {
  base: 'Dz',
  letters: '\u01F2\u01C5'
}, {
  base: 'E',
  letters: '\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E'
}, {
  base: 'F',
  letters: '\u0046\u24BB\uFF26\u1E1E\u0191\uA77B'
}, {
  base: 'G',
  letters: '\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E'
}, {
  base: 'H',
  letters: '\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D'
}, {
  base: 'I',
  letters: '\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197'
}, {
  base: 'J',
  letters: '\u004A\u24BF\uFF2A\u0134\u0248'
}, {
  base: 'K',
  letters: '\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2'
}, {
  base: 'L',
  letters: '\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780'
}, {
  base: 'LJ',
  letters: '\u01C7'
}, {
  base: 'Lj',
  letters: '\u01C8'
}, {
  base: 'M',
  letters: '\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C'
}, {
  base: 'N',
  letters: '\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4'
}, {
  base: 'NJ',
  letters: '\u01CA'
}, {
  base: 'Nj',
  letters: '\u01CB'
}, {
  base: 'O',
  letters: '\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C'
}, {
  base: 'OI',
  letters: '\u01A2'
}, {
  base: 'OO',
  letters: '\uA74E'
}, {
  base: 'OU',
  letters: '\u0222'
}, {
  base: 'OE',
  letters: '\u008C\u0152'
}, {
  base: 'oe',
  letters: '\u009C\u0153'
}, {
  base: 'P',
  letters: '\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754'
}, {
  base: 'Q',
  letters: '\u0051\u24C6\uFF31\uA756\uA758\u024A'
}, {
  base: 'R',
  letters: '\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782'
}, {
  base: 'S',
  letters: '\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784'
}, {
  base: 'T',
  letters: '\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786'
}, {
  base: 'TZ',
  letters: '\uA728'
}, {
  base: 'U',
  letters: '\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244'
}, {
  base: 'V',
  letters: '\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245'
}, {
  base: 'VY',
  letters: '\uA760'
}, {
  base: 'W',
  letters: '\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72'
}, {
  base: 'X',
  letters: '\u0058\u24CD\uFF38\u1E8A\u1E8C'
}, {
  base: 'Y',
  letters: '\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE'
}, {
  base: 'Z',
  letters: '\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762'
}, {
  base: 'a',
  letters: '\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250'
}, {
  base: 'aa',
  letters: '\uA733'
}, {
  base: 'ae',
  letters: '\u00E6\u01FD\u01E3'
}, {
  base: 'ao',
  letters: '\uA735'
}, {
  base: 'au',
  letters: '\uA737'
}, {
  base: 'av',
  letters: '\uA739\uA73B'
}, {
  base: 'ay',
  letters: '\uA73D'
}, {
  base: 'b',
  letters: '\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253'
}, {
  base: 'c',
  letters: '\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184'
}, {
  base: 'd',
  letters: '\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A'
}, {
  base: 'dz',
  letters: '\u01F3\u01C6'
}, {
  base: 'e',
  letters: '\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD'
}, {
  base: 'f',
  letters: '\u0066\u24D5\uFF46\u1E1F\u0192\uA77C'
}, {
  base: 'g',
  letters: '\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F'
}, {
  base: 'h',
  letters: '\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265'
}, {
  base: 'hv',
  letters: '\u0195'
}, {
  base: 'i',
  letters: '\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131'
}, {
  base: 'j',
  letters: '\u006A\u24D9\uFF4A\u0135\u01F0\u0249'
}, {
  base: 'k',
  letters: '\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3'
}, {
  base: 'l',
  letters: '\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747'
}, {
  base: 'lj',
  letters: '\u01C9'
}, {
  base: 'm',
  letters: '\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F'
}, {
  base: 'n',
  letters: '\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5'
}, {
  base: 'nj',
  letters: '\u01CC'
}, {
  base: 'o',
  letters: '\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275'
}, {
  base: 'oi',
  letters: '\u01A3'
}, {
  base: 'ou',
  letters: '\u0223'
}, {
  base: 'oo',
  letters: '\uA74F'
}, {
  base: 'p',
  letters: '\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755'
}, {
  base: 'q',
  letters: '\u0071\u24E0\uFF51\u024B\uA757\uA759'
}, {
  base: 'r',
  letters: '\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783'
}, {
  base: 's',
  letters: '\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B'
}, {
  base: 't',
  letters: '\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787'
}, {
  base: 'tz',
  letters: '\uA729'
}, {
  base: 'u',
  letters: '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289'
}, {
  base: 'v',
  letters: '\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C'
}, {
  base: 'vy',
  letters: '\uA761'
}, {
  base: 'w',
  letters: '\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73'
}, {
  base: 'x',
  letters: '\u0078\u24E7\uFF58\u1E8B\u1E8D'
}, {
  base: 'y',
  letters: '\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF'
}, {
  base: 'z',
  letters: '\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763'
}];
const diacriticsMap = {};

for (let i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
  const letters = defaultDiacriticsRemovalap[i].letters;

  for (let j = 0; j < letters.length; j += 1) {
    diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
  }
}

function removeDiacritics(str) {
  return str.replace(/[^\u0000-\u007E]/g, a => diacriticsMap[a] || a);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (removeDiacritics);

/***/ }),

/***/ "./node_modules/framework7/components/searchbar/searchbar-class.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7/components/searchbar/searchbar-class.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _remove_diacritics_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./remove-diacritics.js */ "./node_modules/framework7/components/searchbar/remove-diacritics.js");







class Searchbar extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const sb = this;
    const defaults = {
      el: undefined,
      inputEl: undefined,
      inputEvents: 'change input compositionend',
      disableButton: true,
      disableButtonEl: undefined,
      backdropEl: undefined,
      searchContainer: undefined,
      // container to search, HTMLElement or CSS selector
      searchItem: 'li',
      // single item selector, CSS selector
      searchIn: undefined,
      // where to search in item, CSS selector
      searchGroup: '.list-group',
      searchGroupTitle: '.item-divider, .list-group-title',
      ignore: '.searchbar-ignore',
      foundEl: '.searchbar-found',
      notFoundEl: '.searchbar-not-found',
      hideOnEnableEl: '.searchbar-hide-on-enable',
      hideOnSearchEl: '.searchbar-hide-on-search',
      backdrop: undefined,
      removeDiacritics: true,
      customSearch: false,
      hideDividers: true,
      hideGroups: true,
      disableOnBackdropClick: true,
      expandable: false,
      inline: false
    }; // Extend defaults with modules params

    sb.useModulesParams(defaults);
    sb.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(defaults, params);
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sb.params.el);
    if ($el.length === 0) return sb;
    if ($el[0].f7Searchbar) return $el[0].f7Searchbar;
    $el[0].f7Searchbar = sb;
    let $pageEl;
    const $navbarEl = $el.parents('.navbar');

    if ($el.parents('.page').length > 0) {
      $pageEl = $el.parents('.page');
    } else if ($navbarEl.length > 0) {
      $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getPageByEl($navbarEl[0]));

      if (!$pageEl.length) {
        const $currentPageEl = $el.parents('.view').find('.page-current');

        if ($currentPageEl[0] && $currentPageEl[0].f7Page && $currentPageEl[0].f7Page.navbarEl === $navbarEl[0]) {
          $pageEl = $currentPageEl;
        }
      }
    }

    let $foundEl;

    if (params.foundEl) {
      $foundEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.foundEl);
    } else if (typeof sb.params.foundEl === 'string' && $pageEl) {
      $foundEl = $pageEl.find(sb.params.foundEl);
    }

    let $notFoundEl;

    if (params.notFoundEl) {
      $notFoundEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.notFoundEl);
    } else if (typeof sb.params.notFoundEl === 'string' && $pageEl) {
      $notFoundEl = $pageEl.find(sb.params.notFoundEl);
    }

    let $hideOnEnableEl;

    if (params.hideOnEnableEl) {
      $hideOnEnableEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.hideOnEnableEl);
    } else if (typeof sb.params.hideOnEnableEl === 'string' && $pageEl) {
      $hideOnEnableEl = $pageEl.find(sb.params.hideOnEnableEl);
    }

    let $hideOnSearchEl;

    if (params.hideOnSearchEl) {
      $hideOnSearchEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.hideOnSearchEl);
    } else if (typeof sb.params.hideOnSearchEl === 'string' && $pageEl) {
      $hideOnSearchEl = $pageEl.find(sb.params.hideOnSearchEl);
    }

    const expandable = sb.params.expandable || $el.hasClass('searchbar-expandable');
    const inline = sb.params.inline || $el.hasClass('searchbar-inline');

    if (typeof sb.params.backdrop === 'undefined') {
      if (!inline) sb.params.backdrop = app.theme !== 'aurora';else sb.params.backdrop = false;
    }

    let $backdropEl;

    if (sb.params.backdrop) {
      if (sb.params.backdropEl) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sb.params.backdropEl);
      } else if ($pageEl && $pageEl.length > 0) {
        $backdropEl = $pageEl.find('.searchbar-backdrop');
      } else {
        $backdropEl = $el.siblings('.searchbar-backdrop');
      }

      if ($backdropEl.length === 0) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="searchbar-backdrop"></div>');

        if ($pageEl && $pageEl.length) {
          if ($el.parents($pageEl).length > 0 && $navbarEl && $el.parents($navbarEl).length === 0) {
            $backdropEl.insertBefore($el);
          } else {
            $backdropEl.insertBefore($pageEl.find('.page-content').eq(0));
          }
        } else {
          $backdropEl.insertBefore($el);
        }
      }
    }

    let $searchContainer;

    if (sb.params.searchContainer) {
      $searchContainer = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sb.params.searchContainer);
    }

    let $inputEl;

    if (sb.params.inputEl) {
      $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sb.params.inputEl);
    } else {
      $inputEl = $el.find('input[type="search"]').eq(0);
    }

    let $disableButtonEl;

    if (sb.params.disableButton) {
      if (sb.params.disableButtonEl) {
        $disableButtonEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sb.params.disableButtonEl);
      } else {
        $disableButtonEl = $el.find('.searchbar-disable-button');
      }
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(sb, {
      app,
      view: app.views.get($el.parents('.view')),
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      $searchContainer,
      searchContainer: $searchContainer && $searchContainer[0],
      $inputEl,
      inputEl: $inputEl[0],
      $disableButtonEl,
      disableButtonEl: $disableButtonEl && $disableButtonEl[0],
      disableButtonHasMargin: false,
      $pageEl,
      pageEl: $pageEl && $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl && $navbarEl[0],
      $foundEl,
      foundEl: $foundEl && $foundEl[0],
      $notFoundEl,
      notFoundEl: $notFoundEl && $notFoundEl[0],
      $hideOnEnableEl,
      hideOnEnableEl: $hideOnEnableEl && $hideOnEnableEl[0],
      $hideOnSearchEl,
      hideOnSearchEl: $hideOnSearchEl && $hideOnSearchEl[0],
      previousQuery: '',
      query: '',
      isVirtualList: $searchContainer && $searchContainer.hasClass('virtual-list'),
      virtualList: undefined,
      enabled: false,
      expandable,
      inline
    }); // Events

    function preventSubmit(e) {
      e.preventDefault();
    }

    function onInputFocus(e) {
      sb.enable(e);
      sb.$el.addClass('searchbar-focused');
    }

    function onInputBlur() {
      sb.$el.removeClass('searchbar-focused');

      if (app.theme === 'aurora' && (!$disableButtonEl || !$disableButtonEl.length || !sb.params.disableButton) && !sb.query) {
        sb.disable();
      }
    }

    function onInputChange() {
      const value = sb.$inputEl.val().trim();

      if (sb.$searchContainer && sb.$searchContainer.length > 0 && (sb.params.searchIn || sb.isVirtualList || sb.params.searchIn === sb.params.searchItem) || sb.params.customSearch) {
        sb.search(value, true);
      }
    }

    function onInputClear(e, previousValue) {
      sb.$el.trigger('searchbar:clear', previousValue);
      sb.emit('local::clear searchbarClear', sb, previousValue);
    }

    function disableOnClick(e) {
      sb.disable(e);
    }

    function onPageBeforeOut() {
      if (!sb || sb && !sb.$el) return;

      if (sb.enabled) {
        sb.$el.removeClass('searchbar-enabled');

        if (sb.expandable) {
          sb.$el.parents('.navbar').removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition');
        }
      }
    }

    function onPageBeforeIn() {
      if (!sb || sb && !sb.$el) return;

      if (sb.enabled) {
        sb.$el.addClass('searchbar-enabled');

        if (sb.expandable) {
          sb.$el.parents('.navbar').addClass('with-searchbar-expandable-enabled-no-transition');
        }
      }
    }

    sb.attachEvents = function attachEvents() {
      $el.on('submit', preventSubmit);

      if (sb.params.disableButton) {
        sb.$disableButtonEl.on('click', disableOnClick);
      }

      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.on('click', disableOnClick);
      }

      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
        sb.$pageEl.on('page:beforeout', onPageBeforeOut);
        sb.$pageEl.on('page:beforein', onPageBeforeIn);
      }

      sb.$inputEl.on('focus', onInputFocus);
      sb.$inputEl.on('blur', onInputBlur);
      sb.$inputEl.on(sb.params.inputEvents, onInputChange);
      sb.$inputEl.on('input:clear', onInputClear);
    };

    sb.detachEvents = function detachEvents() {
      $el.off('submit', preventSubmit);

      if (sb.params.disableButton) {
        sb.$disableButtonEl.off('click', disableOnClick);
      }

      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.off('click', disableOnClick);
      }

      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
        sb.$pageEl.off('page:beforeout', onPageBeforeOut);
        sb.$pageEl.off('page:beforein', onPageBeforeIn);
      }

      sb.$inputEl.off('focus', onInputFocus);
      sb.$inputEl.off('blur', onInputBlur);
      sb.$inputEl.off(sb.params.inputEvents, onInputChange);
      sb.$inputEl.off('input:clear', onInputClear);
    }; // Install Modules


    sb.useModules(); // Init

    sb.init();
    return sb;
  }

  clear(e) {
    const sb = this;

    if (!sb.query && e && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).hasClass('searchbar-clear')) {
      sb.disable();
      return sb;
    }

    const previousQuery = sb.value;
    sb.$inputEl.val('').trigger('change').focus();
    sb.$el.trigger('searchbar:clear', previousQuery);
    sb.emit('local::clear searchbarClear', sb, previousQuery);
    return sb;
  }

  setDisableButtonMargin() {
    const sb = this;
    if (sb.expandable) return;
    const app = sb.app;
    sb.$disableButtonEl.transition(0).show();
    sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, `${-sb.disableButtonEl.offsetWidth}px`);
    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */

    sb._clientLeft = sb.$disableButtonEl[0].clientLeft;
    sb.$disableButtonEl.transition('');
    sb.disableButtonHasMargin = true;
  }

  enable(setFocus) {
    const sb = this;
    if (sb.enabled) return sb;
    const app = sb.app;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__.getDevice)();
    sb.enabled = true;

    function enable() {
      if (sb.$backdropEl && (sb.$searchContainer && sb.$searchContainer.length || sb.params.customSearch) && !sb.$el.hasClass('searchbar-enabled') && !sb.query) {
        sb.backdropShow();
      }

      sb.$el.addClass('searchbar-enabled');

      if (!sb.$disableButtonEl || sb.$disableButtonEl && sb.$disableButtonEl.length === 0) {
        sb.$el.addClass('searchbar-enabled-no-disable-button');
      }

      if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
        if (!sb.disableButtonHasMargin) {
          sb.setDisableButtonMargin();
        }

        sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, '0px');
      }

      if (sb.expandable) {
        const $navbarEl = sb.$el.parents('.navbar');

        if ($navbarEl.hasClass('navbar-large') && sb.$pageEl) {
          const $pageContentEl = sb.$pageEl.find('.page-content');
          const $titleLargeEl = $navbarEl.find('.title-large');
          $pageContentEl.addClass('with-searchbar-expandable-enabled');

          if ($navbarEl.hasClass('navbar-large') && $navbarEl.hasClass('navbar-large-collapsed') && $titleLargeEl.length && $pageContentEl.length) {
            $pageContentEl.transition(0);
            $pageContentEl[0].scrollTop -= $titleLargeEl[0].offsetHeight;
            setTimeout(() => {
              $pageContentEl.transition('');
            }, 200);
          }
        }

        if (app.theme === 'md' && $navbarEl.length) {
          $navbarEl.addClass('with-searchbar-expandable-enabled');
        } else {
          $navbarEl.addClass('with-searchbar-expandable-enabled');

          if ($navbarEl.hasClass('navbar-large')) {
            $navbarEl.addClass('navbar-large-collapsed');
          }
        }
      }

      if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.addClass('hidden-by-searchbar');
      sb.$el.trigger('searchbar:enable');
      sb.emit('local::enable searchbarEnable', sb);
    }

    let needsFocus = false;

    if (setFocus === true) {
      if (document.activeElement !== sb.inputEl) {
        needsFocus = true;
      }
    }

    const isIos = device.ios && app.theme === 'ios';

    if (isIos) {
      if (sb.expandable) {
        if (needsFocus) sb.$inputEl.focus();
        enable();
      } else {
        if (needsFocus) sb.$inputEl.focus();

        if (setFocus && (setFocus.type === 'focus' || setFocus === true)) {
          (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
            enable();
          }, 400);
        } else {
          enable();
        }
      }
    } else {
      if (needsFocus) sb.$inputEl.focus();

      if (app.theme === 'md' && sb.expandable) {
        sb.$el.parents('.page, .view, .navbar-inner, .navbar').scrollLeft(app.rtl ? 100 : 0);
      }

      enable();
    }

    return sb;
  }

  disable() {
    const sb = this;
    if (!sb.enabled) return sb;
    const app = sb.app;
    sb.$inputEl.val('').trigger('change');
    sb.$el.removeClass('searchbar-enabled searchbar-focused searchbar-enabled-no-disable-button');

    if (sb.expandable) {
      const $navbarEl = sb.$el.parents('.navbar');
      const $pageContentEl = sb.$pageEl && sb.$pageEl.find('.page-content');

      if ($navbarEl.hasClass('navbar-large') && $pageContentEl.length) {
        const $titleLargeEl = $navbarEl.find('.title-large');
        sb.$el.transitionEnd(() => {
          $pageContentEl.removeClass('with-searchbar-expandable-closing');
        });

        if ($navbarEl.hasClass('navbar-large') && $navbarEl.hasClass('navbar-large-collapsed') && $titleLargeEl.length) {
          const scrollTop = $pageContentEl[0].scrollTop;
          const titleLargeHeight = $titleLargeEl[0].offsetHeight;

          if (scrollTop > titleLargeHeight) {
            $pageContentEl.transition(0);
            $pageContentEl[0].scrollTop = scrollTop + titleLargeHeight;
            setTimeout(() => {
              $pageContentEl.transition('');
            }, 200);
          }
        }

        $pageContentEl.removeClass('with-searchbar-expandable-enabled').addClass('with-searchbar-expandable-closing');
      }

      if (app.theme === 'md' && $navbarEl.length) {
        $navbarEl.removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition').addClass('with-searchbar-expandable-closing');
        sb.$el.transitionEnd(() => {
          $navbarEl.removeClass('with-searchbar-expandable-closing');
        });
      } else {
        $navbarEl.removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition').addClass('with-searchbar-expandable-closing');
        sb.$el.transitionEnd(() => {
          $navbarEl.removeClass('with-searchbar-expandable-closing');
        });

        if (sb.$pageEl) {
          sb.$pageEl.find('.page-content').trigger('scroll');
        }
      }
    }

    if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
      sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, `${-sb.disableButtonEl.offsetWidth}px`);
    }

    if (sb.$backdropEl && (sb.$searchContainer && sb.$searchContainer.length || sb.params.customSearch)) {
      sb.backdropHide();
    }

    sb.enabled = false;
    sb.$inputEl.blur();
    if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.removeClass('hidden-by-searchbar');
    sb.$el.trigger('searchbar:disable');
    sb.emit('local::disable searchbarDisable', sb);
    return sb;
  }

  toggle() {
    const sb = this;
    if (sb.enabled) sb.disable();else sb.enable(true);
    return sb;
  }

  backdropShow() {
    const sb = this;

    if (sb.$backdropEl) {
      sb.$backdropEl.addClass('searchbar-backdrop-in');
    }

    return sb;
  }

  backdropHide() {
    const sb = this;

    if (sb.$backdropEl) {
      sb.$backdropEl.removeClass('searchbar-backdrop-in');
    }

    return sb;
  }

  search(query, internal) {
    const sb = this;
    sb.previousQuery = sb.query || '';
    if (query === sb.previousQuery) return sb;

    if (!internal) {
      if (!sb.enabled) {
        sb.enable();
      }

      sb.$inputEl.val(query);
      sb.$inputEl.trigger('input');
    }

    sb.query = query;
    sb.value = query;
    const {
      $searchContainer,
      $el,
      $foundEl,
      $notFoundEl,
      $hideOnSearchEl,
      isVirtualList
    } = sb; // Hide on search element

    if (query.length > 0 && $hideOnSearchEl) {
      $hideOnSearchEl.addClass('hidden-by-searchbar');
    } else if ($hideOnSearchEl) {
      $hideOnSearchEl.removeClass('hidden-by-searchbar');
    } // Add active/inactive classes on overlay


    if ($searchContainer && $searchContainer.length && $el.hasClass('searchbar-enabled') || sb.params.customSearch && $el.hasClass('searchbar-enabled')) {
      if (query.length === 0) {
        sb.backdropShow();
      } else {
        sb.backdropHide();
      }
    }

    if (sb.params.customSearch) {
      $el.trigger('searchbar:search', {
        query,
        previousQuery: sb.previousQuery
      });
      sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
      return sb;
    }

    let foundItems = [];
    let vlQuery;

    if (isVirtualList) {
      sb.virtualList = $searchContainer[0].f7VirtualList;

      if (query.trim() === '') {
        sb.virtualList.resetFilter();
        if ($notFoundEl) $notFoundEl.hide();
        if ($foundEl) $foundEl.show();
        $el.trigger('searchbar:search', {
          query,
          previousQuery: sb.previousQuery
        });
        sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
        return sb;
      }

      vlQuery = sb.params.removeDiacritics ? (0,_remove_diacritics_js__WEBPACK_IMPORTED_MODULE_5__["default"])(query) : query;

      if (sb.virtualList.params.searchAll) {
        foundItems = sb.virtualList.params.searchAll(vlQuery, sb.virtualList.items) || [];
      } else if (sb.virtualList.params.searchByItem) {
        for (let i = 0; i < sb.virtualList.items.length; i += 1) {
          if (sb.virtualList.params.searchByItem(vlQuery, sb.virtualList.items[i], i)) {
            foundItems.push(i);
          }
        }
      }
    } else {
      let values;
      if (sb.params.removeDiacritics) values = (0,_remove_diacritics_js__WEBPACK_IMPORTED_MODULE_5__["default"])(query.trim().toLowerCase()).split(' ');else {
        values = query.trim().toLowerCase().split(' ');
      }
      $searchContainer.find(sb.params.searchItem).removeClass('hidden-by-searchbar').each(itemEl => {
        const $itemEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(itemEl);
        let compareWithText = [];
        let $searchIn = sb.params.searchIn ? $itemEl.find(sb.params.searchIn) : $itemEl;

        if (sb.params.searchIn === sb.params.searchItem) {
          $searchIn = $itemEl;
        }

        $searchIn.each(searchInEl => {
          let itemText = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(searchInEl).text().trim().toLowerCase();
          if (sb.params.removeDiacritics) itemText = (0,_remove_diacritics_js__WEBPACK_IMPORTED_MODULE_5__["default"])(itemText);
          compareWithText.push(itemText);
        });
        compareWithText = compareWithText.join(' ');
        let wordsMatch = 0;

        for (let i = 0; i < values.length; i += 1) {
          if (compareWithText.indexOf(values[i]) >= 0) wordsMatch += 1;
        }

        if (wordsMatch !== values.length && !(sb.params.ignore && $itemEl.is(sb.params.ignore))) {
          $itemEl.addClass('hidden-by-searchbar');
        } else {
          foundItems.push($itemEl[0]);
        }
      });

      if (sb.params.hideDividers) {
        $searchContainer.find(sb.params.searchGroupTitle).each(titleEl => {
          const $titleEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(titleEl);
          const $nextElements = $titleEl.nextAll(sb.params.searchItem);
          let hide = true;

          for (let i = 0; i < $nextElements.length; i += 1) {
            const $nextEl = $nextElements.eq(i);
            if ($nextEl.is(sb.params.searchGroupTitle)) break;

            if (!$nextEl.hasClass('hidden-by-searchbar')) {
              hide = false;
            }
          }

          const ignore = sb.params.ignore && $titleEl.is(sb.params.ignore);
          if (hide && !ignore) $titleEl.addClass('hidden-by-searchbar');else $titleEl.removeClass('hidden-by-searchbar');
        });
      }

      if (sb.params.hideGroups) {
        $searchContainer.find(sb.params.searchGroup).each(groupEl => {
          const $groupEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(groupEl);
          const ignore = sb.params.ignore && $groupEl.is(sb.params.ignore); // eslint-disable-next-line

          const notHidden = $groupEl.find(sb.params.searchItem).filter(el => {
            return !(0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el).hasClass('hidden-by-searchbar');
          });

          if (notHidden.length === 0 && !ignore) {
            $groupEl.addClass('hidden-by-searchbar');
          } else {
            $groupEl.removeClass('hidden-by-searchbar');
          }
        });
      }
    }

    if (foundItems.length === 0) {
      if ($notFoundEl) $notFoundEl.show();
      if ($foundEl) $foundEl.hide();
    } else {
      if ($notFoundEl) $notFoundEl.hide();
      if ($foundEl) $foundEl.show();
    }

    if (isVirtualList && sb.virtualList) {
      sb.virtualList.filterItems(foundItems);
    }

    $el.trigger('searchbar:search', {
      query,
      previousQuery: sb.previousQuery,
      foundItems
    });
    sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery, foundItems);
    return sb;
  }

  init() {
    const sb = this;
    if (sb.expandable && sb.$el) sb.$el.addClass('searchbar-expandable');
    if (sb.inline && sb.$el) sb.$el.addClass('searchbar-inline');
    sb.attachEvents();
  }

  destroy() {
    const sb = this;
    sb.emit('local::beforeDestroy searchbarBeforeDestroy', sb);
    sb.$el.trigger('searchbar:beforedestroy');
    sb.detachEvents();

    if (sb.$el[0]) {
      sb.$el[0].f7Searchbar = null;
      delete sb.$el[0].f7Searchbar;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.deleteProps)(sb);
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Searchbar);

/***/ }),

/***/ "./node_modules/framework7/components/searchbar/searchbar.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/searchbar/searchbar.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _searchbar_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./searchbar-class.js */ "./node_modules/framework7/components/searchbar/searchbar-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'searchbar',
  static: {
    Searchbar: _searchbar_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.searchbar = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.searchbar',
      constructor: _searchbar_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7Searchbar',
      addMethods: 'clear enable disable toggle search'.split(' ')
    });
  },

  on: {
    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.searchbar-init').each(searchbarEl => {
        const $searchbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(searchbarEl);
        app.searchbar.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)($searchbarEl.dataset(), {
          el: searchbarEl
        }));
      });
    },

    tabBeforeRemove(tabEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.searchbar-init').each(searchbarEl => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.searchbar-init').each(searchbarEl => {
        const $searchbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(searchbarEl);
        app.searchbar.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)($searchbarEl.dataset(), {
          el: searchbarEl
        }));
      });

      if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.searchbar-init').each(searchbarEl => {
          const $searchbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(searchbarEl);
          app.searchbar.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)($searchbarEl.dataset(), {
            el: searchbarEl
          }));
        });
      }
    },

    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.searchbar-init').each(searchbarEl => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });

      if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.searchbar-init').each(searchbarEl => {
          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
            searchbarEl.f7Searchbar.destroy();
          }
        });
      }
    }

  },
  clicks: {
    '.searchbar-clear': function clear($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.clear();
    },
    '.searchbar-enable': function enable($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.enable(true);
    },
    '.searchbar-disable': function disable($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.disable();
    },
    '.searchbar-toggle': function toggle($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.toggle();
    }
  },
  vnode: {
    'searchbar-init': {
      insert(vnode) {
        const app = this;
        const searchbarEl = vnode.elm;
        const $searchbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(searchbarEl);
        app.searchbar.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)($searchbarEl.dataset(), {
          el: searchbarEl
        }));
      },

      destroy(vnode) {
        const searchbarEl = vnode.elm;

        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/sheet/sheet-class.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/sheet/sheet-class.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modal/modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");







class Sheet extends _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
      on: {}
    }, app.params.sheet, params); // Extends with open/close Modal methods;

    super(app, extendedParams);
    const sheet = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_4__.getSupport)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_5__.getDevice)();
    sheet.params = extendedParams;

    if (typeof sheet.params.backdrop === 'undefined') {
      sheet.params.backdrop = app.theme !== 'ios';
    } // Find Element


    let $el;

    if (!sheet.params.el) {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sheet.params.content).filter(node => node.nodeType === 1).eq(0);
    } else {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sheet.params.el).eq(0);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return sheet.destroy();
    }

    let $backdropEl;

    if (sheet.params.backdrop && sheet.params.backdropEl) {
      $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sheet.params.backdropEl);
    } else if (sheet.params.backdrop) {
      if (sheet.params.backdropUnique) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="sheet-backdrop sheet-backdrop-unique"></div>');
        sheet.$containerEl.append($backdropEl);
      } else {
        $backdropEl = sheet.$containerEl.children('.sheet-backdrop');
      }

      if ($backdropEl.length === 0) {
        $backdropEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('<div class="sheet-backdrop"></div>');
        sheet.$containerEl.append($backdropEl);
      }
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(sheet, {
      app,
      push: $el.hasClass('sheet-modal-push') || sheet.params.push,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'sheet',
      $htmlEl: (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html')
    });

    if (sheet.params.push) {
      $el.addClass('sheet-modal-push');
    }

    let $pageContentEl;

    function scrollToElementOnOpen() {
      const $scrollEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sheet.params.scrollToEl).eq(0);
      if ($scrollEl.length === 0) return;
      $pageContentEl = $scrollEl.parents('.page-content');
      if ($pageContentEl.length === 0) return;
      const paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
      const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
      const pageHeight = $pageContentEl[0].offsetHeight - paddingTop - $el.height();
      const pageScrollHeight = $pageContentEl[0].scrollHeight - paddingTop - $el.height();
      const pageScroll = $pageContentEl.scrollTop();
      let newPaddingBottom;
      const scrollElTop = $scrollEl.offset().top - paddingTop + $scrollEl[0].offsetHeight;

      if (scrollElTop > pageHeight) {
        const scrollTop = pageScroll + scrollElTop - pageHeight;

        if (scrollTop + pageHeight > pageScrollHeight) {
          newPaddingBottom = scrollTop + pageHeight - pageScrollHeight + paddingBottom;

          if (pageHeight === pageScrollHeight) {
            newPaddingBottom = $el.height();
          }

          $pageContentEl.css({
            'padding-bottom': `${newPaddingBottom}px`
          });
        }

        $pageContentEl.scrollTop(scrollTop, 300);
      }
    }

    function scrollToElementOnClose() {
      if ($pageContentEl && $pageContentEl.length > 0) {
        $pageContentEl.css({
          'padding-bottom': ''
        });
      }
    }

    function handleClick(e) {
      const target = e.target;
      const $target = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target);
      const keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened) return;

      if ($target.closest(sheet.el).length === 0) {
        if (sheet.params.closeByBackdropClick && sheet.params.backdrop && sheet.backdropEl && sheet.backdropEl === target) {
          sheet.close();
        } else if (sheet.params.closeByOutsideClick) {
          sheet.close();
        }
      }
    }

    function onKeyDown(e) {
      const keyCode = e.keyCode;

      if (keyCode === 27 && sheet.params.closeOnEscape) {
        sheet.close();
      }
    }

    let pushOffset;

    function pushViewScale(offset) {
      return (app.height - offset * 2) / app.height;
    }

    let isTouched = false;
    let startTouch;
    let currentTouch;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let isMoved = false;
    let isTopSheetModal;
    let swipeStepTranslate;
    let startTranslate;
    let currentTranslate;
    let sheetElOffsetHeight;
    let minTranslate;
    let maxTranslate;
    let $pushViewEl;
    let pushBorderRadius;
    let sheetPageContentEl;
    let sheetPageContentScrollTop;
    let sheetPageContentScrollHeight;
    let sheetPageContentOffsetHeight;

    function handleTouchStart(e) {
      if (isTouched || !(sheet.params.swipeToClose || sheet.params.swipeToStep)) return;

      if (sheet.params.swipeHandler && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest(sheet.params.swipeHandler).length === 0) {
        return;
      }

      isTouched = true;
      isMoved = false;
      startTouch = {
        x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY
      };
      touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.now)();
      isScrolling = undefined;
      isTopSheetModal = $el.hasClass('sheet-modal-top');

      if (!sheet.params.swipeHandler && e.type === 'touchstart') {
        sheetPageContentEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest('.page-content')[0];
      }
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      currentTouch = {
        x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY
      };

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
      }

      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }

      touchesDiff = startTouch.y - currentTouch.y;
      const direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';

      if (!isMoved) {
        if (sheetPageContentEl && !$el.hasClass('modal-in-swipe-step')) {
          sheetPageContentScrollTop = sheetPageContentEl.scrollTop;
          sheetPageContentScrollHeight = sheetPageContentEl.scrollHeight;
          sheetPageContentOffsetHeight = sheetPageContentEl.offsetHeight;

          if (!(sheetPageContentScrollHeight === sheetPageContentOffsetHeight) && !(direction === 'to-bottom' && sheetPageContentScrollTop === 0) && !(direction === 'to-top' && sheetPageContentScrollTop === sheetPageContentScrollHeight - sheetPageContentOffsetHeight)) {
            $el.transform('');
            isTouched = false;
            isMoved = false;
            return;
          }
        }

        if (sheet.push && pushOffset) {
          $pushViewEl = app.$el.children('.view, .views');
        }

        sheetElOffsetHeight = $el[0].offsetHeight;
        startTranslate = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.getTranslate)($el[0], 'y');

        if (isTopSheetModal) {
          minTranslate = sheet.params.swipeToClose ? -sheetElOffsetHeight : -swipeStepTranslate;
          maxTranslate = 0;
        } else {
          minTranslate = 0;
          maxTranslate = sheet.params.swipeToClose ? sheetElOffsetHeight : swipeStepTranslate;
        }

        isMoved = true;
      }

      currentTranslate = startTranslate - touchesDiff;
      currentTranslate = Math.min(Math.max(currentTranslate, minTranslate), maxTranslate);
      e.preventDefault();

      if (sheet.push && pushOffset) {
        let progress = (currentTranslate - startTranslate) / sheetElOffsetHeight;

        if (sheet.params.swipeToStep) {
          if (isTopSheetModal) {
            progress = currentTranslate / swipeStepTranslate;
          } else {
            progress = 1 - (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
          }
        }

        progress = Math.abs(progress);
        progress = Math.min(Math.max(progress, 0), 1);
        const pushProgress = 1 - progress;
        const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
        $pushViewEl.transition(0).forEach(el => {
          el.style.setProperty('transform', `translate3d(0,0,0) scale(${scale})`, 'important');
        });

        if (sheet.params.swipeToStep) {
          $pushViewEl.css('border-radius', `${pushBorderRadius * pushProgress}px`);
        }
      }

      $el.transition(0).transform(`translate3d(0,${currentTranslate}px,0)`);

      if (sheet.params.swipeToStep) {
        let progress;

        if (isTopSheetModal) {
          progress = 1 - currentTranslate / swipeStepTranslate;
        } else {
          progress = (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
        }

        progress = Math.min(Math.max(progress, 0), 1);
        $el.trigger('sheet:stepprogress', progress);
        sheet.emit('local::stepProgress sheetStepProgress', sheet, progress);
      }
    }

    function handleTouchEnd() {
      isTouched = false;

      if (!isMoved) {
        return;
      }

      isMoved = false;
      $el.transform('').transition('');

      if (sheet.push && pushOffset) {
        $pushViewEl.transition('').transform('');
        $pushViewEl.css('border-radius', '');
      }

      const direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';
      const diff = Math.abs(touchesDiff);
      if (diff === 0 || currentTranslate === startTranslate) return;
      const timeDiff = new Date().getTime() - touchStartTime;

      if (!sheet.params.swipeToStep) {
        if (direction !== (isTopSheetModal ? 'to-top' : 'to-bottom')) {
          return;
        }

        if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > sheetElOffsetHeight / 2) {
          sheet.close();
        }

        return;
      }

      const openDirection = isTopSheetModal ? 'to-bottom' : 'to-top';
      const closeDirection = isTopSheetModal ? 'to-top' : 'to-bottom';
      const absCurrentTranslate = Math.abs(currentTranslate);
      const absSwipeStepTranslate = Math.abs(swipeStepTranslate);

      if (timeDiff < 300 && diff > 10) {
        if (direction === openDirection && absCurrentTranslate < absSwipeStepTranslate) {
          // open step
          $el.removeClass('modal-in-swipe-step');
          $el.trigger('sheet:stepprogress', 1);
          sheet.emit('local::stepProgress sheetStepProgress', sheet, 1);
          sheet.emit('local::_swipeStep', false);
          $el.trigger('sheet:stepopen');
          sheet.emit('local::stepOpen sheetStepOpen', sheet);

          if (sheet.push && pushOffset) {
            sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
            $pushViewEl.css('border-radius', '');
          }
        }

        if (direction === closeDirection && absCurrentTranslate > absSwipeStepTranslate) {
          // close sheet
          if (sheet.params.swipeToClose) {
            sheet.close();
          } else {
            // close step
            $el.addClass('modal-in-swipe-step');
            $el.trigger('sheet:stepprogress', 0);
            sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
            sheet.emit('local::_swipeStep', true);
            $el.trigger('sheet:stepclose');
            sheet.emit('local::stepClose sheetStepClose', sheet);

            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
              $pushViewEl.css('border-radius', '0px');
            }
          }
        }

        if (direction === closeDirection && absCurrentTranslate <= absSwipeStepTranslate) {
          // close step
          $el.addClass('modal-in-swipe-step');
          $el.trigger('sheet:stepprogress', 0);
          sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
          sheet.emit('local::_swipeStep', true);
          $el.trigger('sheet:stepclose');
          sheet.emit('local::stepClose sheetStepClose', sheet);

          if (sheet.push && pushOffset) {
            sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
            $pushViewEl.css('border-radius', '0px');
          }
        }

        return;
      }

      if (timeDiff >= 300) {
        const stepOpened = !$el.hasClass('modal-in-swipe-step');

        if (!stepOpened) {
          if (absCurrentTranslate < absSwipeStepTranslate / 2) {
            // open step
            $el.removeClass('modal-in-swipe-step');
            $el.trigger('sheet:stepprogress', 1);
            sheet.emit('local::stepProgress sheetStepProgress', sheet, 1);
            sheet.emit('local::_swipeStep', false);
            $el.trigger('sheet:stepopen');
            sheet.emit('local::stepOpen sheetStepOpen', sheet);

            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
              $pushViewEl.css('border-radius', '');
            }
          } else if (absCurrentTranslate - absSwipeStepTranslate > (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
            // close sheet
            if (sheet.params.swipeToClose) sheet.close();
          }
        } else if (stepOpened) {
          if (absCurrentTranslate > absSwipeStepTranslate + (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
            // close sheet
            if (sheet.params.swipeToClose) sheet.close();
          } else if (absCurrentTranslate > absSwipeStepTranslate / 2) {
            // close step
            $el.addClass('modal-in-swipe-step');
            $el.trigger('sheet:stepprogress', 0);
            sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
            sheet.emit('local::_swipeStep', true);
            $el.trigger('sheet:stepclose');
            sheet.emit('local::stepClose sheetStepClose', sheet);

            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
              $pushViewEl.css('border-radius', '0px');
            }
          }
        }
      }
    }

    sheet.setSwipeStep = function setSwipeStep(byResize) {
      if (byResize === void 0) {
        byResize = true;
      }

      const $swipeStepEl = $el.find('.sheet-modal-swipe-step').eq(0);
      if (!$swipeStepEl.length) return;

      if ($el.hasClass('sheet-modal-top')) {
        swipeStepTranslate = -($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
      } else {
        swipeStepTranslate = $el[0].offsetHeight - ($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
      }

      $el[0].style.setProperty('--f7-sheet-swipe-step', `${swipeStepTranslate}px`);

      if (!byResize) {
        $el.addClass('modal-in-swipe-step');
        sheet.emit('local::_swipeStep', true);
      }
    };

    function onResize() {
      sheet.setSwipeStep(true);
    }

    const passive = support.passiveListener ? {
      passive: true
    } : false;

    if (sheet.params.swipeToClose || sheet.params.swipeToStep) {
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      sheet.once('sheetDestroy', () => {
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off('touchmove', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      });
    }

    sheet.on('open', () => {
      if (sheet.params.closeOnEscape) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('keydown', onKeyDown);
      }

      $el.prevAll('.popup.modal-in').addClass('popup-behind');

      if (sheet.params.swipeToStep) {
        sheet.setSwipeStep(false);
        app.on('resize', onResize);
      }

      if (sheet.params.scrollToEl) {
        scrollToElementOnOpen();
      }

      if (sheet.push) {
        pushOffset = parseInt($el.css('--f7-sheet-push-offset'), 10);
        if (Number.isNaN(pushOffset)) pushOffset = 0;

        if (pushOffset) {
          $el.addClass('sheet-modal-push');
          sheet.$htmlEl.addClass('with-modal-sheet-push');

          if (!sheet.params.swipeToStep) {
            sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
          } else {
            $pushViewEl = app.$el.children('.view, .views');
            pushBorderRadius = parseFloat($el.css(`border-${isTopSheetModal ? 'bottom' : 'top'}-left-radius`));
            $pushViewEl.css('border-radius', '0px');
          }
        }
      }
    });
    sheet.on('opened', () => {
      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    sheet.on('close', () => {
      if (sheet.params.swipeToStep) {
        $el.removeClass('modal-in-swipe-step');
        sheet.emit('local::_swipeStep', false);
        app.off('resize', onResize);
      }

      if (sheet.params.closeOnEscape) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off('keydown', onKeyDown);
      }

      if (sheet.params.scrollToEl) {
        scrollToElementOnClose();
      }

      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }

      $el.prevAll('.popup.modal-in').eq(0).removeClass('popup-behind');

      if (sheet.push && pushOffset) {
        sheet.$htmlEl.removeClass('with-modal-sheet-push');
        sheet.$htmlEl.addClass('with-modal-sheet-push-closing');
      }
    });
    sheet.on('closed', () => {
      if (sheet.push && pushOffset) {
        sheet.$htmlEl.removeClass('with-modal-sheet-push-closing');
        sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
      }
    });

    sheet.stepOpen = function stepOpen() {
      $el.removeClass('modal-in-swipe-step');
      sheet.emit('local::_swipeStep', false);

      if (sheet.push) {
        if (!pushOffset) {
          pushOffset = parseInt($el.css('--f7-sheet-push-offset'), 10);
          if (Number.isNaN(pushOffset)) pushOffset = 0;
        }

        if (pushOffset) {
          sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
        }
      }
    };

    sheet.stepClose = function stepClose() {
      $el.addClass('modal-in-swipe-step');
      sheet.emit('local::_swipeStep', true);

      if (sheet.push) {
        sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
      }
    };

    sheet.stepToggle = function stepToggle() {
      $el.toggleClass('modal-in-swipe-step');
      sheet.emit('local::_swipeStep', $el.hasClass('modal-in-swipe-step'));
    };

    $el[0].f7Modal = sheet;
    return sheet;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sheet);

/***/ }),

/***/ "./node_modules/framework7/components/sheet/sheet.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7/components/sheet/sheet.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _sheet_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sheet-class.js */ "./node_modules/framework7/components/sheet/sheet-class.js");
/* harmony import */ var _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/modal-methods.js */ "./node_modules/framework7/shared/modal-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'sheet',
  params: {
    sheet: {
      push: false,
      backdrop: undefined,
      backdropEl: undefined,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeByOutsideClick: false,
      closeOnEscape: false,
      swipeToClose: false,
      swipeToStep: false,
      swipeHandler: null,
      containerEl: null
    }
  },
  static: {
    Sheet: _sheet_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.sheet = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, (0,_shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
      app,
      constructor: _sheet_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      defaultSelector: '.sheet-modal.modal-in'
    }), {
      stepOpen(sheet) {
        const sheetInstance = app.sheet.get(sheet);
        if (sheetInstance && sheetInstance.stepOpen) return sheetInstance.stepOpen();
        return undefined;
      },

      stepClose(sheet) {
        const sheetInstance = app.sheet.get(sheet);
        if (sheetInstance && sheetInstance.stepClose) return sheetInstance.stepClose();
        return undefined;
      },

      stepToggle(sheet) {
        const sheetInstance = app.sheet.get(sheet);
        if (sheetInstance && sheetInstance.stepToggle) return sheetInstance.stepToggle();
        return undefined;
      }

    });
  },

  clicks: {
    '.sheet-open': function openSheet($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;

      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.sheet-modal.modal-in').length > 0 && data.sheet && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data.sheet)[0] !== (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.sheet-modal.modal-in')[0]) {
        app.sheet.close('.sheet-modal.modal-in');
      }

      app.sheet.open(data.sheet, data.animate, $clickedEl);
    },
    '.sheet-close': function closeSheet($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.sheet.close(data.sheet, data.animate, $clickedEl);
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/skeleton/skeleton.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/skeleton/skeleton.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'skeleton'
});

/***/ }),

/***/ "./node_modules/framework7/components/smart-select/smart-select-class.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/smart-select/smart-select-class.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _searchbar_remove_diacritics_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../searchbar/remove-diacritics.js */ "./node_modules/framework7/components/searchbar/remove-diacritics.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");




/** @jsx $jsx */



class SmartSelect extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const ss = this;
    const defaults = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
      on: {}
    }, app.params.smartSelect);

    if (typeof defaults.searchbarDisableButton === 'undefined') {
      defaults.searchbarDisableButton = app.theme !== 'aurora';
    } // Extend defaults with modules params


    ss.useModulesParams(defaults);
    ss.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, defaults, params);
    ss.app = app;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ss.params.el).eq(0);
    if ($el.length === 0) return ss;
    if ($el[0].f7SmartSelect) return $el[0].f7SmartSelect;
    const $selectEl = $el.find('select').eq(0);
    if ($selectEl.length === 0) return ss;
    let $valueEl;

    if (ss.params.setValueText) {
      $valueEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ss.params.valueEl);

      if ($valueEl.length === 0) {
        $valueEl = $el.find('.item-after');
      }

      if ($valueEl.length === 0) {
        $valueEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="item-after"></div>');
        $valueEl.insertAfter($el.find('.item-title'));
      }
    } // Url


    let url = params.url;

    if (!url) {
      if ($el.attr('href') && $el.attr('href') !== '#') url = $el.attr('href');else if ($selectEl.attr('name')) url = `${$selectEl.attr('name').toLowerCase()}-select/`;
    }

    if (!url) url = ss.params.url;
    const multiple = $selectEl[0].multiple;
    const inputType = multiple ? 'checkbox' : 'radio';
    const selectId = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.id)();
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(ss, {
      $el,
      el: $el[0],
      $selectEl,
      selectEl: $selectEl[0],
      $valueEl,
      valueEl: $valueEl && $valueEl[0],
      url,
      multiple,
      inputType,
      id: selectId,
      inputName: `${inputType}-${selectId}`,
      selectName: $selectEl.attr('name'),
      maxLength: $selectEl.attr('maxlength') || params.maxLength
    });
    $el[0].f7SmartSelect = ss; // Events

    function onClick() {
      ss.open();
    }

    function onChange() {
      const value = ss.$selectEl.val();
      ss.$el.trigger('smartselect:change', value);
      ss.emit('local::change smartSelectChange', ss, value);

      if (ss.vl) {
        ss.vl.clearCache();
      }

      ss.setValueText();
    }

    ss.attachEvents = function attachEvents() {
      $el.on('click', onClick);
      $el.on('change', 'select', onChange);
    };

    ss.detachEvents = function detachEvents() {
      $el.off('click', onClick);
      $el.off('change', 'select', onChange);
    };

    function handleInputChange() {
      let optionEl;
      let text;
      const inputEl = this;
      const value = inputEl.value;
      let optionText = [];
      let displayAs;

      if (inputEl.type === 'checkbox') {
        for (let i = 0; i < ss.selectEl.options.length; i += 1) {
          optionEl = ss.selectEl.options[i];

          if (optionEl.value === value) {
            optionEl.selected = inputEl.checked;
          }

          if (optionEl.selected) {
            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(optionEl).data('display-value-as');
            text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
            optionText.push(text.trim());
          }
        }

        if (ss.maxLength) {
          ss.checkMaxLength();
        }
      } else {
        optionEl = ss.$selectEl.find(`option[value="${value}"]`)[0];

        if (!optionEl) {
          optionEl = ss.$selectEl.find('option').filter(optEl => optEl.value === value)[0];
        }

        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(optionEl).data('display-as');
        text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
        optionText = [text];
        ss.selectEl.value = value;
      }

      ss.$selectEl.trigger('change');

      if (ss.params.setValueText) {
        ss.$valueEl.text(ss.formatValueText(optionText));
      }

      if (ss.params.closeOnSelect && ss.inputType === 'radio') {
        ss.close();
      }
    }

    ss.attachInputsEvents = function attachInputsEvents() {
      ss.$containerEl.on('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };

    ss.detachInputsEvents = function detachInputsEvents() {
      ss.$containerEl.off('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    }; // Install Modules


    ss.useModules(); // Init

    ss.init();
    return ss;
  }

  setValue(value) {
    const ss = this;
    let newValue = value;
    let optionText = [];
    let optionEl;
    let displayAs;
    let text;

    if (ss.multiple) {
      if (!Array.isArray(newValue)) newValue = [newValue];

      for (let i = 0; i < ss.selectEl.options.length; i += 1) {
        optionEl = ss.selectEl.options[i];

        if (newValue.indexOf(optionEl.value) >= 0) {
          optionEl.selected = true;
        } else {
          optionEl.selected = false;
        }

        if (optionEl.selected) {
          displayAs = optionEl.dataset ? optionEl.dataset.displayAs : (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(optionEl).data('display-value-as');
          text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
          optionText.push(text.trim());
        }
      }
    } else {
      optionEl = ss.$selectEl.find(`option[value="${newValue}"]`)[0];

      if (optionEl) {
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(optionEl).data('display-as');
        text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
        optionText = [text];
      }

      ss.selectEl.value = newValue;
    }

    if (ss.params.setValueText) {
      ss.$valueEl.text(ss.formatValueText(optionText));
    }

    ss.$selectEl.trigger('change');
    return ss;
  }

  unsetValue() {
    const ss = this;

    if (ss.params.setValueText) {
      ss.$valueEl.text(ss.formatValueText([]));
    }

    ss.$selectEl.find('option').each(optionEl => {
      optionEl.selected = false;
      optionEl.checked = false;
    });
    ss.$selectEl[0].value = null;

    if (ss.$containerEl) {
      ss.$containerEl.find(`input[name="${ss.inputName}"][type="checkbox"], input[name="${ss.inputName}"][type="radio"]`).prop('checked', false);
    }

    ss.$selectEl.trigger('change');
  }

  getValue() {
    const ss = this;
    return ss.$selectEl.val();
  }

  get view() {
    const {
      params,
      $el
    } = this;
    let view;

    if (params.view) {
      view = params.view;
    }

    if (!view) {
      view = $el.parents('.view').length && $el.parents('.view')[0].f7View;
    }

    if (!view && params.openIn === 'page') {
      throw Error('Smart Select requires initialized View');
    }

    return view;
  }

  checkMaxLength() {
    const ss = this;
    const $containerEl = ss.$containerEl;

    if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
      $containerEl.find('input[type="checkbox"]').each(inputEl => {
        if (!inputEl.checked) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(inputEl).parents('li').addClass('disabled');
        } else {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(inputEl).parents('li').removeClass('disabled');
        }
      });
    } else {
      $containerEl.find('.disabled').removeClass('disabled');
    }
  }

  formatValueText(values) {
    const ss = this;
    let textValue;

    if (ss.params.formatValueText) {
      textValue = ss.params.formatValueText.call(ss, values, ss);
    } else {
      textValue = values.join(', ');
    }

    return textValue;
  }

  setValueText(value) {
    const ss = this;
    let valueArray = [];

    if (typeof value !== 'undefined') {
      if (Array.isArray(value)) {
        valueArray = value;
      } else {
        valueArray = [value];
      }
    } else {
      ss.$selectEl.find('option').each(optionEl => {
        const $optionEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(optionEl);

        if (optionEl.selected) {
          const displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data('display-value-as');

          if (displayAs && typeof displayAs !== 'undefined') {
            valueArray.push(displayAs);
          } else {
            valueArray.push(optionEl.textContent.trim());
          }
        }
      });
    }

    if (ss.params.setValueText) {
      ss.$valueEl.text(ss.formatValueText(valueArray));
    }
  }

  getItemsData() {
    const ss = this;
    const theme = ss.app.theme;
    const items = [];
    let previousGroupEl;
    ss.$selectEl.find('option').each(optionEl => {
      const $optionEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(optionEl);
      const optionData = $optionEl.dataset();
      const optionImage = optionData.optionImage || ss.params.optionImage;
      const optionIcon = optionData.optionIcon || ss.params.optionIcon;
      const optionIconIos = theme === 'ios' && (optionData.optionIconIos || ss.params.optionIconIos);
      const optionIconMd = theme === 'md' && (optionData.optionIconMd || ss.params.optionIconMd);
      const optionIconAurora = theme === 'aurora' && (optionData.optionIconAurora || ss.params.optionIconAurora);
      const optionHasMedia = optionImage || optionIcon || optionIconIos || optionIconMd || optionIconAurora;
      const optionColor = optionData.optionColor;
      let optionClassName = optionData.optionClass || '';
      if ($optionEl[0].disabled) optionClassName += ' disabled';
      const optionGroupEl = $optionEl.parent('optgroup')[0];
      const optionGroupLabel = optionGroupEl && optionGroupEl.label;
      let optionIsLabel = false;

      if (optionGroupEl && optionGroupEl !== previousGroupEl) {
        optionIsLabel = true;
        previousGroupEl = optionGroupEl;
        items.push({
          groupLabel: optionGroupLabel,
          isLabel: optionIsLabel
        });
      }

      items.push({
        value: $optionEl[0].value,
        text: $optionEl[0].textContent.trim(),
        selected: $optionEl[0].selected,
        groupEl: optionGroupEl,
        groupLabel: optionGroupLabel,
        image: optionImage,
        icon: optionIcon,
        iconIos: optionIconIos,
        iconMd: optionIconMd,
        iconAurora: optionIconAurora,
        color: optionColor,
        className: optionClassName,
        disabled: $optionEl[0].disabled,
        id: ss.id,
        hasMedia: optionHasMedia,
        checkbox: ss.inputType === 'checkbox',
        radio: ss.inputType === 'radio',
        inputName: ss.inputName,
        inputType: ss.inputType
      });
    });
    ss.items = items;
    return items;
  }

  renderSearchbar() {
    const ss = this;
    if (ss.params.renderSearchbar) return ss.params.renderSearchbar.call(ss);
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("form", {
      class: "searchbar"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "searchbar-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "searchbar-input-wrap"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("input", {
      type: "search",
      spellcheck: ss.params.searchbarSpellcheck || 'false',
      placeholder: ss.params.searchbarPlaceholder
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("i", {
      class: "searchbar-icon"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("span", {
      class: "input-clear-button"
    })), ss.params.searchbarDisableButton && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("span", {
      class: "searchbar-disable-button"
    }, ss.params.searchbarDisableText)));
  }

  renderItem(item, index) {
    const ss = this;
    if (ss.params.renderItem) return ss.params.renderItem.call(ss, item, index);

    function getIconContent(iconValue) {
      if (iconValue === void 0) {
        iconValue = '';
      }

      if (iconValue.indexOf(':') >= 0) {
        return iconValue.split(':')[1];
      }

      return '';
    }

    function getIconClass(iconValue) {
      if (iconValue === void 0) {
        iconValue = '';
      }

      if (iconValue.indexOf(':') >= 0) {
        let className = iconValue.split(':')[0];
        if (className === 'f7') className = 'f7-icons';
        if (className === 'material') className = 'material-icons';
        return className;
      }

      return iconValue;
    }

    let itemHtml;

    if (item.isLabel) {
      itemHtml = `<li class="item-divider">${item.groupLabel}</li>`;
    } else {
      let selected = item.selected;
      let disabled;

      if (ss.params.virtualList) {
        const ssValue = ss.getValue();
        selected = ss.multiple ? ssValue.indexOf(item.value) >= 0 : ssValue === item.value;

        if (ss.multiple) {
          disabled = ss.multiple && !selected && ssValue.length === parseInt(ss.maxLength, 10);
        }
      }

      const {
        icon,
        iconIos,
        iconMd,
        iconAurora
      } = item;
      const hasIcon = icon || iconIos || iconMd || iconAurora;
      const iconContent = getIconContent(icon || iconIos || iconMd || iconAurora || '');
      const iconClass = getIconClass(icon || iconIos || iconMd || iconAurora || '');
      itemHtml = (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("li", {
        class: `${item.className || ''}${disabled ? ' disabled' : ''}`
      }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("label", {
        class: `item-${item.inputType} item-content`
      }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("input", {
        type: item.inputType,
        name: item.inputName,
        value: item.value,
        _checked: selected
      }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("i", {
        class: `icon icon-${item.inputType}`
      }), item.hasMedia && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
        class: "item-media"
      }, hasIcon && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("i", {
        class: `icon ${iconClass}`
      }, iconContent), item.image && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("img", {
        src: item.image
      })), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
        class: "item-inner"
      }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
        class: `item-title${item.color ? ` text-color-${item.color}` : ''}`
      }, item.text))));
    }

    return itemHtml;
  }

  renderItems() {
    const ss = this;
    if (ss.params.renderItems) return ss.params.renderItems.call(ss, ss.items);
    const itemsHtml = `
      ${ss.items.map((item, index) => `${ss.renderItem(item, index)}`).join('')}
    `;
    return itemsHtml;
  }

  renderPage() {
    const ss = this;
    if (ss.params.renderPage) return ss.params.renderPage.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;

    if (typeof pageTitle === 'undefined') {
      const $itemTitleEl = ss.$el.find('.item-title');
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
    }

    const cssClass = ss.params.cssClass;
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `page smart-select-page ${cssClass}`,
      "data-name": "smart-select-page",
      "data-select-name": ss.selectName
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "navbar-bg"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `navbar-inner sliding ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "left"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("a", {
      class: "link back"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("i", {
      class: "icon icon-back"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("span", {
      class: "if-not-md"
    }, ss.params.pageBackLinkText))), pageTitle && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "title"
    }, pageTitle), ss.params.searchbar && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "subnavbar"
    }, ss.renderSearchbar()))), ss.params.searchbar && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "searchbar-backdrop"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "page-content"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
  }

  renderPopup() {
    const ss = this;
    if (ss.params.renderPopup) return ss.params.renderPopup.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;

    if (typeof pageTitle === 'undefined') {
      const $itemTitleEl = ss.$el.find('.item-title');
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
    }

    const cssClass = ss.params.cssClass || '';
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `popup smart-select-popup ${cssClass} ${ss.params.popupTabletFullscreen ? 'popup-tablet-fullscreen' : ''}`,
      "data-select-name": ss.selectName
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "view"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `page smart-select-page ${ss.params.searchbar ? 'page-with-subnavbar' : ''}`,
      "data-name": "smart-select-page"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "navbar-bg"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "navbar-inner sliding"
    }, pageTitle && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "title"
    }, pageTitle), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "right"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("a", {
      class: "link popup-close",
      "data-popup": `.smart-select-popup[data-select-name='${ss.selectName}']`
    }, ss.params.popupCloseLinkText)), ss.params.searchbar && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "subnavbar"
    }, ss.renderSearchbar()))), ss.params.searchbar && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "searchbar-backdrop"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "page-content"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))))));
  }

  renderSheet() {
    const ss = this;
    if (ss.params.renderSheet) return ss.params.renderSheet.call(ss, ss.items);
    const cssClass = ss.params.cssClass; // prettier-ignore

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `sheet-modal smart-select-sheet ${cssClass}`,
      "data-select-name": ss.selectName
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `toolbar toolbar-top ${ss.params.toolbarColorTheme ? `color-${ss.params.toolbarColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "toolbar-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "left"
    }), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "right"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("a", {
      class: "link sheet-close"
    }, ss.params.sheetCloseLinkText)))), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "sheet-modal-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "page-content"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("ul", null, !ss.params.virtualList && ss.renderItems(ss.items))))));
  }

  renderPopover() {
    const ss = this;
    if (ss.params.renderPopover) return ss.params.renderPopover.call(ss, ss.items);
    const cssClass = ss.params.cssClass; // prettier-ignore

    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `popover smart-select-popover ${cssClass}`,
      "data-select-name": ss.selectName
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: "popover-inner"
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_3__["default"])("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
  }

  scrollToSelectedItem() {
    const ss = this;
    const {
      params,
      $containerEl
    } = ss;
    if (!ss.opened) return ss;

    if (params.virtualList) {
      let selectedIndex;
      ss.vl.items.forEach((item, index) => {
        if (typeof selectedIndex === 'undefined' && item.selected) {
          selectedIndex = index;
        }
      });

      if (typeof selectedIndex !== 'undefined') {
        ss.vl.scrollToItem(selectedIndex);
      }
    } else {
      const $selectedItemEl = $containerEl.find('input:checked').parents('li');
      if (!$selectedItemEl.length) return ss;
      const $scrollableEl = $containerEl.find('.page-content, .popover-inner');
      if (!$scrollableEl.length) return ss;
      $scrollableEl.scrollTop($selectedItemEl.offset().top - $scrollableEl.offset().top - parseInt($scrollableEl.css('padding-top'), 10));
    }

    return ss;
  }

  onOpen(type, containerEl) {
    const ss = this;
    const app = ss.app;
    const $containerEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(containerEl);
    ss.$containerEl = $containerEl;
    ss.openedIn = type;
    ss.opened = true; // Init VL

    if (ss.params.virtualList) {
      ss.vl = app.virtualList.create({
        el: $containerEl.find('.virtual-list'),
        items: ss.items,
        renderItem: ss.renderItem.bind(ss),
        height: ss.params.virtualListHeight,

        searchByItem(query, item) {
          if (item.text && (0,_searchbar_remove_diacritics_js__WEBPACK_IMPORTED_MODULE_4__["default"])(item.text).toLowerCase().indexOf(query.trim().toLowerCase()) >= 0) return true;
          return false;
        }

      });
    }

    if (ss.params.scrollToSelectedItem) {
      ss.scrollToSelectedItem();
    } // Init SB


    if (ss.params.searchbar) {
      let $searchbarEl = $containerEl.find('.searchbar');

      if (type === 'page' && app.theme === 'ios') {
        $searchbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(app.navbar.getElByPage($containerEl)).find('.searchbar');
      }

      if (ss.params.appendSearchbarNotFound && (type === 'page' || type === 'popup')) {
        let $notFoundEl = null;

        if (typeof ss.params.appendSearchbarNotFound === 'string') {
          $notFoundEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="block searchbar-not-found">${ss.params.appendSearchbarNotFound}</div>`);
        } else if (typeof ss.params.appendSearchbarNotFound === 'boolean') {
          $notFoundEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="block searchbar-not-found">Nothing found</div>');
        } else {
          $notFoundEl = ss.params.appendSearchbarNotFound;
        }

        if ($notFoundEl) {
          $containerEl.find('.page-content').append($notFoundEl[0]);
        }
      }

      const searchbarParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
        el: $searchbarEl,
        backdropEl: $containerEl.find('.searchbar-backdrop'),
        searchContainer: `.smart-select-list-${ss.id}`,
        searchIn: '.item-title'
      }, typeof ss.params.searchbar === 'object' ? ss.params.searchbar : {});
      ss.searchbar = app.searchbar.create(searchbarParams);
    } // Check for max length


    if (ss.maxLength) {
      ss.checkMaxLength();
    } // Close on select


    if (ss.params.closeOnSelect) {
      ss.$containerEl.find(`input[type="radio"][name="${ss.inputName}"]:checked`).parents('label').once('click', () => {
        ss.close();
      });
    } // Attach input events


    ss.attachInputsEvents();
    ss.$el.trigger('smartselect:open');
    ss.emit('local::open smartSelectOpen', ss);
  }

  onOpened() {
    const ss = this;
    ss.$el.trigger('smartselect:opened');
    ss.emit('local::opened smartSelectOpened', ss);
  }

  onClose() {
    const ss = this;
    if (ss.destroyed) return; // Destroy VL

    if (ss.vl && ss.vl.destroy) {
      ss.vl.destroy();
      ss.vl = null;
      delete ss.vl;
    } // Destroy SB


    if (ss.searchbar && ss.searchbar.destroy) {
      ss.searchbar.destroy();
      ss.searchbar = null;
      delete ss.searchbar;
    } // Detach events


    ss.detachInputsEvents();
    ss.$el.trigger('smartselect:close');
    ss.emit('local::close smartSelectClose', ss);
  }

  onClosed() {
    const ss = this;
    if (ss.destroyed) return;
    ss.opened = false;
    ss.$containerEl = null;
    delete ss.$containerEl;
    ss.$el.trigger('smartselect:closed');
    ss.emit('local::closed smartSelectClosed', ss);
  }

  openPage() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const pageHtml = ss.renderPage(ss.items);
    ss.view.router.navigate({
      url: ss.url,
      route: {
        content: pageHtml,
        path: ss.url,
        on: {
          pageBeforeIn(e, page) {
            ss.onOpen('page', page.el);
          },

          pageAfterIn(e, page) {
            ss.onOpened('page', page.el);
          },

          pageBeforeOut(e, page) {
            ss.onClose('page', page.el);
          },

          pageAfterOut(e, page) {
            ss.onClosed('page', page.el);
          }

        }
      }
    });
    return ss;
  }

  openPopup() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const popupHtml = ss.renderPopup(ss.items);
    const popupParams = {
      content: popupHtml,
      push: ss.params.popupPush,
      swipeToClose: ss.params.popupSwipeToClose,
      on: {
        popupOpen(popup) {
          ss.onOpen('popup', popup.el);
        },

        popupOpened(popup) {
          ss.onOpened('popup', popup.el);
        },

        popupClose(popup) {
          ss.onClose('popup', popup.el);
        },

        popupClosed(popup) {
          ss.onClosed('popup', popup.el);
        }

      }
    };

    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popup: popupParams
        }
      });
    } else {
      ss.modal = ss.app.popup.create(popupParams).open();
    }

    return ss;
  }

  openSheet() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const sheetHtml = ss.renderSheet(ss.items);
    const sheetParams = {
      content: sheetHtml,
      backdrop: ss.params.sheetBackdrop,
      scrollToEl: ss.$el,
      closeByOutsideClick: true,
      push: ss.params.sheetPush,
      swipeToClose: ss.params.sheetSwipeToClose,
      on: {
        sheetOpen(sheet) {
          ss.onOpen('sheet', sheet.el);
        },

        sheetOpened(sheet) {
          ss.onOpened('sheet', sheet.el);
        },

        sheetClose(sheet) {
          ss.onClose('sheet', sheet.el);
        },

        sheetClosed(sheet) {
          ss.onClosed('sheet', sheet.el);
        }

      }
    };

    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          sheet: sheetParams
        }
      });
    } else {
      ss.modal = ss.app.sheet.create(sheetParams).open();
    }

    return ss;
  }

  openPopover() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const popoverHtml = ss.renderPopover(ss.items);
    const popoverParams = {
      content: popoverHtml,
      targetEl: ss.$el,
      on: {
        popoverOpen(popover) {
          ss.onOpen('popover', popover.el);
        },

        popoverOpened(popover) {
          ss.onOpened('popover', popover.el);
        },

        popoverClose(popover) {
          ss.onClose('popover', popover.el);
        },

        popoverClosed(popover) {
          ss.onClosed('popover', popover.el);
        }

      }
    };

    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popover: popoverParams
        }
      });
    } else {
      ss.modal = ss.app.popover.create(popoverParams).open();
    }

    return ss;
  }

  open(type) {
    const ss = this;
    if (ss.opened) return ss;
    let prevented = false;

    function prevent() {
      prevented = true;
    }

    if (ss.$el) {
      ss.$el.trigger('smartselect:beforeopen', {
        prevent
      });
    }

    ss.emit('local::beforeOpen smartSelectBeforeOpen', ss, prevent);
    if (prevented) return ss;
    const openIn = type || ss.params.openIn;
    ss[`open${openIn.split('').map((el, index) => {
      if (index === 0) return el.toUpperCase();
      return el;
    }).join('')}`]();
    return ss;
  }

  close() {
    const ss = this;
    if (!ss.opened) return ss;

    if (ss.params.routableModals && ss.view || ss.openedIn === 'page') {
      ss.view.router.back();
    } else {
      ss.modal.once('modalClosed', () => {
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
          if (ss.destroyed) return;
          ss.modal.destroy();
          delete ss.modal;
        });
      });
      ss.modal.close();
    }

    return ss;
  }

  init() {
    const ss = this;
    ss.attachEvents();
    ss.setValueText();
  }

  destroy() {
    const ss = this;
    ss.emit('local::beforeDestroy smartSelectBeforeDestroy', ss);
    ss.$el.trigger('smartselect:beforedestroy');
    ss.detachEvents();
    delete ss.$el[0].f7SmartSelect;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(ss);
    ss.destroyed = true;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SmartSelect);

/***/ }),

/***/ "./node_modules/framework7/components/smart-select/smart-select.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7/components/smart-select/smart-select.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _smart_select_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./smart-select-class.js */ "./node_modules/framework7/components/smart-select/smart-select-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'smartSelect',
  params: {
    smartSelect: {
      el: undefined,
      valueEl: undefined,
      setValueText: true,
      formatValueText: null,
      openIn: 'page',
      // or 'popup' or 'sheet' or 'popover'
      popupPush: false,
      popupSwipeToClose: undefined,
      // defaults to app
      sheetPush: false,
      sheetSwipeToClose: undefined,
      // defaults to app
      sheetBackdrop: false,
      pageTitle: undefined,
      pageBackLinkText: 'Back',
      popupCloseLinkText: 'Close',
      popupTabletFullscreen: false,
      sheetCloseLinkText: 'Done',
      searchbar: false,
      searchbarPlaceholder: 'Search',
      searchbarDisableText: 'Cancel',
      searchbarDisableButton: undefined,
      searchbarSpellcheck: false,
      closeOnSelect: false,
      virtualList: false,
      virtualListHeight: undefined,
      scrollToSelectedItem: false,
      formColorTheme: undefined,
      navbarColorTheme: undefined,
      routableModals: false,
      url: 'select/',
      cssClass: '',

      /*
        Custom render functions
      */
      renderPage: undefined,
      renderPopup: undefined,
      renderSheet: undefined,
      renderPopover: undefined,
      renderItems: undefined,
      renderItem: undefined,
      renderSearchbar: undefined
    }
  },
  static: {
    SmartSelect: _smart_select_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.smartSelect = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)((0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
      defaultSelector: '.smart-select',
      constructor: _smart_select_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7SmartSelect'
    }), {
      open(smartSelectEl) {
        const ss = app.smartSelect.get(smartSelectEl);
        if (ss && ss.open) return ss.open();
        return undefined;
      },

      close(smartSelectEl) {
        const ss = app.smartSelect.get(smartSelectEl);
        if (ss && ss.close) return ss.close();
        return undefined;
      }

    });
  },

  on: {
    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.smart-select-init').each(smartSelectEl => {
        app.smartSelect.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
          el: smartSelectEl
        }, (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(smartSelectEl).dataset()));
      });
    },

    tabBeforeRemove(tabEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.smart-select-init').each(smartSelectEl => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.smart-select-init').each(smartSelectEl => {
        app.smartSelect.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
          el: smartSelectEl
        }, (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(smartSelectEl).dataset()));
      });
    },

    pageBeforeRemove(page) {
      page.$el.find('.smart-select-init').each(smartSelectEl => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    }

  },
  clicks: {
    '.smart-select': function open($clickedEl, data) {
      const app = this;

      if (!$clickedEl[0].f7SmartSelect) {
        const ss = app.smartSelect.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
          el: $clickedEl
        }, data));
        ss.open();
      }
    }
  },
  vnode: {
    'smart-select-init': {
      insert(vnode) {
        const app = this;
        const smartSelectEl = vnode.elm;
        app.smartSelect.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
          el: smartSelectEl
        }, (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(smartSelectEl).dataset()));
      },

      destroy(vnode) {
        const smartSelectEl = vnode.elm;

        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/sortable/sortable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/sortable/sortable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");




const Sortable = {
  init() {
    const app = this;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    let isTouched;
    let isMoved;
    let touchStartY;
    let touchesDiff;
    let $sortingEl;
    let $sortingItems;
    let $sortableContainer;
    let sortingElHeight;
    let minTop;
    let maxTop;
    let $insertAfterEl;
    let $insertBeforeEl;
    let indexFrom;
    let $pageEl;
    let $pageContentEl;
    let pageHeight;
    let pageOffset;
    let sortingElOffsetLocal;
    let sortingElOffsetTop;
    let initialScrollTop;
    let wasTapHold;

    function handleTouchStart(e, isTapHold) {
      isMoved = false;
      isTouched = true;
      wasTapHold = false;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      $sortingEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest('li').eq(0);
      indexFrom = $sortingEl.index();
      $sortableContainer = $sortingEl.parents('.sortable');
      const $listGroup = $sortingEl.parents('.list-group');

      if ($listGroup.length && $listGroup.parents($sortableContainer).length) {
        $sortableContainer = $listGroup;
      }

      $sortingItems = $sortableContainer.children('ul').children('li:not(.disallow-sorting):not(.no-sorting)');
      if (app.panel) app.panel.allowOpen = false;
      if (app.swipeout) app.swipeout.allow = false;

      if (isTapHold) {
        $sortingEl.addClass('sorting');
        $sortableContainer.addClass('sortable-sorting');
        wasTapHold = true;
      }
    }

    function handleTouchMove(e) {
      if (!isTouched || !$sortingEl) return;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (!isMoved) {
        $pageEl = $sortingEl.parents('.page');
        $pageContentEl = $sortingEl.parents('.page-content');
        const paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
        const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
        initialScrollTop = $pageContentEl[0].scrollTop;
        pageOffset = $pageEl.offset().top + paddingTop;
        pageHeight = $pageEl.height() - paddingTop - paddingBottom;
        $sortingEl.addClass('sorting');
        $sortableContainer.addClass('sortable-sorting');
        sortingElOffsetLocal = $sortingEl[0].offsetTop;
        minTop = $sortingEl[0].offsetTop;
        maxTop = $sortingEl.parent().height() - sortingElOffsetLocal - $sortingEl.height();
        sortingElHeight = $sortingEl[0].offsetHeight;
        sortingElOffsetTop = $sortingEl.offset().top;
      }

      isMoved = true;
      e.preventDefault();
      e.f7PreventSwipePanel = true;
      touchesDiff = pageY - touchStartY;
      const translateScrollOffset = $pageContentEl[0].scrollTop - initialScrollTop;
      const translate = Math.min(Math.max(touchesDiff + translateScrollOffset, -minTop), maxTop);
      $sortingEl.transform(`translate3d(0,${translate}px,0)`);
      const scrollAddition = 44;
      let allowScroll = true;

      if (touchesDiff + translateScrollOffset + scrollAddition < -minTop) {
        allowScroll = false;
      }

      if (touchesDiff + translateScrollOffset - scrollAddition > maxTop) {
        allowScroll = false;
      }

      $insertBeforeEl = undefined;
      $insertAfterEl = undefined;
      let scrollDiff;

      if (allowScroll) {
        if (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition > pageOffset + pageHeight) {
          // To Bottom
          scrollDiff = sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition - (pageOffset + pageHeight);
        }

        if (sortingElOffsetTop + touchesDiff < pageOffset + scrollAddition) {
          // To Top
          scrollDiff = sortingElOffsetTop + touchesDiff - pageOffset - scrollAddition;
        }

        if (scrollDiff) {
          $pageContentEl[0].scrollTop += scrollDiff;
        }
      }

      $sortingItems.each(el => {
        const $currentEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
        if ($currentEl[0] === $sortingEl[0]) return;
        const currentElOffset = $currentEl[0].offsetTop;
        const currentElHeight = $currentEl.height();
        const sortingElOffset = sortingElOffsetLocal + translate;
        let currentTranslate;
        const prevTranslate = $currentEl[0].f7Translate;

        if (sortingElOffset >= currentElOffset - currentElHeight / 2 && $sortingEl.index() < $currentEl.index()) {
          currentTranslate = -sortingElHeight;
          $currentEl.transform(`translate3d(0, ${currentTranslate}px,0)`);
          $insertAfterEl = $currentEl;
          $insertBeforeEl = undefined;
        } else if (sortingElOffset <= currentElOffset + currentElHeight / 2 && $sortingEl.index() > $currentEl.index()) {
          currentTranslate = sortingElHeight;
          $currentEl[0].f7Translate = currentTranslate;
          $currentEl.transform(`translate3d(0, ${currentTranslate}px,0)`);
          $insertAfterEl = undefined;
          if (!$insertBeforeEl) $insertBeforeEl = $currentEl;
        } else {
          currentTranslate = undefined;
          $currentEl.transform('translate3d(0, 0%,0)');
        }

        if (prevTranslate !== currentTranslate) {
          $currentEl.trigger('sortable:move');
          app.emit('sortableMove', $currentEl[0], $sortableContainer[0]);
        }

        $currentEl[0].f7Translate = currentTranslate;
      });
    }

    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        if (isTouched && !isMoved) {
          if (app.panel) app.panel.allowOpen = true;
          if (app.swipeout) app.swipeout.allow = true;

          if (wasTapHold) {
            $sortingEl.removeClass('sorting');
            $sortableContainer.removeClass('sortable-sorting');
          }
        }

        isTouched = false;
        isMoved = false;
        return;
      }

      if (app.panel) app.panel.allowOpen = true;
      if (app.swipeout) app.swipeout.allow = true;
      $sortingItems.transform('');
      $sortingEl.removeClass('sorting');
      $sortableContainer.removeClass('sortable-sorting');
      let indexTo;
      if ($insertAfterEl) indexTo = $insertAfterEl.index();else if ($insertBeforeEl) indexTo = $insertBeforeEl.index();
      let moveElements = $sortableContainer.dataset().sortableMoveElements;

      if (typeof moveElements === 'undefined') {
        moveElements = app.params.sortable.moveElements;
      }

      if (moveElements) {
        if ($insertAfterEl) {
          $sortingEl.insertAfter($insertAfterEl);
        }

        if ($insertBeforeEl) {
          $sortingEl.insertBefore($insertBeforeEl);
        }
      }

      if (($insertAfterEl || $insertBeforeEl) && $sortableContainer.hasClass('virtual-list')) {
        indexFrom = $sortingEl[0].f7VirtualListIndex;
        if (typeof indexFrom === 'undefined') indexFrom = $sortingEl.attr('data-virtual-list-index');

        if ($insertBeforeEl) {
          indexTo = $insertBeforeEl[0].f7VirtualListIndex;
          if (typeof indexTo === 'undefined') indexTo = $insertBeforeEl.attr('data-virtual-list-index');
        } else {
          indexTo = $insertAfterEl[0].f7VirtualListIndex;
          if (typeof indexTo === 'undefined') indexTo = $insertAfterEl.attr('data-virtual-list-index');
        }

        if (indexTo !== null) indexTo = parseInt(indexTo, 10);else indexTo = undefined;
        const virtualList = $sortableContainer[0].f7VirtualList;
        if (indexFrom) indexFrom = parseInt(indexFrom, 10);
        if (indexTo) indexTo = parseInt(indexTo, 10);
        if (virtualList) virtualList.moveItem(indexFrom, indexTo);
      }

      if (typeof indexTo !== 'undefined' && !Number.isNaN(indexTo) && indexTo !== indexFrom) {
        $sortingEl.trigger('sortable:sort', {
          from: indexFrom,
          to: indexTo
        });
        app.emit('sortableSort', $sortingEl[0], {
          from: indexFrom,
          to: indexTo,
          el: $sortingEl[0]
        }, $sortableContainer[0]);
      }

      $insertBeforeEl = undefined;
      $insertAfterEl = undefined;
      isTouched = false;
      isMoved = false;
    }

    const activeListener = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)().passiveListener ? {
      passive: false,
      capture: false
    } : false;
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on(app.touchEvents.start, '.list.sortable .sortable-handler', handleTouchStart, activeListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('taphold', '.sortable-tap-hold', (e, pointerEvent) => {
      handleTouchStart(pointerEvent, true);
    });
  },

  enable(el) {
    if (el === void 0) {
      el = '.list.sortable';
    }

    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
    if ($el.length === 0) return;
    $el.addClass('sortable-enabled');
    $el.trigger('sortable:enable');
    app.emit('sortableEnable', $el[0]);
  },

  disable(el) {
    if (el === void 0) {
      el = '.list.sortable';
    }

    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
    if ($el.length === 0) return;
    $el.removeClass('sortable-enabled');
    $el.trigger('sortable:disable');
    app.emit('sortableDisable', $el[0]);
  },

  toggle(el) {
    if (el === void 0) {
      el = '.list.sortable';
    }

    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
    if ($el.length === 0) return;

    if ($el.hasClass('sortable-enabled')) {
      app.sortable.disable($el);
    } else {
      app.sortable.enable($el);
    }
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'sortable',
  params: {
    sortable: {
      moveElements: true
    }
  },

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.bindMethods)(app, {
      sortable: Sortable
    });
  },

  on: {
    init() {
      const app = this;
      if (!app.params.sortable) return;
      app.sortable.init();
    }

  },
  clicks: {
    '.sortable-enable': function enable($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.sortable.enable(data.sortable);
    },
    '.sortable-disable': function disable($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.sortable.disable(data.sortable);
    },
    '.sortable-toggle': function toggle($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.sortable.toggle(data.sortable);
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/statusbar/statusbar.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/statusbar/statusbar.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");





const isCapacitor = () => {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  return window.Capacitor && window.Capacitor.isNative && window.Capacitor.Plugins && window.Capacitor.Plugins.StatusBar;
};

const Statusbar = {
  hide() {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();

    if (device.cordova && window.StatusBar) {
      window.StatusBar.hide();
    }

    if (isCapacitor()) {
      window.Capacitor.Plugins.StatusBar.hide();
    }
  },

  show() {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();

    if (device.cordova && window.StatusBar) {
      window.StatusBar.show();
    }

    if (isCapacitor()) {
      window.Capacitor.Plugins.StatusBar.show();
    }
  },

  onClick() {
    const app = this;
    let pageContent;

    if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.popup.modal-in').length > 0) {
      // Check for opened popup
      pageContent = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.popup.modal-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.panel.panel-in').length > 0) {
      // Check for opened panel
      pageContent = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.panel.panel-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.views > .view.tab-active').length > 0) {
      // View in tab bar app layout
      pageContent = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.views > .view.tab-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.views').length > 0) {
      pageContent = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.views').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else {
      pageContent = app.$el.children('.view').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    }

    if (pageContent && pageContent.length > 0) {
      // Check for tab
      if (pageContent.hasClass('tab')) {
        pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
      }

      if (pageContent.length > 0) pageContent.scrollTop(0, 300);
    }
  },

  setTextColor(color) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();

    if (device.cordova && window.StatusBar) {
      if (color === 'white') {
        window.StatusBar.styleLightContent();
      } else {
        window.StatusBar.styleDefault();
      }
    }

    if (isCapacitor()) {
      if (color === 'white') {
        window.Capacitor.Plugins.StatusBar.setStyle({
          style: 'DARK'
        });
      } else {
        window.Capacitor.Plugins.StatusBar.setStyle({
          style: 'LIGHT'
        });
      }
    }
  },

  setBackgroundColor(color) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();

    if (device.cordova && window.StatusBar) {
      window.StatusBar.backgroundColorByHexString(color);
    }

    if (isCapacitor()) {
      window.Capacitor.Plugins.StatusBar.setBackgroundColor({
        color
      });
    }
  },

  isVisible() {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
    return new Promise(resolve => {
      if (device.cordova && window.StatusBar) {
        resolve(window.StatusBar.isVisible);
      }

      if (isCapacitor()) {
        window.Capacitor.Plugins.StatusBar.getInfo().then(info => {
          resolve(info.visible);
        });
      }

      resolve(false);
    });
  },

  overlaysWebView(overlays) {
    if (overlays === void 0) {
      overlays = true;
    }

    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();

    if (device.cordova && window.StatusBar) {
      window.StatusBar.overlaysWebView(overlays);
    }

    if (isCapacitor()) {
      window.Capacitor.Plugins.StatusBar.setOverlaysWebView({
        overlay: overlays
      });
    }
  },

  init() {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
    const params = app.params.statusbar;
    if (!params.enabled) return;
    const isCordova = device.cordova && window.StatusBar;
    const isCap = isCapacitor();

    if (isCordova || isCap) {
      if (params.scrollTopOnClick) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).on('statusTap', Statusbar.onClick.bind(app));
      }

      if (device.ios) {
        if (params.iosOverlaysWebView) {
          Statusbar.overlaysWebView(true);
        } else {
          Statusbar.overlaysWebView(false);
        }

        if (params.iosTextColor === 'white') {
          Statusbar.setTextColor('white');
        } else {
          Statusbar.setTextColor('black');
        }
      }

      if (device.android) {
        if (params.androidOverlaysWebView) {
          Statusbar.overlaysWebView(true);
        } else {
          Statusbar.overlaysWebView(false);
        }

        if (params.androidTextColor === 'white') {
          Statusbar.setTextColor('white');
        } else {
          Statusbar.setTextColor('black');
        }
      }
    }

    if (params.iosBackgroundColor && device.ios) {
      Statusbar.setBackgroundColor(params.iosBackgroundColor);
    }

    if (params.androidBackgroundColor && device.android) {
      Statusbar.setBackgroundColor(params.androidBackgroundColor);
    }
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'statusbar',
  params: {
    statusbar: {
      enabled: true,
      scrollTopOnClick: true,
      iosOverlaysWebView: true,
      iosTextColor: 'black',
      iosBackgroundColor: null,
      androidOverlaysWebView: false,
      androidTextColor: 'black',
      androidBackgroundColor: null
    }
  },

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.bindMethods)(app, {
      statusbar: Statusbar
    });
  },

  on: {
    init() {
      const app = this;
      Statusbar.init.call(app);
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/components/stepper/stepper-class.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7/components/stepper/stepper-class.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");




class Stepper extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    super(params, [app]);
    const stepper = this;
    const defaults = {
      el: null,
      inputEl: null,
      valueEl: null,
      value: 0,
      formatValue: null,
      step: 1,
      min: 0,
      max: 100,
      watchInput: true,
      autorepeat: false,
      autorepeatDynamic: false,
      wraps: false,
      manualInputMode: false,
      decimalPoint: 4,
      buttonsEndInputMode: true
    }; // Extend defaults with modules params

    stepper.useModulesParams(defaults);
    stepper.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(defaults, params);

    if (stepper.params.value < stepper.params.min) {
      stepper.params.value = stepper.params.min;
    }

    if (stepper.params.value > stepper.params.max) {
      stepper.params.value = stepper.params.max;
    }

    const el = stepper.params.el;
    if (!el) return stepper;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    if ($el.length === 0) return stepper;
    if ($el[0].f7Stepper) return $el[0].f7Stepper;
    let $inputEl;

    if (stepper.params.inputEl) {
      $inputEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(stepper.params.inputEl);
    } else if ($el.find('.stepper-input-wrap').find('input, textarea').length) {
      $inputEl = $el.find('.stepper-input-wrap').find('input, textarea').eq(0);
    }

    if ($inputEl && $inputEl.length) {
      'step min max'.split(' ').forEach(paramName => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          stepper.params[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });
      const decimalPoint = parseInt(stepper.params.decimalPoint, 10);

      if (Number.isNaN(decimalPoint)) {
        stepper.params.decimalPoint = 0;
      } else {
        stepper.params.decimalPoint = decimalPoint;
      }

      const inputValue = parseFloat($inputEl.val());

      if (typeof params.value === 'undefined' && !Number.isNaN(inputValue) && (inputValue || inputValue === 0)) {
        stepper.params.value = inputValue;
      }
    }

    let $valueEl;

    if (stepper.params.valueEl) {
      $valueEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(stepper.params.valueEl);
    } else if ($el.find('.stepper-value').length) {
      $valueEl = $el.find('.stepper-value').eq(0);
    }

    const $buttonPlusEl = $el.find('.stepper-button-plus');
    const $buttonMinusEl = $el.find('.stepper-button-minus');
    const {
      step,
      min,
      max,
      value,
      decimalPoint
    } = stepper.params;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(stepper, {
      app,
      $el,
      el: $el[0],
      $buttonPlusEl,
      buttonPlusEl: $buttonPlusEl[0],
      $buttonMinusEl,
      buttonMinusEl: $buttonMinusEl[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : undefined,
      $valueEl,
      valueEl: $valueEl ? $valueEl[0] : undefined,
      step,
      min,
      max,
      value,
      decimalPoint,
      typeModeChanged: false
    });
    $el[0].f7Stepper = stepper; // Handle Events

    const touchesStart = {};
    let isTouched;
    let isScrolling;
    let preventButtonClick;
    let intervalId;
    let timeoutId;
    let autorepeatAction = null;
    let autorepeatInAction = false;
    let manualInput = false;

    function dynamicRepeat(current, progressions, startsIn, progressionStep, repeatEvery, action) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        if (current === 1) {
          preventButtonClick = true;
          autorepeatInAction = true;
        }

        clearInterval(intervalId);
        action();
        intervalId = setInterval(() => {
          action();
        }, repeatEvery);

        if (current < progressions) {
          dynamicRepeat(current + 1, progressions, startsIn, progressionStep, repeatEvery / 2, action);
        }
      }, current === 1 ? startsIn : progressionStep);
    }

    function onTouchStart(e) {
      if (isTouched) return;

      if (manualInput) {
        return;
      }

      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest($buttonPlusEl).length) {
        autorepeatAction = 'increment';
      } else if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest($buttonMinusEl).length) {
        autorepeatAction = 'decrement';
      }

      if (!autorepeatAction) return;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isScrolling = undefined;
      const progressions = stepper.params.autorepeatDynamic ? 4 : 1;
      dynamicRepeat(1, progressions, 500, 1000, 300, () => {
        stepper[autorepeatAction]();
      });
    }

    function onTouchMove(e) {
      if (!isTouched) return;

      if (manualInput) {
        return;
      }

      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (typeof isScrolling === 'undefined' && !autorepeatInAction) {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }

      const distance = ((pageX - touchesStart.x) ** 2 + (pageY - touchesStart.y) ** 2) ** 0.5;

      if (isScrolling || distance > 20) {
        isTouched = false;
        clearTimeout(timeoutId);
        clearInterval(intervalId);
      }
    }

    function onTouchEnd() {
      clearTimeout(timeoutId);
      clearInterval(intervalId);
      autorepeatAction = null;
      autorepeatInAction = false;
      isTouched = false;
    }

    function onMinusClick() {
      if (manualInput) {
        if (stepper.params.buttonsEndInputMode) {
          manualInput = false;
          stepper.endTypeMode(true);
        }

        return;
      }

      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }

      stepper.decrement(true);
    }

    function onPlusClick() {
      if (manualInput) {
        if (stepper.params.buttonsEndInputMode) {
          manualInput = false;
          stepper.endTypeMode(true);
        }

        return;
      }

      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }

      stepper.increment(true);
    }

    function onInputClick(e) {
      if (!e.target.readOnly && stepper.params.manualInputMode) {
        manualInput = true;

        if (typeof e.target.selectionStart === 'number') {
          e.target.selectionStart = e.target.value.length;
          e.target.selectionEnd = e.target.value.length;
        }
      }
    }

    function onInputKey(e) {
      if (e.keyCode === 13 || e.which === 13) {
        e.preventDefault();
        manualInput = false;
        stepper.endTypeMode();
      }
    }

    function onInputBlur() {
      manualInput = false;
      stepper.endTypeMode(true);
    }

    function onInput(e) {
      if (manualInput) {
        stepper.typeValue(e.target.value);
        return;
      }

      if (e.detail && e.detail.sentByF7Stepper) return;
      stepper.setValue(e.target.value, true);
    }

    stepper.attachEvents = function attachEvents() {
      $buttonMinusEl.on('click', onMinusClick);
      $buttonPlusEl.on('click', onPlusClick);

      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.on('input', onInput);
        $inputEl.on('click', onInputClick);
        $inputEl.on('blur', onInputBlur);
        $inputEl.on('keyup', onInputKey);
      }

      if (stepper.params.autorepeat) {
        app.on('touchstart:passive', onTouchStart);
        app.on('touchmove:active', onTouchMove);
        app.on('touchend:passive', onTouchEnd);
      }
    };

    stepper.detachEvents = function detachEvents() {
      $buttonMinusEl.off('click', onMinusClick);
      $buttonPlusEl.off('click', onPlusClick);

      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.off('input', onInput);
        $inputEl.off('click', onInputClick);
        $inputEl.off('blur', onInputBlur);
        $inputEl.off('keyup', onInputKey);
      }
    }; // Install Modules


    stepper.useModules(); // Init

    stepper.init();
    return stepper;
  }

  minus() {
    return this.decrement();
  }

  plus() {
    return this.increment();
  }

  decrement() {
    const stepper = this;
    return stepper.setValue(stepper.value - stepper.step, false, true);
  }

  increment() {
    const stepper = this;
    return stepper.setValue(stepper.value + stepper.step, false, true);
  }

  setValue(newValue, forceUpdate, withWraps) {
    const stepper = this;
    const {
      step,
      min,
      max
    } = stepper;
    const oldValue = stepper.value;
    let value = Math.round(newValue / step) * step;

    if (stepper.params.wraps && withWraps) {
      if (value > max) value = min;
      if (value < min) value = max;
    } else {
      value = Math.max(Math.min(value, max), min);
    }

    if (Number.isNaN(value)) {
      value = oldValue;
    }

    stepper.value = value;
    const valueChanged = oldValue !== value; // Events

    if (!valueChanged && !forceUpdate) return stepper;
    stepper.$el.trigger('stepper:change', stepper.value);
    const formattedValue = stepper.formatValue(stepper.value);

    if (stepper.$inputEl && stepper.$inputEl.length) {
      stepper.$inputEl.val(formattedValue);
      stepper.$inputEl.trigger('input change', {
        sentByF7Stepper: true
      });
    }

    if (stepper.$valueEl && stepper.$valueEl.length) {
      stepper.$valueEl.html(formattedValue);
    }

    stepper.emit('local::change stepperChange', stepper, stepper.value);
    return stepper;
  }

  endTypeMode(noBlur) {
    const stepper = this;
    const {
      min,
      max
    } = stepper;
    let value = parseFloat(stepper.value);
    if (Number.isNaN(value)) value = 0;
    value = Math.max(Math.min(value, max), min);
    stepper.value = value;

    if (!stepper.typeModeChanged) {
      if (stepper.$inputEl && stepper.$inputEl.length && !noBlur) {
        stepper.$inputEl.blur();
      }

      return stepper;
    }

    stepper.typeModeChanged = false;
    stepper.$el.trigger('stepper:change', stepper.value);
    const formattedValue = stepper.formatValue(stepper.value);

    if (stepper.$inputEl && stepper.$inputEl.length) {
      stepper.$inputEl.val(formattedValue);
      stepper.$inputEl.trigger('input change', {
        sentByF7Stepper: true
      });
      if (!noBlur) stepper.$inputEl.blur();
    }

    if (stepper.$valueEl && stepper.$valueEl.length) {
      stepper.$valueEl.html(formattedValue);
    }

    stepper.emit('local::change stepperChange', stepper, stepper.value);
    return stepper;
  }

  typeValue(value) {
    const stepper = this;
    stepper.typeModeChanged = true;
    let inputTxt = String(value);
    if (inputTxt.length === 1 && inputTxt === '-') return stepper;

    if (inputTxt.lastIndexOf('.') + 1 === inputTxt.length || inputTxt.lastIndexOf(',') + 1 === inputTxt.length) {
      if (inputTxt.lastIndexOf('.') !== inputTxt.indexOf('.') || inputTxt.lastIndexOf(',') !== inputTxt.indexOf(',')) {
        inputTxt = inputTxt.slice(0, -1);
        stepper.value = inputTxt;
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
    } else {
      let newValue = parseFloat(inputTxt.replace(',', '.'));

      if (newValue === 0) {
        stepper.value = inputTxt.replace(',', '.');
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }

      if (Number.isNaN(newValue)) {
        stepper.value = 0;
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }

      const powVal = 10 ** stepper.params.decimalPoint;
      newValue = Math.round(newValue * powVal).toFixed(stepper.params.decimalPoint + 1) / powVal;
      stepper.value = parseFloat(String(newValue).replace(',', '.'));
      stepper.$inputEl.val(stepper.value);
      return stepper;
    }

    stepper.value = inputTxt;
    stepper.$inputEl.val(inputTxt);
    return stepper;
  }

  getValue() {
    return this.value;
  }

  formatValue(value) {
    const stepper = this;
    if (!stepper.params.formatValue) return value;
    return stepper.params.formatValue.call(stepper, value);
  }

  init() {
    const stepper = this;
    stepper.attachEvents();

    if (stepper.$valueEl && stepper.$valueEl.length) {
      const formattedValue = stepper.formatValue(stepper.value);
      stepper.$valueEl.html(formattedValue);
    }

    return stepper;
  }

  destroy() {
    let stepper = this;
    stepper.$el.trigger('stepper:beforedestroy');
    stepper.emit('local::beforeDestroy stepperBeforeDestroy', stepper);
    delete stepper.$el[0].f7Stepper;
    stepper.detachEvents();
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(stepper);
    stepper = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Stepper);

/***/ }),

/***/ "./node_modules/framework7/components/stepper/stepper.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/components/stepper/stepper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _stepper_class_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stepper-class.js */ "./node_modules/framework7/components/stepper/stepper-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'stepper',

  create() {
    const app = this;
    app.stepper = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.stepper',
      constructor: _stepper_class_js__WEBPACK_IMPORTED_MODULE_3__["default"],
      app,
      domProp: 'f7Stepper'
    }), {
      getValue(el) {
        if (el === void 0) {
          el = '.stepper';
        }

        const stepper = app.stepper.get(el);
        if (stepper) return stepper.getValue();
        return undefined;
      },

      setValue(el, value) {
        if (el === void 0) {
          el = '.stepper';
        }

        const stepper = app.stepper.get(el);
        if (stepper) return stepper.setValue(value);
        return undefined;
      }

    });
  },

  static: {
    Stepper: _stepper_class_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.stepper-init').each(stepperEl => {
        const dataset = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(stepperEl).dataset();
        app.stepper.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          el: stepperEl
        }, dataset || {}));
      });
    },

    tabBeforeRemove(tabEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.stepper-init').each(stepperEl => {
        if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.stepper-init').each(stepperEl => {
        const dataset = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(stepperEl).dataset();
        app.stepper.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          el: stepperEl
        }, dataset || {}));
      });
    },

    pageBeforeRemove(page) {
      page.$el.find('.stepper-init').each(stepperEl => {
        if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
      });
    }

  },
  vnode: {
    'stepper-init': {
      insert(vnode) {
        const app = this;
        const stepperEl = vnode.elm;
        const dataset = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(stepperEl).dataset();
        app.stepper.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          el: stepperEl
        }, dataset || {}));
      },

      destroy(vnode) {
        const stepperEl = vnode.elm;
        if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/subnavbar/subnavbar.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/subnavbar/subnavbar.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'subnavbar',
  on: {
    pageInit(page) {
      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length) {
        page.$el.addClass('page-with-subnavbar');
      }

      const $innerSubnavbars = page.$el.find('.subnavbar').filter(subnavbarEl => {
        return (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subnavbarEl).parents('.page')[0] === page.$el[0];
      });

      if ($innerSubnavbars.length) {
        page.$el.addClass('page-with-subnavbar');
      }
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/components/swipeout/swipeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/swipeout/swipeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");




const Swipeout = {
  init() {
    const app = this;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const touchesStart = {};
    let isTouched;
    let isMoved;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let $swipeoutEl;
    let $swipeoutContent;
    let $actionsRight;
    let $actionsLeft;
    let actionsLeftWidth;
    let actionsRightWidth;
    let translate;
    let opened;
    let openedActionsSide;
    let $leftButtons;
    let $rightButtons;
    let direction;
    let $overswipeLeftButton;
    let $overswipeRightButton;
    let overswipeLeft;
    let overswipeRight;

    function handleTouchStart(e) {
      if (!app.swipeout.allow) return;
      isMoved = false;
      isTouched = true;
      isScrolling = undefined;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchStartTime = new Date().getTime();
      $swipeoutEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this);
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }

      if (isScrolling) {
        isTouched = false;
        return;
      }

      if (!isMoved) {
        if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.list.sortable-opened').length > 0) return;
        $swipeoutContent = $swipeoutEl.find('.swipeout-content');
        $actionsRight = $swipeoutEl.find('.swipeout-actions-right');
        $actionsLeft = $swipeoutEl.find('.swipeout-actions-left');
        actionsLeftWidth = null;
        actionsRightWidth = null;
        $leftButtons = null;
        $rightButtons = null;
        $overswipeRightButton = null;
        $overswipeLeftButton = null;

        if ($actionsLeft.length > 0) {
          actionsLeftWidth = $actionsLeft.outerWidth();
          $leftButtons = $actionsLeft.children('a');
          $overswipeLeftButton = $actionsLeft.find('.swipeout-overswipe');
        }

        if ($actionsRight.length > 0) {
          actionsRightWidth = $actionsRight.outerWidth();
          $rightButtons = $actionsRight.children('a');
          $overswipeRightButton = $actionsRight.find('.swipeout-overswipe');
        }

        opened = $swipeoutEl.hasClass('swipeout-opened');

        if (opened) {
          openedActionsSide = $swipeoutEl.find('.swipeout-actions-left.swipeout-actions-opened').length > 0 ? 'left' : 'right';
        }

        $swipeoutEl.removeClass('swipeout-transitioning');

        if (!app.params.swipeout.noFollow) {
          $swipeoutEl.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
          $swipeoutEl.removeClass('swipeout-opened');
        }
      }

      isMoved = true;

      if (e.cancelable) {
        e.preventDefault();
      }

      touchesDiff = pageX - touchesStart.x;
      translate = touchesDiff;

      if (opened) {
        if (openedActionsSide === 'right') translate -= actionsRightWidth;else translate += actionsLeftWidth;
      }

      if (translate > 0 && $actionsLeft.length === 0 || translate < 0 && $actionsRight.length === 0) {
        if (!opened) {
          isTouched = false;
          isMoved = false;
          $swipeoutContent.transform('');

          if ($rightButtons && $rightButtons.length > 0) {
            $rightButtons.transform('');
          }

          if ($leftButtons && $leftButtons.length > 0) {
            $leftButtons.transform('');
          }

          return;
        }

        translate = 0;
      }

      if (translate < 0) direction = 'to-left';else if (translate > 0) direction = 'to-right';else if (!direction) direction = 'to-left';
      let buttonOffset;
      let progress;
      e.f7PreventSwipePanel = true;

      if (app.params.swipeout.noFollow) {
        if (opened) {
          if (openedActionsSide === 'right' && touchesDiff > 0) {
            app.swipeout.close($swipeoutEl);
          }

          if (openedActionsSide === 'left' && touchesDiff < 0) {
            app.swipeout.close($swipeoutEl);
          }
        } else {
          if (touchesDiff < 0 && $actionsRight.length > 0) {
            app.swipeout.open($swipeoutEl, 'right');
          }

          if (touchesDiff > 0 && $actionsLeft.length > 0) {
            app.swipeout.open($swipeoutEl, 'left');
          }
        }

        isTouched = false;
        isMoved = false;
        return;
      }

      overswipeLeft = false;
      overswipeRight = false;

      if ($actionsRight.length > 0) {
        // Show right actions
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsRightWidth;

        if (buttonTranslate < -actionsRightWidth) {
          const ratio = buttonTranslate / -actionsRightWidth;
          buttonTranslate = -actionsRightWidth - (-buttonTranslate - actionsRightWidth) ** 0.8;
          translate = buttonTranslate;

          if ($overswipeRightButton.length > 0 && ratio > app.params.swipeout.overswipeRatio) {
            overswipeRight = true;
          }
        }

        if (direction !== 'to-left') {
          progress = 0;
          buttonTranslate = 0;
        }

        $rightButtons.each(buttonEl => {
          const $buttonEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl);

          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }

          buttonOffset = buttonEl.f7SwipeoutButtonOffset;

          if ($overswipeRightButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-left') {
            $buttonEl.css({
              left: `${overswipeRight ? -buttonOffset : 0}px`
            });

            if (overswipeRight) {
              if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
                $swipeoutEl.trigger('swipeout:overswipeenter');
                app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
              }

              $buttonEl.addClass('swipeout-overswipe-active');
            } else {
              if ($buttonEl.hasClass('swipeout-overswipe-active')) {
                $swipeoutEl.trigger('swipeout:overswipeexit');
                app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
              }

              $buttonEl.removeClass('swipeout-overswipe-active');
            }
          }

          $buttonEl.transform(`translate3d(${buttonTranslate - buttonOffset * (1 + Math.max(progress, -1))}px,0,0)`);
        });
      }

      if ($actionsLeft.length > 0) {
        // Show left actions
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsLeftWidth;

        if (buttonTranslate > actionsLeftWidth) {
          const ratio = buttonTranslate / actionsRightWidth;
          buttonTranslate = actionsLeftWidth + (buttonTranslate - actionsLeftWidth) ** 0.8;
          translate = buttonTranslate;

          if ($overswipeLeftButton.length > 0 && ratio > app.params.swipeout.overswipeRatio) {
            overswipeLeft = true;
          }
        }

        if (direction !== 'to-right') {
          buttonTranslate = 0;
          progress = 0;
        }

        $leftButtons.each((buttonEl, index) => {
          const $buttonEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl);

          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }

          buttonOffset = buttonEl.f7SwipeoutButtonOffset;

          if ($overswipeLeftButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-right') {
            $buttonEl.css({
              left: `${overswipeLeft ? buttonOffset : 0}px`
            });

            if (overswipeLeft) {
              if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
                $swipeoutEl.trigger('swipeout:overswipeenter');
                app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
              }

              $buttonEl.addClass('swipeout-overswipe-active');
            } else {
              if ($buttonEl.hasClass('swipeout-overswipe-active')) {
                $swipeoutEl.trigger('swipeout:overswipeexit');
                app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
              }

              $buttonEl.removeClass('swipeout-overswipe-active');
            }
          }

          if ($leftButtons.length > 1) {
            $buttonEl.css('z-index', $leftButtons.length - index);
          }

          $buttonEl.transform(`translate3d(${buttonTranslate + buttonOffset * (1 - Math.min(progress, 1))}px,0,0)`);
        });
      }

      $swipeoutEl.trigger('swipeout', progress);
      app.emit('swipeout', $swipeoutEl[0], progress);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    }

    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }

      isTouched = false;
      isMoved = false;
      const timeDiff = new Date().getTime() - touchStartTime;
      const $actions = direction === 'to-left' ? $actionsRight : $actionsLeft;
      const actionsWidth = direction === 'to-left' ? actionsRightWidth : actionsLeftWidth;
      let action;
      let $buttons;
      let i;

      if (timeDiff < 300 && (touchesDiff < -10 && direction === 'to-left' || touchesDiff > 10 && direction === 'to-right') || timeDiff >= 300 && Math.abs(translate) > actionsWidth / 2) {
        action = 'open';
      } else {
        action = 'close';
      }

      if (timeDiff < 300) {
        if (Math.abs(translate) === 0) action = 'close';
        if (Math.abs(translate) === actionsWidth) action = 'open';
      }

      if (action === 'open') {
        Swipeout.el = $swipeoutEl[0];
        $swipeoutEl.trigger('swipeout:open');
        app.emit('swipeoutOpen', $swipeoutEl[0]);
        $swipeoutEl.addClass('swipeout-opened swipeout-transitioning');
        const newTranslate = direction === 'to-left' ? -actionsWidth : actionsWidth;
        $swipeoutContent.transform(`translate3d(${newTranslate}px,0,0)`);
        $actions.addClass('swipeout-actions-opened');
        $buttons = direction === 'to-left' ? $rightButtons : $leftButtons;

        if ($buttons) {
          for (i = 0; i < $buttons.length; i += 1) {
            (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])($buttons[i]).transform(`translate3d(${newTranslate}px,0,0)`);
          }
        }

        if (overswipeRight) {
          $actionsRight.find('.swipeout-overswipe').trigger('click', 'f7Overswipe');
        }

        if (overswipeLeft) {
          $actionsLeft.find('.swipeout-overswipe').trigger('click', 'f7Overswipe');
        }
      } else {
        $swipeoutEl.trigger('swipeout:close');
        app.emit('swipeoutClose', $swipeoutEl[0]);
        Swipeout.el = undefined;
        $swipeoutEl.addClass('swipeout-transitioning').removeClass('swipeout-opened');
        $swipeoutContent.transform('');
        $actions.removeClass('swipeout-actions-opened');
      }

      let buttonOffset;

      if ($leftButtons && $leftButtons.length > 0 && $leftButtons !== $buttons) {
        $leftButtons.each(buttonEl => {
          const $buttonEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;

          if (typeof buttonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }

          $buttonEl.transform(`translate3d(${buttonOffset}px,0,0)`);
        });
      }

      if ($rightButtons && $rightButtons.length > 0 && $rightButtons !== $buttons) {
        $rightButtons.each(buttonEl => {
          const $buttonEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;

          if (typeof buttonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }

          $buttonEl.transform(`translate3d(${-buttonOffset}px,0,0)`);
        });
      }

      $swipeoutContent.transitionEnd(() => {
        if (opened && action === 'open' || !opened && action === 'close') return;
        $swipeoutEl.trigger(action === 'open' ? 'swipeout:opened' : 'swipeout:closed');
        app.emit(action === 'open' ? 'swipeoutOpened' : 'swipeoutClosed', $swipeoutEl[0]);
        $swipeoutEl.removeClass('swipeout-transitioning');

        if (opened && action === 'close') {
          if ($actionsRight.length > 0) {
            $rightButtons.transform('');
          }

          if ($actionsLeft.length > 0) {
            $leftButtons.transform('');
          }
        }
      });
    }

    const passiveListener = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)().passiveListener ? {
      passive: true
    } : false;
    app.on('touchstart', e => {
      if (Swipeout.el) {
        const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target);

        if (!((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Swipeout.el).is($targetEl[0]) || $targetEl.parents('.swipeout').is(Swipeout.el) || $targetEl.hasClass('modal-in') || ($targetEl.attr('class') || '').indexOf('-backdrop') > 0 || $targetEl.hasClass('actions-modal') || $targetEl.parents('.actions-modal.modal-in, .dialog.modal-in').length > 0)) {
          app.swipeout.close(Swipeout.el);
        }
      }
    });
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on(app.touchEvents.start, 'li.swipeout', handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
  },

  allow: true,
  el: undefined,

  open() {
    const app = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    let [el, side, callback] = args;

    if (typeof args[1] === 'function') {
      [el, callback, side] = args;
    }

    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el).eq(0);
    if ($el.length === 0) return;
    if (!$el.hasClass('swipeout') || $el.hasClass('swipeout-opened')) return;

    if (!side) {
      if ($el.find('.swipeout-actions-right').length > 0) side = 'right';else side = 'left';
    }

    const $swipeoutActions = $el.find(`.swipeout-actions-${side}`);
    const $swipeoutContent = $el.find('.swipeout-content');
    if ($swipeoutActions.length === 0) return;
    $el.trigger('swipeout:open').addClass('swipeout-opened').removeClass('swipeout-transitioning');
    app.emit('swipeoutOpen', $el[0]);
    $swipeoutActions.addClass('swipeout-actions-opened');
    const $buttons = $swipeoutActions.children('a');
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    const translate = side === 'right' ? -swipeoutActionsWidth : swipeoutActionsWidth;

    if ($buttons.length > 1) {
      $buttons.each((buttonEl, buttonIndex) => {
        const $buttonEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl);

        if (side === 'right') {
          $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
        } else {
          $buttonEl.css('z-index', $buttons.length - buttonIndex).transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
        }
      });
    }

    $el.addClass('swipeout-transitioning');
    $swipeoutContent.transitionEnd(() => {
      $el.trigger('swipeout:opened');
      app.emit('swipeoutOpened', $el[0]);
      if (callback) callback.call($el[0]);
    });
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextFrame)(() => {
      $buttons.transform(`translate3d(${translate}px,0,0)`);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    });
    Swipeout.el = $el[0];
  },

  close(el, callback) {
    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el).eq(0);
    if ($el.length === 0) return;
    if (!$el.hasClass('swipeout-opened')) return;
    const side = $el.find('.swipeout-actions-opened').hasClass('swipeout-actions-right') ? 'right' : 'left';
    const $swipeoutActions = $el.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
    const $buttons = $swipeoutActions.children('a');
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    app.swipeout.allow = false;
    $el.trigger('swipeout:close');
    app.emit('swipeoutClose', $el[0]);
    $el.removeClass('swipeout-opened').addClass('swipeout-transitioning');
    let closeTimeout;

    function onSwipeoutClose() {
      app.swipeout.allow = true;
      if ($el.hasClass('swipeout-opened')) return;
      $el.removeClass('swipeout-transitioning');
      $buttons.transform('');
      $el.trigger('swipeout:closed');
      app.emit('swipeoutClosed', $el[0]);
      if (callback) callback.call($el[0]);
      if (closeTimeout) clearTimeout(closeTimeout);
    }

    $el.find('.swipeout-content').transform('').transitionEnd(onSwipeoutClose);
    closeTimeout = setTimeout(onSwipeoutClose, 500);
    $buttons.each(buttonEl => {
      const $buttonEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl);

      if (side === 'right') {
        $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
      } else {
        $buttonEl.transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
      }

      $buttonEl.css({
        left: '0px'
      }).removeClass('swipeout-overswipe-active');
    });
    if (Swipeout.el && Swipeout.el === $el[0]) Swipeout.el = undefined;
  },

  delete(el, callback) {
    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el).eq(0);
    if ($el.length === 0) return;
    Swipeout.el = undefined;
    $el.trigger('swipeout:delete');
    app.emit('swipeoutDelete', $el[0]);
    $el.css({
      height: `${$el.outerHeight()}px`
    });
    $el.transitionEnd(() => {
      $el.trigger('swipeout:deleted');
      app.emit('swipeoutDeleted', $el[0]);
      if (callback) callback.call($el[0]);

      if ($el.parents('.virtual-list').length > 0) {
        const virtualList = $el.parents('.virtual-list')[0].f7VirtualList;
        const virtualIndex = $el[0].f7VirtualListIndex;
        if (virtualList && typeof virtualIndex !== 'undefined') virtualList.deleteItem(virtualIndex);
      } else if (app.params.swipeout.removeElements) {
        if (app.params.swipeout.removeElementsWithTimeout) {
          setTimeout(() => {
            $el.remove();
          }, app.params.swipeout.removeElementsTimeout);
        } else {
          $el.remove();
        }
      } else {
        $el.removeClass('swipeout-deleting swipeout-transitioning');
      }
    }); // eslint-disable-next-line
    // $el[0]._clientLeft = $el[0].clientLeft;

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextFrame)(() => {
      $el.addClass('swipeout-deleting swipeout-transitioning').css({
        height: '0px'
      }).find('.swipeout-content').transform('translate3d(-100%,0,0)');
    });
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'swipeout',
  params: {
    swipeout: {
      actionsNoFold: false,
      noFollow: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
      overswipeRatio: 1.2
    }
  },

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.bindMethods)(app, {
      swipeout: Swipeout
    });
  },

  clicks: {
    '.swipeout-open': function openSwipeout($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      app.swipeout.open(data.swipeout, data.side);
    },
    '.swipeout-close': function closeSwipeout($clickedEl) {
      const app = this;
      const $swipeoutEl = $clickedEl.closest('.swipeout');
      if ($swipeoutEl.length === 0) return;
      app.swipeout.close($swipeoutEl);
    },
    '.swipeout-delete': function deleteSwipeout($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      const app = this;
      const $swipeoutEl = $clickedEl.closest('.swipeout');
      if ($swipeoutEl.length === 0) return;
      const {
        confirm,
        confirmTitle
      } = data;

      if (data.confirm) {
        app.dialog.confirm(confirm, confirmTitle, () => {
          app.swipeout.delete($swipeoutEl);
        });
      } else {
        app.swipeout.delete($swipeoutEl);
      }
    }
  },
  on: {
    init() {
      const app = this;
      if (!app.params.swipeout) return;
      app.swipeout.init();
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/components/swiper/swiper.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7/components/swiper/swiper.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var swiper_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper/bundle */ "./node_modules/swiper/swiper-bundle.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");
// eslint-disable-next-line


 


function initSwiper(swiperEl) {
  const app = this;
  const $swiperEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiperEl);
  if ($swiperEl.length === 0) return;
  if ($swiperEl[0].swiper) return;
  let initialSlide;
  let params = {};
  let isTabs;
  let isRoutableTabs;

  if ($swiperEl.hasClass('tabs-swipeable-wrap')) {
    $swiperEl.addClass('swiper').children('.tabs').addClass('swiper-wrapper').children('.tab').addClass('swiper-slide');
    initialSlide = $swiperEl.children('.tabs').children('.tab-active').index();
    isTabs = true;
    isRoutableTabs = $swiperEl.find('.tabs-routable').length > 0;
  }

  if ($swiperEl.attr('data-swiper')) {
    params = JSON.parse($swiperEl.attr('data-swiper'));
  } else if ($swiperEl[0].f7SwiperParams) {
    params = $swiperEl[0].f7SwiperParams;
  } else {
    params = $swiperEl.dataset();
    Object.keys(params).forEach(key => {
      const value = params[key];

      if (typeof value === 'string' && value.indexOf('{') === 0 && value.indexOf('}') > 0) {
        try {
          params[key] = JSON.parse(value);
        } catch (e) {// not JSON
        }
      }
    });
  }

  if (typeof params.initialSlide === 'undefined' && typeof initialSlide !== 'undefined') {
    params.initialSlide = initialSlide;
  }

  const swiper = app.swiper.create($swiperEl[0], params);

  function updateSwiper() {
    swiper.update();
  }

  const $tabEl = $swiperEl.parents('.tab').filter(tabEl => {
    return (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl).parent('.tabs').parent('.tabs-animated-wrap, .tabs-swipeable-wrap').length === 0;
  }).eq(0);
  $swiperEl.parents('.popup, .login-screen, .sheet-modal, .popover').on('modal:open', updateSwiper);
  $swiperEl.parents('.panel').on('panel:open', updateSwiper);

  if ($tabEl && $tabEl.length) {
    $tabEl.on('tab:show', updateSwiper);
  }

  swiper.on('beforeDestroy', () => {
    $swiperEl.parents('.popup, .login-screen, .sheet-modal, .popover').off('modal:open', updateSwiper);
    $swiperEl.parents('.panel').off('panel:open', updateSwiper);

    if ($tabEl && $tabEl.length) {
      $tabEl.off('tab:show', updateSwiper);
    }
  });

  if (isTabs) {
    swiper.on('slideChange', () => {
      if (isRoutableTabs) {
        let view = app.views.get($swiperEl.parents('.view'));
        if (!view) view = app.views.main;
        const router = view.router;
        const tabRouteUrl = router.findTabRouteUrl(swiper.slides.eq(swiper.activeIndex)[0]);

        if (tabRouteUrl) {
          setTimeout(() => {
            router.navigate(tabRouteUrl);
          }, 0);
        }
      } else {
        app.tab.show({
          tabEl: swiper.slides.eq(swiper.activeIndex)
        });
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'swiper',
  static: {
    Swiper: swiper_bundle__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;
    app.swiper = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.swiper',
      constructor: swiper_bundle__WEBPACK_IMPORTED_MODULE_0__["default"],
      domProp: 'swiper'
    });
  },

  on: {
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(swiperEl => {
        app.swiper.destroy(swiperEl);
      });
    },

    pageMounted(page) {
      const app = this;
      page.$el.find('.tabs-swipeable-wrap').each(swiperEl => {
        initSwiper.call(app, swiperEl);
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(swiperEl => {
        initSwiper.call(app, swiperEl);
      });
    },

    pageReinit(page) {
      const app = this;
      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(swiperEl => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update) swiper.update();
      });
    },

    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each(swiperEl => {
        initSwiper.call(app, swiperEl);
      });
    },

    tabShow(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each(swiperEl => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update) swiper.update();
      });
    },

    tabBeforeRemove(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each(swiperEl => {
        app.swiper.destroy(swiperEl);
      });
    }

  },
  vnode: {
    'swiper-init': {
      insert(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        initSwiper.call(app, swiperEl);
      },

      destroy(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        app.swiper.destroy(swiperEl);
      }

    },
    'tabs-swipeable-wrap': {
      insert(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        initSwiper.call(app, swiperEl);
      },

      destroy(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        app.swiper.destroy(swiperEl);
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/tabs/tabs.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/components/tabs/tabs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const Tab = {
  show() {
    const app = this;
    let tabEl;
    let tabLinkEl;
    let animate;
    let tabRoute;
    let animatedInit;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && args[0] && args[0].constructor === Object) {
      tabEl = args[0].tabEl;
      tabLinkEl = args[0].tabLinkEl;
      animate = args[0].animate;
      tabRoute = args[0].tabRoute;
      animatedInit = args[0].animatedInit;
    } else {
      [tabEl, tabLinkEl, animate, tabRoute] = args;

      if (typeof args[1] === 'boolean') {
        [tabEl, animate, tabLinkEl, tabRoute] = args;

        if (args.length > 2 && tabLinkEl.constructor === Object) {
          [tabEl, animate, tabRoute, tabLinkEl] = args;
        }
      }
    }

    if (typeof animate === 'undefined') animate = true;
    const $newTabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl);

    if (tabRoute && $newTabEl[0]) {
      $newTabEl[0].f7TabRoute = tabRoute;
    }

    if (!animatedInit && ($newTabEl.length === 0 || $newTabEl.hasClass('tab-active'))) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0]
      };
    }

    let $tabLinkEl;
    if (tabLinkEl) $tabLinkEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabLinkEl);
    const $tabsEl = $newTabEl.parent('.tabs');

    if ($tabsEl.length === 0) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0]
      };
    } // Release swipeouts in hidden tabs


    if (app.swipeout) app.swipeout.allowOpen = true; // Animated tabs

    const tabsChangedCallbacks = [];

    function onTabsChanged(callback) {
      tabsChangedCallbacks.push(callback);
    }

    function tabsChanged() {
      tabsChangedCallbacks.forEach(callback => {
        callback();
      });
    }

    let animated = false;

    if ($tabsEl.parent().hasClass('tabs-animated-wrap')) {
      $tabsEl.parent()[animate ? 'removeClass' : 'addClass']('not-animated');
      const transitionDuration = parseFloat($tabsEl.css('transition-duration').replace(',', '.'));

      if (animate && transitionDuration) {
        $tabsEl.transitionEnd(tabsChanged);
        animated = true;
      }

      const tabsTranslate = (app.rtl ? $newTabEl.index() : -$newTabEl.index()) * 100;
      $tabsEl.transform(`translate3d(${tabsTranslate}%,0,0)`);
    } // Swipeable tabs


    let swiper;

    if ($tabsEl.parent().hasClass('tabs-swipeable-wrap') && app.swiper) {
      swiper = $tabsEl.parent()[0].swiper;

      if (swiper && swiper.activeIndex !== $newTabEl.index()) {
        animated = true;
        swiper.once('slideChangeTransitionEnd', () => {
          tabsChanged();
        }).slideTo($newTabEl.index(), animate ? undefined : 0);
      } else if (swiper && swiper.animating) {
        animated = true;
        swiper.once('slideChangeTransitionEnd', () => {
          tabsChanged();
        });
      }
    } // Remove active class from old tabs


    const $oldTabEl = $tabsEl.children('.tab-active');
    $oldTabEl.removeClass('tab-active');

    if (!animatedInit && (!swiper || swiper && !swiper.animating || swiper && tabRoute)) {
      if ($oldTabEl.hasClass('view') && $oldTabEl.children('.page').length) {
        $oldTabEl.children('.page').each(pageEl => {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(pageEl).trigger('page:tabhide');
          app.emit('pageTabHide', pageEl);
        });
      }

      $oldTabEl.trigger('tab:hide');
      app.emit('tabHide', $oldTabEl[0]);
    } // Trigger 'show' event on new tab


    $newTabEl.addClass('tab-active');

    if (!animatedInit && (!swiper || swiper && !swiper.animating || swiper && tabRoute)) {
      if ($newTabEl.hasClass('view') && $newTabEl.children('.page').length) {
        $newTabEl.children('.page').each(pageEl => {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(pageEl).trigger('page:tabshow');
          app.emit('pageTabShow', pageEl);
        });
      }

      $newTabEl.trigger('tab:show');
      app.emit('tabShow', $newTabEl[0]);
    } // Find related link for new tab


    if (!$tabLinkEl) {
      // Search by id
      if (typeof tabEl === 'string') $tabLinkEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`.tab-link[href="${tabEl}"]`);else $tabLinkEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`.tab-link[href="#${$newTabEl.attr('id')}"]`); // Search by data-tab

      if (!$tabLinkEl || $tabLinkEl && $tabLinkEl.length === 0) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('[data-tab]').each(el => {
          if ($newTabEl.is((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).attr('data-tab'))) $tabLinkEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
        });
      }

      if (tabRoute && (!$tabLinkEl || $tabLinkEl && $tabLinkEl.length === 0)) {
        $tabLinkEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);

        if ($tabLinkEl.length === 0) {
          $tabLinkEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`.tab-link[href="${tabRoute.url}"]`);
        }
      }

      if ($tabLinkEl.length > 1 && $newTabEl.parents('.page').length) {
        // eslint-disable-next-line
        $tabLinkEl = $tabLinkEl.filter(tabLinkElement => {
          return (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabLinkElement).parents('.page')[0] === $newTabEl.parents('.page')[0];
        });

        if (app.theme === 'ios' && $tabLinkEl.length === 0 && tabRoute) {
          const $pageEl = $newTabEl.parents('.page');
          const $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(app.navbar.getElByPage($pageEl));
          $tabLinkEl = $navbarEl.find(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);

          if ($tabLinkEl.length === 0) {
            $tabLinkEl = $navbarEl.find(`.tab-link[href="${tabRoute.url}"]`);
          }
        }
      }
    }

    if ($tabLinkEl.length > 0) {
      // Find related link for old tab
      let $oldTabLinkEl;

      if ($oldTabEl && $oldTabEl.length > 0) {
        // Search by id
        const oldTabId = $oldTabEl.attr('id');

        if (oldTabId) {
          $oldTabLinkEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`.tab-link[href="#${oldTabId}"]`); // Search by data-route-tab-id

          if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
            $oldTabLinkEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`.tab-link[data-route-tab-id="${oldTabId}"]`);
          }
        } // Search by data-tab


        if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('[data-tab]').each(tabLinkElement => {
            if ($oldTabEl.is((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabLinkElement).attr('data-tab'))) $oldTabLinkEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabLinkElement);
          });
        }

        if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
          $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
        }
      } else if (tabRoute) {
        $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
      }

      if ($oldTabLinkEl && $oldTabLinkEl.length > 1 && $oldTabEl && $oldTabEl.parents('.page').length) {
        // eslint-disable-next-line
        $oldTabLinkEl = $oldTabLinkEl.filter(tabLinkElement => {
          return (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabLinkElement).parents('.page')[0] === $oldTabEl.parents('.page')[0];
        });
      }

      if ($oldTabLinkEl && $oldTabLinkEl.length > 0) $oldTabLinkEl.removeClass('tab-link-active'); // Update links' classes

      if ($tabLinkEl && $tabLinkEl.length > 0) {
        $tabLinkEl.addClass('tab-link-active'); // Material Highlight

        const $tabbarEl = $tabLinkEl.parents('.tabbar, .tabbar-labels');
        const hasHighlight = app.toolbar && $tabbarEl.length > 0 && ($tabbarEl.hasClass('tabbar-highlight') || app.theme !== 'ios');

        if (hasHighlight) {
          app.toolbar.setHighlight($tabbarEl);
        }
      }
    }

    return {
      $newTabEl,
      newTabEl: $newTabEl[0],
      $oldTabEl,
      oldTabEl: $oldTabEl[0],
      onTabsChanged,
      animated
    };
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'tabs',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(app, {
      tab: {
        show: Tab.show.bind(app)
      }
    });
  },

  on: {
    'pageInit tabMounted': function onInit(pageOrTabEl) {
      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(pageOrTabEl.el || pageOrTabEl);
      const animatedTabEl = $el.find('.tabs-animated-wrap > .tabs > .tab-active')[0];
      if (!animatedTabEl) return;
      const app = this;
      app.tab.show({
        tabEl: animatedTabEl,
        animatedInit: true,
        animate: false
      });
    }
  },
  clicks: {
    '.tab-link': function tabLinkClick($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }

      if ($clickedEl.attr('href') && $clickedEl.attr('href').indexOf('#') === 0 || $clickedEl.attr('data-tab')) {
        const app = this;
        app.tab.show({
          tabEl: data.tab || $clickedEl.attr('href'),
          tabLinkEl: $clickedEl,
          animate: data.animate
        });
      }
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/text-editor/text-editor-class.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/framework7/components/text-editor/text-editor-class.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");





const textEditorButtonsMap = {
  // f7-icon, material-icon, command
  bold: ['bold', 'format_bold', 'bold'],
  italic: ['italic', 'format_italic', 'italic'],
  underline: ['underline', 'format_underlined', 'underline'],
  strikeThrough: ['strikethrough', 'strikethrough_s', 'strikeThrough'],
  orderedList: ['list_number', 'format_list_numbered', 'insertOrderedList'],
  unorderedList: ['list_bullet', 'format_list_bulleted', 'insertUnorderedList'],
  link: ['link', 'link', 'createLink'],
  image: ['photo', 'image', 'insertImage'],
  paragraph: ['paragraph', '<i class="icon">¶</i>', 'formatBlock.P'],
  h1: ['<i class="icon">H<sub>1</sub></i>', '<i class="icon">H<sub>1</sub></i>', 'formatBlock.H1'],
  h2: ['<i class="icon">H<sub>2</sub></i>', '<i class="icon">H<sub>2</sub></i>', 'formatBlock.H2'],
  h3: ['<i class="icon">H<sub>3</sub></i>', '<i class="icon">H<sub>3</sub></i>', 'formatBlock.H3'],
  alignLeft: ['text_alignleft', 'format_align_left', 'justifyLeft'],
  alignCenter: ['text_aligncenter', 'format_align_center', 'justifyCenter'],
  alignRight: ['text_alignright', 'format_align_right', 'justifyRight'],
  alignJustify: ['text_justify', 'format_align_justify', 'justifyFull'],
  subscript: ['textformat_subscript', '<i class="icon">A<sub>1</sub></i>', 'subscript'],
  superscript: ['textformat_superscript', '<i class="icon">A<sup>1</sup></i>', 'superscript'],
  indent: ['increase_indent', 'format_indent_increase', 'indent'],
  outdent: ['decrease_indent', 'format_indent_decrease', 'outdent']
};

class TextEditor extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    super(params, [app]);
    const self = this;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__.getDevice)();
    const defaults = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)({}, app.params.textEditor); // Extend defaults with modules params

    self.useModulesParams(defaults);
    self.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)(defaults, params);
    const el = self.params.el;
    if (!el) return self;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
    if ($el.length === 0) return self;
    if ($el[0].f7TextEditor) return $el[0].f7TextEditor;
    let $contentEl = $el.children('.text-editor-content');

    if (!$contentEl.length) {
      $el.append('<div class="text-editor-content" contenteditable></div>');
      $contentEl = $el.children('.text-editor-content');
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)(self, {
      app,
      $el,
      el: $el[0],
      $contentEl,
      contentEl: $contentEl[0]
    });

    if ('value' in params) {
      self.value = self.params.value;
    }

    if (self.params.mode === 'keyboard-toolbar') {
      if (!(device.cordova || device.capacitor) && !device.android) {
        self.params.mode = 'popover';
      }
    }

    if (typeof self.params.buttons === 'string') {
      try {
        self.params.buttons = JSON.parse(self.params.buttons);
      } catch (err) {
        throw new Error('Framework7: TextEditor: wrong "buttons" parameter format');
      }
    }

    $el[0].f7TextEditor = self; // Bind

    self.onButtonClick = self.onButtonClick.bind(self);
    self.onFocus = self.onFocus.bind(self);
    self.onBlur = self.onBlur.bind(self);
    self.onInput = self.onInput.bind(self);
    self.onPaste = self.onPaste.bind(self);
    self.onSelectionChange = self.onSelectionChange.bind(self);
    self.closeKeyboardToolbar = self.closeKeyboardToolbar.bind(self); // Handle Events

    self.attachEvents = function attachEvents() {
      if (self.params.mode === 'toolbar') {
        self.$el.find('.text-editor-toolbar').on('click', 'button', self.onButtonClick);
      }

      if (self.params.mode === 'keyboard-toolbar') {
        self.$keyboardToolbarEl.on('click', 'button', self.onButtonClick);
        self.$el.parents('.page').on('page:beforeout', self.closeKeyboardToolbar);
      }

      if (self.params.mode === 'popover' && self.popover) {
        self.popover.$el.on('click', 'button', self.onButtonClick);
      }

      self.$contentEl.on('paste', self.onPaste);
      self.$contentEl.on('focus', self.onFocus);
      self.$contentEl.on('blur', self.onBlur);
      self.$contentEl.on('input', self.onInput, true);
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('selectionchange', self.onSelectionChange);
    };

    self.detachEvents = function detachEvents() {
      if (self.params.mode === 'toolbar') {
        self.$el.find('.text-editor-toolbar').off('click', 'button', self.onButtonClick);
      }

      if (self.params.mode === 'keyboard-toolbar') {
        self.$keyboardToolbarEl.off('click', 'button', self.onButtonClick);
        self.$el.parents('.page').off('page:beforeout', self.closeKeyboardToolbar);
      }

      if (self.params.mode === 'popover' && self.popover) {
        self.popover.$el.off('click', 'button', self.onButtonClick);
      }

      self.$contentEl.off('paste', self.onPaste);
      self.$contentEl.off('focus', self.onFocus);
      self.$contentEl.off('blur', self.onBlur);
      self.$contentEl.off('input', self.onInput, true);
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off('selectionchange', self.onSelectionChange);
    }; // Install Modules


    self.useModules(); // Init

    self.init();
    return self;
  }

  setValue(newValue) {
    const self = this;
    const currentValue = self.value;
    if (currentValue === newValue) return self;
    self.value = newValue;
    self.$contentEl.html(newValue);
    self.$el.trigger('texteditor:change', self.value);
    self.emit('local::change textEditorChange', self, self.value);
    return self;
  }

  getValue() {
    const self = this;
    return self.value;
  }

  clearValue() {
    const self = this;
    self.setValue('');

    if (self.params.placeholder && !self.$contentEl.html()) {
      self.insertPlaceholder();
    }

    return self;
  }

  createLink() {
    const self = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const currentSelection = window.getSelection();
    const selectedNodes = [];
    let $selectedLinks;

    if (currentSelection && currentSelection.anchorNode && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentSelection.anchorNode).parents(self.$el).length) {
      let anchorNode = currentSelection.anchorNode;

      while (anchorNode) {
        selectedNodes.push(anchorNode);

        if (!anchorNode.nextSibling || anchorNode === currentSelection.focusNode) {
          anchorNode = null;
        }

        if (anchorNode) {
          anchorNode = anchorNode.nextSibling;
        }
      }

      const selectedNodesLinks = [];
      const $selectedNodes = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selectedNodes);

      for (let i = 0; i < $selectedNodes.length; i += 1) {
        const childNodes = $selectedNodes[i].children;

        if (childNodes) {
          for (let j = 0; j < childNodes.length; j += 1) {
            if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(childNodes[j]).is('a')) {
              selectedNodesLinks.push(childNodes[j]);
            }
          }
        }
      }

      $selectedLinks = $selectedNodes.closest('a').add((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selectedNodesLinks));
    }

    if ($selectedLinks && $selectedLinks.length) {
      $selectedLinks.each(linkNode => {
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(linkNode);
        selection.removeAllRanges();
        selection.addRange(range);
        document.execCommand('unlink', false);
        selection.removeAllRanges();
      });
      return self;
    }

    const currentRange = self.getSelectionRange();
    if (!currentRange) return self;
    const dialog = self.app.dialog.prompt(self.params.linkUrlText, '', link => {
      if (link && link.trim().length) {
        self.setSelectionRange(currentRange);
        document.execCommand('createLink', false, link.trim());
        self.$el.trigger('texteditor:insertlink', {
          url: link.trim()
        });
        self.emit('local:insertLink textEditorInsertLink', self, link.trim());
      }
    });
    dialog.$el.find('input').focus();
    return self;
  }

  insertImage() {
    const self = this;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const currentRange = self.getSelectionRange();
    if (!currentRange) return self;
    const dialog = self.app.dialog.prompt(self.params.imageUrlText, '', imageUrl => {
      if (imageUrl && imageUrl.trim().length) {
        self.setSelectionRange(currentRange);
        document.execCommand('insertImage', false, imageUrl.trim());
        self.$el.trigger('texteditor:insertimage', {
          url: imageUrl.trim()
        });
        self.emit('local:insertImage textEditorInsertImage', self, imageUrl.trim());
      }
    });
    dialog.$el.find('input').focus();
    return self;
  }

  removePlaceholder() {
    const self = this;
    self.$contentEl.find('.text-editor-placeholder').remove();
  }

  insertPlaceholder() {
    const self = this;
    self.$contentEl.append(`<div class="text-editor-placeholder">${self.params.placeholder}</div>`);
  }

  onSelectionChange() {
    const self = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    if (self.params.mode === 'toolbar') return;
    const selection = window.getSelection();
    const selectionIsInContent = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;

    if (self.params.mode === 'keyboard-toolbar') {
      if (!selectionIsInContent) {
        self.closeKeyboardToolbar();
      } else {
        self.openKeyboardToolbar();
      }

      return;
    }

    if (self.params.mode === 'popover') {
      const selectionIsInPopover = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selection.anchorNode).parents(self.popover.el).length || selection.anchorNode === self.popover.el;

      if (!selectionIsInContent && !selectionIsInPopover) {
        self.closePopover();
        return;
      }

      if (!selection.isCollapsed && selection.rangeCount) {
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        const rootEl = self.app.$el[0] || document.body;
        self.openPopover(rect.x + (window.scrollX || 0) - rootEl.offsetLeft, rect.y + (window.scrollY || 0) - rootEl.offsetTop, rect.width, rect.height);
      } else if (selection.isCollapsed) {
        self.closePopover();
      }
    }
  }

  onPaste(e) {
    const self = this;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

    if (self.params.clearFormattingOnPaste && e.clipboardData && e.clipboardData.getData) {
      const text = e.clipboardData.getData('text/plain');
      e.preventDefault();
      document.execCommand('insertText', false, text);
    }
  }

  onInput() {
    const self = this;
    const value = self.$contentEl.html();
    self.value = value;
    self.$el.trigger('texteditor:input');
    self.emit('local:input textEditorInput', self, self.value);
    self.$el.trigger('texteditor:change', self.value);
    self.emit('local::change textEditorChange', self, self.value);
  }

  onFocus() {
    const self = this;
    self.removePlaceholder();
    self.$contentEl.focus();
    self.$el.trigger('texteditor:focus');
    self.emit('local::focus textEditorFocus', self);
  }

  onBlur() {
    const self = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

    if (self.params.placeholder && self.$contentEl.html() === '') {
      self.insertPlaceholder();
    }

    if (self.params.mode === 'popover') {
      const selection = window.getSelection();
      const selectionIsInContent = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
      const inPopover = document.activeElement && self.popover && (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document.activeElement).closest(self.popover.$el).length;

      if (!inPopover && !selectionIsInContent) {
        self.closePopover();
      }
    }

    if (self.params.mode === 'keyboard-toolbar') {
      const selection = window.getSelection();
      const selectionIsInContent = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;

      if (!selectionIsInContent) {
        self.closeKeyboardToolbar();
      }
    }

    self.$el.trigger('texteditor:blur');
    self.emit('local::blur textEditorBlur', self);
  }

  onButtonClick(e) {
    const self = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const selection = window.getSelection();
    const selectionIsInContent = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
    if (!selectionIsInContent) return;
    const $buttonEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest('button');

    if ($buttonEl.parents('form').length) {
      e.preventDefault();
    }

    const button = $buttonEl.attr('data-button');
    const buttonData = self.params.customButtons && self.params.customButtons[button];
    if (!button || !(textEditorButtonsMap[button] || buttonData)) return;
    $buttonEl.trigger('texteditor:buttonclick', button);
    self.emit('local::buttonClick textEditorButtonClick', self, button);

    if (buttonData) {
      if (buttonData.onClick) buttonData.onClick(self, $buttonEl[0]);
      return;
    }

    const command = textEditorButtonsMap[button][2];

    if (command === 'createLink') {
      self.createLink();
      return;
    }

    if (command === 'insertImage') {
      self.insertImage();
      return;
    }

    if (command.indexOf('formatBlock') === 0) {
      const tagName = command.split('.')[1];
      const $anchorNode = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selection.anchorNode);

      if ($anchorNode.parents(tagName.toLowerCase()).length || $anchorNode.is(tagName)) {
        document.execCommand('formatBlock', false, 'div');
      } else {
        document.execCommand('formatBlock', false, tagName);
      }

      return;
    }

    document.execCommand(command, false);
  } // eslint-disable-next-line


  getSelectionRange() {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

    if (window.getSelection) {
      const sel = window.getSelection();

      if (sel.getRangeAt && sel.rangeCount) {
        return sel.getRangeAt(0);
      }
    } else if (document.selection && document.selection.createRange) {
      return document.selection.createRange();
    }

    return null;
  } // eslint-disable-next-line


  setSelectionRange(range) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

    if (range) {
      if (window.getSelection) {
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      } else if (document.selection && range.select) {
        range.select();
      }
    }
  }

  renderButtons() {
    const self = this;
    let html = '';

    function renderButton(button) {
      const iconClass = self.app.theme === 'md' ? 'material-icons' : 'f7-icons';

      if (self.params.customButtons && self.params.customButtons[button]) {
        const buttonData = self.params.customButtons[button];
        return `<button type="button" class="text-editor-button" data-button="${button}">${buttonData.content || ''}</button>`;
      }

      if (!textEditorButtonsMap[button]) return '';
      const iconContent = textEditorButtonsMap[button][self.app.theme === 'md' ? 1 : 0];
      return `<button type="button" class="text-editor-button" data-button="${button}">${iconContent.indexOf('<') >= 0 ? iconContent : `<i class="${iconClass}">${iconContent}</i>`}</button>`.trim();
    }

    self.params.buttons.forEach((button, buttonIndex) => {
      if (Array.isArray(button)) {
        button.forEach(b => {
          html += renderButton(b);
        });

        if (buttonIndex < self.params.buttons.length - 1 && self.params.dividers) {
          html += '<div class="text-editor-button-divider"></div>';
        }
      } else {
        html += renderButton(button);
      }
    });
    return html;
  }

  createToolbar() {
    const self = this;
    self.$el.prepend(`<div class="text-editor-toolbar">${self.renderButtons()}</div>`);
  }

  createKeyboardToolbar() {
    const self = this;
    self.$keyboardToolbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(`<div class="toolbar toolbar-bottom text-editor-keyboard-toolbar"><div class="toolbar-inner">${self.renderButtons()}</div></div>`);
  }

  createPopover() {
    const self = this;
    self.popover = self.app.popover.create({
      content: `
        <div class="popover dark text-editor-popover">
          <div class="popover-inner">${self.renderButtons()}</div>
        </div>
      `,
      closeByOutsideClick: false,
      backdrop: false
    });
  }

  openKeyboardToolbar() {
    const self = this;
    if (self.$keyboardToolbarEl.parent(self.app.$el).length) return;
    self.$el.trigger('texteditor:keyboardopen');
    self.emit('local::keyboardOpen textEditorKeyboardOpen', self);
    self.app.$el.append(self.$keyboardToolbarEl);
  }

  closeKeyboardToolbar() {
    const self = this;
    self.$keyboardToolbarEl.remove();
    self.$el.trigger('texteditor:keyboardclose');
    self.emit('local::keyboardClose textEditorKeyboardClose', self);
  }

  openPopover(targetX, targetY, targetWidth, targetHeight) {
    const self = this;
    if (!self.popover) return;
    Object.assign(self.popover.params, {
      targetX,
      targetY,
      targetWidth,
      targetHeight
    });
    clearTimeout(self.popoverTimeout);
    self.popoverTimeout = setTimeout(() => {
      if (!self.popover) return;

      if (self.popover.opened) {
        self.popover.resize();
      } else {
        self.$el.trigger('texteditor:popoveropen');
        self.emit('local::popoverOpen textEditorPopoverOpen', self);
        self.popover.open();
      }
    }, 400);
  }

  closePopover() {
    const self = this;
    clearTimeout(self.popoverTimeout);
    if (!self.popover || !self.popover.opened) return;
    self.popoverTimeout = setTimeout(() => {
      if (!self.popover) return;
      self.$el.trigger('texteditor:popoverclose');
      self.emit('local::popoverClose textEditorPopoverClose', self);
      self.popover.close();
    }, 400);
  }

  init() {
    const self = this;

    if (self.value) {
      self.$contentEl.html(self.value);
    } else {
      self.value = self.$contentEl.html();
    }

    if (self.params.placeholder && self.value === '') {
      self.insertPlaceholder();
    }

    if (self.params.mode === 'toolbar') {
      self.createToolbar();
    } else if (self.params.mode === 'popover') {
      self.createPopover();
    } else if (self.params.mode === 'keyboard-toolbar') {
      self.createKeyboardToolbar();
    }

    self.attachEvents();
    self.$el.trigger('texteditor:init');
    self.emit('local::init textEditorInit', self);
    return self;
  }

  destroy() {
    let self = this;
    self.$el.trigger('texteditor:beforedestroy');
    self.emit('local::beforeDestroy textEditorBeforeDestroy', self);
    self.detachEvents();

    if (self.params.mode === 'keyboard-toolbar' && self.$keyboardToolbarEl) {
      self.$keyboardToolbarEl.remove();
    }

    if (self.popover) {
      self.popover.close(false);
      self.popover.destroy();
    }

    delete self.$el[0].f7TextEditor;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.deleteProps)(self);
    self = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextEditor);

/***/ }),

/***/ "./node_modules/framework7/components/text-editor/text-editor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/framework7/components/text-editor/text-editor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _text_editor_class_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./text-editor-class.js */ "./node_modules/framework7/components/text-editor/text-editor-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'textEditor',
  params: {
    textEditor: {
      el: null,
      mode: 'toolbar',
      // or 'popover'
      value: undefined,
      // will use html content
      customButtons: null,
      buttons: [['bold', 'italic', 'underline', 'strikeThrough'], ['orderedList', 'unorderedList'], ['link', 'image'], ['paragraph', 'h1', 'h2', 'h3'], ['alignLeft', 'alignCenter', 'alignRight', 'alignJustify'], ['subscript', 'superscript'], ['indent', 'outdent']],
      dividers: true,
      imageUrlText: 'Insert image URL',
      linkUrlText: 'Insert link URL',
      placeholder: null,
      clearFormattingOnPaste: true
    }
  },

  create() {
    const app = this;
    app.textEditor = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.text-editor',
      constructor: _text_editor_class_js__WEBPACK_IMPORTED_MODULE_3__["default"],
      app,
      domProp: 'f7TextEditor'
    }));
  },

  static: {
    TextEditor: _text_editor_class_js__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.text-editor-init').each(editorEl => {
        const dataset = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(editorEl).dataset();
        app.textEditor.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          el: editorEl
        }, dataset || {}));
      });
    },

    tabBeforeRemove(tabEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.text-editor-init').each(editorEl => {
        if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.text-editor-init').each(editorEl => {
        const dataset = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(editorEl).dataset();
        app.textEditor.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          el: editorEl
        }, dataset || {}));
      });
    },

    pageBeforeRemove(page) {
      page.$el.find('.text-editor-init').each(editorEl => {
        if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
      });
    }

  },
  vnode: {
    'text-editor-init': {
      insert(vnode) {
        const app = this;
        const editorEl = vnode.elm;
        const dataset = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(editorEl).dataset();
        app.textEditor.create((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
          el: editorEl
        }, dataset || {}));
      },

      destroy(vnode) {
        const editorEl = vnode.elm;
        if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/timeline/timeline.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/timeline/timeline.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'timeline'
});

/***/ }),

/***/ "./node_modules/framework7/components/toast/toast-class.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/toast/toast-class.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modal/modal-class.js */ "./node_modules/framework7/components/modal/modal-class.js");
/* harmony import */ var _shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/$jsx.js */ "./node_modules/framework7/shared/$jsx.js");




/** @jsx $jsx */



class Toast extends _modal_modal_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    const extendedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({
      on: {}
    }, app.params.toast, params); // Extends with open/close Modal methods;

    super(app, extendedParams);
    const toast = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    toast.app = app;
    toast.params = extendedParams;
    const {
      closeButton,
      closeTimeout
    } = toast.params;
    let $el;

    if (!toast.params.el) {
      // Find Element
      const toastHtml = toast.render();
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(toastHtml);
    } else {
      $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(toast.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return toast.destroy();
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(toast, {
      $el,
      el: $el[0],
      type: 'toast'
    });
    $el[0].f7Modal = toast;

    if (closeButton) {
      $el.find('.toast-button').on('click', () => {
        toast.emit('local::closeButtonClick toastCloseButtonClick', toast);
        toast.close();
      });
      toast.on('beforeDestroy', () => {
        $el.find('.toast-button').off('click');
      });
    }

    let timeoutId;
    toast.on('open', () => {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.toast.modal-in').each(openedEl => {
        const toastInstance = app.toast.get(openedEl);

        if (openedEl !== toast.el && toastInstance) {
          toastInstance.close();
        }
      });

      if (closeTimeout) {
        timeoutId = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
          toast.close();
        }, closeTimeout);
      }
    });
    toast.on('close', () => {
      window.clearTimeout(timeoutId);
    });

    if (toast.params.destroyOnClose) {
      toast.once('closed', () => {
        setTimeout(() => {
          toast.destroy();
        }, 0);
      });
    }

    return toast;
  }

  render() {
    const toast = this;
    if (toast.params.render) return toast.params.render.call(toast, toast);
    const {
      position,
      horizontalPosition,
      cssClass,
      icon,
      text,
      closeButton,
      closeButtonColor,
      closeButtonText
    } = toast.params;
    const horizontalClass = position === 'top' || position === 'bottom' ? `toast-horizontal-${horizontalPosition}` : '';
    return (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: `toast toast-${position} ${horizontalClass} ${cssClass || ''} ${icon ? 'toast-with-icon' : ''}`
    }, (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "toast-content"
    }, icon && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "toast-icon"
    }, icon), (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("div", {
      class: "toast-text"
    }, text), closeButton && !icon && (0,_shared_$jsx_js__WEBPACK_IMPORTED_MODULE_4__["default"])("a", {
      class: `toast-button button ${closeButtonColor ? `color-${closeButtonColor}` : ''}`
    }, closeButtonText)));
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Toast);

/***/ }),

/***/ "./node_modules/framework7/components/toast/toast.js":
/*!***********************************************************!*\
  !*** ./node_modules/framework7/components/toast/toast.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _toast_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toast-class.js */ "./node_modules/framework7/components/toast/toast-class.js");
/* harmony import */ var _shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/modal-methods.js */ "./node_modules/framework7/shared/modal-methods.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'toast',
  static: {
    Toast: _toast_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;
    app.toast = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, (0,_shared_modal_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      app,
      constructor: _toast_class_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      defaultSelector: '.toast.modal-in'
    }), {
      // Shortcuts
      show(params) {
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(params, {
          destroyOnClose: true
        });
        return new _toast_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](app, params).open();
      }

    });
  },

  params: {
    toast: {
      icon: null,
      text: null,
      position: 'bottom',
      horizontalPosition: 'left',
      closeButton: false,
      closeButtonColor: null,
      closeButtonText: 'Ok',
      closeTimeout: null,
      cssClass: null,
      render: null,
      containerEl: null
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/toggle/toggle-class.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/toggle/toggle-class.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");





class Toggle extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const toggle = this;
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_2__.getSupport)();
    const defaults = {}; // Extend defaults with modules params

    toggle.useModulesParams(defaults);
    toggle.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(defaults, params);
    const el = toggle.params.el;
    if (!el) return toggle;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    if ($el.length === 0) return toggle;
    if ($el[0].f7Toggle) return $el[0].f7Toggle;
    const $inputEl = $el.children('input[type="checkbox"]');
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(toggle, {
      app,
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl[0],
      disabled: $el.hasClass('disabled') || $inputEl.hasClass('disabled') || $inputEl.attr('disabled') || $inputEl[0].disabled
    });
    Object.defineProperty(toggle, 'checked', {
      enumerable: true,
      configurable: true,

      set(checked) {
        if (!toggle || typeof toggle.$inputEl === 'undefined') return;
        if (toggle.checked === checked) return;
        $inputEl[0].checked = checked;
        toggle.$inputEl.trigger('change');
      },

      get() {
        return $inputEl[0].checked;
      }

    });
    $el[0].f7Toggle = toggle;
    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let toggleWidth;
    let touchStartTime;
    let touchStartChecked;

    function handleTouchStart(e) {
      if (isTouched || toggle.disabled) return;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchesDiff = 0;
      isTouched = true;
      isScrolling = undefined;
      touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.now)();
      touchStartChecked = toggle.checked;
      toggleWidth = $el[0].offsetWidth;
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
        if (isTouched) {
          $el.addClass('toggle-active-state');
        }
      });
    }

    function handleTouchMove(e) {
      if (!isTouched || toggle.disabled) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      const inverter = app.rtl ? -1 : 1;

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }

      if (isScrolling) {
        isTouched = false;
        return;
      }

      e.preventDefault();
      touchesDiff = pageX - touchesStart.x;
      let changed;

      if (touchesDiff * inverter < 0 && Math.abs(touchesDiff) > toggleWidth / 3 && touchStartChecked) {
        changed = true;
      }

      if (touchesDiff * inverter > 0 && Math.abs(touchesDiff) > toggleWidth / 3 && !touchStartChecked) {
        changed = true;
      }

      if (changed) {
        touchesStart.x = pageX;
        toggle.checked = !touchStartChecked;
        touchStartChecked = !touchStartChecked;
      }
    }

    function handleTouchEnd() {
      if (!isTouched || toggle.disabled) {
        if (isScrolling) $el.removeClass('toggle-active-state');
        isTouched = false;
        return;
      }

      const inverter = app.rtl ? -1 : 1;
      isTouched = false;
      $el.removeClass('toggle-active-state');
      let changed;

      if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.now)() - touchStartTime < 300) {
        if (touchesDiff * inverter < 0 && touchStartChecked) {
          changed = true;
        }

        if (touchesDiff * inverter > 0 && !touchStartChecked) {
          changed = true;
        }

        if (changed) {
          toggle.checked = !touchStartChecked;
        }
      }
    }

    function handleInputChange() {
      toggle.$el.trigger('toggle:change');
      toggle.emit('local::change toggleChange', toggle);
    }

    toggle.attachEvents = function attachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      toggle.$inputEl.on('change', handleInputChange);
    };

    toggle.detachEvents = function detachEvents() {
      const passive = support.passiveListener ? {
        passive: true
      } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off('touchmove', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      toggle.$inputEl.off('change', handleInputChange);
    }; // Install Modules


    toggle.useModules(); // Init

    toggle.init();
  }

  toggle() {
    const toggle = this;
    toggle.checked = !toggle.checked;
  }

  init() {
    const toggle = this;
    toggle.attachEvents();
  }

  destroy() {
    let toggle = this;
    toggle.$el.trigger('toggle:beforedestroy');
    toggle.emit('local::beforeDestroy toggleBeforeDestroy', toggle);
    delete toggle.$el[0].f7Toggle;
    toggle.detachEvents();
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.deleteProps)(toggle);
    toggle = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Toggle);

/***/ }),

/***/ "./node_modules/framework7/components/toggle/toggle.js":
/*!*************************************************************!*\
  !*** ./node_modules/framework7/components/toggle/toggle.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");
/* harmony import */ var _toggle_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toggle-class.js */ "./node_modules/framework7/components/toggle/toggle-class.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'toggle',

  create() {
    const app = this;
    app.toggle = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
      defaultSelector: '.toggle',
      constructor: _toggle_class_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      app,
      domProp: 'f7Toggle'
    });
  },

  static: {
    Toggle: _toggle_class_js__WEBPACK_IMPORTED_MODULE_2__["default"]
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.toggle-init').each(toggleEl => app.toggle.create({
        el: toggleEl
      }));
    },

    tabBeforeRemove(tabEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.toggle-init').each(toggleEl => {
        if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.toggle-init').each(toggleEl => app.toggle.create({
        el: toggleEl
      }));
    },

    pageBeforeRemove(page) {
      page.$el.find('.toggle-init').each(toggleEl => {
        if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
      });
    }

  },
  vnode: {
    'toggle-init': {
      insert(vnode) {
        const app = this;
        const toggleEl = vnode.elm;
        app.toggle.create({
          el: toggleEl
        });
      },

      destroy(vnode) {
        const toggleEl = vnode.elm;
        if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/toolbar/toolbar.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/components/toolbar/toolbar.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const Toolbar = {
  setHighlight(tabbarEl) {
    const app = this;
    const $tabbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabbarEl);
    if (app.theme === 'ios' && !$tabbarEl.hasClass('tabbar-highlight')) return;
    if ($tabbarEl.length === 0 || !($tabbarEl.hasClass('tabbar') || $tabbarEl.hasClass('tabbar-labels'))) return;
    let $highlightEl = $tabbarEl.find('.tab-link-highlight');
    const tabLinksCount = $tabbarEl.find('.tab-link').length;

    if (tabLinksCount === 0) {
      $highlightEl.remove();
      return;
    }

    if ($highlightEl.length === 0) {
      $tabbarEl.children('.toolbar-inner').append('<span class="tab-link-highlight"></span>');
      $highlightEl = $tabbarEl.find('.tab-link-highlight');
    } else if ($highlightEl.next().length) {
      $tabbarEl.children('.toolbar-inner').append($highlightEl);
    }

    const $activeLink = $tabbarEl.find('.tab-link-active');
    let highlightWidth;
    let highlightTranslate;

    if ($tabbarEl.hasClass('tabbar-scrollable') && $activeLink && $activeLink[0]) {
      highlightWidth = `${$activeLink[0].offsetWidth}px`;
      highlightTranslate = `${$activeLink[0].offsetLeft}px`;
    } else {
      const activeIndex = $activeLink.index();
      highlightWidth = `${100 / tabLinksCount}%`;
      highlightTranslate = `${(app.rtl ? -activeIndex : activeIndex) * 100}%`;
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextFrame)(() => {
      $highlightEl.css('width', highlightWidth).transform(`translate3d(${highlightTranslate},0,0)`);
    });
  },

  init(tabbarEl) {
    const app = this;
    app.toolbar.setHighlight(tabbarEl);
  },

  hide(el, animate) {
    if (animate === void 0) {
      animate = true;
    }

    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    if ($el.hasClass('toolbar-hidden')) return;
    const className = `toolbar-hidden${animate ? ' toolbar-transitioning' : ''}`;
    $el.transitionEnd(() => {
      $el.removeClass('toolbar-transitioning');
    });
    $el.addClass(className);
    $el.trigger('toolbar:hide');
    app.emit('toolbarHide', $el[0]);
  },

  show(el, animate) {
    if (animate === void 0) {
      animate = true;
    }

    const app = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    if (!$el.hasClass('toolbar-hidden')) return;

    if (animate) {
      $el.addClass('toolbar-transitioning');
      $el.transitionEnd(() => {
        $el.removeClass('toolbar-transitioning');
      });
    }

    $el.removeClass('toolbar-hidden');
    $el.trigger('toolbar:show');
    app.emit('toolbarShow', $el[0]);
  },

  initToolbarOnScroll(pageEl) {
    const app = this;
    const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(pageEl);
    let $toolbarEl = $pageEl.parents('.view').children('.toolbar');

    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.find('.toolbar');
    }

    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.parents('.views').children('.tabbar, .tabbar-labels');
    }

    if ($toolbarEl.length === 0) {
      return;
    }

    let previousScrollTop;
    let currentScrollTop;
    let scrollHeight;
    let offsetHeight;
    let reachEnd;
    let action;
    let toolbarHidden;

    function handleScroll(e) {
      if ($pageEl.hasClass('page-with-card-opened')) return;
      if ($pageEl.hasClass('page-previous')) return;
      const scrollContent = this;

      if (e && e.target && e.target !== scrollContent) {
        return;
      }

      currentScrollTop = scrollContent.scrollTop;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      toolbarHidden = $toolbarEl.hasClass('toolbar-hidden');

      if (reachEnd) {
        if (app.params.toolbar.showOnPageScrollEnd) {
          action = 'show';
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
          action = 'show';
        } else {
          action = 'hide';
        }
      } else if (currentScrollTop > 44) {
        action = 'hide';
      } else {
        action = 'show';
      }

      if (action === 'show' && toolbarHidden) {
        app.toolbar.show($toolbarEl);
        toolbarHidden = false;
      } else if (action === 'hide' && !toolbarHidden) {
        app.toolbar.hide($toolbarEl);
        toolbarHidden = true;
      }

      previousScrollTop = currentScrollTop;
    }

    $pageEl.on('scroll', '.page-content', handleScroll, true);
    $pageEl[0].f7ScrollToolbarHandler = handleScroll;
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'toolbar',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.bindMethods)(app, {
      toolbar: Toolbar
    });
  },

  params: {
    toolbar: {
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true
    }
  },
  on: {
    pageBeforeRemove(page) {
      if (page.$el[0].f7ScrollToolbarHandler) {
        page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollToolbarHandler, true);
      }
    },

    pageBeforeIn(page) {
      const app = this;
      let $toolbarEl = page.$el.parents('.view').children('.toolbar');

      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.parents('.views').children('.tabbar, .tabbar-labels');
      }

      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.find('.toolbar');
      }

      if ($toolbarEl.length === 0) {
        return;
      }

      if (page.$el.hasClass('no-toolbar')) {
        app.toolbar.hide($toolbarEl);
      } else {
        app.toolbar.show($toolbarEl);
      }
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.tabbar, .tabbar-labels').each(tabbarEl => {
        app.toolbar.init(tabbarEl);
      });

      if (app.params.toolbar.hideOnPageScroll || page.$el.find('.hide-toolbar-on-scroll').length || page.$el.hasClass('hide-toolbar-on-scroll') || page.$el.find('.hide-bars-on-scroll').length || page.$el.hasClass('hide-bars-on-scroll')) {
        if (page.$el.find('.keep-toolbar-on-scroll').length || page.$el.hasClass('keep-toolbar-on-scroll') || page.$el.find('.keep-bars-on-scroll').length || page.$el.hasClass('keep-bars-on-scroll')) {
          return;
        }

        app.toolbar.initToolbarOnScroll(page.el);
      }
    },

    init() {
      const app = this;
      app.$el.find('.tabbar, .tabbar-labels').each(tabbarEl => {
        app.toolbar.init(tabbarEl);
      });
    }

  },
  vnode: {
    tabbar: {
      insert(vnode) {
        const app = this;
        app.toolbar.init(vnode.elm);
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/tooltip/tooltip-class.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7/components/tooltip/tooltip-class.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");






class Tooltip extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const tooltip = this;
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__.getSupport)();
    const defaults = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)({}, app.params.tooltip);
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)(); // Extend defaults with modules params

    tooltip.useModulesParams(defaults);
    tooltip.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)(defaults, params);

    if (typeof params.offset === 'undefined' && support.touch && tooltip.params.trigger === 'hover') {
      tooltip.params.offset = 10;
    }

    const {
      targetEl,
      containerEl
    } = tooltip.params;
    if (!targetEl && !tooltip.params.delegated) return tooltip;
    const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(targetEl);
    if ($targetEl.length === 0 && !tooltip.params.delegated) return tooltip;
    if ($targetEl[0] && $targetEl[0].f7Tooltip && !tooltip.params.delegated) return $targetEl[0].f7Tooltip;
    let $containerEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(containerEl || app.$el).eq(0);

    if ($containerEl.length === 0) {
      $containerEl = app.$el;
    }

    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tooltip.render()).eq(0);
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)(tooltip, {
      app,
      $targetEl,
      targetEl: $targetEl && $targetEl[0],
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      $el,
      el: $el && $el[0],
      text: tooltip.params.text || '',
      visible: false,
      opened: false
    });
    if ($targetEl[0]) $targetEl[0].f7Tooltip = tooltip;
    const touchesStart = {};
    let isTouched;

    function handleClick() {
      if (tooltip.opened) tooltip.hide();else tooltip.show(this);
    }

    function handleClickOut(e) {
      if (tooltip.opened && ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest($targetEl).length || (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest(tooltip.$el).length)) return;
      tooltip.hide();
    }

    function handleTouchStart(e) {
      if (isTouched) return;
      isTouched = true;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      tooltip.show(this);
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      const x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      const distance = ((x - touchesStart.x) ** 2 + (y - touchesStart.y) ** 2) ** 0.5;

      if (distance > 50) {
        isTouched = false;
        tooltip.hide();
      }
    }

    function handleTouchEnd() {
      if (!isTouched) return;
      isTouched = false;
      tooltip.hide();
    }

    function handleMouseEnter() {
      tooltip.show(this);
    }

    function handleMouseLeave() {
      tooltip.hide();
    }

    function handleTransitionEnd() {
      if (!$el.hasClass('tooltip-in')) {
        $el.removeClass('tooltip-out').remove();
      }
    }

    tooltip.attachEvents = function attachEvents() {
      $el.on('transitionend', handleTransitionEnd);

      if (tooltip.params.trigger === 'click') {
        if (tooltip.params.delegated) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('click', tooltip.params.targetEl, handleClick);
        } else {
          tooltip.$targetEl.on('click', handleClick);
        }

        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').on('click', handleClickOut);
        return;
      }

      if (tooltip.params.trigger === 'manual') return;

      if (support.touch) {
        const passive = support.passiveListener ? {
          passive: true
        } : false;

        if (tooltip.params.delegated) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on(app.touchEvents.start, tooltip.params.targetEl, handleTouchStart, passive);
        } else {
          tooltip.$targetEl.on(app.touchEvents.start, handleTouchStart, passive);
        }

        app.on('touchmove', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      } else {
        // eslint-disable-next-line
        if (tooltip.params.delegated) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on(support.pointerEvents ? 'pointerenter' : 'mouseenter', tooltip.params.targetEl, handleMouseEnter, true);
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on(support.pointerEvents ? 'pointerleave' : 'mouseleave', tooltip.params.targetEl, handleMouseLeave, true);
        } else {
          tooltip.$targetEl.on(support.pointerEvents ? 'pointerenter' : 'mouseenter', handleMouseEnter);
          tooltip.$targetEl.on(support.pointerEvents ? 'pointerleave' : 'mouseleave', handleMouseLeave);
        }
      }
    };

    tooltip.detachEvents = function detachEvents() {
      $el.off('transitionend', handleTransitionEnd);

      if (tooltip.params.trigger === 'click') {
        if (tooltip.params.delegated) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('click', tooltip.params.targetEl, handleClick);
        } else {
          tooltip.$targetEl.off('click', handleClick);
        }

        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('html').off('click', handleClickOut);
        return;
      }

      if (tooltip.params.trigger === 'manual') return;

      if (support.touch) {
        const passive = support.passiveListener ? {
          passive: true
        } : false;

        if (tooltip.params.delegated) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off(app.touchEvents.start, tooltip.params.targetEl, handleTouchStart, passive);
        } else {
          tooltip.$targetEl.off(app.touchEvents.start, handleTouchStart, passive);
        }

        app.off('touchmove', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      } else {
        // eslint-disable-next-line
        if (tooltip.params.delegated) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off(support.pointerEvents ? 'pointerenter' : 'mouseenter', tooltip.params.targetEl, handleMouseEnter, true);
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off(support.pointerEvents ? 'pointerleave' : 'mouseleave', tooltip.params.targetEl, handleMouseLeave, true);
        } else {
          tooltip.$targetEl.off(support.pointerEvents ? 'pointerenter' : 'mouseenter', handleMouseEnter);
          tooltip.$targetEl.off(support.pointerEvents ? 'pointerleave' : 'mouseleave', handleMouseLeave);
        }
      }
    }; // Install Modules


    tooltip.useModules();
    tooltip.init();
    return tooltip;
  }

  setTargetEl(targetEl) {
    const tooltip = this;
    tooltip.detachEvents();
    tooltip.$targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(targetEl);
    tooltip.targetEl = tooltip.$targetEl[0];
    tooltip.attachEvents();
    return tooltip;
  }

  position(targetEl) {
    const tooltip = this;
    const {
      $el,
      app,
      $containerEl
    } = tooltip;
    const hasContainerEl = !!tooltip.params.containerEl;
    const tooltipOffset = tooltip.params.offset || 0;
    $el.css({
      left: '',
      top: ''
    });
    const $targetEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(targetEl || tooltip.targetEl);
    const [width, height] = [$el.width(), $el.height()];
    $el.css({
      left: '',
      top: ''
    });
    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    const boundaries = hasContainerEl && $containerEl.length ? $containerEl[0].getBoundingClientRect() : app;

    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();

      if (typeof targetWidth === 'undefined' && typeof targetHeight === 'undefined') {
        const clientRect = $targetEl[0].getBoundingClientRect();
        targetWidth = clientRect.width;
        targetHeight = clientRect.height;
      }

      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - boundaries.left;
      targetOffsetTop = targetOffset.top - boundaries.top;
      const targetParentPage = $targetEl.parents('.page');

      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    }

    let [left, top] = [0, 0, 0]; // Top Position

    let position = 'top';

    if (height + tooltipOffset < targetOffsetTop) {
      // On top
      top = targetOffsetTop - height - tooltipOffset;
    } else if (height < boundaries.height - targetOffsetTop - targetHeight) {
      // On bottom
      position = 'bottom';
      top = targetOffsetTop + targetHeight + tooltipOffset;
    } else {
      // On middle
      position = 'middle';
      top = targetHeight / 2 + targetOffsetTop - height / 2;

      if (top <= 0) {
        top = 8;
      } else if (top + height >= boundaries.height) {
        top = boundaries.height - height - 8;
      }
    } // Horizontal Position


    if (position === 'top' || position === 'bottom') {
      left = targetWidth / 2 + targetOffsetLeft - width / 2;
      if (left < 8) left = 8;
      if (left + width > boundaries.width) left = boundaries.width - width - 8;
      if (left < 0) left = 0;
    } else if (position === 'middle') {
      left = targetOffsetLeft - width;

      if (left < 8 || left + width > boundaries.width) {
        if (left < 8) left = targetOffsetLeft + targetWidth;
        if (left + width > boundaries.width) left = boundaries.width - width - 8;
      }
    } // Apply Styles


    $el.css({
      top: `${top}px`,
      left: `${left}px`
    });
  }

  show(aroundEl) {
    const tooltip = this;
    const {
      $el,
      $targetEl,
      $containerEl
    } = tooltip;

    if ($containerEl[0] && $el[0] && !$containerEl[0].contains($el[0])) {
      $containerEl.append($el);
    }

    tooltip.position(aroundEl);
    const $aroundEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(aroundEl);
    tooltip.visible = true;
    tooltip.opened = true;
    $targetEl.trigger('tooltip:show');
    $el.trigger('tooltip:show');

    if ($aroundEl.length && $aroundEl[0] !== $targetEl[0]) {
      $aroundEl.trigger('tooltip:show');
    }

    tooltip.emit('local::show tooltipShow', tooltip);
    $el.removeClass('tooltip-out').addClass('tooltip-in');
    return tooltip;
  }

  hide() {
    const tooltip = this;
    const {
      $el,
      $targetEl
    } = tooltip;
    tooltip.visible = false;
    tooltip.opened = false;
    $targetEl.trigger('tooltip:hide');
    $el.trigger('tooltip:hide');
    tooltip.emit('local::hide tooltipHide', tooltip);
    $el.addClass('tooltip-out').removeClass('tooltip-in');
    return tooltip;
  }

  render() {
    const tooltip = this;
    if (tooltip.params.render) return tooltip.params.render.call(tooltip, tooltip);
    const {
      cssClass,
      text
    } = tooltip.params;
    return `
      <div class="tooltip ${cssClass || ''}">
        <div class="tooltip-content">${text || ''}</div>
      </div>
    `.trim();
  }

  setText(newText) {
    const tooltip = this;

    if (typeof newText === 'undefined') {
      return tooltip;
    }

    tooltip.params.text = newText;
    tooltip.text = newText;

    if (tooltip.$el) {
      tooltip.$el.children('.tooltip-content').html(newText);
    }

    if (tooltip.opened) {
      tooltip.position();
    }

    return tooltip;
  }

  init() {
    const tooltip = this;
    tooltip.attachEvents();
  }

  destroy() {
    const tooltip = this;
    if (!tooltip.$targetEl || tooltip.destroyed) return;
    tooltip.$targetEl.trigger('tooltip:beforedestroy');
    tooltip.emit('local::beforeDestroy tooltipBeforeDestroy', tooltip);
    tooltip.$el.remove();
    if (tooltip.$targetEl[0]) delete tooltip.$targetEl[0].f7Tooltip;
    tooltip.detachEvents();
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.deleteProps)(tooltip);
    tooltip.destroyed = true;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tooltip);

/***/ }),

/***/ "./node_modules/framework7/components/tooltip/tooltip.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/components/tooltip/tooltip.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _tooltip_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tooltip-class.js */ "./node_modules/framework7/components/tooltip/tooltip-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'tooltip',
  static: {
    Tooltip: _tooltip_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    app.tooltip = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      defaultSelector: '.tooltip',
      constructor: _tooltip_class_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      app,
      domProp: 'f7Tooltip'
    });

    app.tooltip.show = function show(el) {
      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
      if ($el.length === 0) return undefined;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip) return undefined;
      tooltip.show($el[0]);
      return tooltip;
    };

    app.tooltip.hide = function hide(el) {
      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
      if ($el.length === 0) return undefined;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip) return undefined;
      tooltip.hide();
      return tooltip;
    };

    app.tooltip.setText = function text(el, newText) {
      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
      if ($el.length === 0) return undefined;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip) return undefined;
      tooltip.setText(newText);
      return tooltip;
    };
  },

  params: {
    tooltip: {
      targetEl: null,
      delegated: false,
      text: null,
      cssClass: null,
      render: null,
      offset: 0,
      trigger: 'hover',
      containerEl: undefined
    }
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.tooltip-init').each(el => {
        const text = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).attr('data-tooltip');
        if (!text) return;
        app.tooltip.create({
          targetEl: el,
          text
        });
      });
    },

    tabBeforeRemove(tabEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabEl).find('.tooltip-init').each(el => {
        if (el.f7Tooltip) el.f7Tooltip.destroy();
      });
    },

    pageInit(page) {
      const app = this;
      page.$el.find('.tooltip-init').each(el => {
        const text = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).attr('data-tooltip');
        if (!text) return;
        app.tooltip.create({
          targetEl: el,
          text
        });
      });

      if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.tooltip-init').each(el => {
          const text = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).attr('data-tooltip');
          if (!text) return;
          app.tooltip.create({
            targetEl: el,
            text
          });
        });
      }
    },

    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.tooltip-init').each(el => {
        if (el.f7Tooltip) el.f7Tooltip.destroy();
      });

      if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.tooltip-init').each(el => {
          if (el.f7Tooltip) el.f7Tooltip.destroy();
        });
      }
    }

  },
  vnode: {
    'tooltip-init': {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        const text = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).attr('data-tooltip');
        if (!text) return;
        app.tooltip.create({
          targetEl: el,
          text
        });
      },

      update(vnode) {
        const el = vnode.elm;
        if (!el.f7Tooltip) return;

        if (vnode && vnode.data && vnode.data.attrs && vnode.data.attrs['data-tooltip']) {
          el.f7Tooltip.setText(vnode.data.attrs['data-tooltip']);
        }
      },

      destroy(vnode) {
        const el = vnode.elm;
        if (el.f7Tooltip) el.f7Tooltip.destroy();
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/touch-ripple/touch-ripple-class.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/touch-ripple/touch-ripple-class.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TouchRipple)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");

class TouchRipple {
  constructor(app, $el, x, y) {
    const ripple = this;
    if (!$el) return undefined;
    const {
      left,
      top,
      width,
      height
    } = $el[0].getBoundingClientRect();
    const center = {
      x: x - left,
      y: y - top
    };
    let diameter = Math.max((height ** 2 + width ** 2) ** 0.5, 48);
    let isInset = false;
    const insetElements = app.params.touch.touchRippleInsetElements || '';

    if (insetElements && $el.is(insetElements)) {
      isInset = true;
    }

    if (isInset) {
      diameter = Math.max(Math.min(width, height), 48);
    }

    if (!isInset && $el.css('overflow') === 'hidden') {
      const distanceFromCenter = ((center.x - width / 2) ** 2 + (center.y - height / 2) ** 2) ** 0.5;
      const scale = (diameter / 2 + distanceFromCenter) / (diameter / 2);
      ripple.rippleTransform = `translate3d(0px, 0px, 0) scale(${scale})`;
    } else {
      // prettier-ignore
      ripple.rippleTransform = `translate3d(${-center.x + width / 2}px, ${-center.y + height / 2}px, 0) scale(1)`;
    }

    if (isInset) {
      $el.addClass('ripple-inset');
    }

    ripple.$rippleWaveEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="ripple-wave" style="width: ${diameter}px; height: ${diameter}px; margin-top:-${diameter / 2}px; margin-left:-${diameter / 2}px; left:${center.x}px; top:${center.y}px; --f7-ripple-transform: ${ripple.rippleTransform}"></div>`);
    $el.prepend(ripple.$rippleWaveEl);
    ripple.$rippleWaveEl.animationEnd(() => {
      if (!ripple.$rippleWaveEl) return;
      if (ripple.$rippleWaveEl.hasClass('ripple-wave-out')) return;
      ripple.$rippleWaveEl.addClass('ripple-wave-in');

      if (ripple.shouldBeRemoved) {
        ripple.out();
      }
    });
    return ripple;
  }

  destroy() {
    let ripple = this;

    if (ripple.$rippleWaveEl) {
      ripple.$rippleWaveEl.remove();
    }

    Object.keys(ripple).forEach(key => {
      ripple[key] = null;
      delete ripple[key];
    });
    ripple = null;
  }

  out() {
    const ripple = this;
    const {
      $rippleWaveEl
    } = this;
    clearTimeout(ripple.removeTimeout);
    $rippleWaveEl.addClass('ripple-wave-out');
    ripple.removeTimeout = setTimeout(() => {
      ripple.destroy();
    }, 300);
    $rippleWaveEl.animationEnd(() => {
      clearTimeout(ripple.removeTimeout);
      ripple.destroy();
    });
  }

  remove() {
    const ripple = this;
    if (ripple.shouldBeRemoved) return;
    ripple.removeTimeout = setTimeout(() => {
      ripple.destroy();
    }, 400);
    ripple.shouldBeRemoved = true;

    if (ripple.$rippleWaveEl.hasClass('ripple-wave-in')) {
      ripple.out();
    }
  }

}

/***/ }),

/***/ "./node_modules/framework7/components/touch-ripple/touch-ripple.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7/components/touch-ripple/touch-ripple.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _touch_ripple_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./touch-ripple-class.js */ "./node_modules/framework7/components/touch-ripple/touch-ripple-class.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'touch-ripple',
  static: {
    TouchRipple: _touch_ripple_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;
    app.touchRipple = {
      create() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return new _touch_ripple_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](...args);
      }

    };
  }

});

/***/ }),

/***/ "./node_modules/framework7/components/treeview/treeview.js":
/*!*****************************************************************!*\
  !*** ./node_modules/framework7/components/treeview/treeview.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const Treeview = {
  open(itemEl) {
    const app = this;
    const $itemEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(itemEl).eq(0);
    if (!$itemEl.length) return;
    $itemEl.addClass('treeview-item-opened');
    $itemEl.trigger('treeview:open');
    app.emit('treeviewOpen', $itemEl[0]);

    function done(cancel) {
      if (cancel) {
        $itemEl.removeClass('treeview-item-opened');
        $itemEl.trigger('treeview:close');
        app.emit('treeviewClose', $itemEl[0]);
      } else {
        $itemEl[0].f7TreeviewChildrenLoaded = true;
      }

      $itemEl.find('.treeview-toggle').removeClass('treeview-toggle-hidden');
      $itemEl.find('.treeview-preloader').remove();
    }

    if ($itemEl.hasClass('treeview-load-children') && !$itemEl[0].f7TreeviewChildrenLoaded) {
      const preloaders = {
        iosPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.iosPreloaderContent,
        mdPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.mdPreloaderContent,
        auroraPreloaderContent: _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.auroraPreloaderContent
      };
      $itemEl.trigger('treeview:loadchildren', done);
      app.emit('treeviewLoadChildren', $itemEl[0], done);
      $itemEl.find('.treeview-toggle').addClass('treeview-toggle-hidden');
      $itemEl.find('.treeview-item-root').prepend(`<div class="preloader treeview-preloader">${preloaders[`${app.theme}PreloaderContent`]}</div>`);
    }
  },

  close(itemEl) {
    const app = this;
    const $itemEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(itemEl).eq(0);
    if (!$itemEl.length) return;
    $itemEl.removeClass('treeview-item-opened');
    $itemEl.trigger('treeview:close');
    app.emit('treeviewClose', $itemEl[0]);
  },

  toggle(itemEl) {
    const app = this;
    const $itemEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(itemEl).eq(0);
    if (!$itemEl.length) return;
    const wasOpened = $itemEl.hasClass('treeview-item-opened');
    app.treeview[wasOpened ? 'close' : 'open']($itemEl);
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'treeview',

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.bindMethods)(app, {
      treeview: Treeview
    });
  },

  clicks: {
    '.treeview-toggle': function toggle($clickedEl, clickedData, e) {
      const app = this;
      if ($clickedEl.parents('.treeview-item-toggle').length) return;
      const $treeviewItemEl = $clickedEl.parents('.treeview-item').eq(0);
      if (!$treeviewItemEl.length) return;
      e.preventF7Router = true;
      app.treeview.toggle($treeviewItemEl[0]);
    },
    '.treeview-item-toggle': function toggle($clickedEl, clickedData, e) {
      const app = this;
      const $treeviewItemEl = $clickedEl.closest('.treeview-item').eq(0);
      if (!$treeviewItemEl.length) return;
      e.preventF7Router = true;
      app.treeview.toggle($treeviewItemEl[0]);
    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/typography/typography.js":
/*!*********************************************************************!*\
  !*** ./node_modules/framework7/components/typography/typography.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'typography'
});

/***/ }),

/***/ "./node_modules/framework7/components/view/resizable-view.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/components/view/resizable-view.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");




function resizableView(view) {
  const app = view.app;
  const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_1__.getSupport)();
  if (view.resizableInitialized) return;
  (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(view, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true
  });
  const $htmlEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('html');
  const {
    $el
  } = view;
  if (!$el) return;
  let $resizeHandlerEl;
  let isTouched;
  let isMoved;
  const touchesStart = {};
  let touchesDiff;
  let width;
  let minWidth;
  let maxWidth;

  function transformCSSWidth(v) {
    if (!v) return null;

    if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
      return parseInt(v, 10) / 100 * app.width;
    }

    const newV = parseInt(v, 10);
    if (Number.isNaN(newV)) return null;
    return newV;
  }

  function isResizable() {
    return view.resizable && $el.hasClass('view-resizable') && $el.hasClass('view-master-detail');
  }

  function handleTouchStart(e) {
    if (!isResizable()) return;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    const $pageMasterEl = $el.children('.page-master');
    minWidth = transformCSSWidth($pageMasterEl.css('min-width'));
    maxWidth = transformCSSWidth($pageMasterEl.css('max-width'));
  }

  function handleTouchMove(e) {
    if (!isTouched) return;
    e.f7PreventSwipePanel = true;
    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

    if (!isMoved) {
      width = $resizeHandlerEl[0].offsetLeft + $resizeHandlerEl[0].offsetWidth;
      $el.addClass('view-resizing');
      $htmlEl.css('cursor', 'col-resize');
    }

    isMoved = true;
    e.preventDefault();
    touchesDiff = pageX - touchesStart.x;
    let newWidth = width + touchesDiff;

    if (minWidth && !Number.isNaN(minWidth)) {
      newWidth = Math.max(newWidth, minWidth);
    }

    if (maxWidth && !Number.isNaN(maxWidth)) {
      newWidth = Math.min(newWidth, maxWidth);
    }

    newWidth = Math.min(Math.max(newWidth, 0), app.width);
    view.resizableWidth = newWidth;
    $htmlEl[0].style.setProperty('--f7-page-master-width', `${newWidth}px`);
    $el.trigger('view:resize', newWidth);
    view.emit('local::resize viewResize', view, newWidth);
  }

  function handleTouchEnd() {
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('html').css('cursor', '');

    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }

    isTouched = false;
    isMoved = false;
    $htmlEl[0].style.setProperty('--f7-page-master-width', `${view.resizableWidth}px`);
    $el.removeClass('view-resizing');
  }

  function handleResize() {
    if (!view.resizableWidth) return;
    minWidth = transformCSSWidth($resizeHandlerEl.css('min-width'));
    maxWidth = transformCSSWidth($resizeHandlerEl.css('max-width'));

    if (minWidth && !Number.isNaN(minWidth) && view.resizableWidth < minWidth) {
      view.resizableWidth = Math.max(view.resizableWidth, minWidth);
    }

    if (maxWidth && !Number.isNaN(maxWidth) && view.resizableWidth > maxWidth) {
      view.resizableWidth = Math.min(view.resizableWidth, maxWidth);
    }

    view.resizableWidth = Math.min(Math.max(view.resizableWidth, 0), app.width);
    $htmlEl[0].style.setProperty('--f7-page-master-width', `${view.resizableWidth}px`);
  }

  $resizeHandlerEl = view.$el.children('.view-resize-handler');

  if (!$resizeHandlerEl.length) {
    view.$el.append('<div class="view-resize-handler"></div>');
    $resizeHandlerEl = view.$el.children('.view-resize-handler');
  }

  view.$resizeHandlerEl = $resizeHandlerEl;
  $el.addClass('view-resizable'); // Add Events

  const passive = support.passiveListener ? {
    passive: true
  } : false;
  view.$el.on(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
  app.on('touchmove:active', handleTouchMove);
  app.on('touchend:passive', handleTouchEnd);
  app.on('resize', handleResize);
  view.on('beforeOpen', handleResize);
  view.once('viewDestroy', () => {
    $el.removeClass('view-resizable');
    view.$resizeHandlerEl.remove();
    view.$el.off(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
    app.off('resize', handleResize);
    view.off('beforeOpen', handleResize);
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resizableView);

/***/ }),

/***/ "./node_modules/framework7/components/view/view-class.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/components/view/view-class.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _modules_router_router_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../modules/router/router.js */ "./node_modules/framework7/modules/router/router.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _resizable_view_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resizable-view.js */ "./node_modules/framework7/components/view/resizable-view.js");






class View extends _shared_class_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(app, el, viewParams) {
    if (viewParams === void 0) {
      viewParams = {};
    }

    super(viewParams, [app]);
    const view = this;
    const ssr = view.params.routerId;
    const defaults = {
      routes: [],
      routesAdd: []
    };

    if (!ssr) {
      const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);

      if (!$el.length) {
        let message = "Framework7: can't create a View instance because ";
        message += typeof el === 'string' ? `the selector "${el}" didn't match any element` : 'el must be an HTMLElement or Dom7 object';
        throw new Error(message);
      }
    } // Default View params


    view.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({
      el
    }, defaults, app.params.view, viewParams); // Routes

    if (view.params.routes.length > 0) {
      view.routes = view.params.routes;
    } else {
      view.routes = [].concat(app.routes, view.params.routesAdd);
    } // View Props


    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(false, view, {
      app,
      name: view.params.name,
      main: view.params.main,
      history: [],
      scrollHistory: {}
    }); // Install Modules

    view.useModules(); // Add to app

    app.views.push(view);

    if (view.main) {
      app.views.main = view;
    }

    if (view.name) {
      app.views[view.name] = view;
    } // Index


    view.index = app.views.indexOf(view); // View ID

    let viewId;

    if (view.name) {
      viewId = `view_${view.name}`;
    } else if (view.main) {
      viewId = 'view_main';
    } else {
      viewId = `view_${view.index}`;
    }

    view.id = viewId;

    if (!view.params.init) {
      return view;
    } // Init View


    if (app.initialized) {
      view.init();
    } else {
      app.on('init', () => {
        view.init();
      });
    }

    return view;
  }

  destroy() {
    let view = this;
    const app = view.app;
    view.$el.trigger('view:beforedestroy');
    view.emit('local::beforeDestroy viewBeforeDestroy', view);
    app.off('resize', view.checkMasterDetailBreakpoint);

    if (view.main) {
      app.views.main = null;
      delete app.views.main;
    } else if (view.name) {
      app.views[view.name] = null;
      delete app.views[view.name];
    }

    view.$el[0].f7View = null;
    delete view.$el[0].f7View;
    app.views.splice(app.views.indexOf(view), 1); // Destroy Router

    if (view.params.router && view.router) {
      view.router.destroy();
    }

    view.emit('local::destroy viewDestroy', view); // Delete props & methods

    Object.keys(view).forEach(viewProp => {
      view[viewProp] = null;
      delete view[viewProp];
    });
    view = null;
  }

  checkMasterDetailBreakpoint(force) {
    const view = this;
    const app = view.app;
    const wasMasterDetail = view.$el.hasClass('view-master-detail');
    const isMasterDetail = app.width >= view.params.masterDetailBreakpoint && view.$el.children('.page-master').length;

    if (typeof force === 'undefined' && isMasterDetail || force === true) {
      view.$el.addClass('view-master-detail');

      if (!wasMasterDetail) {
        view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
        view.$el.trigger('view:masterDetailBreakpoint');
      }
    } else {
      view.$el.removeClass('view-master-detail');

      if (wasMasterDetail) {
        view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
        view.$el.trigger('view:masterDetailBreakpoint');
      }
    }
  }

  initMasterDetail() {
    const view = this;
    const app = view.app;
    view.checkMasterDetailBreakpoint = view.checkMasterDetailBreakpoint.bind(view);
    view.checkMasterDetailBreakpoint();

    if (view.params.masterDetailResizable) {
      (0,_resizable_view_js__WEBPACK_IMPORTED_MODULE_3__["default"])(view);
    }

    app.on('resize', view.checkMasterDetailBreakpoint);
  }

  mount(viewEl) {
    const view = this;
    const app = view.app;
    const el = view.params.el || viewEl;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el); // Selector

    let selector;
    if (typeof el === 'string') selector = el;else {
      // Supposed to be HTMLElement or Dom7
      selector = ($el.attr('id') ? `#${$el.attr('id')}` : '') + ($el.attr('class') ? `.${$el.attr('class').replace(/ /g, '.').replace('.active', '')}` : '');
    } // DynamicNavbar

    let $navbarsEl;

    if (app.theme === 'ios' && view.params.iosDynamicNavbar) {
      $navbarsEl = $el.children('.navbars').eq(0);

      if ($navbarsEl.length === 0) {
        $navbarsEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="navbars"></div>');
      }
    }

    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(view, {
      $el,
      el: $el[0],
      main: view.main || $el.hasClass('view-main'),
      $navbarsEl,
      navbarsEl: $navbarsEl ? $navbarsEl[0] : undefined,
      selector
    });

    if (view.main) {
      app.views.main = view;
    } // Save in DOM


    if ($el && $el[0]) {
      $el[0].f7View = view;
    }

    view.emit('local::mount viewMount', view);
  }

  init(viewEl) {
    const view = this;
    view.mount(viewEl);

    if (view.params.router) {
      if (view.params.masterDetailBreakpoint > 0) {
        view.initMasterDetail();
      }

      if (view.params.initRouterOnTabShow && view.$el.hasClass('tab') && !view.$el.hasClass('tab-active')) {
        view.$el.once('tab:show', () => {
          view.router.init();
        });
      } else {
        view.router.init();
      }

      view.$el.trigger('view:init');
      view.emit('local::init viewInit', view);
    }
  }

} // Use Router


View.use(_modules_router_router_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (View);

/***/ }),

/***/ "./node_modules/framework7/components/view/view.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/components/view/view.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _view_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view-class.js */ "./node_modules/framework7/components/view/view-class.js");




function getCurrentView(app) {
  const $popoverView = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.popover.modal-in .view');
  const $popupView = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.popup.modal-in .view');
  const $panelView = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.panel.panel-in .view');
  let $viewsEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.views');
  if ($viewsEl.length === 0) $viewsEl = app.$el; // Find active view as tab

  let $viewEl = $viewsEl.children('.view');

  if ($viewEl.length === 0) {
    $viewEl = $viewsEl.children('.tabs').children('.view');
  } // Propably in tabs or split view


  if ($viewEl.length > 1) {
    if ($viewEl.hasClass('tab')) {
      // Tabs
      $viewEl = $viewsEl.children('.view.tab-active');

      if ($viewEl.length === 0) {
        $viewEl = $viewsEl.children('.tabs').children('.view.tab-active');
      }
    } else {// Split View, leave appView intact
    }
  }

  if ($popoverView.length > 0 && $popoverView[0].f7View) return $popoverView[0].f7View;
  if ($popupView.length > 0 && $popupView[0].f7View) return $popupView[0].f7View;
  if ($panelView.length > 0 && $panelView[0].f7View) return $panelView[0].f7View;

  if ($viewEl.length > 0) {
    if ($viewEl.length === 1 && $viewEl[0].f7View) return $viewEl[0].f7View;

    if ($viewEl.length > 1) {
      return app.views.main;
    }
  }

  return undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'view',
  params: {
    view: {
      init: true,
      initRouterOnTabShow: false,
      name: undefined,
      main: false,
      router: true,
      linksView: null,
      stackPages: false,
      xhrCache: true,
      xhrCacheIgnore: [],
      xhrCacheIgnoreGetParameters: false,
      xhrCacheDuration: 1000 * 60 * 10,
      // Ten minutes
      componentCache: true,
      preloadPreviousPage: true,
      allowDuplicateUrls: false,
      reloadPages: false,
      reloadDetail: false,
      masterDetailBreakpoint: 0,
      masterDetailResizable: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
      restoreScrollTopOnBack: true,
      unloadTabContent: true,
      passRouteQueryToRequest: true,
      passRouteParamsToRequest: false,
      loadInitialPage: true,
      // Swipe Back
      iosSwipeBack: true,
      iosSwipeBackAnimateShadow: true,
      iosSwipeBackAnimateOpacity: true,
      iosSwipeBackActiveArea: 30,
      iosSwipeBackThreshold: 0,
      mdSwipeBack: false,
      mdSwipeBackAnimateShadow: true,
      mdSwipeBackAnimateOpacity: false,
      mdSwipeBackActiveArea: 30,
      mdSwipeBackThreshold: 0,
      auroraSwipeBack: false,
      auroraSwipeBackAnimateShadow: false,
      auroraSwipeBackAnimateOpacity: true,
      auroraSwipeBackActiveArea: 30,
      auroraSwipeBackThreshold: 0,
      // Push State
      browserHistory: false,
      browserHistoryRoot: undefined,
      browserHistoryAnimate: true,
      browserHistoryAnimateOnLoad: false,
      browserHistorySeparator: '#!',
      browserHistoryOnLoad: true,
      browserHistoryInitialMatch: false,
      browserHistoryStoreHistory: true,
      browserHistoryTabs: 'replace',
      // Animate Pages
      animate: true,
      // iOS Dynamic Navbar
      iosDynamicNavbar: true,
      // Animate iOS Navbar Back Icon
      iosAnimateNavbarBackIcon: true,
      // Delays
      iosPageLoadDelay: 0,
      mdPageLoadDelay: 0,
      auroraPageLoadDelay: 0,
      // Routes hooks
      routesBeforeEnter: null,
      routesBeforeLeave: null
    }
  },
  static: {
    View: _view_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  create() {
    const app = this;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(app, {
      views: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)([], {
        create(el, params) {
          return new _view_class_js__WEBPACK_IMPORTED_MODULE_1__["default"](app, el, params);
        },

        get(viewEl) {
          const $viewEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(viewEl);
          if ($viewEl.length && $viewEl[0].f7View) return $viewEl[0].f7View;
          return undefined;
        }

      })
    });
    Object.defineProperty(app.views, 'current', {
      enumerable: true,
      configurable: true,

      get() {
        return getCurrentView(app);
      }

    }); // Alias

    app.view = app.views;
  },

  on: {
    init() {
      const app = this;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.view-init').each(viewEl => {
        if (viewEl.f7View) return;
        const viewParams = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      });
    },

    'modalOpen panelOpen': function onOpen(instance) {
      const app = this;
      instance.$el.find('.view-init').each(viewEl => {
        if (viewEl.f7View) return;
        const viewParams = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      });
    },
    'modalBeforeDestroy panelBeforeDestroy': function onClose(instance) {
      if (!instance || !instance.$el) return;
      instance.$el.find('.view-init').each(viewEl => {
        const view = viewEl.f7View;
        if (!view) return;
        view.destroy();
      });
    }
  },
  vnode: {
    'view-init': {
      insert(vnode) {
        const app = this;
        const viewEl = vnode.elm;
        if (viewEl.f7View) return;
        const viewParams = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      },

      destroy(vnode) {
        const viewEl = vnode.elm;
        const view = viewEl.f7View;
        if (!view) return;
        view.destroy();
      }

    }
  }
});

/***/ }),

/***/ "./node_modules/framework7/components/virtual-list/virtual-list-class.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/framework7/components/virtual-list/virtual-list-class.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");






class VirtualList extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }

    super(params, [app]);
    const vl = this;
    const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_3__.getDevice)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    let defaultHeight;

    if (app.theme === 'md') {
      defaultHeight = 48;
    } else if (app.theme === 'ios') {
      defaultHeight = 44;
    } else if (app.theme === 'aurora') {
      defaultHeight = 38;
    }

    const defaults = {
      cols: 1,
      height: defaultHeight,
      cache: true,
      dynamicHeightBufferSize: 1,
      showFilteredItemsOnly: false,
      renderExternal: undefined,
      setListHeight: true,
      searchByItem: undefined,
      searchAll: undefined,
      ul: null,
      createUl: true,
      scrollableParentEl: undefined,

      renderItem(item) {
        return `
          <li>
            <div class="item-content">
              <div class="item-inner">
                <div class="item-title">${item}</div>
              </div>
            </div>
          </li>
        `.trim();
      },

      on: {}
    }; // Extend defaults with modules params

    vl.useModulesParams(defaults);
    vl.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)(defaults, params);

    if (vl.params.height === undefined || !vl.params.height) {
      vl.params.height = defaultHeight;
    }

    vl.$el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.el);
    vl.el = vl.$el[0];
    if (vl.$el.length === 0) return undefined;
    vl.$el[0].f7VirtualList = vl;
    vl.items = vl.params.items;

    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    }

    if (vl.params.renderItem) {
      vl.renderItem = vl.params.renderItem;
    }

    vl.$pageContentEl = vl.$el.parents('.page-content');
    vl.pageContentEl = vl.$pageContentEl[0];
    vl.$scrollableParentEl = vl.params.scrollableParentEl ? (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(vl.params.scrollableParentEl).eq(0) : vl.$pageContentEl;

    if (!vl.$scrollableParentEl.length && vl.$pageContentEl.length) {
      vl.$scrollableParentEl = vl.$pageContentEl;
    }

    vl.scrollableParentEl = vl.$scrollableParentEl[0]; // Bad scroll

    if (typeof vl.params.updatableScroll !== 'undefined') {
      vl.updatableScroll = vl.params.updatableScroll;
    } else {
      vl.updatableScroll = true;

      if (device.ios && device.osVersion.split('.')[0] < 8) {
        vl.updatableScroll = false;
      }
    } // Append <ul>


    const ul = vl.params.ul;
    vl.$ul = ul ? (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(vl.params.ul) : vl.$el.children('ul');

    if (vl.$ul.length === 0 && vl.params.createUl) {
      vl.$el.append('<ul></ul>');
      vl.$ul = vl.$el.children('ul');
    }

    vl.ul = vl.$ul[0];
    let $itemsWrapEl;
    if (!vl.ul && !vl.params.createUl) $itemsWrapEl = vl.$el;else $itemsWrapEl = vl.$ul;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)(vl, {
      $itemsWrapEl,
      itemsWrapEl: $itemsWrapEl[0],
      // DOM cached items
      domCache: {},
      displayDomCache: {},
      // Temporary DOM Element
      tempDomElement: document.createElement('ul'),
      // Last repain position
      lastRepaintY: null,
      // Fragment
      fragment: document.createDocumentFragment(),
      // Props
      pageHeight: undefined,
      rowsPerScreen: undefined,
      rowsBefore: undefined,
      rowsAfter: undefined,
      rowsToRender: undefined,
      maxBufferHeight: 0,
      listHeight: undefined,
      dynamicHeight: typeof vl.params.height === 'function',
      autoHeight: vl.params.height === 'auto'
    }); // Install Modules

    vl.useModules(); // Attach events

    const handleScrollBound = vl.handleScroll.bind(vl);
    const handleResizeBound = vl.handleResize.bind(vl);
    let $pageEl;
    let $tabEl;
    let $panelEl;
    let $popupEl;

    vl.attachEvents = function attachEvents() {
      $pageEl = vl.$el.parents('.page').eq(0);
      $tabEl = vl.$el.parents('.tab').filter(tabEl => {
        return (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl).parent('.tabs').parent('.tabs-animated-wrap, .tabs-swipeable-wrap').length === 0;
      }).eq(0);
      $panelEl = vl.$el.parents('.panel').eq(0);
      $popupEl = vl.$el.parents('.popup').eq(0);
      vl.$scrollableParentEl.on('scroll', handleScrollBound);
      if ($pageEl.length) $pageEl.on('page:reinit', handleResizeBound);
      if ($tabEl.length) $tabEl.on('tab:show', handleResizeBound);
      if ($panelEl.length) $panelEl.on('panel:open', handleResizeBound);
      if ($popupEl.length) $popupEl.on('popup:open', handleResizeBound);
      app.on('resize', handleResizeBound);
    };

    vl.detachEvents = function attachEvents() {
      vl.$scrollableParentEl.off('scroll', handleScrollBound);
      if ($pageEl.length) $pageEl.off('page:reinit', handleResizeBound);
      if ($tabEl.length) $tabEl.off('tab:show', handleResizeBound);
      if ($panelEl.length) $panelEl.off('panel:open', handleResizeBound);
      if ($popupEl.length) $popupEl.off('popup:open', handleResizeBound);
      app.off('resize', handleResizeBound);
    }; // Init


    vl.init();
    return vl;
  }

  setListSize(autoHeightRerender) {
    const vl = this;
    const items = vl.filteredItems || vl.items;

    if (!autoHeightRerender) {
      vl.pageHeight = vl.$scrollableParentEl[0].offsetHeight;
    }

    if (vl.dynamicHeight) {
      vl.listHeight = 0;
      vl.heights = [];

      for (let i = 0; i < items.length; i += 1) {
        const itemHeight = vl.params.height(items[i]);
        vl.listHeight += itemHeight;
        vl.heights.push(itemHeight);
      }
    } else if (vl.autoHeight) {
      vl.listHeight = 0;
      if (!vl.heights) vl.heights = [];
      if (!vl.heightsCalculated) vl.heightsCalculated = [];
      const renderedItems = {};
      vl.$itemsWrapEl.find(`[data-virtual-list-index]`).forEach(el => {
        renderedItems[parseInt(el.getAttribute('data-virtual-list-index'), 10)] = el;
      });

      for (let i = 0; i < items.length; i += 1) {
        const renderedItem = renderedItems[i];

        if (renderedItem) {
          if (!vl.heightsCalculated.includes(i)) {
            vl.heights[i] = renderedItem.offsetHeight;
            vl.heightsCalculated.push(i);
          }
        }

        if (typeof vl.heights[i] === 'undefined') {
          vl.heights[i] = 40;
        }

        vl.listHeight += vl.heights[i];
      }
    } else {
      vl.listHeight = Math.ceil(items.length / vl.params.cols) * vl.params.height;
      vl.rowsPerScreen = Math.ceil(vl.pageHeight / vl.params.height);
      vl.rowsBefore = vl.params.rowsBefore || vl.rowsPerScreen * 2;
      vl.rowsAfter = vl.params.rowsAfter || vl.rowsPerScreen;
      vl.rowsToRender = vl.rowsPerScreen + vl.rowsBefore + vl.rowsAfter;
      vl.maxBufferHeight = vl.rowsBefore / 2 * vl.params.height;
    }

    if (vl.updatableScroll || vl.params.setListHeight) {
      vl.$itemsWrapEl.css({
        height: `${vl.listHeight}px`
      });
    }
  }

  render(force, forceScrollTop) {
    const vl = this;
    if (force) vl.lastRepaintY = null;
    let scrollTop = -(vl.$el[0].getBoundingClientRect().top - vl.$scrollableParentEl[0].getBoundingClientRect().top);
    if (typeof forceScrollTop !== 'undefined') scrollTop = forceScrollTop;

    if (vl.lastRepaintY === null || Math.abs(scrollTop - vl.lastRepaintY) > vl.maxBufferHeight || !vl.updatableScroll && vl.$scrollableParentEl[0].scrollTop + vl.pageHeight >= vl.$scrollableParentEl[0].scrollHeight) {
      vl.lastRepaintY = scrollTop;
    } else {
      return;
    }

    const items = vl.filteredItems || vl.items;
    let fromIndex;
    let toIndex;
    let heightBeforeFirstItem = 0;
    let heightBeforeLastItem = 0;

    if (vl.dynamicHeight || vl.autoHeight) {
      let itemTop = 0;
      let itemHeight;
      vl.maxBufferHeight = vl.pageHeight;

      for (let j = 0; j < vl.heights.length; j += 1) {
        itemHeight = vl.heights[j];

        if (typeof fromIndex === 'undefined') {
          if (itemTop + itemHeight >= scrollTop - vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize) fromIndex = j;else heightBeforeFirstItem += itemHeight;
        }

        if (typeof toIndex === 'undefined') {
          if (itemTop + itemHeight >= scrollTop + vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize || j === vl.heights.length - 1) toIndex = j + 1;
          heightBeforeLastItem += itemHeight;
        }

        itemTop += itemHeight;
      }

      toIndex = Math.min(toIndex, items.length);
    } else {
      fromIndex = (parseInt(scrollTop / vl.params.height, 10) - vl.rowsBefore) * vl.params.cols;

      if (fromIndex < 0) {
        fromIndex = 0;
      }

      toIndex = Math.min(fromIndex + vl.rowsToRender * vl.params.cols, items.length);
    }

    let topPosition;
    const renderExternalItems = [];
    vl.reachEnd = false;
    let i;

    for (i = fromIndex; i < toIndex; i += 1) {
      let itemEl; // Define real item index

      const index = vl.items.indexOf(items[i]);
      if (i === fromIndex) vl.currentFromIndex = index;
      if (i === toIndex - 1) vl.currentToIndex = index;

      if (vl.filteredItems) {
        if (vl.items[index] === vl.filteredItems[vl.filteredItems.length - 1]) vl.reachEnd = true;
      } else if (index === vl.items.length - 1) vl.reachEnd = true; // Find items


      if (vl.params.renderExternal) {
        renderExternalItems.push(items[i]);
      } else if (vl.domCache[index]) {
        itemEl = vl.domCache[index];
        itemEl.f7VirtualListIndex = index;
      } else {
        if (vl.renderItem) {
          vl.tempDomElement.innerHTML = vl.renderItem(items[i], index).trim();
        } else {
          vl.tempDomElement.innerHTML = items[i].toString().trim();
        }

        itemEl = vl.tempDomElement.childNodes[0];
        if (vl.params.cache) vl.domCache[index] = itemEl;
        itemEl.f7VirtualListIndex = index;
      } // Set item top position


      if (i === fromIndex) {
        if (vl.dynamicHeight || vl.autoHeight) {
          topPosition = heightBeforeFirstItem;
        } else {
          topPosition = i * vl.params.height / vl.params.cols;
        }
      }

      if (!vl.params.renderExternal) {
        itemEl.style.top = `${topPosition}px`; // Before item insert

        vl.emit('local::itemBeforeInsert vlItemBeforeInsert', vl, itemEl, items[i]); // Append item to fragment

        vl.fragment.appendChild(itemEl);
      }
    } // Update list height with not updatable scroll


    if (!vl.updatableScroll) {
      if (vl.dynamicHeight || vl.autoHeight) {
        vl.itemsWrapEl.style.height = `${heightBeforeLastItem}px`;
      } else {
        vl.itemsWrapEl.style.height = `${i * vl.params.height / vl.params.cols}px`;
      }
    } // Update list html


    if (vl.params.renderExternal) {
      if (items && items.length === 0) {
        vl.reachEnd = true;
      }
    } else {
      vl.emit('local::beforeClear vlBeforeClear', vl, vl.fragment);
      vl.itemsWrapEl.innerHTML = '';
      vl.emit('local::itemsBeforeInsert vlItemsBeforeInsert', vl, vl.fragment);

      if (items && items.length === 0) {
        vl.reachEnd = true;
        if (vl.params.emptyTemplate) vl.itemsWrapEl.innerHTML = vl.params.emptyTemplate;
      } else {
        vl.itemsWrapEl.appendChild(vl.fragment);
      }

      vl.emit('local::itemsAfterInsert vlItemsAfterInsert', vl, vl.fragment);
    }

    if (typeof forceScrollTop !== 'undefined' && force) {
      vl.$scrollableParentEl.scrollTop(forceScrollTop, 0);
    }

    if (vl.params.renderExternal) {
      vl.params.renderExternal(vl, {
        fromIndex,
        toIndex,
        listHeight: vl.listHeight,
        topPosition,
        items: renderExternalItems
      });
    }

    if (vl.autoHeight) {
      requestAnimationFrame(() => {
        vl.setListSize(true);
      });
    }
  } // Filter


  filterItems(indexes, resetScrollTop) {
    if (resetScrollTop === void 0) {
      resetScrollTop = true;
    }

    const vl = this;
    vl.filteredItems = [];

    for (let i = 0; i < indexes.length; i += 1) {
      vl.filteredItems.push(vl.items[indexes[i]]);
    }

    if (resetScrollTop) {
      vl.$scrollableParentEl[0].scrollTop = 0;
    }

    vl.update();
  }

  resetFilter() {
    const vl = this;

    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    } else {
      vl.filteredItems = null;
      delete vl.filteredItems;
    }

    vl.update();
  }

  scrollToItem(index) {
    const vl = this;
    if (index > vl.items.length) return false;
    let itemTop = 0;

    if (vl.dynamicHeight || vl.autoHeight) {
      for (let i = 0; i < index; i += 1) {
        itemTop += vl.heights[i];
      }
    } else {
      itemTop = index * vl.params.height;
    }

    const listTop = vl.$el[0].offsetTop;
    vl.render(true, listTop + itemTop - parseInt(vl.$scrollableParentEl.css('padding-top'), 10));
    return true;
  }

  handleScroll() {
    const vl = this;
    vl.render();
  } // Handle resize event


  isVisible() {
    const vl = this;
    return !!(vl.el.offsetWidth || vl.el.offsetHeight || vl.el.getClientRects().length);
  }

  handleResize() {
    const vl = this;

    if (vl.isVisible()) {
      vl.heightsCalculated = [];
      vl.setListSize();
      vl.render(true);
    }
  } // Append


  appendItems(items) {
    const vl = this;

    for (let i = 0; i < items.length; i += 1) {
      vl.items.push(items[i]);
    }

    vl.update();
  }

  appendItem(item) {
    const vl = this;
    vl.appendItems([item]);
  } // Replace


  replaceAllItems(items) {
    const vl = this;
    vl.items = items;
    delete vl.filteredItems;
    vl.domCache = {};
    vl.update();
  }

  replaceItem(index, item) {
    const vl = this;
    vl.items[index] = item;
    if (vl.params.cache) delete vl.domCache[index];
    vl.update();
  } // Prepend


  prependItems(items) {
    const vl = this;

    for (let i = items.length - 1; i >= 0; i -= 1) {
      vl.items.unshift(items[i]);
    }

    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach(cached => {
        newCache[parseInt(cached, 10) + items.length] = vl.domCache[cached];
      });
      vl.domCache = newCache;
    }

    vl.update();
  }

  prependItem(item) {
    const vl = this;
    vl.prependItems([item]);
  } // Move


  moveItem(from, to) {
    const vl = this;
    const fromIndex = from;
    let toIndex = to;
    if (fromIndex === toIndex) return; // remove item from array

    const item = vl.items.splice(fromIndex, 1)[0];

    if (toIndex >= vl.items.length) {
      // Add item to the end
      vl.items.push(item);
      toIndex = vl.items.length - 1;
    } else {
      // Add item to new index
      vl.items.splice(toIndex, 0, item);
    } // Update cache


    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach(cached => {
        const cachedIndex = parseInt(cached, 10);
        const leftIndex = fromIndex < toIndex ? fromIndex : toIndex;
        const rightIndex = fromIndex < toIndex ? toIndex : fromIndex;
        const indexShift = fromIndex < toIndex ? -1 : 1;
        if (cachedIndex < leftIndex || cachedIndex > rightIndex) newCache[cachedIndex] = vl.domCache[cachedIndex];
        if (cachedIndex === leftIndex) newCache[rightIndex] = vl.domCache[cachedIndex];
        if (cachedIndex > leftIndex && cachedIndex <= rightIndex) newCache[cachedIndex + indexShift] = vl.domCache[cachedIndex];
      });
      vl.domCache = newCache;
    }

    vl.update();
  } // Insert before


  insertItemBefore(index, item) {
    const vl = this;

    if (index === 0) {
      vl.prependItem(item);
      return;
    }

    if (index >= vl.items.length) {
      vl.appendItem(item);
      return;
    }

    vl.items.splice(index, 0, item); // Update cache

    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach(cached => {
        const cachedIndex = parseInt(cached, 10);

        if (cachedIndex >= index) {
          newCache[cachedIndex + 1] = vl.domCache[cachedIndex];
        }
      });
      vl.domCache = newCache;
    }

    vl.update();
  } // Delete


  deleteItems(indexes) {
    const vl = this;
    let prevIndex;
    let indexShift = 0;

    for (let i = 0; i < indexes.length; i += 1) {
      let index = indexes[i];

      if (typeof prevIndex !== 'undefined') {
        if (index > prevIndex) {
          indexShift = -i;
        }
      }

      index += indexShift;
      prevIndex = indexes[i]; // Delete item

      const deletedItem = vl.items.splice(index, 1)[0]; // Delete from filtered

      if (vl.filteredItems && vl.filteredItems.indexOf(deletedItem) >= 0) {
        vl.filteredItems.splice(vl.filteredItems.indexOf(deletedItem), 1);
      } // Update cache


      if (vl.params.cache) {
        const newCache = {};
        Object.keys(vl.domCache).forEach(cached => {
          const cachedIndex = parseInt(cached, 10);

          if (cachedIndex === index) {
            delete vl.domCache[index];
          } else if (parseInt(cached, 10) > index) {
            newCache[cachedIndex - 1] = vl.domCache[cached];
          } else {
            newCache[cachedIndex] = vl.domCache[cached];
          }
        });
        vl.domCache = newCache;
      }
    }

    vl.update();
  }

  deleteAllItems() {
    const vl = this;
    vl.items = [];
    delete vl.filteredItems;
    if (vl.params.cache) vl.domCache = {};
    vl.update();
  }

  deleteItem(index) {
    const vl = this;
    vl.deleteItems([index]);
  } // Clear cache


  clearCache() {
    const vl = this;
    vl.domCache = {};
  } // Update Virtual List


  update(deleteCache) {
    const vl = this;

    if (deleteCache && vl.params.cache) {
      vl.domCache = {};
    }

    vl.heightsCalculated = [];
    vl.setListSize();
    vl.render(true);
  }

  init() {
    const vl = this;
    vl.attachEvents();
    vl.setListSize();
    vl.render();
  }

  destroy() {
    let vl = this;
    vl.detachEvents();
    vl.$el[0].f7VirtualList = null;
    delete vl.$el[0].f7VirtualList;
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.deleteProps)(vl);
    vl = null;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VirtualList);

/***/ }),

/***/ "./node_modules/framework7/components/virtual-list/virtual-list.js":
/*!*************************************************************************!*\
  !*** ./node_modules/framework7/components/virtual-list/virtual-list.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _virtual_list_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./virtual-list-class.js */ "./node_modules/framework7/components/virtual-list/virtual-list-class.js");
/* harmony import */ var _shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'virtualList',
  static: {
    VirtualList: _virtual_list_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  create() {
    const app = this;
    app.virtualList = (0,_shared_constructor_methods_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
      defaultSelector: '.virtual-list',
      constructor: _virtual_list_class_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      app,
      domProp: 'f7VirtualList'
    });
  }

});

/***/ }),

/***/ "./node_modules/framework7/framework7-lite-bundle.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/framework7-lite-bundle.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dom7": () => (/* reexport safe */ _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "createStore": () => (/* reexport safe */ _modules_store_store_js__WEBPACK_IMPORTED_MODULE_77__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getDevice": () => (/* reexport safe */ _shared_get_device_js__WEBPACK_IMPORTED_MODULE_75__.getDevice),
/* harmony export */   "getSupport": () => (/* reexport safe */ _shared_get_support_js__WEBPACK_IMPORTED_MODULE_76__.getSupport),
/* harmony export */   "request": () => (/* reexport safe */ _shared_request_js__WEBPACK_IMPORTED_MODULE_73__["default"]),
/* harmony export */   "utils": () => (/* reexport module object */ _shared_utils_js__WEBPACK_IMPORTED_MODULE_74__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _components_app_app_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/app/app-class.js */ "./node_modules/framework7/components/app/app-class.js");
/* harmony import */ var _shared_request_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./shared/request.js */ "./node_modules/framework7/shared/request.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _modules_device_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/device/device.js */ "./node_modules/framework7/modules/device/device.js");
/* harmony import */ var _modules_support_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/support/support.js */ "./node_modules/framework7/modules/support/support.js");
/* harmony import */ var _modules_utils_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/utils/utils.js */ "./node_modules/framework7/modules/utils/utils.js");
/* harmony import */ var _modules_resize_resize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/resize/resize.js */ "./node_modules/framework7/modules/resize/resize.js");
/* harmony import */ var _modules_request_request_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/request/request.js */ "./node_modules/framework7/modules/request/request.js");
/* harmony import */ var _modules_touch_touch_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/touch/touch.js */ "./node_modules/framework7/modules/touch/touch.js");
/* harmony import */ var _modules_clicks_clicks_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/clicks/clicks.js */ "./node_modules/framework7/modules/clicks/clicks.js");
/* harmony import */ var _modules_router_router_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/router/router.js */ "./node_modules/framework7/modules/router/router.js");
/* harmony import */ var _modules_history_history_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/history/history.js */ "./node_modules/framework7/modules/history/history.js");
/* harmony import */ var _modules_service_worker_service_worker_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/service-worker/service-worker.js */ "./node_modules/framework7/modules/service-worker/service-worker.js");
/* harmony import */ var _modules_store_store_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/store/store.js */ "./node_modules/framework7/modules/store/store.js");
/* harmony import */ var _modules_store_store_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./modules/store/store.js */ "./node_modules/framework7/modules/store/create-store.js");
/* harmony import */ var _components_statusbar_statusbar_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/statusbar/statusbar.js */ "./node_modules/framework7/components/statusbar/statusbar.js");
/* harmony import */ var _components_view_view_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/view/view.js */ "./node_modules/framework7/components/view/view.js");
/* harmony import */ var _components_navbar_navbar_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/navbar/navbar.js */ "./node_modules/framework7/components/navbar/navbar.js");
/* harmony import */ var _components_toolbar_toolbar_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/toolbar/toolbar.js */ "./node_modules/framework7/components/toolbar/toolbar.js");
/* harmony import */ var _components_subnavbar_subnavbar_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/subnavbar/subnavbar.js */ "./node_modules/framework7/components/subnavbar/subnavbar.js");
/* harmony import */ var _components_touch_ripple_touch_ripple_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/touch-ripple/touch-ripple.js */ "./node_modules/framework7/components/touch-ripple/touch-ripple.js");
/* harmony import */ var _components_modal_modal_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/modal/modal.js */ "./node_modules/framework7/components/modal/modal.js");
/* harmony import */ var _components_appbar_appbar_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/appbar/appbar.js */ "./node_modules/framework7/components/appbar/appbar.js");
/* harmony import */ var _components_dialog_dialog_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/dialog/dialog.js */ "./node_modules/framework7/components/dialog/dialog.js");
/* harmony import */ var _components_popup_popup_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/popup/popup.js */ "./node_modules/framework7/components/popup/popup.js");
/* harmony import */ var _components_login_screen_login_screen_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/login-screen/login-screen.js */ "./node_modules/framework7/components/login-screen/login-screen.js");
/* harmony import */ var _components_popover_popover_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/popover/popover.js */ "./node_modules/framework7/components/popover/popover.js");
/* harmony import */ var _components_actions_actions_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/actions/actions.js */ "./node_modules/framework7/components/actions/actions.js");
/* harmony import */ var _components_sheet_sheet_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./components/sheet/sheet.js */ "./node_modules/framework7/components/sheet/sheet.js");
/* harmony import */ var _components_toast_toast_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./components/toast/toast.js */ "./node_modules/framework7/components/toast/toast.js");
/* harmony import */ var _components_preloader_preloader_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./components/preloader/preloader.js */ "./node_modules/framework7/components/preloader/preloader.js");
/* harmony import */ var _components_progressbar_progressbar_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./components/progressbar/progressbar.js */ "./node_modules/framework7/components/progressbar/progressbar.js");
/* harmony import */ var _components_sortable_sortable_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./components/sortable/sortable.js */ "./node_modules/framework7/components/sortable/sortable.js");
/* harmony import */ var _components_swipeout_swipeout_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./components/swipeout/swipeout.js */ "./node_modules/framework7/components/swipeout/swipeout.js");
/* harmony import */ var _components_accordion_accordion_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./components/accordion/accordion.js */ "./node_modules/framework7/components/accordion/accordion.js");
/* harmony import */ var _components_contacts_list_contacts_list_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./components/contacts-list/contacts-list.js */ "./node_modules/framework7/components/contacts-list/contacts-list.js");
/* harmony import */ var _components_virtual_list_virtual_list_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./components/virtual-list/virtual-list.js */ "./node_modules/framework7/components/virtual-list/virtual-list.js");
/* harmony import */ var _components_list_index_list_index_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./components/list-index/list-index.js */ "./node_modules/framework7/components/list-index/list-index.js");
/* harmony import */ var _components_timeline_timeline_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./components/timeline/timeline.js */ "./node_modules/framework7/components/timeline/timeline.js");
/* harmony import */ var _components_tabs_tabs_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./components/tabs/tabs.js */ "./node_modules/framework7/components/tabs/tabs.js");
/* harmony import */ var _components_panel_panel_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./components/panel/panel.js */ "./node_modules/framework7/components/panel/panel.js");
/* harmony import */ var _components_card_card_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./components/card/card.js */ "./node_modules/framework7/components/card/card.js");
/* harmony import */ var _components_chip_chip_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./components/chip/chip.js */ "./node_modules/framework7/components/chip/chip.js");
/* harmony import */ var _components_form_form_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./components/form/form.js */ "./node_modules/framework7/components/form/form.js");
/* harmony import */ var _components_input_input_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./components/input/input.js */ "./node_modules/framework7/components/input/input.js");
/* harmony import */ var _components_checkbox_checkbox_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./components/checkbox/checkbox.js */ "./node_modules/framework7/components/checkbox/checkbox.js");
/* harmony import */ var _components_radio_radio_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./components/radio/radio.js */ "./node_modules/framework7/components/radio/radio.js");
/* harmony import */ var _components_toggle_toggle_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./components/toggle/toggle.js */ "./node_modules/framework7/components/toggle/toggle.js");
/* harmony import */ var _components_range_range_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./components/range/range.js */ "./node_modules/framework7/components/range/range.js");
/* harmony import */ var _components_stepper_stepper_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./components/stepper/stepper.js */ "./node_modules/framework7/components/stepper/stepper.js");
/* harmony import */ var _components_smart_select_smart_select_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./components/smart-select/smart-select.js */ "./node_modules/framework7/components/smart-select/smart-select.js");
/* harmony import */ var _components_grid_grid_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./components/grid/grid.js */ "./node_modules/framework7/components/grid/grid.js");
/* harmony import */ var _components_calendar_calendar_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./components/calendar/calendar.js */ "./node_modules/framework7/components/calendar/calendar.js");
/* harmony import */ var _components_picker_picker_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./components/picker/picker.js */ "./node_modules/framework7/components/picker/picker.js");
/* harmony import */ var _components_infinite_scroll_infinite_scroll_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./components/infinite-scroll/infinite-scroll.js */ "./node_modules/framework7/components/infinite-scroll/infinite-scroll.js");
/* harmony import */ var _components_pull_to_refresh_pull_to_refresh_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./components/pull-to-refresh/pull-to-refresh.js */ "./node_modules/framework7/components/pull-to-refresh/pull-to-refresh.js");
/* harmony import */ var _components_lazy_lazy_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./components/lazy/lazy.js */ "./node_modules/framework7/components/lazy/lazy.js");
/* harmony import */ var _components_data_table_data_table_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./components/data-table/data-table.js */ "./node_modules/framework7/components/data-table/data-table.js");
/* harmony import */ var _components_fab_fab_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./components/fab/fab.js */ "./node_modules/framework7/components/fab/fab.js");
/* harmony import */ var _components_searchbar_searchbar_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./components/searchbar/searchbar.js */ "./node_modules/framework7/components/searchbar/searchbar.js");
/* harmony import */ var _components_messages_messages_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./components/messages/messages.js */ "./node_modules/framework7/components/messages/messages.js");
/* harmony import */ var _components_messagebar_messagebar_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./components/messagebar/messagebar.js */ "./node_modules/framework7/components/messagebar/messagebar.js");
/* harmony import */ var _components_swiper_swiper_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./components/swiper/swiper.js */ "./node_modules/framework7/components/swiper/swiper.js");
/* harmony import */ var _components_photo_browser_photo_browser_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./components/photo-browser/photo-browser.js */ "./node_modules/framework7/components/photo-browser/photo-browser.js");
/* harmony import */ var _components_notification_notification_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./components/notification/notification.js */ "./node_modules/framework7/components/notification/notification.js");
/* harmony import */ var _components_autocomplete_autocomplete_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./components/autocomplete/autocomplete.js */ "./node_modules/framework7/components/autocomplete/autocomplete.js");
/* harmony import */ var _components_tooltip_tooltip_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./components/tooltip/tooltip.js */ "./node_modules/framework7/components/tooltip/tooltip.js");
/* harmony import */ var _components_skeleton_skeleton_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./components/skeleton/skeleton.js */ "./node_modules/framework7/components/skeleton/skeleton.js");
/* harmony import */ var _components_menu_menu_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./components/menu/menu.js */ "./node_modules/framework7/components/menu/menu.js");
/* harmony import */ var _components_color_picker_color_picker_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./components/color-picker/color-picker.js */ "./node_modules/framework7/components/color-picker/color-picker.js");
/* harmony import */ var _components_treeview_treeview_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./components/treeview/treeview.js */ "./node_modules/framework7/components/treeview/treeview.js");
/* harmony import */ var _components_text_editor_text_editor_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./components/text-editor/text-editor.js */ "./node_modules/framework7/components/text-editor/text-editor.js");
/* harmony import */ var _components_breadcrumbs_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./components/breadcrumbs/breadcrumbs.js */ "./node_modules/framework7/components/breadcrumbs/breadcrumbs.js");
/* harmony import */ var _components_elevation_elevation_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./components/elevation/elevation.js */ "./node_modules/framework7/components/elevation/elevation.js");
/* harmony import */ var _components_typography_typography_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./components/typography/typography.js */ "./node_modules/framework7/components/typography/typography.js");
/**
 * Framework7 7.0.9
 * Full featured mobile HTML framework for building iOS & Android apps
 * https://framework7.io/
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: November 21, 2022
 */














































































_components_app_app_class_js__WEBPACK_IMPORTED_MODULE_1__["default"].use([_modules_device_device_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modules_support_support_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modules_utils_utils_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modules_resize_resize_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modules_request_request_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modules_touch_touch_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modules_clicks_clicks_js__WEBPACK_IMPORTED_MODULE_8__["default"], _modules_router_router_js__WEBPACK_IMPORTED_MODULE_9__["default"], _modules_history_history_js__WEBPACK_IMPORTED_MODULE_10__["default"], _modules_service_worker_service_worker_js__WEBPACK_IMPORTED_MODULE_11__["default"], _modules_store_store_js__WEBPACK_IMPORTED_MODULE_12__["default"], _components_statusbar_statusbar_js__WEBPACK_IMPORTED_MODULE_13__["default"], _components_view_view_js__WEBPACK_IMPORTED_MODULE_14__["default"], _components_navbar_navbar_js__WEBPACK_IMPORTED_MODULE_15__["default"], _components_toolbar_toolbar_js__WEBPACK_IMPORTED_MODULE_16__["default"], _components_subnavbar_subnavbar_js__WEBPACK_IMPORTED_MODULE_17__["default"], _components_touch_ripple_touch_ripple_js__WEBPACK_IMPORTED_MODULE_18__["default"], _components_modal_modal_js__WEBPACK_IMPORTED_MODULE_19__["default"], _components_appbar_appbar_js__WEBPACK_IMPORTED_MODULE_20__["default"], _components_dialog_dialog_js__WEBPACK_IMPORTED_MODULE_21__["default"], _components_popup_popup_js__WEBPACK_IMPORTED_MODULE_22__["default"], _components_login_screen_login_screen_js__WEBPACK_IMPORTED_MODULE_23__["default"], _components_popover_popover_js__WEBPACK_IMPORTED_MODULE_24__["default"], _components_actions_actions_js__WEBPACK_IMPORTED_MODULE_25__["default"], _components_sheet_sheet_js__WEBPACK_IMPORTED_MODULE_26__["default"], _components_toast_toast_js__WEBPACK_IMPORTED_MODULE_27__["default"], _components_preloader_preloader_js__WEBPACK_IMPORTED_MODULE_28__["default"], _components_progressbar_progressbar_js__WEBPACK_IMPORTED_MODULE_29__["default"], _components_sortable_sortable_js__WEBPACK_IMPORTED_MODULE_30__["default"], _components_swipeout_swipeout_js__WEBPACK_IMPORTED_MODULE_31__["default"], _components_accordion_accordion_js__WEBPACK_IMPORTED_MODULE_32__["default"], _components_contacts_list_contacts_list_js__WEBPACK_IMPORTED_MODULE_33__["default"], _components_virtual_list_virtual_list_js__WEBPACK_IMPORTED_MODULE_34__["default"], _components_list_index_list_index_js__WEBPACK_IMPORTED_MODULE_35__["default"], _components_timeline_timeline_js__WEBPACK_IMPORTED_MODULE_36__["default"], _components_tabs_tabs_js__WEBPACK_IMPORTED_MODULE_37__["default"], _components_panel_panel_js__WEBPACK_IMPORTED_MODULE_38__["default"], _components_card_card_js__WEBPACK_IMPORTED_MODULE_39__["default"], _components_chip_chip_js__WEBPACK_IMPORTED_MODULE_40__["default"], _components_form_form_js__WEBPACK_IMPORTED_MODULE_41__["default"], _components_input_input_js__WEBPACK_IMPORTED_MODULE_42__["default"], _components_checkbox_checkbox_js__WEBPACK_IMPORTED_MODULE_43__["default"], _components_radio_radio_js__WEBPACK_IMPORTED_MODULE_44__["default"], _components_toggle_toggle_js__WEBPACK_IMPORTED_MODULE_45__["default"], _components_range_range_js__WEBPACK_IMPORTED_MODULE_46__["default"], _components_stepper_stepper_js__WEBPACK_IMPORTED_MODULE_47__["default"], _components_smart_select_smart_select_js__WEBPACK_IMPORTED_MODULE_48__["default"], _components_grid_grid_js__WEBPACK_IMPORTED_MODULE_49__["default"], _components_calendar_calendar_js__WEBPACK_IMPORTED_MODULE_50__["default"], _components_picker_picker_js__WEBPACK_IMPORTED_MODULE_51__["default"], _components_infinite_scroll_infinite_scroll_js__WEBPACK_IMPORTED_MODULE_52__["default"], _components_pull_to_refresh_pull_to_refresh_js__WEBPACK_IMPORTED_MODULE_53__["default"], _components_lazy_lazy_js__WEBPACK_IMPORTED_MODULE_54__["default"], _components_data_table_data_table_js__WEBPACK_IMPORTED_MODULE_55__["default"], _components_fab_fab_js__WEBPACK_IMPORTED_MODULE_56__["default"], _components_searchbar_searchbar_js__WEBPACK_IMPORTED_MODULE_57__["default"], _components_messages_messages_js__WEBPACK_IMPORTED_MODULE_58__["default"], _components_messagebar_messagebar_js__WEBPACK_IMPORTED_MODULE_59__["default"], _components_swiper_swiper_js__WEBPACK_IMPORTED_MODULE_60__["default"], _components_photo_browser_photo_browser_js__WEBPACK_IMPORTED_MODULE_61__["default"], _components_notification_notification_js__WEBPACK_IMPORTED_MODULE_62__["default"], _components_autocomplete_autocomplete_js__WEBPACK_IMPORTED_MODULE_63__["default"], _components_tooltip_tooltip_js__WEBPACK_IMPORTED_MODULE_64__["default"], _components_skeleton_skeleton_js__WEBPACK_IMPORTED_MODULE_65__["default"], _components_menu_menu_js__WEBPACK_IMPORTED_MODULE_66__["default"], _components_color_picker_color_picker_js__WEBPACK_IMPORTED_MODULE_67__["default"], _components_treeview_treeview_js__WEBPACK_IMPORTED_MODULE_68__["default"], _components_text_editor_text_editor_js__WEBPACK_IMPORTED_MODULE_69__["default"], _components_breadcrumbs_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_70__["default"], _components_elevation_elevation_js__WEBPACK_IMPORTED_MODULE_71__["default"], _components_typography_typography_js__WEBPACK_IMPORTED_MODULE_72__["default"]]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_components_app_app_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/framework7/framework7-lite.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7/framework7-lite.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dom7": () => (/* reexport safe */ _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "createStore": () => (/* reexport safe */ _modules_store_store_js__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getDevice": () => (/* reexport safe */ _shared_get_device_js__WEBPACK_IMPORTED_MODULE_22__.getDevice),
/* harmony export */   "getSupport": () => (/* reexport safe */ _shared_get_support_js__WEBPACK_IMPORTED_MODULE_23__.getSupport),
/* harmony export */   "request": () => (/* reexport safe */ _shared_request_js__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   "utils": () => (/* reexport module object */ _shared_utils_js__WEBPACK_IMPORTED_MODULE_21__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _components_app_app_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/app/app-class.js */ "./node_modules/framework7/components/app/app-class.js");
/* harmony import */ var _shared_request_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./shared/request.js */ "./node_modules/framework7/shared/request.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _modules_device_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/device/device.js */ "./node_modules/framework7/modules/device/device.js");
/* harmony import */ var _modules_support_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/support/support.js */ "./node_modules/framework7/modules/support/support.js");
/* harmony import */ var _modules_utils_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/utils/utils.js */ "./node_modules/framework7/modules/utils/utils.js");
/* harmony import */ var _modules_resize_resize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/resize/resize.js */ "./node_modules/framework7/modules/resize/resize.js");
/* harmony import */ var _modules_request_request_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/request/request.js */ "./node_modules/framework7/modules/request/request.js");
/* harmony import */ var _modules_touch_touch_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/touch/touch.js */ "./node_modules/framework7/modules/touch/touch.js");
/* harmony import */ var _modules_clicks_clicks_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/clicks/clicks.js */ "./node_modules/framework7/modules/clicks/clicks.js");
/* harmony import */ var _modules_router_router_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/router/router.js */ "./node_modules/framework7/modules/router/router.js");
/* harmony import */ var _modules_history_history_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/history/history.js */ "./node_modules/framework7/modules/history/history.js");
/* harmony import */ var _modules_service_worker_service_worker_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/service-worker/service-worker.js */ "./node_modules/framework7/modules/service-worker/service-worker.js");
/* harmony import */ var _modules_store_store_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/store/store.js */ "./node_modules/framework7/modules/store/store.js");
/* harmony import */ var _modules_store_store_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./modules/store/store.js */ "./node_modules/framework7/modules/store/create-store.js");
/* harmony import */ var _components_statusbar_statusbar_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/statusbar/statusbar.js */ "./node_modules/framework7/components/statusbar/statusbar.js");
/* harmony import */ var _components_view_view_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/view/view.js */ "./node_modules/framework7/components/view/view.js");
/* harmony import */ var _components_navbar_navbar_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/navbar/navbar.js */ "./node_modules/framework7/components/navbar/navbar.js");
/* harmony import */ var _components_toolbar_toolbar_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/toolbar/toolbar.js */ "./node_modules/framework7/components/toolbar/toolbar.js");
/* harmony import */ var _components_subnavbar_subnavbar_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/subnavbar/subnavbar.js */ "./node_modules/framework7/components/subnavbar/subnavbar.js");
/* harmony import */ var _components_touch_ripple_touch_ripple_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/touch-ripple/touch-ripple.js */ "./node_modules/framework7/components/touch-ripple/touch-ripple.js");
/* harmony import */ var _components_modal_modal_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/modal/modal.js */ "./node_modules/framework7/components/modal/modal.js");
/**
 * Framework7 7.0.9
 * Full featured mobile HTML framework for building iOS & Android apps
 * https://framework7.io/
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: November 21, 2022
 */

























_components_app_app_class_js__WEBPACK_IMPORTED_MODULE_1__["default"].use([_modules_device_device_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modules_support_support_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modules_utils_utils_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modules_resize_resize_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modules_request_request_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modules_touch_touch_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modules_clicks_clicks_js__WEBPACK_IMPORTED_MODULE_8__["default"], _modules_router_router_js__WEBPACK_IMPORTED_MODULE_9__["default"], _modules_history_history_js__WEBPACK_IMPORTED_MODULE_10__["default"], _modules_service_worker_service_worker_js__WEBPACK_IMPORTED_MODULE_11__["default"], _modules_store_store_js__WEBPACK_IMPORTED_MODULE_12__["default"], _components_statusbar_statusbar_js__WEBPACK_IMPORTED_MODULE_13__["default"], _components_view_view_js__WEBPACK_IMPORTED_MODULE_14__["default"], _components_navbar_navbar_js__WEBPACK_IMPORTED_MODULE_15__["default"], _components_toolbar_toolbar_js__WEBPACK_IMPORTED_MODULE_16__["default"], _components_subnavbar_subnavbar_js__WEBPACK_IMPORTED_MODULE_17__["default"], _components_touch_ripple_touch_ripple_js__WEBPACK_IMPORTED_MODULE_18__["default"], _components_modal_modal_js__WEBPACK_IMPORTED_MODULE_19__["default"]]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_components_app_app_class_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/framework7/modules/clicks/clicks.js":
/*!**********************************************************!*\
  !*** ./node_modules/framework7/modules/clicks/clicks.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _components_view_view_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/view/view-class.js */ "./node_modules/framework7/components/view/view-class.js");




function initClicks(app) {
  function handleClicks(e) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const $clickedEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target);
    const $clickedLinkEl = $clickedEl.closest('a');
    const isLink = $clickedLinkEl.length > 0;
    const url = isLink && $clickedLinkEl.attr('href'); // Check if link is external

    if (isLink) {
      if ($clickedLinkEl.is(app.params.clicks.externalLinks) || // eslint-disable-next-line
      url && url.indexOf('javascript:') >= 0) {
        const target = $clickedLinkEl.attr('target');

        if (url && window.cordova && window.cordova.InAppBrowser && (target === '_system' || target === '_blank')) {
          e.preventDefault();
          window.cordova.InAppBrowser.open(url, target);
        } else if (url && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Browser && (target === '_system' || target === '_blank')) {
          e.preventDefault();
          window.Capacitor.Plugins.Browser.open({
            url
          });
        }

        return;
      }
    } // Modules Clicks


    Object.keys(app.modules).forEach(moduleName => {
      const moduleClicks = app.modules[moduleName].clicks;
      if (!moduleClicks) return;
      if (e.preventF7Router) return;
      Object.keys(moduleClicks).forEach(clickSelector => {
        const matchingClickedElement = $clickedEl.closest(clickSelector).eq(0);

        if (matchingClickedElement.length > 0) {
          moduleClicks[clickSelector].call(app, matchingClickedElement, matchingClickedElement.dataset(), e);
        }
      });
    }); // Load Page

    let clickedLinkData = {};

    if (isLink) {
      e.preventDefault();
      clickedLinkData = $clickedLinkEl.dataset();
    }

    clickedLinkData.clickedEl = $clickedLinkEl[0]; // Prevent Router

    if (e.preventF7Router) return;
    if ($clickedLinkEl.hasClass('prevent-router') || $clickedLinkEl.hasClass('router-prevent')) return;
    const validUrl = url && url.length > 0 && url[0] !== '#';

    if (validUrl || $clickedLinkEl.hasClass('back')) {
      let view;

      if (clickedLinkData.view && clickedLinkData.view === 'current') {
        view = app.views.current;
      } else if (clickedLinkData.view) {
        view = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(clickedLinkData.view)[0].f7View;
      } else {
        view = $clickedEl.parents('.view')[0] && $clickedEl.parents('.view')[0].f7View;

        if (!$clickedLinkEl.hasClass('back') && view && view.params.linksView) {
          if (typeof view.params.linksView === 'string') view = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(view.params.linksView)[0].f7View;else if (view.params.linksView instanceof _components_view_view_class_js__WEBPACK_IMPORTED_MODULE_2__["default"]) view = view.params.linksView;
        }
      }

      if (!view) {
        if (app.views.main) view = app.views.main;
      }

      if (!view || !view.router) return;

      if ($clickedLinkEl[0].f7RouteProps) {
        clickedLinkData.props = $clickedLinkEl[0].f7RouteProps;
      }

      if ($clickedLinkEl.hasClass('back')) view.router.back(url, clickedLinkData);else view.router.navigate(url, clickedLinkData);
    }
  }

  app.on('click', handleClicks);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'clicks',
  params: {
    clicks: {
      // External Links
      externalLinks: '.external'
    }
  },
  on: {
    init() {
      const app = this;
      initClicks(app);
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/modules/device/device.js":
/*!**********************************************************!*\
  !*** ./node_modules/framework7/modules/device/device.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'device',
  static: {
    getDevice: _shared_get_device_js__WEBPACK_IMPORTED_MODULE_1__.getDevice
  },
  on: {
    init() {
      const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
      const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_1__.getDevice)();
      const classNames = [];
      const html = document.querySelector('html');
      const metaStatusbar = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
      if (!html) return;

      if (device.standalone && device.ios && metaStatusbar && metaStatusbar.content === 'black-translucent') {
        classNames.push('device-full-viewport');
      } // Pixel Ratio


      classNames.push(`device-pixel-ratio-${Math.floor(device.pixelRatio)}`); // OS classes

      if (device.os && !device.desktop) {
        classNames.push(`device-${device.os}`);
      } else if (device.desktop) {
        classNames.push('device-desktop');

        if (device.os) {
          classNames.push(`device-${device.os}`);
        }
      }

      if (device.cordova) {
        classNames.push('device-cordova');
      }

      if (device.capacitor) {
        classNames.push('device-capacitor');
      } // Add html classes


      classNames.forEach(className => {
        html.classList.add(className);
      });
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/modules/history/history.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7/modules/history/history.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_history_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/history.js */ "./node_modules/framework7/shared/history.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'history',
  static: {
    history: _shared_history_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  on: {
    init() {
      _shared_history_js__WEBPACK_IMPORTED_MODULE_0__["default"].init(this);
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/modules/request/request.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7/modules/request/request.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/request.js */ "./node_modules/framework7/shared/request.js");
/* eslint no-param-reassign: "off" */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'request',
  proto: {
    request: _shared_request_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  static: {
    request: _shared_request_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  }
});

/***/ }),

/***/ "./node_modules/framework7/modules/resize/resize.js":
/*!**********************************************************!*\
  !*** ./node_modules/framework7/modules/resize/resize.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'resize',

  create() {
    const app = this;

    app.getSize = () => {
      if (!app.el) return {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      };
      const offset = app.$el.offset();
      const [width, height, left, top] = [app.el.offsetWidth, app.el.offsetHeight, offset.left, offset.top];
      app.width = width;
      app.height = height;
      app.left = left;
      app.top = top;
      return {
        width,
        height,
        left,
        top
      };
    };
  },

  on: {
    init() {
      const app = this;
      const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)(); // Get Size

      app.getSize(); // Emit resize

      window.addEventListener('resize', () => {
        app.emit('resize');
      }, false); // Emit orientationchange

      window.addEventListener('orientationchange', () => {
        app.emit('orientationchange');
      });
    },

    orientationchange() {
      const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
      const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_1__.getDevice)(); // Fix iPad weird body scroll

      if (device.ipad) {
        document.body.scrollLeft = 0;
        setTimeout(() => {
          document.body.scrollLeft = 0;
        }, 0);
      }
    },

    resize() {
      const app = this;
      app.getSize();
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/modules/router/app-router-check.js":
/*!********************************************************************!*\
  !*** ./node_modules/framework7/modules/router/app-router-check.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ appRouterCheck)
/* harmony export */ });
function appRouterCheck(router, method) {
  if (!router.view) {
    throw new Error(`Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router.${method}(...)`);
  }
}

/***/ }),

/***/ "./node_modules/framework7/modules/router/async-component.js":
/*!*******************************************************************!*\
  !*** ./node_modules/framework7/modules/router/async-component.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ asyncComponent)
/* harmony export */ });
function asyncComponent(router, component, resolve, reject) {
  function resolvePromise(componentPromise) {
    componentPromise.then(c => {
      // eslint-disable-next-line
      resolve({
        component: c.default || c._default || c
      });
    }).catch(err => {
      reject();
      throw new Error(err);
    });
  }

  if (component instanceof Promise) {
    resolvePromise(component);
    return;
  }

  const asyncComponentResult = component.call(router);

  if (asyncComponentResult instanceof Promise) {
    resolvePromise(asyncComponentResult);
  } else {
    resolve({
      component: asyncComponentResult
    });
  }
}

/***/ }),

/***/ "./node_modules/framework7/modules/router/back.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7/modules/router/back.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "back": () => (/* binding */ back)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _shared_history_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/history.js */ "./node_modules/framework7/shared/history.js");
/* harmony import */ var _redirect_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./redirect.js */ "./node_modules/framework7/modules/router/redirect.js");
/* harmony import */ var _process_route_queue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./process-route-queue.js */ "./node_modules/framework7/modules/router/process-route-queue.js");
/* harmony import */ var _app_router_check_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./app-router-check.js */ "./node_modules/framework7/modules/router/app-router-check.js");
/* harmony import */ var _async_component_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./async-component.js */ "./node_modules/framework7/modules/router/async-component.js");










function backward(router, el, backwardOptions) {
  const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
  const app = router.app;
  const view = router.view;
  const options = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(false, {
    animate: router.params.animate,
    browserHistory: true,
    replaceState: false
  }, backwardOptions);
  const masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
  const isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === 'function' && options.route.route.master(app, router));
  let masterPageEl;
  let masterPageRemoved;
  const dynamicNavbar = router.dynamicNavbar;
  const $newPage = $el;
  const $oldPage = router.$el.children('.page-current');
  const initialPreload = $oldPage.length === 0 && options.preload;
  const currentIsMaster = masterDetailEnabled && $oldPage.hasClass('page-master');

  if ($newPage.length) {
    // Remove theme elements
    router.removeThemeElements($newPage);
  }

  let $navbarsEl;
  let $newNavbarEl;
  let $oldNavbarEl;

  if (dynamicNavbar) {
    $newNavbarEl = $newPage.children('.navbar');
    $navbarsEl = router.$navbarsEl;

    if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
      // Try from pageData
      $newNavbarEl = $newPage[0].f7Page.$navbarEl;
    }

    $oldNavbarEl = $navbarsEl.find('.navbar-current');
  }

  router.allowPageChange = false;

  if ($newPage.length === 0 || $oldPage.length === 0 && !options.preload) {
    router.allowPageChange = true;
    return router;
  } // Remove theme elements


  router.removeThemeElements($newPage); // Save Keep Alive Cache

  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
    options.route.route.keepAliveData = {
      pageEl: $el[0]
    };
  } // Pages In View


  let isDetail;
  let isDetailRoot;

  if (masterDetailEnabled) {
    const $pagesInView = router.$el.children('.page:not(.stacked)').filter(pageInView => pageInView !== $newPage[0]); // Find Detail' master page

    for (let i = 0; i < $pagesInView.length; i += 1) {
      if (!masterPageEl && $pagesInView[i].classList.contains('page-master')) {
        masterPageEl = $pagesInView[i];
        continue; // eslint-disable-line
      }
    }

    isDetail = !isMaster && masterPageEl && router.history.indexOf(options.route.url) > router.history.indexOf(masterPageEl.f7Page.route.url);

    if (!isDetail && !isMaster && masterPageEl && masterPageEl.f7Page && options.route.route.masterRoute) {
      isDetail = options.route.route.masterRoute.path === masterPageEl.f7Page.route.route.path;
    }
  }

  if (isDetail && masterPageEl && masterPageEl.f7Page) {
    isDetailRoot = router.history.indexOf(options.route.url) - router.history.indexOf(masterPageEl.f7Page.route.url) === 1;
  } // New Page


  $newPage.addClass(`page-${initialPreload ? 'current' : 'previous'}${isMaster ? ' page-master' : ''}${isDetail ? ' page-master-detail' : ''}${isDetailRoot ? ' page-master-detail-root' : ''}`).removeClass('stacked').removeAttr('aria-hidden').trigger('page:unstack').trigger('page:position', {
    position: initialPreload ? 'current' : 'previous'
  });
  router.emit('pageUnstack', $newPage[0]);
  router.emit('pagePosition', $newPage[0], initialPreload ? 'current' : 'previous');

  if (isMaster || isDetail) {
    $newPage.trigger('page:role', {
      role: isMaster ? 'master' : 'detail',
      root: !!isDetailRoot
    });
    router.emit('pageRole', $newPage[0], {
      role: isMaster ? 'master' : 'detail',
      detailRoot: !!isDetailRoot
    });
  }

  if (dynamicNavbar && $newNavbarEl.length > 0) {
    $newNavbarEl.addClass(`navbar-${initialPreload ? 'current' : 'previous'}${isMaster ? ' navbar-master' : ''}${isDetail ? ' navbar-master-detail' : ''}${isDetailRoot ? ' navbar-master-detail-root' : ''}`).removeClass('stacked').removeAttr('aria-hidden');
    $newNavbarEl.trigger('navbar:position', {
      position: initialPreload ? 'current' : 'previous'
    });
    router.emit('navbarPosition', $newNavbarEl[0], initialPreload ? 'current' : 'previous');

    if (isMaster || isDetailRoot) {
      router.emit('navbarRole', $newNavbarEl[0], {
        role: isMaster ? 'master' : 'detail',
        detailRoot: !!isDetailRoot
      });
    }
  } // Remove previous page in case of "forced"


  let backIndex;

  if (options.force) {
    if ($oldPage.prev('.page-previous:not(.stacked)').length > 0 || $oldPage.prev('.page-previous').length === 0) {
      if (router.history.indexOf(options.route.url) >= 0) {
        backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
        router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
        view.history = router.history;
      } else if (router.history[[router.history.length - 2]]) {
        router.history[router.history.length - 2] = options.route.url;
      } else {
        router.history.unshift(router.url);
      }

      if (backIndex && router.params.stackPages) {
        $oldPage.prevAll('.page-previous').each(pageToRemove => {
          const $pageToRemove = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageToRemove);
          let $navbarToRemove;

          if (dynamicNavbar) {
            // $navbarToRemove = $oldNavbarEl.prevAll('.navbar-previous').eq(index);
            $navbarToRemove = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getElByPage($pageToRemove));
          }

          if ($pageToRemove[0] !== $newPage[0] && $pageToRemove.index() > $newPage.index()) {
            if (router.initialPages.indexOf($pageToRemove[0]) >= 0) {
              $pageToRemove.addClass('stacked');
              $pageToRemove.trigger('page:stack');
              router.emit('pageStack', $pageToRemove[0]);

              if (dynamicNavbar) {
                $navbarToRemove.addClass('stacked');
              }
            } else {
              router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);

              if ($pageToRemove[0] === masterPageEl) {
                masterPageRemoved = true;
              }

              router.removePage($pageToRemove);

              if (dynamicNavbar && $navbarToRemove.length > 0) {
                router.removeNavbar($navbarToRemove);
              }
            }
          }
        });
      } else {
        const $pageToRemove = $oldPage.prev('.page-previous:not(.stacked)');
        let $navbarToRemove;

        if (dynamicNavbar) {
          // $navbarToRemove = $oldNavbarEl.prev('.navbar-inner:not(.stacked)');
          $navbarToRemove = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getElByPage($pageToRemove));
        }

        if (router.params.stackPages && router.initialPages.indexOf($pageToRemove[0]) >= 0) {
          $pageToRemove.addClass('stacked');
          $pageToRemove.trigger('page:stack');
          router.emit('pageStack', $pageToRemove[0]);
          $navbarToRemove.addClass('stacked');
        } else if ($pageToRemove.length > 0) {
          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);

          if ($pageToRemove[0] === masterPageEl) {
            masterPageRemoved = true;
          }

          router.removePage($pageToRemove);

          if (dynamicNavbar && $navbarToRemove.length) {
            router.removeNavbar($navbarToRemove);
          }
        }
      }
    }
  } // Insert new page


  const newPageInDom = $newPage.parents(document).length > 0;
  const f7Component = $newPage[0].f7Component;

  function insertPage() {
    if (initialPreload) {
      if (!newPageInDom && f7Component) {
        f7Component.mount(componentEl => {
          router.$el.append(componentEl);
        });
      } else {
        router.$el.append($newPage);
      }
    }

    if ($newPage.next($oldPage).length === 0) {
      if (!newPageInDom && f7Component) {
        f7Component.mount(componentEl => {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(componentEl).insertBefore($oldPage);
        });
      } else {
        $newPage.insertBefore($oldPage);
      }
    }

    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find('.title-large').length) {
        $newNavbarEl.addClass('navbar-large');
      }

      $newNavbarEl.insertBefore($oldNavbarEl);

      if ($oldNavbarEl.length > 0) {
        $newNavbarEl.insertBefore($oldNavbarEl);
      } else {
        if (!router.$navbarsEl.parents(document).length) {
          router.$el.prepend(router.$navbarsEl);
        }

        $navbarsEl.append($newNavbarEl);
      }
    }

    if (!newPageInDom) {
      router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
    } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
      $newPage[0].f7PageMounted = true;
      router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
    }
  }

  if (options.preload) {
    // Insert Page
    insertPage(); // Tab route

    if (options.route.route.tab) {
      router.tabLoad(options.route.route.tab, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, options, {
        history: false,
        browserHistory: false,
        preload: true
      }));
    }

    if (isMaster) {
      $newPage.removeClass('page-master-stacked').trigger('page:masterunstack');
      router.emit('pageMasterUnstack', $newPage[0]);

      if (dynamicNavbar) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getElByPage($newPage)).removeClass('navbar-master-stacked');
        router.emit('navbarMasterUnstack', app.navbar.getElByPage($newPage));
      }
    } // Page init and before init events


    router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);

    if (initialPreload) {
      router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'current', undefined, options);
      router.pageCallback('afterIn', $newPage, $newNavbarEl, 'current', undefined, options);
    }

    const $previousPages = $newPage.prevAll('.page-previous:not(.stacked):not(.page-master)');

    if ($previousPages.length > 0) {
      $previousPages.each(pageToRemove => {
        const $pageToRemove = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageToRemove);
        let $navbarToRemove;

        if (dynamicNavbar) {
          // $navbarToRemove = $newNavbarEl.prevAll('.navbar-previous:not(.stacked)').eq(index);
          $navbarToRemove = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getElByPage($pageToRemove));
        }

        if (router.params.stackPages && router.initialPages.indexOf(pageToRemove) >= 0) {
          $pageToRemove.addClass('stacked');
          $pageToRemove.trigger('page:stack');
          router.emit('pageStack', $pageToRemove[0]);

          if (dynamicNavbar) {
            $navbarToRemove.addClass('stacked');
          }
        } else {
          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined);
          router.removePage($pageToRemove);

          if (dynamicNavbar && $navbarToRemove.length) {
            router.removeNavbar($navbarToRemove);
          }
        }
      });
    }

    router.allowPageChange = true;
    return router;
  } // History State


  if (!(device.ie || device.edge || device.firefox && !device.ios)) {
    if (router.params.browserHistory && options.browserHistory) {
      if (options.replaceState) {
        const browserHistoryRoot = router.params.browserHistoryRoot || '';
        _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].replace(view.id, {
          url: options.route.url
        }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
      } else if (backIndex) {
        _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].go(-backIndex);
      } else {
        _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].back();
      }
    }
  } // Update History


  if (options.replaceState) {
    router.history[router.history.length - 1] = options.route.url;
  } else {
    if (router.history.length === 1) {
      router.history.unshift(router.url);
    }

    router.history.pop();
  }

  router.saveHistory(); // Current Page & Navbar

  router.currentPageEl = $newPage[0];

  if (dynamicNavbar && $newNavbarEl.length) {
    router.currentNavbarEl = $newNavbarEl[0];
  } else {
    delete router.currentNavbarEl;
  } // Current Route


  router.currentRoute = options.route; // History State

  if (device.ie || device.edge || device.firefox && !device.ios) {
    if (router.params.browserHistory && options.browserHistory) {
      if (options.replaceState) {
        const browserHistoryRoot = router.params.browserHistoryRoot || '';
        _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].replace(view.id, {
          url: options.route.url
        }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
      } else if (backIndex) {
        _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].go(-backIndex);
      } else {
        _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].back();
      }
    }
  } // Insert Page


  insertPage(); // Load Tab

  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, options, {
      history: false,
      browserHistory: false
    }));
  } // Check master detail


  if (masterDetailEnabled && (currentIsMaster || masterPageRemoved)) {
    view.checkMasterDetailBreakpoint(false);
  } // Page init and before init events


  router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage); // Before animation callback

  router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
  router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'previous', 'current', options); // Animation

  function afterAnimation() {
    // Set classes
    router.setPagePosition($newPage, 'current', false);
    router.setPagePosition($oldPage, 'next', true);

    if (dynamicNavbar) {
      router.setNavbarPosition($newNavbarEl, 'current', false);
      router.setNavbarPosition($oldNavbarEl, 'next', true);
    } // After animation event


    router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
    router.pageCallback('afterIn', $newPage, $newNavbarEl, 'previous', 'current', options); // Remove Old Page

    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass('stacked');
      $oldPage.trigger('page:stack');
      router.emit('pageStack', $oldPage[0]);

      if (dynamicNavbar) {
        $oldNavbarEl.addClass('stacked');
      }
    } else {
      router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'next', undefined, options);
      router.removePage($oldPage);

      if (dynamicNavbar && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }

    router.allowPageChange = true;
    router.emit('routeChanged', router.currentRoute, router.previousRoute, router); // Preload previous page

    const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`];

    if (preloadPreviousPage && router.history[router.history.length - 2] && !isMaster) {
      router.back(router.history[router.history.length - 2], {
        preload: true
      });
    }

    if (router.params.browserHistory) {
      _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].clearRouterQueue();
    }
  }

  function setPositionClasses() {
    router.setPagePosition($oldPage, 'current');
    router.setPagePosition($newPage, 'previous', false);

    if (dynamicNavbar) {
      router.setNavbarPosition($oldNavbarEl, 'current');
      router.setNavbarPosition($newNavbarEl, 'previous', false);
    }
  }

  if (options.animate && !(currentIsMaster && app.width >= router.params.masterDetailBreakpoint)) {
    let transition = router.params.transition;

    if ($oldPage[0] && $oldPage[0].f7PageTransition) {
      transition = $oldPage[0].f7PageTransition;
      delete $oldPage[0].f7PageTransition;
    }

    if (options.transition) transition = options.transition;

    if (!transition && router.previousRoute && router.previousRoute.route) {
      transition = router.previousRoute.route.transition;
    }

    if (!transition && router.previousRoute && router.previousRoute.route && router.previousRoute.route.options) {
      transition = router.previousRoute.route.options.transition;
    }

    setPositionClasses();
    router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'backward', transition, () => {
      afterAnimation();
    });
  } else {
    afterAnimation();
  }

  return router;
}

function loadBack(router, backParams, backOptions, ignorePageChange) {
  if (!router.allowPageChange && !ignorePageChange) return router;
  const params = backParams;
  const options = backOptions;
  const {
    url,
    content,
    el,
    pageName,
    component,
    componentUrl
  } = params;

  if (options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
    return false;
  }

  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
  } // Component Callbacks


  function resolve(pageEl, newOptions) {
    return backward(router, pageEl, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options, newOptions));
  }

  function reject() {
    router.allowPageChange = true;
    return router;
  }

  if (url || componentUrl || component) {
    router.allowPageChange = false;
  } // Proceed


  if (content) {
    backward(router, router.getPageEl(content), options);
  } else if (el) {
    // Load page from specified HTMLElement or by page name in pages container
    backward(router, router.getPageEl(el), options);
  } else if (pageName) {
    // Load page by page name in pages container
    backward(router, router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
  } else if (component || componentUrl) {
    // Load from component (F7/Vue/React/...)
    try {
      router.pageComponentLoader({
        routerEl: router.el,
        component,
        componentUrl,
        options,
        resolve,
        reject
      });
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    // Load using XHR
    if (router.xhrAbortController) {
      router.xhrAbortController.abort();
      router.xhrAbortController = false;
    }

    router.xhrRequest(url, options).then(pageContent => {
      backward(router, router.getPageEl(pageContent), options);
    }).catch(() => {
      router.allowPageChange = true;
    });
  }

  return router;
}

function back() {
  const router = this;
  const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
  if (router.swipeBackActive) return router;
  let navigateUrl;
  let navigateOptions;
  let route;

  if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object') {
    navigateOptions = (arguments.length <= 0 ? undefined : arguments[0]) || {};
  } else {
    navigateUrl = arguments.length <= 0 ? undefined : arguments[0];
    navigateOptions = (arguments.length <= 1 ? undefined : arguments[1]) || {};
  }

  const {
    name,
    params,
    query
  } = navigateOptions;

  if (name) {
    navigateUrl = router.generateUrl({
      name,
      params,
      query
    });

    if (navigateUrl) {
      return router.back(navigateUrl, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, navigateOptions, {
        name: null,
        params: null,
        query: null
      }));
    }

    return router;
  }

  const app = router.app;
  (0,_app_router_check_js__WEBPACK_IMPORTED_MODULE_5__["default"])(router, 'back');
  let currentRouteIsModal = router.currentRoute.modal;
  let modalType;

  if (!currentRouteIsModal) {
    'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(modalLoadProp => {
      if (router.currentRoute.route[modalLoadProp]) {
        currentRouteIsModal = true;
        modalType = modalLoadProp;
      }
    });
  }

  if (currentRouteIsModal && !navigateOptions.preload) {
    const modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app[modalType].get();
    const previousUrl = router.history[router.history.length - 2];
    let previousRoute; // check if previous route is modal too

    if (modalToClose && modalToClose.$el) {
      const prevOpenedModals = modalToClose.$el.prevAll('.modal-in');

      if (prevOpenedModals.length && prevOpenedModals[0].f7Modal) {
        const modalEl = prevOpenedModals[0]; // check if current router not inside of the modalEl

        if (!router.$el.parents(modalEl).length) {
          previousRoute = modalEl.f7Modal.route;
        }
      }
    }

    if (!previousRoute) {
      previousRoute = router.findMatchingRoute(previousUrl);
    }

    if (!previousRoute && previousUrl) {
      previousRoute = {
        url: previousUrl,
        path: previousUrl.split('?')[0],
        query: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.parseUrlQuery)(previousUrl),
        route: {
          path: previousUrl.split('?')[0],
          url: previousUrl
        }
      };
    }

    if (!navigateUrl || navigateUrl.replace(/[# ]/g, '').trim().length === 0) {
      if (!previousRoute || !modalToClose) {
        return router;
      }
    }

    const forceOtherUrl = navigateOptions.force && previousRoute && navigateUrl;

    if (previousRoute && modalToClose) {
      const isBrokenBrowserHistory = device.ie || device.edge || device.firefox && !device.ios;
      const needHistoryBack = router.params.browserHistory && navigateOptions.browserHistory !== false;
      const currentRouteWithoutBrowserHistory = router.currentRoute && router.currentRoute.route && router.currentRoute.route.options && router.currentRoute.route.options.browserHistory === false;

      if (needHistoryBack && !isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
        _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].back();
      }

      router.currentRoute = previousRoute;
      router.history.pop();
      router.saveHistory();

      if (needHistoryBack && isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
        _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].back();
      }

      router.modalRemove(modalToClose);

      if (forceOtherUrl) {
        router.navigate(navigateUrl, {
          reloadCurrent: true
        });
      }
    } else if (modalToClose) {
      router.modalRemove(modalToClose);

      if (navigateUrl) {
        router.navigate(navigateUrl, {
          reloadCurrent: true
        });
      }
    }

    return router;
  }

  let $previousPage = router.$el.children('.page-current').prevAll('.page-previous:not(.page-master)').eq(0);
  let skipMaster;

  if (router.params.masterDetailBreakpoint > 0) {
    const classes = [];
    router.$el.children('.page').each(pageEl => {
      classes.push(pageEl.className);
    });
    const $previousMaster = router.$el.children('.page-current').prevAll('.page-master').eq(0);

    if ($previousMaster.length) {
      const expectedPreviousPageUrl = router.history[router.history.length - 2];
      const expectedPreviousPageRoute = router.findMatchingRoute(expectedPreviousPageUrl);

      if (expectedPreviousPageRoute && $previousMaster[0].f7Page && expectedPreviousPageRoute.route === $previousMaster[0].f7Page.route.route) {
        $previousPage = $previousMaster;

        if (!navigateOptions.preload) {
          skipMaster = app.width >= router.params.masterDetailBreakpoint;
        }
      }
    }
  }

  if (!navigateOptions.force && $previousPage.length && !skipMaster) {
    if (router.params.browserHistory && $previousPage[0].f7Page && router.history[router.history.length - 2] !== $previousPage[0].f7Page.route.url) {
      router.back(router.history[router.history.length - 2], (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(navigateOptions, {
        force: true
      }));
      return router;
    }

    const previousPageRoute = $previousPage[0].f7Page.route;

    if (navigateOptions.preload && $previousPage.hasClass('stacked')) {
      loadBack(router, {
        el: $previousPage
      }, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(navigateOptions, {
        route: previousPageRoute
      }));
      return router;
    }

    _process_route_queue_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(router, previousPageRoute, router.currentRoute, () => {
      loadBack(router, {
        el: $previousPage
      }, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(navigateOptions, {
        route: previousPageRoute
      }));
    }, () => {}, 'backward');
    return router;
  } // Navigate URL


  if (navigateUrl === '#') {
    navigateUrl = undefined;
  }

  if (navigateUrl && navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
    navigateUrl = ((router.path || '/') + navigateUrl).replace('//', '/');
  }

  if (!navigateUrl && router.history.length > 1) {
    navigateUrl = router.history[router.history.length - 2];
  }

  if (skipMaster && !navigateOptions.force && router.history[router.history.length - 3]) {
    return router.back(router.history[router.history.length - 3], (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, navigateOptions || {}, {
      force: true,
      animate: false
    }));
  }

  if (skipMaster && !navigateOptions.force) {
    return router;
  } // Find route to load


  route = router.findMatchingRoute(navigateUrl);

  if (!route) {
    if (navigateUrl) {
      route = {
        url: navigateUrl,
        path: navigateUrl.split('?')[0],
        query: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.parseUrlQuery)(navigateUrl),
        route: {
          path: navigateUrl.split('?')[0],
          url: navigateUrl
        }
      };
    }
  }

  if (!route) {
    return router;
  }

  if (route.route.redirect) {
    return _redirect_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(router, 'backward', route, navigateOptions);
  }

  const options = {};

  if (route.route.options) {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options, route.route.options, navigateOptions);
  } else {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options, navigateOptions);
  }

  options.route = route;
  let backForceLoaded;

  if (options.force && router.params.stackPages) {
    router.$el.children('.page-previous.stacked').each(pageEl => {
      if (pageEl.f7Page && pageEl.f7Page.route && pageEl.f7Page.route.url === route.url) {
        backForceLoaded = true;
        loadBack(router, {
          el: pageEl
        }, options);
      }
    });

    if (backForceLoaded) {
      return router;
    }
  }

  function resolve() {
    let routerLoaded = false;

    if (route.route.keepAlive && route.route.keepAliveData) {
      loadBack(router, {
        el: route.route.keepAliveData.pageEl
      }, options);
      routerLoaded = true;
    }

    'url content component pageName el componentUrl'.split(' ').forEach(pageLoadProp => {
      if (route.route[pageLoadProp] && !routerLoaded) {
        routerLoaded = true;
        loadBack(router, {
          [pageLoadProp]: route.route[pageLoadProp]
        }, options);
      }
    });
    if (routerLoaded) return; // Async

    function asyncResolve(resolveParams, resolveOptions) {
      router.allowPageChange = false;
      loadBack(router, resolveParams, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options, resolveOptions), true);
    }

    function asyncReject() {
      router.allowPageChange = true;
    }

    if (route.route.async) {
      router.allowPageChange = false;
      route.route.async.call(router, {
        router,
        to: route,
        from: router.currentRoute,
        resolve: asyncResolve,
        reject: asyncReject,
        direction: 'backward',
        app
      });
    }

    if (route.route.asyncComponent) {
      (0,_async_component_js__WEBPACK_IMPORTED_MODULE_8__["default"])(router, route.route.asyncComponent, asyncResolve, asyncReject);
    }
  }

  function reject() {
    router.allowPageChange = true;
  }

  if (options.preload) {
    resolve();
  } else {
    _process_route_queue_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(router, route, router.currentRoute, () => {
      if (route.route.modules) {
        app.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(() => {
          resolve();
        }).catch(() => {
          reject();
        });
      } else {
        resolve();
      }
    }, () => {
      reject();
    }, 'backward');
  } // Return Router


  return router;
}



/***/ }),

/***/ "./node_modules/framework7/modules/router/clear-previous-history.js":
/*!**************************************************************************!*\
  !*** ./node_modules/framework7/modules/router/clear-previous-history.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearPreviousHistory": () => (/* binding */ clearPreviousHistory)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _app_router_check_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app-router-check.js */ "./node_modules/framework7/modules/router/app-router-check.js");



function clearPreviousPages(router) {
  (0,_app_router_check_js__WEBPACK_IMPORTED_MODULE_1__["default"])(router, 'clearPreviousPages');
  const app = router.app;
  const dynamicNavbar = router.dynamicNavbar;
  const $pagesToRemove = router.$el.children('.page').filter(pageInView => {
    if (router.currentRoute && (router.currentRoute.modal || router.currentRoute.panel)) return true;
    return pageInView !== router.currentPageEl;
  });
  $pagesToRemove.each(pageEl => {
    const $oldPageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(pageEl);
    const $oldNavbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(app.navbar.getElByPage($oldPageEl));

    if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
      $oldPageEl.addClass('stacked');

      if (dynamicNavbar) {
        $oldNavbarEl.addClass('stacked');
      }
    } else {
      // Page remove event
      router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl, 'previous', undefined, {});
      router.removePage($oldPageEl);

      if (dynamicNavbar && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
  });
}

function clearPreviousHistory() {
  const router = this;
  (0,_app_router_check_js__WEBPACK_IMPORTED_MODULE_1__["default"])(router, 'clearPreviousHistory');
  const url = router.history[router.history.length - 1];
  clearPreviousPages(router);
  router.history = [url];
  router.view.history = [url];
  router.saveHistory();
}

 // eslint-disable-line

/***/ }),

/***/ "./node_modules/framework7/modules/router/modal.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/modules/router/modal.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "modalLoad": () => (/* binding */ modalLoad),
/* harmony export */   "modalRemove": () => (/* binding */ modalRemove)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_history_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/history.js */ "./node_modules/framework7/shared/history.js");
/* harmony import */ var _async_component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./async-component.js */ "./node_modules/framework7/modules/router/async-component.js");




function modalLoad(modalType, route, loadOptions, direction) {
  if (loadOptions === void 0) {
    loadOptions = {};
  }

  const router = this;
  const app = router.app;
  const isPanel = modalType === 'panel';
  const modalOrPanel = isPanel ? 'panel' : 'modal';
  const options = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)({
    animate: router.params.animate,
    browserHistory: true,
    history: true,
    on: {},
    once: {}
  }, loadOptions);
  const modalParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, route.route[modalType]);
  const modalRoute = route.route;

  const routeCallback = (modal, name) => {
    const {
      on,
      once
    } = options;
    let callback;

    if (name === 'open') {
      callback = on.modalOpen || once.modalOpen || on.panelOpen || once.panelOpen;
    }

    if (name === 'close') {
      callback = on.modalClose || once.modalClose || on.panelClose || once.panelClose;
    }

    if (name === 'closed') {
      callback = on.modalClosed || once.modalClosed || on.panelClosed || once.panelClosed;
    }

    if (callback) callback(modal);
  };

  function onModalLoaded() {
    // Create Modal
    const modal = app[modalType].create(modalParams);
    modalRoute.modalInstance = modal;
    const hasEl = modal.el;

    function closeOnSwipeBack() {
      modal.close();
    }

    modal.on(`${modalOrPanel}Open`, () => {
      if (!hasEl) {
        // Remove theme elements
        router.removeThemeElements(modal.el); // Emit events

        modal.$el.trigger(`${modalType.toLowerCase()}:init ${modalType.toLowerCase()}:mounted`, route, modal);
        router.emit(`${!isPanel ? 'modalInit' : ''} ${modalType}Init ${modalType}Mounted`, modal.el, route, modal);
      }

      router.once('swipeBackMove', closeOnSwipeBack);
      routeCallback(modal, 'open');
    });
    modal.on(`${modalOrPanel}Close`, () => {
      router.off('swipeBackMove', closeOnSwipeBack);

      if (!modal.closeByRouter) {
        router.back();
      }

      routeCallback(modal, 'close');
    });
    modal.on(`${modalOrPanel}Closed`, () => {
      modal.$el.trigger(`${modalType.toLowerCase()}:beforeremove`, route, modal);
      modal.emit(`${!isPanel ? 'modalBeforeRemove ' : ''}${modalType}BeforeRemove`, modal.el, route, modal);
      const modalComponent = modal.el.f7Component;
      routeCallback(modal, 'closed');

      if (modalComponent) {
        modalComponent.destroy();
      }

      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
        if (modalComponent || modalParams.component || modalParams.asyncComponent) {
          router.removeModal(modal.el);
        }

        modal.destroy();
        delete modal.route;
        delete modalRoute.modalInstance;
      });
    });

    if (options.route) {
      // Update Browser History
      if (router.params.browserHistory && options.browserHistory) {
        _shared_history_js__WEBPACK_IMPORTED_MODULE_1__["default"].push(router.view.id, {
          url: options.route.url,
          modal: modalType
        }, (router.params.browserHistoryRoot || '') + router.params.browserHistorySeparator + options.route.url);
      } // Set Route


      if (options.route !== router.currentRoute) {
        modal.route = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(options.route, {
          modal
        });
        router.currentRoute = modal.route;
      } // Update Router History


      if (options.history && !options.reloadCurrent) {
        router.history.push(options.route.url);
        router.saveHistory();
      }
    }

    if (hasEl) {
      // Remove theme elements
      router.removeThemeElements(modal.el); // Emit events

      modal.$el.trigger(`${modalType.toLowerCase()}:init ${modalType.toLowerCase()}:mounted`, route, modal);
      router.emit(`${modalOrPanel}Init ${modalType}Init ${modalType}Mounted`, modal.el, route, modal);
    } // Open


    modal.open(options.animate === false || options.animate === true ? options.animate : undefined);
  } // Load Modal Content


  function loadModal(loadModalParams, loadModalOptions) {
    // Load Modal Props
    const {
      url,
      content,
      component,
      componentUrl
    } = loadModalParams; // Component/Template Callbacks

    function resolve(contentEl) {
      if (contentEl) {
        if (typeof contentEl === 'string') {
          modalParams.content = contentEl;
        } else if (contentEl.f7Component) {
          contentEl.f7Component.mount(componentEl => {
            modalParams.el = componentEl;
            app.$el.append(componentEl);
          });
        } else {
          modalParams.el = contentEl;
        }

        onModalLoaded();
      }
    }

    function reject() {
      router.allowPageChange = true;
      return router;
    }

    if (content) {
      resolve(content);
    } else if (component || componentUrl) {
      // Load from component (F7/Vue/React/...)
      try {
        router.modalComponentLoader({
          rootEl: app.el,
          component,
          componentUrl,
          options: loadModalOptions,
          resolve,
          reject
        });
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      // Load using XHR
      if (router.xhrAbortController) {
        router.xhrAbortController.abort();
        router.xhrAbortController = false;
      }

      router.xhrRequest(url, loadModalOptions).then(modalContent => {
        modalParams.content = modalContent;
        onModalLoaded();
      }).catch(() => {
        router.allowPageChange = true;
      });
    } else {
      onModalLoaded();
    }
  }

  let foundLoadProp;
  'url content component el componentUrl template'.split(' ').forEach(modalLoadProp => {
    if (modalParams[modalLoadProp] && !foundLoadProp) {
      foundLoadProp = true;
      loadModal({
        [modalLoadProp]: modalParams[modalLoadProp]
      }, options);
    }
  });

  if (!foundLoadProp && modalType === 'actions') {
    onModalLoaded();
  } // Async


  function asyncResolve(resolveParams, resolveOptions) {
    loadModal(resolveParams, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(options, resolveOptions));
  }

  function asyncReject() {
    router.allowPageChange = true;
  }

  if (modalParams.async) {
    modalParams.async.call(router, {
      router,
      to: options.route,
      from: router.currentRoute,
      resolve: asyncResolve,
      reject: asyncReject,
      direction,
      app
    });
  }

  if (modalParams.asyncComponent) {
    (0,_async_component_js__WEBPACK_IMPORTED_MODULE_2__["default"])(router, modalParams.asyncComponent, asyncResolve, asyncReject);
  }

  return router;
}

function modalRemove(modal) {
  (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(modal, {
    closeByRouter: true
  });
  modal.close();
}



/***/ }),

/***/ "./node_modules/framework7/modules/router/navigate.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7/modules/router/navigate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "navigate": () => (/* binding */ navigate),
/* harmony export */   "refreshPage": () => (/* binding */ refreshPage)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_history_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/history.js */ "./node_modules/framework7/shared/history.js");
/* harmony import */ var _redirect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./redirect.js */ "./node_modules/framework7/modules/router/redirect.js");
/* harmony import */ var _process_route_queue_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./process-route-queue.js */ "./node_modules/framework7/modules/router/process-route-queue.js");
/* harmony import */ var _app_router_check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app-router-check.js */ "./node_modules/framework7/modules/router/app-router-check.js");
/* harmony import */ var _async_component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./async-component.js */ "./node_modules/framework7/modules/router/async-component.js");









function refreshPage() {
  const router = this;
  (0,_app_router_check_js__WEBPACK_IMPORTED_MODULE_2__["default"])(router, 'refreshPage');
  return router.navigate(router.currentRoute.url, {
    ignoreCache: true,
    reloadCurrent: true
  });
}

function forward(router, el, forwardOptions) {
  if (forwardOptions === void 0) {
    forwardOptions = {};
  }

  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
  const app = router.app;
  const view = router.view;
  const options = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(false, {
    animate: router.params.animate,
    browserHistory: true,
    replaceState: false,
    history: true,
    reloadCurrent: router.params.reloadPages,
    reloadPrevious: false,
    reloadAll: false,
    clearPreviousHistory: false,
    reloadDetail: router.params.reloadDetail,
    on: {}
  }, forwardOptions);
  const masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
  const isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === 'function' && options.route.route.master(app, router));
  let masterPageEl;
  let otherDetailPageEl;
  let detailsInBetweenRemoved = 0;
  let currentRouteIsModal = router.currentRoute.modal;
  let modalType;

  if (!currentRouteIsModal) {
    'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(modalLoadProp => {
      if (router.currentRoute && router.currentRoute.route && router.currentRoute.route[modalLoadProp]) {
        currentRouteIsModal = true;
        modalType = modalLoadProp;
      }
    });
  }

  if (currentRouteIsModal) {
    const modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app[modalType].get();
    const previousUrl = router.history[router.history.length - 2];
    let previousRoute = router.findMatchingRoute(previousUrl);

    if (!previousRoute && previousUrl) {
      previousRoute = {
        url: previousUrl,
        path: previousUrl.split('?')[0],
        query: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.parseUrlQuery)(previousUrl),
        route: {
          path: previousUrl.split('?')[0],
          url: previousUrl
        }
      };
    }

    router.modalRemove(modalToClose);
  }

  const dynamicNavbar = router.dynamicNavbar;
  const $viewEl = router.$el;
  const $newPage = $el;
  const reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
  let $oldPage;
  let $navbarsEl;
  let $newNavbarEl;
  let $oldNavbarEl;
  router.allowPageChange = false;

  if ($newPage.length === 0) {
    router.allowPageChange = true;
    return router;
  }

  if ($newPage.length) {
    // Remove theme elements
    router.removeThemeElements($newPage);
  }

  if (dynamicNavbar) {
    $newNavbarEl = $newPage.children('.navbar');
    $navbarsEl = router.$navbarsEl;

    if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
      // Try from pageData
      $newNavbarEl = $newPage[0].f7Page.$navbarEl;
    }
  } // Save Keep Alive Cache


  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
    options.route.route.keepAliveData = {
      pageEl: $el[0]
    };
  } // Pages In View


  const $pagesInView = $viewEl.children('.page:not(.stacked)').filter(pageInView => pageInView !== $newPage[0]); // Navbars In View

  let $navbarsInView;

  if (dynamicNavbar) {
    $navbarsInView = $navbarsEl.children('.navbar:not(.stacked)').filter(navbarInView => navbarInView !== $newNavbarEl[0]);
  } // Exit when reload previous and only 1 page in view so nothing ro reload


  if (options.reloadPrevious && $pagesInView.length < 2) {
    router.allowPageChange = true;
    return router;
  } // Find Detail' master page


  let isDetail;
  let reloadDetail;
  let isDetailRoot;

  if (masterDetailEnabled && !options.reloadAll) {
    for (let i = 0; i < $pagesInView.length; i += 1) {
      if (!masterPageEl && $pagesInView[i].classList.contains('page-master')) {
        masterPageEl = $pagesInView[i];
        continue; // eslint-disable-line
      }
    }

    isDetail = !isMaster && masterPageEl;

    if (isDetail) {
      // Find Other Detail
      if (masterPageEl) {
        for (let i = 0; i < $pagesInView.length; i += 1) {
          if ($pagesInView[i].classList.contains('page-master-detail')) {
            otherDetailPageEl = $pagesInView[i];
            continue; // eslint-disable-line
          }
        }
      }
    }

    reloadDetail = isDetail && options.reloadDetail && app.width >= router.params.masterDetailBreakpoint && masterPageEl;
  }

  if (isDetail) {
    isDetailRoot = !otherDetailPageEl || reloadDetail || options.reloadAll || options.reloadCurrent;
  } // New Page


  let newPagePosition = 'next';

  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
    newPagePosition = 'current';
  } else if (options.reloadPrevious) {
    newPagePosition = 'previous';
  }

  $newPage.removeClass('page-previous page-current page-next').addClass(`page-${newPagePosition}${isMaster ? ' page-master' : ''}${isDetail ? ' page-master-detail' : ''}${isDetailRoot ? ' page-master-detail-root' : ''}`).removeClass('stacked').trigger('page:unstack').trigger('page:position', {
    position: newPagePosition
  });
  router.emit('pageUnstack', $newPage[0]);
  router.emit('pagePosition', $newPage[0], newPagePosition);

  if (isMaster || isDetail) {
    $newPage.trigger('page:role', {
      role: isMaster ? 'master' : 'detail',
      root: !!isDetailRoot
    });
    router.emit('pageRole', $newPage[0], {
      role: isMaster ? 'master' : 'detail',
      detailRoot: !!isDetailRoot
    });
  }

  if (dynamicNavbar && $newNavbarEl.length) {
    $newNavbarEl.removeClass('navbar-previous navbar-current navbar-next').addClass(`navbar-${newPagePosition}${isMaster ? ' navbar-master' : ''}${isDetail ? ' navbar-master-detail' : ''}${isDetailRoot ? ' navbar-master-detail-root' : ''}`).removeClass('stacked');
    $newNavbarEl.trigger('navbar:position', {
      position: newPagePosition
    });
    router.emit('navbarPosition', $newNavbarEl[0], newPagePosition);

    if (isMaster || isDetail) {
      router.emit('navbarRole', $newNavbarEl[0], {
        role: isMaster ? 'master' : 'detail',
        detailRoot: !!isDetailRoot
      });
    }
  } // Find Old Page


  if (options.reloadCurrent || reloadDetail) {
    if (reloadDetail) {
      $oldPage = $pagesInView.filter(pageEl => !pageEl.classList.contains('page-master'));

      if (dynamicNavbar) {
        $oldNavbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])($oldPage.map(pageEl => app.navbar.getElByPage(pageEl)));
      }

      if ($oldPage.length > 1 && masterPageEl) {
        detailsInBetweenRemoved = $oldPage.length - 1;
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(masterPageEl).removeClass('page-master-stacked').trigger('page:masterunstack');
        router.emit('pageMasterUnstack', masterPageEl);

        if (dynamicNavbar) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getElByPage(masterPageEl)).removeClass('navbar-master-stacked');
          router.emit('navbarMasterUnstack', app.navbar.getElByPage(masterPageEl));
        }
      }
    } else {
      $oldPage = $pagesInView.eq($pagesInView.length - 1);

      if (dynamicNavbar) {
        $oldNavbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getElByPage($oldPage));
      }
    }
  } else if (options.reloadPrevious) {
    $oldPage = $pagesInView.eq($pagesInView.length - 2);

    if (dynamicNavbar) {
      // $oldNavbarEl = $navbarsInView.eq($pagesInView.length - 2);
      $oldNavbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getElByPage($oldPage));
    }
  } else if (options.reloadAll) {
    $oldPage = $pagesInView.filter(pageEl => pageEl !== $newPage[0]);

    if (dynamicNavbar) {
      $oldNavbarEl = $navbarsInView.filter(navbarEl => navbarEl !== $newNavbarEl[0]);
    }
  } else {
    let removedPageEls = [];
    let removedNavbarEls = [];

    if ($pagesInView.length > 1) {
      let i = 0;

      for (i = 0; i < $pagesInView.length - 1; i += 1) {
        if (masterPageEl && $pagesInView[i] === masterPageEl) {
          $pagesInView.eq(i).addClass('page-master-stacked');
          $pagesInView.eq(i).trigger('page:masterstack');
          router.emit('pageMasterStack', $pagesInView[i]);

          if (dynamicNavbar) {
            (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getElByPage(masterPageEl)).addClass('navbar-master-stacked');
            router.emit('navbarMasterStack', app.navbar.getElByPage(masterPageEl));
          }

          continue; // eslint-disable-line
        }

        const oldNavbarEl = app.navbar.getElByPage($pagesInView.eq(i));

        if (router.params.stackPages) {
          $pagesInView.eq(i).addClass('stacked');
          $pagesInView.eq(i).trigger('page:stack');
          router.emit('pageStack', $pagesInView[i]);

          if (dynamicNavbar) {
            (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(oldNavbarEl).addClass('stacked');
          }
        } else {
          // Page remove event
          removedPageEls.push($pagesInView[i]);
          router.pageCallback('beforeRemove', $pagesInView[i], $navbarsInView && $navbarsInView[i], 'previous', undefined, options);
          router.removePage($pagesInView[i]);

          if (dynamicNavbar && oldNavbarEl) {
            removedNavbarEls.push(oldNavbarEl);
            router.removeNavbar(oldNavbarEl);
          }
        }
      }
    }

    $oldPage = $viewEl.children('.page:not(.stacked)').filter(pageEl => pageEl !== $newPage[0] && removedPageEls.indexOf(pageEl) < 0);

    if (dynamicNavbar) {
      $oldNavbarEl = $navbarsEl.children('.navbar:not(.stacked)').filter(navbarEl => navbarEl !== $newNavbarEl[0] && removedNavbarEls.indexOf(removedNavbarEls) < 0);
    }

    removedPageEls = [];
    removedNavbarEls = [];
  }

  if (isDetail && !options.reloadAll) {
    if ($oldPage.length > 1 || reloadDetail) {
      $oldPage = $oldPage.filter(pageEl => !pageEl.classList.contains('page-master'));
    }

    if ($oldNavbarEl && ($oldNavbarEl.length > 1 || reloadDetail)) {
      $oldNavbarEl = $oldNavbarEl.filter(navbarEl => !navbarEl.classList.contains('navbar-master'));
    }
  } // Push State


  if (router.params.browserHistory && (options.browserHistory || options.replaceState) && !options.reloadPrevious) {
    const browserHistoryRoot = router.params.browserHistoryRoot || '';
    _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"][options.reloadCurrent || reloadDetail && otherDetailPageEl || options.reloadAll || options.replaceState ? 'replace' : 'push'](view.id, {
      url: options.route.url
    }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
  }

  if (!options.reloadPrevious) {
    // Current Page & Navbar
    router.currentPageEl = $newPage[0];

    if (dynamicNavbar && $newNavbarEl.length) {
      router.currentNavbarEl = $newNavbarEl[0];
    } else {
      delete router.currentNavbarEl;
    } // Current Route


    router.currentRoute = options.route;
  } // Update router history


  const url = options.route.url;

  if (options.history) {
    if (((options.reloadCurrent || reloadDetail && otherDetailPageEl) && router.history.length) > 0 || options.replaceState) {
      if (reloadDetail && detailsInBetweenRemoved > 0) {
        router.history = router.history.slice(0, router.history.length - detailsInBetweenRemoved);
      }

      router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
    } else if (options.reloadPrevious) {
      router.history[router.history.length - 2] = url;
    } else if (options.reloadAll) {
      router.history = [url];
    } else {
      router.history.push(url);
    }
  }

  router.saveHistory(); // Insert new page and navbar

  const newPageInDom = $newPage.parents(document).length > 0;
  const f7Component = $newPage[0].f7Component;

  if (options.reloadPrevious) {
    if (f7Component && !newPageInDom) {
      f7Component.mount(componentEl => {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(componentEl).insertBefore($oldPage);
      });
    } else {
      $newPage.insertBefore($oldPage);
    }

    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find('.title-large').length) {
        $newNavbarEl.addClass('navbar-large');
      }

      if ($oldNavbarEl.length) {
        $newNavbarEl.insertBefore($oldNavbarEl);
      } else {
        if (!router.$navbarsEl.parents(document).length) {
          router.$el.prepend(router.$navbarsEl);
        }

        $navbarsEl.append($newNavbarEl);
      }
    }
  } else {
    if ($oldPage.next('.page')[0] !== $newPage[0]) {
      if (f7Component && !newPageInDom) {
        f7Component.mount(componentEl => {
          $viewEl.append(componentEl);
        });
      } else {
        $viewEl.append($newPage[0]);
      }
    }

    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find('.title-large').length) {
        $newNavbarEl.addClass('navbar-large');
      }

      if (!router.$navbarsEl.parents(document).length) {
        router.$el.prepend(router.$navbarsEl);
      }

      $navbarsEl.append($newNavbarEl[0]);
    }
  }

  if (!newPageInDom) {
    router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
  } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
    $newPage[0].f7PageMounted = true;
    router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
  } // Remove old page


  if ((options.reloadCurrent || reloadDetail) && $oldPage.length > 0) {
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass('stacked');
      $oldPage.trigger('page:stack');
      router.emit('pageStack', $oldPage[0]);

      if (dynamicNavbar) {
        $oldNavbarEl.addClass('stacked');
      }
    } else {
      // Page remove event
      router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
      router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
      router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'current', undefined, options);
      router.removePage($oldPage);

      if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
  } else if (options.reloadAll) {
    $oldPage.each((pageEl, index) => {
      const $oldPageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageEl);
      const $oldNavbarElEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(app.navbar.getElByPage($oldPageEl));

      if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
        $oldPageEl.addClass('stacked');
        $oldPageEl.trigger('page:stack');
        router.emit('pageStack', $oldPageEl[0]);

        if (dynamicNavbar) {
          $oldNavbarElEl.addClass('stacked');
        }
      } else {
        // Page remove event
        if ($oldPageEl.hasClass('page-current')) {
          router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
          router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
        }

        router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl && $oldNavbarEl.eq(index), 'previous', undefined, options);
        router.removePage($oldPageEl);

        if (dynamicNavbar && $oldNavbarElEl.length) {
          router.removeNavbar($oldNavbarElEl);
        }
      }
    });
  } else if (options.reloadPrevious) {
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass('stacked');
      $oldPage.trigger('page:stack');
      router.emit('pageStack', $oldPage[0]);

      if (dynamicNavbar) {
        $oldNavbarEl.addClass('stacked');
      }
    } else {
      // Page remove event
      router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
      router.removePage($oldPage);

      if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
  } // Load Tab


  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, options, {
      history: false,
      browserHistory: false
    }));
  } // Check master detail


  if (masterDetailEnabled) {
    view.checkMasterDetailBreakpoint();
  } // Page init and before init events


  router.pageCallback('init', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);

  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
    router.allowPageChange = true;
    router.pageCallback('beforeIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
    $newPage.removeAttr('aria-hidden');

    if (dynamicNavbar && $newNavbarEl) {
      $newNavbarEl.removeAttr('aria-hidden');
    }

    router.pageCallback('afterIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
    if (options.reloadCurrent && options.clearPreviousHistory) router.clearPreviousHistory();

    if (reloadDetail) {
      router.setPagePosition((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(masterPageEl), 'previous');

      if (masterPageEl.f7Page && masterPageEl.f7Page.navbarEl) {
        router.setNavbarPosition((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(masterPageEl.f7Page.navbarEl), 'previous');
      }
    }

    return router;
  }

  if (options.reloadPrevious) {
    router.allowPageChange = true;
    return router;
  } // Before animation event


  router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
  router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'next', 'current', options); // Animation

  function afterAnimation() {
    router.setPagePosition($newPage, 'current', false);
    router.setPagePosition($oldPage, 'previous', !$oldPage.hasClass('page-master'));

    if (dynamicNavbar) {
      router.setNavbarPosition($newNavbarEl, 'current', false);
      router.setNavbarPosition($oldNavbarEl, 'previous', !$oldNavbarEl.hasClass('navbar-master'));
    } // After animation event


    router.allowPageChange = true;
    router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
    router.pageCallback('afterIn', $newPage, $newNavbarEl, 'next', 'current', options);
    let keepOldPage = (router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`]) && !isMaster;

    if (!keepOldPage) {
      if ($newPage.hasClass('smart-select-page') || $newPage.hasClass('photo-browser-page') || $newPage.hasClass('autocomplete-page') || $newPage.hasClass('color-picker-page')) {
        keepOldPage = true;
      }
    }

    if (!keepOldPage) {
      if (router.params.stackPages) {
        $oldPage.addClass('stacked');
        $oldPage.trigger('page:stack');
        router.emit('pageStack', $oldPage[0]);

        if (dynamicNavbar) {
          $oldNavbarEl.addClass('stacked');
        }
      } else if (!($newPage.attr('data-name') && $newPage.attr('data-name') === 'smart-select-page')) {
        // Remove event
        router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
        router.removePage($oldPage);

        if (dynamicNavbar && $oldNavbarEl.length) {
          router.removeNavbar($oldNavbarEl);
        }
      }
    }

    if (options.clearPreviousHistory) router.clearPreviousHistory();
    router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

    if (router.params.browserHistory) {
      _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].clearRouterQueue();
    }
  }

  function setPositionClasses() {
    router.setPagePosition($oldPage, 'current', false);
    router.setPagePosition($newPage, 'next', false);

    if (dynamicNavbar) {
      router.setNavbarPosition($oldNavbarEl, 'current', false);
      router.setNavbarPosition($newNavbarEl, 'next', false);
    }
  }

  if (options.animate && !(isMaster && app.width >= router.params.masterDetailBreakpoint)) {
    const delay = router.params[`${router.app.theme}PageLoadDelay`];
    let transition = router.params.transition;
    if (options.transition) transition = options.transition;

    if (!transition && router.currentRoute && router.currentRoute.route) {
      transition = router.currentRoute.route.transition;
    }

    if (!transition && router.currentRoute && router.currentRoute.route.options) {
      transition = router.currentRoute.route.options.transition;
    }

    if (transition) {
      $newPage[0].f7PageTransition = transition;
    }

    if (delay) {
      setTimeout(() => {
        setPositionClasses();
        router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, () => {
          afterAnimation();
        });
      }, delay);
    } else {
      setPositionClasses();
      router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, () => {
        afterAnimation();
      });
    }
  } else {
    afterAnimation();
  }

  return router;
}

function load(router, loadParams, loadOptions, ignorePageChange) {
  if (loadParams === void 0) {
    loadParams = {};
  }

  if (loadOptions === void 0) {
    loadOptions = {};
  }

  if (!router.allowPageChange && !ignorePageChange) return router;
  const params = loadParams;
  const options = loadOptions;
  const {
    url,
    content,
    el,
    pageName,
    component,
    componentUrl
  } = params;

  if (!options.reloadCurrent && options.route && options.route.route && options.route.route.parentPath && router.currentRoute.route && router.currentRoute.route.parentPath === options.route.route.parentPath) {
    // Do something nested
    if (options.route.url === router.url) {
      router.allowPageChange = true;
      return false;
    } // Check for same params


    let sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;

    if (sameParams) {
      // Check for equal params name
      Object.keys(options.route.params).forEach(paramName => {
        if (!(paramName in router.currentRoute.params) || router.currentRoute.params[paramName] !== options.route.params[paramName]) {
          sameParams = false;
        }
      });
    }

    if (sameParams) {
      if (options.route.route.tab) {
        return router.tabLoad(options.route.route.tab, options);
      }

      return false;
    }

    if (!sameParams && options.route.route.tab && router.currentRoute.route.tab && router.currentRoute.parentPath === options.route.parentPath) {
      return router.tabLoad(options.route.route.tab, options);
    }
  }

  if (options.route && options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
    router.allowPageChange = true;
    return false;
  }

  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options.route, {
      route: {
        url,
        path: url
      }
    });
  } // Component Callbacks


  function resolve(pageEl, newOptions) {
    return forward(router, pageEl, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options, newOptions));
  }

  function reject() {
    router.allowPageChange = true;
    return router;
  }

  if (url || componentUrl || component) {
    router.allowPageChange = false;
  } // Proceed


  if (content) {
    forward(router, router.getPageEl(content), options);
  } else if (el) {
    // Load page from specified HTMLElement or by page name in pages container
    forward(router, router.getPageEl(el), options);
  } else if (pageName) {
    // Load page by page name in pages container
    forward(router, router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
  } else if (component || componentUrl) {
    // Load from component (F7/Vue/React/...)
    try {
      router.pageComponentLoader({
        routerEl: router.el,
        component,
        componentUrl,
        options,
        resolve,
        reject
      });
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    // Load using XHR
    if (router.xhrAbortController) {
      router.xhrAbortController.abort();
      router.xhrAbortController = false;
    }

    router.xhrRequest(url, options).then(pageContent => {
      forward(router, router.getPageEl(pageContent), options);
    }).catch(() => {
      router.allowPageChange = true;
    });
  }

  return router;
}

function navigate(navigateParams, navigateOptions) {
  if (navigateOptions === void 0) {
    navigateOptions = {};
  }

  const router = this;
  if (router.swipeBackActive) return router;
  let url;
  let createRoute;
  let name;
  let path;
  let query;
  let params;
  let route;

  if (typeof navigateParams === 'string') {
    url = navigateParams;
  } else {
    url = navigateParams.url;
    createRoute = navigateParams.route;
    name = navigateParams.name;
    path = navigateParams.path;
    query = navigateParams.query;
    params = navigateParams.params;
  }

  if (name || path) {
    url = router.generateUrl({
      path,
      name,
      params,
      query
    });

    if (url) {
      return router.navigate(url, navigateOptions);
    }

    return router;
  }

  const app = router.app;
  (0,_app_router_check_js__WEBPACK_IMPORTED_MODULE_2__["default"])(router, 'navigate');

  if (url === '#' || url === '') {
    return router;
  }

  let navigateUrl = url.replace('./', '');

  if (navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
    const currentPath = router.currentRoute.parentPath || router.currentRoute.path;
    navigateUrl = ((currentPath ? `${currentPath}/` : '/') + navigateUrl).replace('///', '/').replace('//', '/');
  }

  if (createRoute) {
    route = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(router.parseRouteUrl(navigateUrl), {
      route: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, createRoute)
    });
  } else {
    route = router.findMatchingRoute(navigateUrl);
  }

  if (!route) {
    return router;
  }

  if (route.route && route.route.viewName) {
    const anotherViewName = route.route.viewName;
    const anotherView = app.views[anotherViewName];

    if (!anotherView) {
      throw new Error(`Framework7: There is no View with "${anotherViewName}" name that was specified in this route`);
    }

    if (anotherView !== router.view) {
      return anotherView.router.navigate(navigateParams, navigateOptions);
    }
  }

  if (route.route.redirect) {
    return _redirect_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(router, 'forward', route, navigateOptions);
  }

  const options = {};

  if (route.route.options) {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options, route.route.options, navigateOptions);
  } else {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options, navigateOptions);
  }

  if (options.openIn && (!router.params.ignoreOpenIn || router.params.ignoreOpenIn && router.history.length > 0)) {
    return router.openIn(router, navigateUrl, options);
  }

  options.route = route;

  function resolve() {
    let routerLoaded = false;
    'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(modalLoadProp => {
      if (route.route[modalLoadProp] && !routerLoaded) {
        routerLoaded = true;
        router.modalLoad(modalLoadProp, route, options, 'forward');
      }
    });

    if (route.route.keepAlive && route.route.keepAliveData) {
      load(router, {
        el: route.route.keepAliveData.pageEl
      }, options, false);
      routerLoaded = true;
    }

    'url content component pageName el componentUrl'.split(' ').forEach(pageLoadProp => {
      if (route.route[pageLoadProp] && !routerLoaded) {
        routerLoaded = true;
        load(router, {
          [pageLoadProp]: route.route[pageLoadProp]
        }, options, false);
      }
    });
    if (routerLoaded) return; // Async

    function asyncResolve(resolveParams, resolveOptions) {
      router.allowPageChange = false;
      let resolvedAsModal = false;
      'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(modalLoadProp => {
        if (resolveParams[modalLoadProp]) {
          resolvedAsModal = true;
          const modalRoute = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, route, {
            route: resolveParams
          });
          router.allowPageChange = true;
          router.modalLoad(modalLoadProp, modalRoute, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options, resolveOptions), 'forward');
        }
      });
      if (resolvedAsModal) return;
      load(router, resolveParams, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(options, resolveOptions), true);
    }

    function asyncReject() {
      router.allowPageChange = true;
    }

    if (route.route.async) {
      router.allowPageChange = false;
      route.route.async.call(router, {
        router,
        to: options.route,
        from: router.currentRoute,
        resolve: asyncResolve,
        reject: asyncReject,
        direction: 'forward',
        app
      });
    }

    if (route.route.asyncComponent) {
      (0,_async_component_js__WEBPACK_IMPORTED_MODULE_6__["default"])(router, route.route.asyncComponent, asyncResolve, asyncReject);
    }
  }

  function reject() {
    router.allowPageChange = true;
  }

  if (router.params.masterDetailBreakpoint > 0 && route.route.masterRoute) {
    // load detail route
    let preloadMaster = true;
    let masterLoaded = false;

    if (router.currentRoute && router.currentRoute.route) {
      if ((router.currentRoute.route.master === true || typeof router.currentRoute.route.master === 'function' && router.currentRoute.route.master(app, router)) && (router.currentRoute.route === route.route.masterRoute || router.currentRoute.route.path === route.route.masterRoute.path)) {
        preloadMaster = false;
      }

      if (router.currentRoute.route.masterRoute && (router.currentRoute.route.masterRoute === route.route.masterRoute || router.currentRoute.route.masterRoute.path === route.route.masterRoute.path)) {
        preloadMaster = false;
        masterLoaded = true;
      }
    }

    if (preloadMaster || masterLoaded && navigateOptions.reloadAll) {
      router.navigate({
        path: route.route.masterRoute.path,
        params: route.params || {}
      }, {
        animate: false,
        reloadAll: navigateOptions.reloadAll,
        reloadCurrent: navigateOptions.reloadCurrent,
        reloadPrevious: navigateOptions.reloadPrevious,
        browserHistory: !navigateOptions.initial,
        history: !navigateOptions.initial,
        once: {
          pageAfterIn() {
            router.navigate(navigateParams, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, navigateOptions, {
              animate: false,
              reloadAll: false,
              reloadCurrent: false,
              reloadPrevious: false,
              history: !navigateOptions.initial,
              browserHistory: !navigateOptions.initial
            }));
          }

        }
      });
      return router;
    }
  }

  _process_route_queue_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(router, route, router.currentRoute, () => {
    if (route.route.modules) {
      app.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(() => {
        resolve();
      }).catch(() => {
        reject();
      });
    } else {
      resolve();
    }
  }, () => {
    reject();
  }, 'forward'); // Return Router

  return router;
}



/***/ }),

/***/ "./node_modules/framework7/modules/router/process-route-queue.js":
/*!***********************************************************************!*\
  !*** ./node_modules/framework7/modules/router/process-route-queue.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ processRouteQueue)
/* harmony export */ });
function processQueue(router, routerQueue, routeQueue, to, from, resolve, reject, direction) {
  const queue = [];

  if (Array.isArray(routeQueue)) {
    queue.push(...routeQueue);
  } else if (routeQueue && typeof routeQueue === 'function') {
    queue.push(routeQueue);
  }

  if (routerQueue) {
    if (Array.isArray(routerQueue)) {
      queue.push(...routerQueue);
    } else {
      queue.push(routerQueue);
    }
  }

  function next() {
    if (queue.length === 0) {
      resolve();
      return;
    }

    const queueItem = queue.shift();
    queueItem.call(router, {
      router,
      to,
      from,

      resolve() {
        next();
      },

      reject() {
        reject();
      },

      direction,
      app: router.app
    });
  }

  next();
}

function processRouteQueue(to, from, resolve, reject, direction) {
  const router = this;

  function enterNextRoute() {
    if (to && to.route && (router.params.routesBeforeEnter || to.route.beforeEnter)) {
      router.allowPageChange = false;
      processQueue(router, router.params.routesBeforeEnter, to.route.beforeEnter, to, from, () => {
        router.allowPageChange = true;
        resolve();
      }, () => {
        reject();
      }, direction);
    } else {
      resolve();
    }
  }

  function leaveCurrentRoute() {
    if (from && from.route && (router.params.routesBeforeLeave || from.route.beforeLeave)) {
      router.allowPageChange = false;
      processQueue(router, router.params.routesBeforeLeave, from.route.beforeLeave, to, from, () => {
        router.allowPageChange = true;
        enterNextRoute();
      }, () => {
        reject();
      }, direction);
    } else {
      enterNextRoute();
    }
  }

  leaveCurrentRoute();
}

/***/ }),

/***/ "./node_modules/framework7/modules/router/redirect.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7/modules/router/redirect.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ redirect)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");

function redirect(direction, route, options) {
  const router = this;
  const r = route.route.redirect;
  const method = direction === 'forward' ? 'navigate' : 'back';

  if (options.initial && router.params.browserHistory) {
    options.replaceState = true; // eslint-disable-line

    options.history = true; // eslint-disable-line
  }

  function redirectResolve(redirectUrl, redirectOptions) {
    if (redirectOptions === void 0) {
      redirectOptions = {};
    }

    router.allowPageChange = true;
    router[method](redirectUrl, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, redirectOptions));
  }

  function redirectReject() {
    router.allowPageChange = true;
  }

  if (typeof r === 'function') {
    router.allowPageChange = false;
    const redirectUrl = r.call(router, {
      router,
      to: route,
      resolve: redirectResolve,
      reject: redirectReject,
      direction,
      app: router.app
    });

    if (redirectUrl && typeof redirectUrl === 'string') {
      router.allowPageChange = true;
      return router[method](redirectUrl, options);
    }

    return router;
  }

  return router[method](r, options);
}

/***/ }),

/***/ "./node_modules/framework7/modules/router/router-class.js":
/*!****************************************************************!*\
  !*** ./node_modules/framework7/modules/router/router-class.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path-to-regexp */ "./node_modules/framework7/node_modules/path-to-regexp/dist.es2015/index.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/class.js */ "./node_modules/framework7/shared/class.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_history_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../shared/history.js */ "./node_modules/framework7/shared/history.js");
/* harmony import */ var _swipe_back_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./swipe-back.js */ "./node_modules/framework7/modules/router/swipe-back.js");
/* harmony import */ var _navigate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./navigate.js */ "./node_modules/framework7/modules/router/navigate.js");
/* harmony import */ var _tab_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tab.js */ "./node_modules/framework7/modules/router/tab.js");
/* harmony import */ var _modal_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modal.js */ "./node_modules/framework7/modules/router/modal.js");
/* harmony import */ var _back_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./back.js */ "./node_modules/framework7/modules/router/back.js");
/* harmony import */ var _clear_previous_history_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./clear-previous-history.js */ "./node_modules/framework7/modules/router/clear-previous-history.js");
/* harmony import */ var _app_router_check_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./app-router-check.js */ "./node_modules/framework7/modules/router/app-router-check.js");














class Router extends _shared_class_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(app, view) {
    super({}, [typeof view === 'undefined' ? app : view]);
    const router = this; // Is App Router

    router.isAppRouter = typeof view === 'undefined';

    if (router.isAppRouter) {
      // App Router
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(false, router, {
        app,
        params: app.params.view,
        routes: app.routes || [],
        cache: app.cache
      });
    } else {
      // View Router
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(false, router, {
        app,
        view,
        viewId: view.id,
        id: view.params.routerId,
        params: view.params,
        routes: view.routes,
        history: view.history,
        scrollHistory: view.scrollHistory,
        cache: app.cache,
        dynamicNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar,
        initialPages: [],
        initialNavbars: []
      });
    } // Install Modules


    router.useModules(); // AllowPageChage

    router.allowPageChange = true; // Current Route

    let currentRoute = {};
    let previousRoute = {};
    Object.defineProperty(router, 'currentRoute', {
      enumerable: true,
      configurable: true,

      set(newRoute) {
        if (newRoute === void 0) {
          newRoute = {};
        }

        previousRoute = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, currentRoute);
        currentRoute = newRoute;
        if (!currentRoute) return;
        router.url = currentRoute.url;
        router.emit('routeChange', newRoute, previousRoute, router);
      },

      get() {
        return currentRoute;
      }

    });
    Object.defineProperty(router, 'previousRoute', {
      enumerable: true,
      configurable: true,

      get() {
        return previousRoute;
      },

      set(newRoute) {
        previousRoute = newRoute;
      }

    });
    return router;
  }

  mount() {
    const router = this;
    const view = router.view;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(false, router, {
      tempDom: document.createElement('div'),
      $el: view.$el,
      el: view.el,
      $navbarsEl: view.$navbarsEl,
      navbarsEl: view.navbarsEl
    });
    router.emit('local::mount routerMount', router);
  }

  animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction) {
    const router = this;
    const dynamicNavbar = router.dynamicNavbar;
    const animateIcon = router.params.iosAnimateNavbarBackIcon;
    let newNavEls;
    let oldNavEls;

    function animatableNavEl($el, $navbarInner) {
      const isSliding = $el.hasClass('sliding') || $navbarInner.hasClass('sliding');
      const isSubnavbar = $el.hasClass('subnavbar');
      const needsOpacityTransition = isSliding ? !isSubnavbar : true;
      const $iconEl = $el.find('.back .icon');
      let isIconLabel;

      if (isSliding && animateIcon && $el.hasClass('left') && $iconEl.length > 0 && $iconEl.next('span').length) {
        $el = $iconEl.next('span'); // eslint-disable-line

        isIconLabel = true;
      }

      return {
        $el,
        isIconLabel,
        leftOffset: $el[0].f7NavbarLeftOffset,
        rightOffset: $el[0].f7NavbarRightOffset,
        isSliding,
        isSubnavbar,
        needsOpacityTransition
      };
    }

    if (dynamicNavbar) {
      newNavEls = [];
      oldNavEls = [];
      $newNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each(navEl => {
        const $navEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(navEl);
        if ($navEl.hasClass('left') && fromLarge && direction === 'forward') return;
        if ($navEl.hasClass('title') && toLarge) return;
        newNavEls.push(animatableNavEl($navEl, $newNavbarEl.children('.navbar-inner')));
      });

      if (!($oldNavbarEl.hasClass('navbar-master') && router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint)) {
        $oldNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each(navEl => {
          const $navEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(navEl);
          if ($navEl.hasClass('left') && toLarge && !fromLarge && direction === 'forward') return;
          if ($navEl.hasClass('left') && toLarge && direction === 'backward') return;

          if ($navEl.hasClass('title') && fromLarge) {
            return;
          }

          oldNavEls.push(animatableNavEl($navEl, $oldNavbarEl.children('.navbar-inner')));
        });
      }

      [oldNavEls, newNavEls].forEach(navEls => {
        navEls.forEach(navEl => {
          const n = navEl;
          const {
            isSliding,
            $el
          } = navEl;
          const otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
          if (!(isSliding && $el.hasClass('title') && otherEls)) return;
          otherEls.forEach(otherNavEl => {
            if (otherNavEl.isIconLabel) {
              const iconTextEl = otherNavEl.$el[0];
              n.leftOffset += iconTextEl ? iconTextEl.offsetLeft || 0 : 0;
            }
          });
        });
      });
    }

    return {
      newNavEls,
      oldNavEls
    };
  }

  animate($oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, transition, callback) {
    const router = this;

    if (router.params.animateCustom) {
      router.params.animateCustom.apply(router, [$oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, callback]);
      return;
    }

    const dynamicNavbar = router.dynamicNavbar;
    const ios = router.app.theme === 'ios';

    if (transition) {
      const routerCustomTransitionClass = `router-transition-custom router-transition-${transition}-${direction}`; // Animate

      const onCustomTransitionDone = () => {
        router.$el.removeClass(routerCustomTransitionClass);

        if (dynamicNavbar && router.$navbarsEl.length) {
          if ($newNavbarEl) {
            router.$navbarsEl.prepend($newNavbarEl);
          }

          if ($oldNavbarEl) {
            router.$navbarsEl.prepend($oldNavbarEl);
          }
        }

        if (callback) callback();
      };

      (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(onCustomTransitionDone);

      if (dynamicNavbar) {
        if ($newNavbarEl && $newPageEl) {
          router.setNavbarPosition($newNavbarEl, '');
          $newNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
          $newPageEl.prepend($newNavbarEl);
        }

        if ($oldNavbarEl && $oldPageEl) {
          router.setNavbarPosition($oldNavbarEl, '');
          $oldNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
          $oldPageEl.prepend($oldNavbarEl);
        }
      }

      router.$el.addClass(routerCustomTransitionClass);
      return;
    } // Router Animation class


    const routerTransitionClass = `router-transition-${direction} router-transition`;
    let newNavEls;
    let oldNavEls;
    let fromLarge;
    let toLarge;
    let toDifferent;
    let oldIsLarge;
    let newIsLarge;

    if (ios && dynamicNavbar) {
      const betweenMasterAndDetail = router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint && ($oldNavbarEl.hasClass('navbar-master') && $newNavbarEl.hasClass('navbar-master-detail') || $oldNavbarEl.hasClass('navbar-master-detail') && $newNavbarEl.hasClass('navbar-master'));

      if (!betweenMasterAndDetail) {
        oldIsLarge = $oldNavbarEl && $oldNavbarEl.hasClass('navbar-large');
        newIsLarge = $newNavbarEl && $newNavbarEl.hasClass('navbar-large');
        fromLarge = oldIsLarge && !$oldNavbarEl.hasClass('navbar-large-collapsed');
        toLarge = newIsLarge && !$newNavbarEl.hasClass('navbar-large-collapsed');
        toDifferent = fromLarge && !toLarge || toLarge && !fromLarge;
      }

      const navEls = router.animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction);
      newNavEls = navEls.newNavEls;
      oldNavEls = navEls.oldNavEls;
    }

    function animateNavbars(progress) {
      if (!(ios && dynamicNavbar)) return;

      if (progress === 1) {
        if (toLarge) {
          $newNavbarEl.addClass('router-navbar-transition-to-large');
          $oldNavbarEl.addClass('router-navbar-transition-to-large');
        }

        if (fromLarge) {
          $newNavbarEl.addClass('router-navbar-transition-from-large');
          $oldNavbarEl.addClass('router-navbar-transition-from-large');
        }
      }

      newNavEls.forEach(navEl => {
        const $el = navEl.$el;
        const offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;

        if (navEl.isSliding) {
          if (navEl.isSubnavbar && newIsLarge) {
            // prettier-ignore
            $el[0].style.setProperty('transform', `translate3d(${offset * (1 - progress)}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`, 'important');
          } else {
            $el.transform(`translate3d(${offset * (1 - progress)}px,0,0)`);
          }
        }
      });
      oldNavEls.forEach(navEl => {
        const $el = navEl.$el;
        const offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;

        if (navEl.isSliding) {
          if (navEl.isSubnavbar && oldIsLarge) {
            $el.transform(`translate3d(${offset * progress}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`);
          } else {
            $el.transform(`translate3d(${offset * progress}px,0,0)`);
          }
        }
      });
    } // AnimationEnd Callback


    function onDone() {
      if (router.dynamicNavbar) {
        if ($newNavbarEl) {
          $newNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
          $newNavbarEl.addClass('navbar-no-title-large-transition');
          (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextFrame)(() => {
            $newNavbarEl.removeClass('navbar-no-title-large-transition');
          });
        }

        if ($oldNavbarEl) {
          $oldNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
        }

        if ($newNavbarEl.hasClass('sliding') || $newNavbarEl.children('.navbar-inner.sliding').length) {
          $newNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
        } else {
          $newNavbarEl.find('.sliding').transform('');
        }

        if ($oldNavbarEl.hasClass('sliding') || $oldNavbarEl.children('.navbar-inner.sliding').length) {
          $oldNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
        } else {
          $oldNavbarEl.find('.sliding').transform('');
        }
      }

      router.$el.removeClass(routerTransitionClass);
      if (callback) callback();
    }

    (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(() => {
      onDone();
    }); // Animate

    if (dynamicNavbar) {
      // Prepare Navbars
      animateNavbars(0);
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.nextFrame)(() => {
        // Add class, start animation
        router.$el.addClass(routerTransitionClass);

        if (toDifferent) {
          // eslint-disable-next-line
          router.el._clientLeft = router.el.clientLeft;
        }

        animateNavbars(1);
      });
    } else {
      // Add class, start animation
      router.$el.addClass(routerTransitionClass);
    }
  }

  removeModal(modalEl) {
    const router = this;
    router.removeEl(modalEl);
  } // eslint-disable-next-line


  removeTabContent(tabEl) {
    const $tabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl);
    $tabEl.html('');
  }

  removeNavbar(el) {
    const router = this;
    router.removeEl(el);
  }

  removePage(el) {
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
    const f7Page = $el && $el[0] && $el[0].f7Page;
    const router = this;

    if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
      $el.remove();
      return;
    }

    router.removeEl(el);
  }

  removeEl(el) {
    if (!el) return;
    const router = this;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
    if ($el.length === 0) return;
    $el.find('.tab').each(tabEl => {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl).children().each(tabChild => {
        if (tabChild.f7Component) {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabChild).trigger('tab:beforeremove');
          tabChild.f7Component.destroy();
        }
      });
    });

    if ($el[0].f7Component && $el[0].f7Component.destroy) {
      $el[0].f7Component.destroy();
    }

    if (!router.params.removeElements) {
      return;
    }

    if (router.params.removeElementsWithTimeout) {
      setTimeout(() => {
        $el.remove();
      }, router.params.removeElementsTimeout);
    } else {
      $el.remove();
    }
  }

  getPageEl(content) {
    const router = this;

    if (typeof content === 'string') {
      router.tempDom.innerHTML = content;
    } else {
      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(content).hasClass('page')) {
        return content;
      }

      router.tempDom.innerHTML = '';
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(router.tempDom).append(content);
    }

    return router.findElement('.page', router.tempDom);
  }

  findElement(stringSelector, container, notStacked) {
    const router = this;
    const view = router.view;
    const app = router.app; // Modals Selector

    const modalsSelector = '.popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page';
    const $container = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(container);
    let selector = stringSelector;
    if (notStacked) selector += ':not(.stacked)';
    let found = $container.find(selector).filter(el => (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el).parents(modalsSelector).length === 0);

    if (found.length > 1) {
      if (typeof view.selector === 'string') {
        // Search in related view
        found = $container.find(`${view.selector} ${selector}`);
      }

      if (found.length > 1) {
        // Search in main view
        found = $container.find(`.${app.params.viewMainClass} ${selector}`);
      }
    }

    if (found.length === 1) return found; // Try to find not stacked

    if (!notStacked) found = router.findElement(selector, $container, true);
    if (found && found.length === 1) return found;
    if (found && found.length > 1) return (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(found[0]);
    return undefined;
  }

  flattenRoutes(routes) {
    if (routes === void 0) {
      routes = this.routes;
    }

    const router = this;
    let flattenedRoutes = [];
    routes.forEach(route => {
      let hasTabRoutes = false;

      if ('tabs' in route && route.tabs) {
        const mergedPathsRoutes = route.tabs.map(tabRoute => {
          const tRoute = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, route, {
            path: `${route.path}/${tabRoute.path}`.replace('///', '/').replace('//', '/'),
            parentPath: route.path,
            tab: tabRoute
          });
          delete tRoute.tabs;
          delete tRoute.routes;
          return tRoute;
        });
        hasTabRoutes = true;
        flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
      }

      if ('detailRoutes' in route) {
        const mergedPathsRoutes = route.detailRoutes.map(detailRoute => {
          const dRoute = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, detailRoute);
          dRoute.masterRoute = route;
          dRoute.masterRoutePath = route.path;
          return dRoute;
        });
        flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes));
      }

      if ('routes' in route) {
        const mergedPathsRoutes = route.routes.map(childRoute => {
          const cRoute = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, childRoute);
          cRoute.path = `${route.path}/${cRoute.path}`.replace('///', '/').replace('//', '/');
          return cRoute;
        });

        if (hasTabRoutes) {
          flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
        } else {
          flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes));
        }
      }

      if (!('routes' in route) && !('tabs' in route && route.tabs) && !('detailRoutes' in route)) {
        flattenedRoutes.push(route);
      }
    });
    return flattenedRoutes;
  } // eslint-disable-next-line


  parseRouteUrl(url) {
    if (!url) return {};
    const query = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.parseUrlQuery)(url);
    const hash = url.split('#')[1];
    const params = {};
    const path = url.split('#')[0].split('?')[0];
    return {
      query,
      hash,
      params,
      url,
      path
    };
  }

  generateUrl(parameters) {
    if (parameters === void 0) {
      parameters = {};
    }

    if (typeof parameters === 'string') {
      return parameters;
    }

    const {
      name,
      path,
      params,
      query
    } = parameters;

    if (!name && !path) {
      throw new Error('Framework7: "name" or "path" parameter is required');
    }

    const router = this;
    const route = name ? router.findRouteByKey('name', name) : router.findRouteByKey('path', path);

    if (!route) {
      if (name) {
        throw new Error(`Framework7: route with name "${name}" not found`);
      } else {
        throw new Error(`Framework7: route with path "${path}" not found`);
      }
    }

    const url = router.constructRouteUrl(route, {
      params,
      query
    });

    if (!url) {
      throw new Error(`Framework7: can't construct URL for route with name "${name}"`);
    }

    return url;
  } // eslint-disable-next-line


  constructRouteUrl(route, _temp) {
    let {
      params,
      query
    } = _temp === void 0 ? {} : _temp;
    const {
      path
    } = route;
    const toUrl = (0,path_to_regexp__WEBPACK_IMPORTED_MODULE_4__.compile)(path);
    let url;

    try {
      url = toUrl(params || {});
    } catch (error) {
      throw new Error(`Framework7: error constructing route URL from passed params:\nRoute: ${path}\n${error.toString()}`);
    }

    if (query) {
      if (typeof query === 'string') url += `?${query}`;else if (Object.keys(query).length) url += `?${(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.serializeObject)(query)}`;
    }

    return url;
  }

  findTabRouteUrl(tabEl) {
    const router = this;
    const $tabEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(tabEl);
    const parentPath = router.currentRoute.route.parentPath;
    const tabId = $tabEl.attr('id');
    const flattenedRoutes = router.flattenRoutes(router.routes);
    let foundTabRouteUrl;
    flattenedRoutes.forEach(route => {
      if (route.parentPath === parentPath && route.tab && route.tab.id === tabId) {
        if (router.currentRoute.params && Object.keys(router.currentRoute.params).length > 0) {
          foundTabRouteUrl = router.constructRouteUrl(route, {
            params: router.currentRoute.params,
            query: router.currentRoute.query
          });
        } else {
          foundTabRouteUrl = route.path;
        }
      }
    });
    return foundTabRouteUrl;
  }

  findRouteByKey(key, value) {
    const router = this;
    const routes = router.routes;
    const flattenedRoutes = router.flattenRoutes(routes);
    let matchingRoute;
    flattenedRoutes.forEach(route => {
      if (matchingRoute) return;

      if (route[key] === value) {
        matchingRoute = route;
      }
    });
    return matchingRoute;
  }

  findMatchingRoute(url) {
    if (!url) return undefined;
    const router = this;
    const routes = router.routes;
    const flattenedRoutes = router.flattenRoutes(routes);
    const {
      path,
      query,
      hash,
      params
    } = router.parseRouteUrl(url);
    let matchingRoute;
    flattenedRoutes.forEach(route => {
      if (matchingRoute) return;
      const keys = [];
      const pathsToMatch = [route.path];

      if (route.alias) {
        if (typeof route.alias === 'string') pathsToMatch.push(route.alias);else if (Array.isArray(route.alias)) {
          route.alias.forEach(aliasPath => {
            pathsToMatch.push(aliasPath);
          });
        }
      }

      let matched;
      pathsToMatch.forEach(pathToMatch => {
        if (matched) return;
        matched = (0,path_to_regexp__WEBPACK_IMPORTED_MODULE_4__.pathToRegexp)(pathToMatch, keys).exec(path);
      });

      if (matched) {
        keys.forEach((keyObj, index) => {
          if (typeof keyObj.name === 'number') return;
          const paramValue = matched[index + 1];

          if (typeof paramValue === 'undefined' || paramValue === null) {
            params[keyObj.name] = paramValue;
          } else {
            params[keyObj.name] = decodeURIComponent(paramValue);
          }
        });
        let parentPath;

        if (route.parentPath) {
          parentPath = path.split('/').slice(0, route.parentPath.split('/').length - 1).join('/');
        }

        matchingRoute = {
          query,
          hash,
          params,
          url,
          path,
          parentPath,
          route,
          name: route.name
        };
      }
    });
    return matchingRoute;
  } // eslint-disable-next-line


  replaceRequestUrlParams(url, options) {
    if (url === void 0) {
      url = '';
    }

    if (options === void 0) {
      options = {};
    }

    let compiledUrl = url;

    if (typeof compiledUrl === 'string' && compiledUrl.indexOf('{{') >= 0 && options && options.route && options.route.params && Object.keys(options.route.params).length) {
      Object.keys(options.route.params).forEach(paramName => {
        const regExp = new RegExp(`{{${paramName}}}`, 'g');
        compiledUrl = compiledUrl.replace(regExp, options.route.params[paramName] || '');
      });
    }

    return compiledUrl;
  }

  removeFromXhrCache(url) {
    const router = this;
    const xhrCache = router.cache.xhr;
    let index = false;

    for (let i = 0; i < xhrCache.length; i += 1) {
      if (xhrCache[i].url === url) index = i;
    }

    if (index !== false) xhrCache.splice(index, 1);
  }

  xhrRequest(requestUrl, options) {
    const router = this;
    const params = router.params;
    const {
      ignoreCache
    } = options;
    let url = requestUrl;
    let hasQuery = url.indexOf('?') >= 0;

    if (params.passRouteQueryToRequest && options && options.route && options.route.query && Object.keys(options.route.query).length) {
      url += `${hasQuery ? '&' : '?'}${(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.serializeObject)(options.route.query)}`;
      hasQuery = true;
    }

    if (params.passRouteParamsToRequest && options && options.route && options.route.params && Object.keys(options.route.params).length) {
      url += `${hasQuery ? '&' : '?'}${(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.serializeObject)(options.route.params)}`;
      hasQuery = true;
    }

    if (url.indexOf('{{') >= 0) {
      url = router.replaceRequestUrlParams(url, options);
    } // should we ignore get params or not


    if (params.xhrCacheIgnoreGetParameters && url.indexOf('?') >= 0) {
      url = url.split('?')[0];
    }

    return new Promise((resolve, reject) => {
      if (params.xhrCache && !ignoreCache && url.indexOf('nocache') < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
        for (let i = 0; i < router.cache.xhr.length; i += 1) {
          const cachedUrl = router.cache.xhr[i];

          if (cachedUrl.url === url) {
            // Check expiration
            if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.now)() - cachedUrl.time < params.xhrCacheDuration) {
              // Load from cache
              resolve(cachedUrl.content);
              return;
            }
          }
        }
      }

      router.xhrAbortController = router.app.request.abortController();
      router.app.request({
        abortController: router.xhrAbortController,
        url,
        method: 'GET',

        beforeSend(xhr) {
          router.emit('routerAjaxStart', xhr, options);
        },

        complete(xhr, status) {
          router.emit('routerAjaxComplete', xhr);

          if (status !== 'error' && status !== 'timeout' && xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) {
            if (params.xhrCache && xhr.responseText !== '') {
              router.removeFromXhrCache(url);
              router.cache.xhr.push({
                url,
                time: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.now)(),
                content: xhr.responseText
              });
            }

            router.emit('routerAjaxSuccess', xhr, options);
            resolve(xhr.responseText);
          } else {
            router.emit('routerAjaxError', xhr, options);
            reject(xhr);
          }
        },

        error(xhr) {
          router.emit('routerAjaxError', xhr, options);
          reject(xhr);
        }

      });
    });
  }

  setNavbarPosition($el, position, ariaHidden) {
    const router = this;
    $el.removeClass('navbar-previous navbar-current navbar-next');

    if (position) {
      $el.addClass(`navbar-${position}`);
    }

    if (ariaHidden === false) {
      $el.removeAttr('aria-hidden');
    } else if (ariaHidden === true) {
      $el.attr('aria-hidden', 'true');
    }

    $el.trigger('navbar:position', {
      position
    });
    router.emit('navbarPosition', $el[0], position);
  }

  setPagePosition($el, position, ariaHidden) {
    const router = this;
    $el.removeClass('page-previous page-current page-next');
    $el.addClass(`page-${position}`);

    if (ariaHidden === false) {
      $el.removeAttr('aria-hidden');
    } else if (ariaHidden === true) {
      $el.attr('aria-hidden', 'true');
    }

    $el.trigger('page:position', {
      position
    });
    router.emit('pagePosition', $el[0], position);
  } // Remove theme elements


  removeThemeElements(el) {
    const router = this;
    const theme = router.app.theme;
    let toRemove;

    if (theme === 'ios') {
      toRemove = '.md-only, .aurora-only, .if-md, .if-aurora, .if-not-ios, .not-ios';
    } else if (theme === 'md') {
      toRemove = '.ios-only, .aurora-only, .if-ios, .if-aurora, .if-not-md, .not-md';
    } else if (theme === 'aurora') {
      toRemove = '.ios-only, .md-only, .if-ios, .if-md, .if-not-aurora, .not-aurora';
    }

    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el).find(toRemove).remove();
  }

  getPageData(pageEl, navbarEl, from, to, route, pageFromEl) {
    if (route === void 0) {
      route = {};
    }

    const router = this;
    const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageEl).eq(0);
    const $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(navbarEl).eq(0);
    const currentPage = $pageEl[0].f7Page || {};
    let direction;
    let pageFrom;
    if (from === 'next' && to === 'current' || from === 'current' && to === 'previous') direction = 'forward';
    if (from === 'current' && to === 'next' || from === 'previous' && to === 'current') direction = 'backward';

    if (currentPage && !currentPage.fromPage) {
      const $pageFromEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageFromEl);

      if ($pageFromEl.length) {
        pageFrom = $pageFromEl[0].f7Page;
      }
    }

    pageFrom = currentPage.pageFrom || pageFrom;

    if (pageFrom && pageFrom.pageFrom) {
      pageFrom.pageFrom = null;
    }

    const page = {
      app: router.app,
      view: router.view,
      router,
      $el: $pageEl,
      el: $pageEl[0],
      $pageEl,
      pageEl: $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl[0],
      name: $pageEl.attr('data-name'),
      position: from,
      from,
      to,
      direction,
      route: currentPage.route ? currentPage.route : route,
      pageFrom
    };
    $pageEl[0].f7Page = page;
    return page;
  } // Callbacks


  pageCallback(callback, pageEl, navbarEl, from, to, options, pageFromEl) {
    if (options === void 0) {
      options = {};
    }

    if (!pageEl) return;
    const router = this;
    const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageEl);
    if (!$pageEl.length) return;
    const $navbarEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(navbarEl);
    const {
      route
    } = options;
    const restoreScrollTopOnBack = router.params.restoreScrollTopOnBack && !(router.params.masterDetailBreakpoint > 0 && $pageEl.hasClass('page-master') && router.app.width >= router.params.masterDetailBreakpoint);
    const keepAlive = $pageEl[0].f7Page && $pageEl[0].f7Page.route && $pageEl[0].f7Page.route.route && $pageEl[0].f7Page.route.route.keepAlive;

    if (callback === 'beforeRemove' && keepAlive) {
      callback = 'beforeUnmount'; // eslint-disable-line
    }

    const camelName = `page${callback[0].toUpperCase() + callback.slice(1, callback.length)}`;
    const colonName = `page:${callback.toLowerCase()}`;
    let page = {};

    if (callback === 'beforeRemove' && $pageEl[0].f7Page) {
      page = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)($pageEl[0].f7Page, {
        from,
        to,
        position: from
      });
    } else {
      page = router.getPageData($pageEl[0], $navbarEl[0], from, to, route, pageFromEl);
    }

    page.swipeBack = !!options.swipeBack;
    const {
      on = {},
      once = {}
    } = options.route ? options.route.route : {};

    if (options.on) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(on, options.on);
    }

    if (options.once) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(once, options.once);
    }

    function attachEvents() {
      if ($pageEl[0].f7RouteEventsAttached) return;
      $pageEl[0].f7RouteEventsAttached = true;

      if (on && Object.keys(on).length > 0) {
        $pageEl[0].f7RouteEventsOn = on;
        Object.keys(on).forEach(eventName => {
          on[eventName] = on[eventName].bind(router);
          $pageEl.on((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.eventNameToColonCase)(eventName), on[eventName]);
        });
      }

      if (once && Object.keys(once).length > 0) {
        $pageEl[0].f7RouteEventsOnce = once;
        Object.keys(once).forEach(eventName => {
          once[eventName] = once[eventName].bind(router);
          $pageEl.once((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.eventNameToColonCase)(eventName), once[eventName]);
        });
      }
    }

    function detachEvents() {
      if (!$pageEl[0].f7RouteEventsAttached) return;

      if ($pageEl[0].f7RouteEventsOn) {
        Object.keys($pageEl[0].f7RouteEventsOn).forEach(eventName => {
          $pageEl.off((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.eventNameToColonCase)(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
        });
      }

      if ($pageEl[0].f7RouteEventsOnce) {
        Object.keys($pageEl[0].f7RouteEventsOnce).forEach(eventName => {
          $pageEl.off((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.eventNameToColonCase)(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
        });
      }

      $pageEl[0].f7RouteEventsAttached = null;
      $pageEl[0].f7RouteEventsOn = null;
      $pageEl[0].f7RouteEventsOnce = null;
      delete $pageEl[0].f7RouteEventsAttached;
      delete $pageEl[0].f7RouteEventsOn;
      delete $pageEl[0].f7RouteEventsOnce;
    }

    if (callback === 'mounted') {
      attachEvents();
    }

    if (callback === 'init') {
      if (restoreScrollTopOnBack && (from === 'previous' || !from) && to === 'current' && router.scrollHistory[page.route.url] && !$pageEl.hasClass('no-restore-scroll')) {
        let $pageContent = $pageEl.find('.page-content');

        if ($pageContent.length > 0) {
          // eslint-disable-next-line
          $pageContent = $pageContent.filter(pageContentEl => {
            return (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageContentEl).parents('.tab:not(.tab-active)').length === 0 && !(0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageContentEl).is('.tab:not(.tab-active)');
          });
        }

        $pageContent.scrollTop(router.scrollHistory[page.route.url]);
      }

      attachEvents();

      if ($pageEl[0].f7PageInitialized) {
        $pageEl.trigger('page:reinit', page);
        router.emit('pageReinit', page);
        return;
      }

      $pageEl[0].f7PageInitialized = true;
    }

    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'previous') {
      // Save scroll position
      let $pageContent = $pageEl.find('.page-content');

      if ($pageContent.length > 0) {
        // eslint-disable-next-line
        $pageContent = $pageContent.filter(pageContentEl => {
          return (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageContentEl).parents('.tab:not(.tab-active)').length === 0 && !(0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageContentEl).is('.tab:not(.tab-active)');
        });
      }

      router.scrollHistory[page.route.url] = $pageContent.scrollTop();
    }

    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'next') {
      // Delete scroll position
      delete router.scrollHistory[page.route.url];
    }

    $pageEl.trigger(colonName, page);
    router.emit(camelName, page);

    if (callback === 'beforeRemove' || callback === 'beforeUnmount') {
      detachEvents();

      if (!keepAlive) {
        if ($pageEl[0].f7Page && $pageEl[0].f7Page.navbarEl) {
          delete $pageEl[0].f7Page.navbarEl.f7Page;
        }

        $pageEl[0].f7Page = null;
      }
    }
  }

  saveHistory() {
    const router = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    router.view.history = router.history;

    if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window.localStorage) {
      window.localStorage[`f7router-${router.view.id}-history`] = JSON.stringify(router.history);
    }
  }

  restoreHistory() {
    const router = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

    if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window.localStorage && window.localStorage[`f7router-${router.view.id}-history`]) {
      router.history = JSON.parse(window.localStorage[`f7router-${router.view.id}-history`]);
      router.view.history = router.history;
    }
  }

  clearHistory() {
    const router = this;
    router.history = [];
    if (router.view) router.view.history = [];
    router.saveHistory();
  }

  updateCurrentUrl(newUrl) {
    const router = this;
    (0,_app_router_check_js__WEBPACK_IMPORTED_MODULE_5__["default"])(router, 'updateCurrentUrl'); // Update history

    if (router.history.length) {
      router.history[router.history.length - 1] = newUrl;
    } else {
      router.history.push(newUrl);
    } // Update current route params


    const {
      query,
      hash,
      params,
      url,
      path
    } = router.parseRouteUrl(newUrl);

    if (router.currentRoute) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(router.currentRoute, {
        query,
        hash,
        params,
        url,
        path
      });
    }

    if (router.params.browserHistory) {
      const browserHistoryRoot = router.params.browserHistoryRoot || '';
      _shared_history_js__WEBPACK_IMPORTED_MODULE_6__["default"].replace(router.view.id, {
        url: newUrl
      }, browserHistoryRoot + router.params.browserHistorySeparator + newUrl);
    } // Save History


    router.saveHistory();
    router.emit('routeUrlUpdate', router.currentRoute, router);
  }

  getInitialUrl() {
    const router = this;

    if (router.initialUrl) {
      return {
        initialUrl: router.initialUrl,
        historyRestored: router.historyRestored
      };
    }

    const {
      app,
      view
    } = router;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const location = app.params.url && typeof app.params.url === 'string' && typeof URL !== 'undefined' ? new URL(app.params.url) : document.location;
    let initialUrl = router.params.url;
    let documentUrl = location.href.split(location.origin)[1];
    let historyRestored;
    const {
      browserHistory,
      browserHistoryOnLoad,
      browserHistorySeparator
    } = router.params;
    let {
      browserHistoryRoot
    } = router.params;

    if ((window.cordova || window.Capacitor && window.Capacitor.isNative) && browserHistory && !browserHistorySeparator && !browserHistoryRoot && location.pathname.indexOf('index.html')) {
      // eslint-disable-next-line
      console.warn('Framework7: wrong or not complete browserHistory configuration, trying to guess browserHistoryRoot');
      browserHistoryRoot = location.pathname.split('index.html')[0];
    }

    if (!browserHistory || !browserHistoryOnLoad) {
      if (!initialUrl) {
        initialUrl = documentUrl;
      }

      if (location.search && initialUrl.indexOf('?') < 0) {
        initialUrl += location.search;
      }

      if (location.hash && initialUrl.indexOf('#') < 0) {
        initialUrl += location.hash;
      }
    } else {
      if (browserHistoryRoot && documentUrl.indexOf(browserHistoryRoot) >= 0) {
        documentUrl = documentUrl.split(browserHistoryRoot)[1];
        if (documentUrl === '') documentUrl = '/';
      }

      if (browserHistorySeparator.length > 0 && documentUrl.indexOf(browserHistorySeparator) >= 0) {
        initialUrl = documentUrl.split(browserHistorySeparator)[1];
      } else {
        initialUrl = documentUrl;
      }

      router.restoreHistory();

      if (router.history.indexOf(initialUrl) >= 0) {
        router.history = router.history.slice(0, router.history.indexOf(initialUrl) + 1);
      } else if (router.params.url === initialUrl) {
        router.history = [initialUrl];
      } else if (_shared_history_js__WEBPACK_IMPORTED_MODULE_6__["default"].state && _shared_history_js__WEBPACK_IMPORTED_MODULE_6__["default"].state[view.id] && _shared_history_js__WEBPACK_IMPORTED_MODULE_6__["default"].state[view.id].url === router.history[router.history.length - 1]) {
        initialUrl = router.history[router.history.length - 1];
      } else {
        router.history = [documentUrl.split(browserHistorySeparator)[0] || '/', initialUrl];
      }

      if (router.history.length > 1) {
        historyRestored = true;
      } else {
        router.history = [];
      }

      router.saveHistory();
    }

    router.initialUrl = initialUrl;
    router.historyRestored = historyRestored;
    return {
      initialUrl,
      historyRestored
    };
  }

  init() {
    const router = this;
    const {
      app,
      view
    } = router;
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    router.mount();
    const {
      initialUrl,
      historyRestored
    } = router.getInitialUrl(); // Init Swipeback

    if (view && router.params.iosSwipeBack && app.theme === 'ios' || view && router.params.mdSwipeBack && app.theme === 'md' || view && router.params.auroraSwipeBack && app.theme === 'aurora') {
      (0,_swipe_back_js__WEBPACK_IMPORTED_MODULE_7__["default"])(router);
    }

    const {
      browserHistory,
      browserHistoryOnLoad,
      browserHistoryAnimateOnLoad,
      browserHistoryInitialMatch
    } = router.params;
    let currentRoute;

    if (router.history.length > 1) {
      // Will load page
      const initUrl = browserHistoryInitialMatch ? initialUrl : router.history[0];
      currentRoute = router.findMatchingRoute(initUrl);

      if (!currentRoute) {
        currentRoute = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(router.parseRouteUrl(initUrl), {
          route: {
            url: initUrl,
            path: initUrl.split('?')[0]
          }
        });
      }
    } else {
      // Don't load page
      currentRoute = router.findMatchingRoute(initialUrl);

      if (!currentRoute) {
        currentRoute = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(router.parseRouteUrl(initialUrl), {
          route: {
            url: initialUrl,
            path: initialUrl.split('?')[0]
          }
        });
      }
    }

    if (router.params.stackPages) {
      router.$el.children('.page').each(pageEl => {
        const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageEl);
        router.initialPages.push($pageEl[0]);

        if (router.dynamicNavbar && $pageEl.children('.navbar').length > 0) {
          router.initialNavbars.push($pageEl.children('.navbar')[0]);
        }
      });
    }

    if (router.$el.children('.page:not(.stacked)').length === 0 && initialUrl && router.params.loadInitialPage) {
      // No pages presented in DOM, reload new page
      router.navigate(initialUrl, {
        initial: true,
        reloadCurrent: true,
        browserHistory: false,
        animate: false,
        once: {
          modalOpen() {
            if (!historyRestored) return;
            const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`];

            if (preloadPreviousPage && router.history.length > 1) {
              router.back({
                preload: true
              });
            }
          },

          pageAfterIn() {
            if (!historyRestored) return;
            const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`];

            if (preloadPreviousPage && router.history.length > 1) {
              router.back({
                preload: true
              });
            }
          }

        }
      });
    } else if (router.$el.children('.page:not(.stacked)').length) {
      // Init current DOM page
      let hasTabRoute;
      router.currentRoute = currentRoute;
      router.$el.children('.page:not(.stacked)').each(pageEl => {
        const $pageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(pageEl);
        let $navbarEl;
        router.setPagePosition($pageEl, 'current');

        if (router.dynamicNavbar) {
          $navbarEl = $pageEl.children('.navbar');

          if ($navbarEl.length > 0) {
            if (!router.$navbarsEl.parents(document).length) {
              router.$el.prepend(router.$navbarsEl);
            }

            router.setNavbarPosition($navbarEl, 'current');
            router.$navbarsEl.append($navbarEl);

            if ($navbarEl.children('.title-large').length) {
              $navbarEl.addClass('navbar-large');
            }

            $pageEl.children('.navbar').remove();
          } else {
            router.$navbarsEl.addClass('navbar-hidden');

            if ($navbarEl.children('.title-large').length) {
              router.$navbarsEl.addClass('navbar-hidden navbar-large-hidden');
            }
          }
        }

        if (router.currentRoute && router.currentRoute.route && (router.currentRoute.route.master === true || typeof router.currentRoute.route.master === 'function' && router.currentRoute.route.master(app, router)) && router.params.masterDetailBreakpoint > 0) {
          $pageEl.addClass('page-master');
          $pageEl.trigger('page:role', {
            role: 'master'
          });

          if ($navbarEl && $navbarEl.length) {
            $navbarEl.addClass('navbar-master');
          }

          view.checkMasterDetailBreakpoint();
        }

        const initOptions = {
          route: router.currentRoute
        };

        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
          (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(initOptions, router.currentRoute.route.options);
        }

        router.currentPageEl = $pageEl[0];

        if (router.dynamicNavbar && $navbarEl.length) {
          router.currentNavbarEl = $navbarEl[0];
        }

        router.removeThemeElements($pageEl);

        if (router.dynamicNavbar && $navbarEl.length) {
          router.removeThemeElements($navbarEl);
        }

        if (initOptions.route.route.tab) {
          hasTabRoute = true;
          router.tabLoad(initOptions.route.route.tab, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, initOptions));
        }

        router.pageCallback('init', $pageEl, $navbarEl, 'current', undefined, initOptions);
        router.pageCallback('beforeIn', $pageEl, $navbarEl, 'current', undefined, initOptions);
        router.pageCallback('afterIn', $pageEl, $navbarEl, 'current', undefined, initOptions);
      });

      if (historyRestored) {
        if (browserHistoryInitialMatch) {
          const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`];

          if (preloadPreviousPage && router.history.length > 1) {
            router.back({
              preload: true
            });
          }
        } else {
          router.navigate(initialUrl, {
            initial: true,
            browserHistory: false,
            history: false,
            animate: browserHistoryAnimateOnLoad,
            once: {
              pageAfterIn() {
                const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`];

                if (preloadPreviousPage && router.history.length > 2) {
                  router.back({
                    preload: true
                  });
                }
              }

            }
          });
        }
      }

      if (!historyRestored && !hasTabRoute) {
        router.history.push(initialUrl);
        router.saveHistory();
      }
    }

    if (initialUrl && browserHistory && browserHistoryOnLoad && (!_shared_history_js__WEBPACK_IMPORTED_MODULE_6__["default"].state || !_shared_history_js__WEBPACK_IMPORTED_MODULE_6__["default"].state[view.id])) {
      _shared_history_js__WEBPACK_IMPORTED_MODULE_6__["default"].initViewState(view.id, {
        url: initialUrl
      });
    }

    router.emit('local::init routerInit', router);
  }

  destroy() {
    let router = this;
    router.emit('local::destroy routerDestroy', router); // Delete props & methods

    Object.keys(router).forEach(routerProp => {
      router[routerProp] = null;
      delete router[routerProp];
    });
    router = null;
  }

} // Load


Router.prototype.navigate = _navigate_js__WEBPACK_IMPORTED_MODULE_8__.navigate;
Router.prototype.refreshPage = _navigate_js__WEBPACK_IMPORTED_MODULE_8__.refreshPage; // Tab

Router.prototype.tabLoad = _tab_js__WEBPACK_IMPORTED_MODULE_9__.tabLoad;
Router.prototype.tabRemove = _tab_js__WEBPACK_IMPORTED_MODULE_9__.tabRemove; // Modal

Router.prototype.modalLoad = _modal_js__WEBPACK_IMPORTED_MODULE_10__.modalLoad;
Router.prototype.modalRemove = _modal_js__WEBPACK_IMPORTED_MODULE_10__.modalRemove; // Back

Router.prototype.back = _back_js__WEBPACK_IMPORTED_MODULE_11__.back; // Clear history

Router.prototype.clearPreviousHistory = _clear_previous_history_js__WEBPACK_IMPORTED_MODULE_12__.clearPreviousHistory;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Router);

/***/ }),

/***/ "./node_modules/framework7/modules/router/router.js":
/*!**********************************************************!*\
  !*** ./node_modules/framework7/modules/router/router.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _router_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router-class.js */ "./node_modules/framework7/modules/router/router-class.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'router',
  static: {
    Router: _router_class_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  instance: {
    cache: {
      xhr: [],
      templates: [],
      components: []
    }
  },

  create() {
    const instance = this;

    if (instance.app) {
      // View Router
      if (instance.params.router) {
        instance.router = new _router_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](instance.app, instance);
      }
    } else {
      // App Router
      instance.router = new _router_class_js__WEBPACK_IMPORTED_MODULE_0__["default"](instance);
    }
  }

});

/***/ }),

/***/ "./node_modules/framework7/modules/router/swipe-back.js":
/*!**************************************************************!*\
  !*** ./node_modules/framework7/modules/router/swipe-back.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_history_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/history.js */ "./node_modules/framework7/shared/history.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");






function SwipeBack(r) {
  const router = r;
  const {
    $el,
    $navbarsEl,
    app,
    params
  } = router;
  const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_1__.getSupport)();
  const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
  let isTouched = false;
  let isMoved = false;
  const touchesStart = {};
  let isScrolling;
  let $currentPageEl = [];
  let $previousPageEl = [];
  let viewContainerWidth;
  let touchesDiff;
  let allowViewTouchMove = true;
  let touchStartTime;
  let $currentNavbarEl = [];
  let $previousNavbarEl = [];
  let dynamicNavbar;
  let $pageShadowEl;
  let $pageOpacityEl;
  let animatableNavEls;
  const paramsSwipeBackAnimateShadow = params[`${app.theme}SwipeBackAnimateShadow`];
  const paramsSwipeBackAnimateOpacity = params[`${app.theme}SwipeBackAnimateOpacity`];
  const paramsSwipeBackActiveArea = params[`${app.theme}SwipeBackActiveArea`];
  const paramsSwipeBackThreshold = params[`${app.theme}SwipeBackThreshold`];
  const transformOrigin = app.rtl ? 'right center' : 'left center';
  const transformOriginTitleLarge = app.rtl ? 'calc(100% - var(--f7-navbar-large-title-padding-left) - var(--f7-safe-area-left)) center' : 'calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center';

  function animatableNavElements() {
    const els = [];
    const inverter = app.rtl ? -1 : 1;
    const currentNavIsTransparent = $currentNavbarEl.hasClass('navbar-transparent') && !$currentNavbarEl.hasClass('navbar-large') && !$currentNavbarEl.hasClass('navbar-transparent-visible');
    const currentNavIsLarge = $currentNavbarEl.hasClass('navbar-large');
    const currentNavIsCollapsed = $currentNavbarEl.hasClass('navbar-large-collapsed');
    const currentNavIsLargeTransparent = $currentNavbarEl.hasClass('navbar-large-transparent') || $currentNavbarEl.hasClass('navbar-large') && $currentNavbarEl.hasClass('navbar-transparent');
    const previousNavIsTransparent = $previousNavbarEl.hasClass('navbar-transparent') && !$previousNavbarEl.hasClass('navbar-large') && !$previousNavbarEl.hasClass('navbar-transparent-visible');
    const previousNavIsLarge = $previousNavbarEl.hasClass('navbar-large');
    const previousNavIsCollapsed = $previousNavbarEl.hasClass('navbar-large-collapsed');
    const previousNavIsLargeTransparent = $previousNavbarEl.hasClass('navbar-large-transparent') || $previousNavbarEl.hasClass('navbar-large') && $previousNavbarEl.hasClass('navbar-transparent');
    const fromLarge = currentNavIsLarge && !currentNavIsCollapsed;
    const toLarge = previousNavIsLarge && !previousNavIsCollapsed;
    const $currentNavElements = $currentNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
    const $previousNavElements = $previousNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
    let activeNavBackIconText;
    let previousNavBackIconText;

    if (params.iosAnimateNavbarBackIcon) {
      if ($currentNavbarEl.hasClass('sliding') || $currentNavbarEl.find('.navbar-inner.sliding').length) {
        activeNavBackIconText = $currentNavbarEl.find('.left').find('.back .icon + span').eq(0);
      } else {
        activeNavBackIconText = $currentNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
      }

      if ($previousNavbarEl.hasClass('sliding') || $previousNavbarEl.find('.navbar-inner.sliding').length) {
        previousNavBackIconText = $previousNavbarEl.find('.left').find('.back .icon + span').eq(0);
      } else {
        previousNavBackIconText = $previousNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
      }

      if (activeNavBackIconText.length) {
        $previousNavElements.each(el => {
          if (!(0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).hasClass('title')) return;
          el.f7NavbarLeftOffset += activeNavBackIconText.prev('.icon')[0].offsetWidth;
        });
      }
    }

    $currentNavElements.each(navEl => {
      const $navEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navEl);
      const isSubnavbar = $navEl.hasClass('subnavbar');
      const isLeft = $navEl.hasClass('left');
      const isTitle = $navEl.hasClass('title');
      const isBg = $navEl.hasClass('navbar-bg');
      if ((isTitle || isBg) && currentNavIsTransparent) return;
      if (!fromLarge && $navEl.hasClass('.title-large')) return;
      const el = {
        el: navEl
      };

      if (fromLarge) {
        if (isTitle) return;

        if ($navEl.hasClass('title-large')) {
          if (els.indexOf(el) < 0) els.push(el);
          el.overflow = 'visible';
          $navEl.find('.title-large-text').each(subNavEl => {
            els.push({
              el: subNavEl,
              transform: progress => `translateX(${progress * 100 * inverter}%)`
            });
          });
          return;
        }
      }

      if (toLarge) {
        if (!fromLarge) {
          if ($navEl.hasClass('title-large')) {
            if (els.indexOf(el) < 0) els.push(el);
            el.opacity = 0;
          }
        }

        if (isLeft) {
          if (els.indexOf(el) < 0) els.push(el);

          el.opacity = progress => 1 - progress ** 0.33;

          $navEl.find('.back span').each(subNavEl => {
            els.push({
              el: subNavEl,
              'transform-origin': transformOrigin,
              transform: progress => `translateX(calc(${progress} * (var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset)))) translateY(calc(${progress} * (var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2))) scale(${1 + 1 * progress})`
            });
          });
          return;
        }
      }

      if (isBg) {
        if (els.indexOf(el) < 0) els.push(el);

        if (!fromLarge && !toLarge) {
          if (currentNavIsCollapsed) {
            if (currentNavIsLargeTransparent) {
              el.className = 'ios-swipeback-navbar-bg-large';
            }

            el.transform = progress => `translateX(${100 * progress * inverter}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`;
          } else {
            el.transform = progress => `translateX(${100 * progress * inverter}%)`;
          }
        }

        if (!fromLarge && toLarge) {
          el.className = 'ios-swipeback-navbar-bg-large';

          el.transform = progress => `translateX(${100 * progress * inverter}%) translateY(calc(-1 * ${1 - progress} * var(--f7-navbar-large-title-height)))`;
        }

        if (fromLarge && toLarge) {
          el.transform = progress => `translateX(${100 * progress * inverter}%)`;
        }

        if (fromLarge && !toLarge) {
          el.transform = progress => `translateX(${100 * progress * inverter}%) translateY(calc(-${progress} * var(--f7-navbar-large-title-height)))`;
        }

        return;
      }

      if ($navEl.hasClass('title-large')) return;
      const isSliding = $navEl.hasClass('sliding') || $navEl.parents('.navbar-inner.sliding').length;
      if (els.indexOf(el) < 0) els.push(el);

      if (!isSubnavbar || isSubnavbar && !isSliding) {
        el.opacity = progress => 1 - progress ** 0.33;
      }

      if (isSliding) {
        let transformTarget = el;

        if (isLeft && activeNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
          const textEl = {
            el: activeNavBackIconText[0]
          };
          transformTarget = textEl;
          els.push(textEl);
        }

        transformTarget.transform = progress => {
          let activeNavTranslate = progress * transformTarget.el.f7NavbarRightOffset;
          if (device.pixelRatio === 1) activeNavTranslate = Math.round(activeNavTranslate);

          if (isSubnavbar && currentNavIsLarge) {
            return `translate3d(${activeNavTranslate}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`;
          }

          return `translate3d(${activeNavTranslate}px,0,0)`;
        };
      }
    });
    $previousNavElements.each(navEl => {
      const $navEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(navEl);
      const isSubnavbar = $navEl.hasClass('subnavbar');
      const isLeft = $navEl.hasClass('left');
      const isTitle = $navEl.hasClass('title');
      const isBg = $navEl.hasClass('navbar-bg');
      if ((isTitle || isBg) && previousNavIsTransparent) return;
      const el = {
        el: navEl
      };

      if (toLarge) {
        if (isTitle) return;
        if (els.indexOf(el) < 0) els.push(el);

        if ($navEl.hasClass('title-large')) {
          el.opacity = 1;
          el.overflow = 'visible';
          $navEl.find('.title-large-text').each(subNavEl => {
            els.push({
              el: subNavEl,
              'transform-origin': transformOriginTitleLarge,
              opacity: progress => progress ** 3,
              transform: progress => `translateX(calc(${1 - progress} * (var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset)))) translateY(calc(${progress - 1} * var(--f7-navbar-large-title-height) + ${1 - progress} * var(--f7-navbar-large-title-padding-vertical))) scale(${0.5 + progress * 0.5})`
            });
          });
          return;
        }
      }

      if (isBg) {
        if (els.indexOf(el) < 0) els.push(el);

        if (!fromLarge && !toLarge) {
          if (previousNavIsCollapsed) {
            if (previousNavIsLargeTransparent) {
              el.className = 'ios-swipeback-navbar-bg-large';
            }

            el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`;
          } else {
            el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%)`;
          }
        }

        if (!fromLarge && toLarge) {
          el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-1 * ${1 - progress} * var(--f7-navbar-large-title-height)))`;
        }

        if (fromLarge && !toLarge) {
          el.className = 'ios-swipeback-navbar-bg-large';

          el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-${progress} * var(--f7-navbar-large-title-height)))`;
        }

        if (fromLarge && toLarge) {
          el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%)`;
        }

        return;
      }

      if ($navEl.hasClass('title-large')) return;
      const isSliding = $navEl.hasClass('sliding') || $previousNavbarEl.children('.navbar-inner.sliding').length;
      if (els.indexOf(el) < 0) els.push(el);

      if (!isSubnavbar || isSubnavbar && !isSliding) {
        el.opacity = progress => progress ** 3;
      }

      if (isSliding) {
        let transformTarget = el;

        if (isLeft && previousNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
          const textEl = {
            el: previousNavBackIconText[0]
          };
          transformTarget = textEl;
          els.push(textEl);
        }

        transformTarget.transform = progress => {
          let previousNavTranslate = transformTarget.el.f7NavbarLeftOffset * (1 - progress);
          if (device.pixelRatio === 1) previousNavTranslate = Math.round(previousNavTranslate);

          if (isSubnavbar && previousNavIsLarge) {
            return `translate3d(${previousNavTranslate}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`;
          }

          return `translate3d(${previousNavTranslate}px,0,0)`;
        };
      }
    });
    return els;
  }

  function setAnimatableNavElements(_temp) {
    let {
      progress,
      reset,
      transition,
      reflow
    } = _temp === void 0 ? {} : _temp;
    const styles = ['overflow', 'transform', 'transform-origin', 'opacity'];

    if (transition === true || transition === false) {
      for (let i = 0; i < animatableNavEls.length; i += 1) {
        const el = animatableNavEls[i];

        if (el && el.el) {
          if (transition === true) el.el.classList.add('navbar-page-transitioning');
          if (transition === false) el.el.classList.remove('navbar-page-transitioning');
        }
      }
    }

    if (reflow && animatableNavEls.length && animatableNavEls[0] && animatableNavEls[0].el) {
      // eslint-disable-next-line
      animatableNavEls[0].el._clientLeft = animatableNavEls[0].el.clientLeft;
    }

    for (let i = 0; i < animatableNavEls.length; i += 1) {
      const el = animatableNavEls[i];

      if (el && el.el) {
        if (el.className && !el.classNameSet && !reset) {
          el.el.classList.add(el.className);
          el.classNameSet = true;
        }

        if (el.className && reset) {
          el.el.classList.remove(el.className);
        }

        for (let j = 0; j < styles.length; j += 1) {
          const styleProp = styles[j];

          if (el[styleProp]) {
            if (reset) {
              el.el.style[styleProp] = '';
            } else if (typeof el[styleProp] === 'function') {
              el.el.style[styleProp] = el[styleProp](progress);
            } else {
              el.el.style[styleProp] = el[styleProp];
            }
          }
        }
      }
    }
  }

  function handleTouchStart(e) {
    const swipeBackEnabled = params[`${app.theme}SwipeBack`];
    if (!allowViewTouchMove || !swipeBackEnabled || isTouched || app.swipeout && app.swipeout.el || !router.allowPageChange) return;
    if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.range-slider, .calendar-months').length > 0) return;
    if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target).closest('.page-master, .page-master-detail').length > 0 && params.masterDetailBreakpoint > 0 && app.width >= params.masterDetailBreakpoint) return;
    isMoved = false;
    isTouched = true;
    isScrolling = undefined;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.now)();
    dynamicNavbar = router.dynamicNavbar;
  }

  function handleTouchMove(e) {
    if (!isTouched) return;
    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (typeof isScrolling === 'undefined') {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || pageX < touchesStart.x && !app.rtl || pageX > touchesStart.x && app.rtl;
    }

    if (isScrolling || e.f7PreventSwipeBack || app.preventSwipeBack) {
      isTouched = false;
      return;
    }

    if (!isMoved) {
      // Calc values during first move fired
      let cancel = false;
      const target = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e.target);
      const swipeout = target.closest('.swipeout');

      if (swipeout.length > 0) {
        if (!app.rtl && swipeout.find('.swipeout-actions-left').length > 0) cancel = true;
        if (app.rtl && swipeout.find('.swipeout-actions-right').length > 0) cancel = true;
      }

      $currentPageEl = target.closest('.page');
      if ($currentPageEl.hasClass('no-swipeback') || target.closest('.no-swipeback, .card-opened').length > 0) cancel = true;
      $previousPageEl = $el.find('.page-previous:not(.stacked)');

      if ($previousPageEl.length > 1) {
        $previousPageEl = $previousPageEl.eq($previousPageEl.length - 1);
      }

      let notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      viewContainerWidth = $el.width();

      if (app.rtl) {
        notFromBorder = touchesStart.x < $el.offset().left - $el[0].scrollLeft + (viewContainerWidth - paramsSwipeBackActiveArea);
      } else {
        notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      }

      if (notFromBorder) cancel = true;
      if ($previousPageEl.length === 0 || $currentPageEl.length === 0) cancel = true;

      if (cancel) {
        isTouched = false;
        return;
      }

      if (paramsSwipeBackAnimateShadow) {
        $pageShadowEl = $currentPageEl.find('.page-shadow-effect');

        if ($pageShadowEl.length === 0) {
          $pageShadowEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="page-shadow-effect"></div>');
          $currentPageEl.append($pageShadowEl);
        }
      }

      if (paramsSwipeBackAnimateOpacity) {
        $pageOpacityEl = $previousPageEl.find('.page-opacity-effect');

        if ($pageOpacityEl.length === 0) {
          $pageOpacityEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="page-opacity-effect"></div>');
          $previousPageEl.append($pageOpacityEl);
        }
      }

      if (dynamicNavbar) {
        $currentNavbarEl = $navbarsEl.find('.navbar-current:not(.stacked)');
        $previousNavbarEl = $navbarsEl.find('.navbar-previous:not(.stacked)');

        if ($previousNavbarEl.length > 1) {
          $previousNavbarEl = $previousNavbarEl.eq($previousNavbarEl.length - 1);
        }

        animatableNavEls = animatableNavElements($previousNavbarEl, $currentNavbarEl);
      } // Close/Hide Any Picker


      if ((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.sheet.modal-in').length > 0 && app.sheet) {
        app.sheet.close((0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])('.sheet.modal-in'));
      }
    }

    e.f7PreventSwipePanel = true;
    isMoved = true;
    app.preventSwipePanelBySwipeBack = true;
    e.preventDefault(); // RTL inverter

    const inverter = app.rtl ? -1 : 1; // Touches diff

    touchesDiff = (pageX - touchesStart.x - paramsSwipeBackThreshold) * inverter;
    if (touchesDiff < 0) touchesDiff = 0;
    const percentage = Math.min(Math.max(touchesDiff / viewContainerWidth, 0), 1); // Swipe Back Callback

    const callbackData = {
      percentage,
      progress: percentage,
      currentPageEl: $currentPageEl[0],
      previousPageEl: $previousPageEl[0],
      currentNavbarEl: $currentNavbarEl[0],
      previousNavbarEl: $previousNavbarEl[0]
    };
    $el.trigger('swipeback:move', callbackData);
    router.emit('swipebackMove', callbackData); // Transform pages

    let currentPageTranslate = touchesDiff * inverter;
    let previousPageTranslate = (touchesDiff / 5 - viewContainerWidth / 5) * inverter;

    if (!app.rtl) {
      currentPageTranslate = Math.min(currentPageTranslate, viewContainerWidth);
      previousPageTranslate = Math.min(previousPageTranslate, 0);
    } else {
      currentPageTranslate = Math.max(currentPageTranslate, -viewContainerWidth);
      previousPageTranslate = Math.max(previousPageTranslate, 0);
    }

    if (device.pixelRatio === 1) {
      currentPageTranslate = Math.round(currentPageTranslate);
      previousPageTranslate = Math.round(previousPageTranslate);
    }

    router.swipeBackActive = true;
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])([$currentPageEl[0], $previousPageEl[0]]).addClass('page-swipeback-active');
    $currentPageEl.transform(`translate3d(${currentPageTranslate}px,0,0)`);
    if (paramsSwipeBackAnimateShadow) $pageShadowEl[0].style.opacity = 1 - 1 * percentage;

    if (app.theme === 'ios') {
      $previousPageEl.transform(`translate3d(${previousPageTranslate}px,0,0)`);
    }

    if (paramsSwipeBackAnimateOpacity) $pageOpacityEl[0].style.opacity = 1 - 1 * percentage; // Dynamic Navbars Animation

    if (!dynamicNavbar) return;
    setAnimatableNavElements({
      progress: percentage
    });
  }

  function handleTouchEnd() {
    app.preventSwipePanelBySwipeBack = false;

    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }

    isTouched = false;
    isMoved = false;
    router.swipeBackActive = false;
    const $pages = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])([$currentPageEl[0], $previousPageEl[0]]);
    $pages.removeClass('page-swipeback-active');

    if (touchesDiff === 0) {
      $pages.transform('');
      if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
      if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();

      if (dynamicNavbar) {
        setAnimatableNavElements({
          reset: true
        });
      }

      return;
    }

    const timeDiff = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.now)() - touchStartTime;
    let pageChanged = false; // Swipe back to previous page

    if (timeDiff < 300 && touchesDiff > 10 || timeDiff >= 300 && touchesDiff > viewContainerWidth / 2) {
      $currentPageEl.removeClass('page-current').addClass(`page-next${app.theme !== 'ios' ? ' page-next-on-right' : ''}`);
      $previousPageEl.removeClass('page-previous').addClass('page-current').removeAttr('aria-hidden');
      if ($pageShadowEl) $pageShadowEl[0].style.opacity = '';
      if ($pageOpacityEl) $pageOpacityEl[0].style.opacity = '';

      if (dynamicNavbar) {
        router.setNavbarPosition($currentNavbarEl, 'next');
        router.setNavbarPosition($previousNavbarEl, 'current', false);
      }

      pageChanged = true;
    } // Reset custom styles
    // Add transitioning class for transition-duration


    $pages.addClass('page-transitioning page-transitioning-swipeback');

    if (device.ios) {
      // eslint-disable-next-line
      $currentPageEl[0]._clientLeft = $currentPageEl[0].clientLeft;
    }

    $pages.transform('');

    if (dynamicNavbar) {
      setAnimatableNavElements({
        progress: pageChanged ? 1 : 0,
        transition: true,
        reflow: !!device.ios
      });
    }

    allowViewTouchMove = false;
    router.allowPageChange = false; // Swipe Back Callback

    const callbackData = {
      currentPageEl: $currentPageEl[0],
      previousPageEl: $previousPageEl[0],
      currentNavbarEl: $currentNavbarEl[0],
      previousNavbarEl: $previousNavbarEl[0]
    };

    if (pageChanged) {
      // Update Route
      router.currentRoute = $previousPageEl[0].f7Page.route;
      router.currentPage = $previousPageEl[0]; // Page before animation callback

      router.pageCallback('beforeOut', $currentPageEl, $currentNavbarEl, 'current', 'next', {
        route: $currentPageEl[0].f7Page.route,
        swipeBack: true
      });
      router.pageCallback('beforeIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', {
        route: $previousPageEl[0].f7Page.route,
        swipeBack: true
      }, $currentPageEl[0]);
      $el.trigger('swipeback:beforechange', callbackData);
      router.emit('swipebackBeforeChange', callbackData);
    } else {
      $el.trigger('swipeback:beforereset', callbackData);
      router.emit('swipebackBeforeReset', callbackData);
    }

    $currentPageEl.transitionEnd(() => {
      $pages.removeClass('page-transitioning page-transitioning-swipeback');

      if (dynamicNavbar) {
        setAnimatableNavElements({
          reset: true,
          transition: false
        });
      }

      allowViewTouchMove = true;
      router.allowPageChange = true;

      if (pageChanged) {
        // Update History
        if (router.history.length === 1) {
          router.history.unshift(router.url);
        }

        router.history.pop();
        router.saveHistory(); // Update push state

        if (params.browserHistory) {
          _shared_history_js__WEBPACK_IMPORTED_MODULE_4__["default"].back();
        } // Page after animation callback


        router.pageCallback('afterOut', $currentPageEl, $currentNavbarEl, 'current', 'next', {
          route: $currentPageEl[0].f7Page.route,
          swipeBack: true
        });
        router.pageCallback('afterIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', {
          route: $previousPageEl[0].f7Page.route,
          swipeBack: true
        }); // Remove Old Page

        if (params.stackPages && router.initialPages.indexOf($currentPageEl[0]) >= 0) {
          $currentPageEl.addClass('stacked');

          if (dynamicNavbar) {
            $currentNavbarEl.addClass('stacked');
          }
        } else {
          router.pageCallback('beforeRemove', $currentPageEl, $currentNavbarEl, 'next', {
            swipeBack: true
          });
          router.removePage($currentPageEl);

          if (dynamicNavbar) {
            router.removeNavbar($currentNavbarEl);
          }
        }

        $el.trigger('swipeback:afterchange', callbackData);
        router.emit('swipebackAfterChange', callbackData);
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

        if (params.preloadPreviousPage) {
          router.back(router.history[router.history.length - 2], {
            preload: true
          });
        }
      } else {
        $el.trigger('swipeback:afterreset', callbackData);
        router.emit('swipebackAfterReset', callbackData);
      }

      if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
      if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();
    });
  }

  function attachEvents() {
    const passiveListener = app.touchEvents.start === 'touchstart' && support.passiveListener ? {
      passive: true,
      capture: false
    } : false;
    $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
  }

  function detachEvents() {
    const passiveListener = app.touchEvents.start === 'touchstart' && support.passiveListener ? {
      passive: true,
      capture: false
    } : false;
    $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
  }

  attachEvents();
  router.on('routerDestroy', detachEvents);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SwipeBack);

/***/ }),

/***/ "./node_modules/framework7/modules/router/tab.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7/modules/router/tab.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tabLoad": () => (/* binding */ tabLoad),
/* harmony export */   "tabRemove": () => (/* binding */ tabRemove)
/* harmony export */ });
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _shared_history_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/history.js */ "./node_modules/framework7/shared/history.js");
/* harmony import */ var _async_component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./async-component.js */ "./node_modules/framework7/modules/router/async-component.js");





function tabLoad(tabRoute, loadOptions) {
  if (loadOptions === void 0) {
    loadOptions = {};
  }

  const router = this;
  const options = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
    animate: router.params.animate,
    browserHistory: true,
    history: true,
    parentPageEl: null,
    preload: false,
    on: {}
  }, loadOptions);
  let currentRoute;
  let previousRoute;

  if (options.route) {
    // Set Route
    if (!options.preload && options.route !== router.currentRoute) {
      previousRoute = router.previousRoute;
      router.currentRoute = options.route;
    }

    if (options.preload) {
      currentRoute = options.route;
      previousRoute = router.currentRoute;
    } else {
      currentRoute = router.currentRoute;
      if (!previousRoute) previousRoute = router.previousRoute;
    } // Update Browser History


    if (router.params.browserHistory && options.browserHistory && !options.reloadPrevious) {
      _shared_history_js__WEBPACK_IMPORTED_MODULE_2__["default"][router.params.browserHistoryTabs](router.view.id, {
        url: options.route.url
      }, (router.params.browserHistoryRoot || '') + router.params.browserHistorySeparator + options.route.url);
    } // Update Router History


    if (options.history) {
      router.history[Math.max(router.history.length - 1, 0)] = options.route.url;
      router.saveHistory();
    }
  } // Show Tab


  const $parentPageEl = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options.parentPageEl || router.currentPageEl);
  let tabEl;

  if ($parentPageEl.length && $parentPageEl.find(`#${tabRoute.id}`).length) {
    tabEl = $parentPageEl.find(`#${tabRoute.id}`).eq(0);
  } else if (router.view.selector) {
    tabEl = `${router.view.selector} #${tabRoute.id}`;
  } else {
    tabEl = `#${tabRoute.id}`;
  }

  const tabShowResult = router.app.tab.show({
    tabEl,
    animate: options.animate,
    tabRoute: options.route
  });
  const {
    $newTabEl,
    $oldTabEl,
    animated,
    onTabsChanged
  } = tabShowResult;

  if ($newTabEl && $newTabEl.parents('.page').length > 0 && options.route) {
    const tabParentPageData = $newTabEl.parents('.page')[0].f7Page;

    if (tabParentPageData && options.route) {
      tabParentPageData.route = options.route;
    }
  } // Tab Content Loaded


  function onTabLoaded(contentEl) {
    // Remove theme elements
    router.removeThemeElements($newTabEl);
    let tabEventTarget = $newTabEl;
    if (typeof contentEl !== 'string') tabEventTarget = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(contentEl);
    tabEventTarget.trigger('tab:init tab:mounted', tabRoute);
    router.emit('tabInit tabMounted', $newTabEl[0], tabRoute);

    if ($oldTabEl && $oldTabEl.length) {
      if (animated) {
        onTabsChanged(() => {
          router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

          if (router.params.unloadTabContent) {
            router.tabRemove($oldTabEl, $newTabEl, tabRoute);
          }
        });
      } else {
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

        if (router.params.unloadTabContent) {
          router.tabRemove($oldTabEl, $newTabEl, tabRoute);
        }
      }
    }
  }

  if ($newTabEl[0].f7RouterTabLoaded) {
    if (!$oldTabEl || !$oldTabEl.length) return router;

    if (animated) {
      onTabsChanged(() => {
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
      });
    } else {
      router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
    }

    return router;
  } // Load Tab Content


  function loadTab(loadTabParams, loadTabOptions) {
    // Load Tab Props
    const {
      url,
      content,
      el,
      component,
      componentUrl
    } = loadTabParams; // Component/Template Callbacks

    function resolve(contentEl) {
      router.allowPageChange = true;
      if (!contentEl) return;

      if (typeof contentEl === 'string') {
        $newTabEl.html(contentEl);
      } else {
        $newTabEl.html('');

        if (contentEl.f7Component) {
          contentEl.f7Component.mount(componentEl => {
            $newTabEl.append(componentEl);
          });
        } else {
          $newTabEl.append(contentEl);
        }
      }

      $newTabEl[0].f7RouterTabLoaded = true;
      onTabLoaded(contentEl);
    }

    function reject() {
      router.allowPageChange = true;
      return router;
    }

    if (content) {
      resolve(content);
    } else if (el) {
      resolve(el);
    } else if (component || componentUrl) {
      // Load from component (F7/Vue/React/...)
      try {
        router.tabComponentLoader({
          tabEl: $newTabEl[0],
          component,
          componentUrl,
          options: loadTabOptions,
          resolve,
          reject
        });
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      // Load using XHR
      if (router.xhrAbortController) {
        router.xhrAbortController.abort();
        router.xhrAbortController = false;
      }

      router.xhrRequest(url, loadTabOptions).then(tabContent => {
        resolve(tabContent);
      }).catch(() => {
        router.allowPageChange = true;
      });
    }
  }

  let hasContentLoadProp;
  'url content component el componentUrl'.split(' ').forEach(tabLoadProp => {
    if (tabRoute[tabLoadProp]) {
      hasContentLoadProp = true;
      loadTab({
        [tabLoadProp]: tabRoute[tabLoadProp]
      }, options);
    }
  }); // Async

  function asyncResolve(resolveParams, resolveOptions) {
    loadTab(resolveParams, (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(options, resolveOptions));
  }

  function asyncReject() {
    router.allowPageChange = true;
  }

  if (tabRoute.async) {
    tabRoute.async.call(router, {
      router,
      to: currentRoute,
      from: previousRoute,
      resolve: asyncResolve,
      reject: asyncReject,
      app: router.app
    });
  } else if (tabRoute.asyncComponent) {
    (0,_async_component_js__WEBPACK_IMPORTED_MODULE_3__["default"])(router, tabRoute.asyncComponent, asyncResolve, asyncReject);
  } else if (!hasContentLoadProp) {
    router.allowPageChange = true;
  }

  return router;
}

function tabRemove($oldTabEl, $newTabEl, tabRoute) {
  const router = this;
  let hasTabComponentChild;

  if ($oldTabEl[0]) {
    $oldTabEl[0].f7RouterTabLoaded = false;
    delete $oldTabEl[0].f7RouterTabLoaded;
  }

  $oldTabEl.children().each(tabChild => {
    if (tabChild.f7Component) {
      hasTabComponentChild = true;
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(tabChild).trigger('tab:beforeremove', tabRoute);
      tabChild.f7Component.destroy();
    }
  });

  if (!hasTabComponentChild) {
    $oldTabEl.trigger('tab:beforeremove', tabRoute);
  }

  router.emit('tabBeforeRemove', $oldTabEl[0], $newTabEl[0], tabRoute);
  router.removeTabContent($oldTabEl[0], tabRoute);
}



/***/ }),

/***/ "./node_modules/framework7/modules/service-worker/service-worker.js":
/*!**************************************************************************!*\
  !*** ./node_modules/framework7/modules/service-worker/service-worker.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");


const SW = {
  registrations: [],

  register(path, scope) {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

    if (!('serviceWorker' in window.navigator) || !app.serviceWorker.container) {
      return new Promise((resolve, reject) => {
        reject(new Error('Service worker is not supported'));
      });
    }

    return new Promise((resolve, reject) => {
      app.serviceWorker.container.register(path, scope ? {
        scope
      } : {}).then(reg => {
        SW.registrations.push(reg);
        app.emit('serviceWorkerRegisterSuccess', reg);
        resolve(reg);
      }).catch(error => {
        app.emit('serviceWorkerRegisterError', error);
        reject(error);
      });
    });
  },

  unregister(registration) {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

    if (!('serviceWorker' in window.navigator) || !app.serviceWorker.container) {
      return new Promise((resolve, reject) => {
        reject(new Error('Service worker is not supported'));
      });
    }

    let registrations;
    if (!registration) registrations = SW.registrations;else if (Array.isArray(registration)) registrations = registration;else registrations = [registration];
    return Promise.all(registrations.map(reg => new Promise((resolve, reject) => {
      reg.unregister().then(() => {
        if (SW.registrations.indexOf(reg) >= 0) {
          SW.registrations.splice(SW.registrations.indexOf(reg), 1);
        }

        app.emit('serviceWorkerUnregisterSuccess', reg);
        resolve();
      }).catch(error => {
        app.emit('serviceWorkerUnregisterError', reg, error);
        reject(error);
      });
    })));
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'sw',
  params: {
    serviceWorker: {
      path: undefined,
      scope: undefined
    }
  },

  create() {
    const app = this;
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(app, {
      serviceWorker: {
        container: 'serviceWorker' in window.navigator ? window.navigator.serviceWorker : undefined,
        registrations: SW.registrations,
        register: SW.register.bind(app),
        unregister: SW.unregister.bind(app)
      }
    });
  },

  on: {
    init() {
      const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
      if (!('serviceWorker' in window.navigator)) return;
      const app = this;
      if (app.device.cordova || window.Capacitor && window.Capacitor.isNative) return;
      if (!app.serviceWorker.container) return;
      const paths = app.params.serviceWorker.path;
      const scope = app.params.serviceWorker.scope;
      if (!paths || Array.isArray(paths) && !paths.length) return;
      const toRegister = Array.isArray(paths) ? paths : [paths];
      toRegister.forEach(path => {
        app.serviceWorker.register(path, scope);
      });
    }

  }
});

/***/ }),

/***/ "./node_modules/framework7/modules/store/create-store.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/modules/store/create-store.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* eslint-disable no-underscore-dangle */


function createStore(storeParams) {
  if (storeParams === void 0) {
    storeParams = {};
  }

  const store = {
    __store: true
  };
  const originalState = { ...(storeParams.state || {})
  };
  const actions = { ...(storeParams.actions || {})
  };
  const getters = { ...(storeParams.getters || {})
  };
  const state = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, originalState);
  let propsQueue = [];
  const gettersDependencies = {};
  const gettersCallbacks = {};
  Object.keys(getters).forEach(getterKey => {
    gettersDependencies[getterKey] = [];
    gettersCallbacks[getterKey] = [];
  });

  const getGetterValue = getterKey => {
    return getters[getterKey]({
      state: store.state
    });
  };

  const addGetterDependencies = (getterKey, deps) => {
    if (!gettersDependencies[getterKey]) gettersDependencies[getterKey] = [];
    deps.forEach(dep => {
      if (gettersDependencies[getterKey].indexOf(dep) < 0) {
        gettersDependencies[getterKey].push(dep);
      }
    });
  };

  const addGetterCallback = (getterKey, callback) => {
    if (!gettersCallbacks[getterKey]) gettersCallbacks[getterKey] = [];
    gettersCallbacks[getterKey].push(callback);
  };

  const runGetterCallbacks = stateKey => {
    const keys = Object.keys(gettersDependencies).filter(getterKey => {
      return gettersDependencies[getterKey].indexOf(stateKey) >= 0;
    });
    keys.forEach(getterKey => {
      if (!gettersCallbacks[getterKey] || !gettersCallbacks[getterKey].length) return;
      gettersCallbacks[getterKey].forEach(callback => {
        callback(getGetterValue(getterKey));
      });
    });
  };

  const removeGetterCallback = callback => {
    Object.keys(gettersCallbacks).forEach(stateKey => {
      const callbacks = gettersCallbacks[stateKey];

      if (callbacks.indexOf(callback) >= 0) {
        callbacks.splice(callbacks.indexOf(callback), 1);
      }
    });
  }; // eslint-disable-next-line


  store.__removeCallback = callback => {
    removeGetterCallback(callback);
  };

  const getterValue = function (getterKey, addCallback) {
    if (addCallback === void 0) {
      addCallback = true;
    }

    if (getterKey === 'constructor') return undefined;
    propsQueue = [];
    const value = getGetterValue(getterKey);
    addGetterDependencies(getterKey, propsQueue);

    const onUpdated = callback => {
      addGetterCallback(getterKey, callback);
    };

    const obj = {
      value,
      onUpdated
    };

    if (!addCallback) {
      return obj;
    }

    const callback = v => {
      obj.value = v;
    };

    obj.__callback = callback;
    addGetterCallback(getterKey, callback); // eslint-disable-next-line

    return obj;
  };

  store.state = new Proxy(state, {
    set: (target, prop, value) => {
      target[prop] = value;
      runGetterCallbacks(prop);
      return true;
    },
    get: (target, prop) => {
      propsQueue.push(prop);
      return target[prop];
    }
  });
  store.getters = new Proxy(getters, {
    set: () => false,
    get: (target, prop) => {
      if (!target[prop]) {
        return undefined;
      }

      return getterValue(prop, true);
    }
  });
  store._gettersPlain = new Proxy(getters, {
    set: () => false,
    get: (target, prop) => {
      if (!target[prop]) {
        return undefined;
      }

      return getterValue(prop, false);
    }
  });

  store.dispatch = (actionName, data) => {
    return new Promise((resolve, reject) => {
      if (!actions[actionName]) {
        reject();
        throw new Error(`Framework7: Store action "${actionName}" is not found`);
      }

      const result = actions[actionName]({
        state: store.state,
        dispatch: store.dispatch
      }, data);
      resolve(result);
    });
  };

  return store;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createStore);

/***/ }),

/***/ "./node_modules/framework7/modules/store/store.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7/modules/store/store.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStore": () => (/* reexport safe */ _create_store_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _create_store_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-store.js */ "./node_modules/framework7/modules/store/create-store.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'store',
  static: {
    createStore: _create_store_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  proto: {
    createStore: _create_store_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  }
});

/***/ }),

/***/ "./node_modules/framework7/modules/support/support.js":
/*!************************************************************!*\
  !*** ./node_modules/framework7/modules/support/support.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'support',
  static: {
    getSupport: _shared_get_support_js__WEBPACK_IMPORTED_MODULE_0__.getSupport
  }
});

/***/ }),

/***/ "./node_modules/framework7/modules/touch/touch.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7/modules/touch/touch.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/get-device.js */ "./node_modules/framework7/shared/get-device.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");
/* eslint-disable no-nested-ternary */






function initTouch() {
  const app = this;
  const device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_2__.getDevice)();
  const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__.getSupport)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const params = app.params.touch;
  const useRipple = params[`${app.theme}TouchRipple`];

  if (device.ios && device.webView) {
    // Strange hack required for iOS 8 webview to work on inputs
    window.addEventListener('touchstart', () => {});
  }

  let touchStartX;
  let touchStartY;
  let targetElement;
  let isMoved;
  let tapHoldFired;
  let tapHoldTimeout;
  let preventClick;
  let activableElement;
  let activeTimeout;
  let rippleWave;
  let rippleTarget;
  let rippleTimeout;

  function findActivableElement(el) {
    const target = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
    const parents = target.parents(params.activeStateElements);

    if (target.closest('.no-active-state').length) {
      return null;
    }

    let activable;

    if (target.is(params.activeStateElements)) {
      activable = target;
    }

    if (parents.length > 0) {
      activable = activable ? activable.add(parents) : parents;
    }

    if (activable && activable.length > 1) {
      const newActivable = [];
      let preventPropagation;

      for (let i = 0; i < activable.length; i += 1) {
        if (!preventPropagation) {
          newActivable.push(activable[i]);

          if (activable.eq(i).hasClass('prevent-active-state-propagation') || activable.eq(i).hasClass('no-active-state-propagation')) {
            preventPropagation = true;
          }
        }
      }

      activable = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(newActivable);
    }

    return activable || target;
  }

  function isInsideScrollableView(el) {
    const pageContent = el.parents('.page-content');
    return pageContent.length > 0;
  }

  function addActive() {
    if (!activableElement) return;
    activableElement.addClass('active-state');
  }

  function removeActive() {
    if (!activableElement) return;
    activableElement.removeClass('active-state');
    activableElement = null;
  } // Ripple handlers


  function findRippleElement(el) {
    const rippleElements = params.touchRippleElements;
    const $el = (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);

    if ($el.is(rippleElements)) {
      if ($el.hasClass('no-ripple')) {
        return false;
      }

      return $el;
    }

    if ($el.parents(rippleElements).length > 0) {
      const rippleParent = $el.parents(rippleElements).eq(0);

      if (rippleParent.hasClass('no-ripple')) {
        return false;
      }

      return rippleParent;
    }

    return false;
  }

  function createRipple($el, x, y) {
    if (!$el) return;
    rippleWave = app.touchRipple.create(app, $el, x, y);
  }

  function removeRipple() {
    if (!rippleWave) return;
    rippleWave.remove();
    rippleWave = undefined;
    rippleTarget = undefined;
  }

  function rippleTouchStart(el) {
    rippleTarget = findRippleElement(el);

    if (!rippleTarget || rippleTarget.length === 0) {
      rippleTarget = undefined;
      return;
    }

    const inScrollable = isInsideScrollableView(rippleTarget);

    if (!inScrollable) {
      removeRipple();
      createRipple(rippleTarget, touchStartX, touchStartY);
    } else {
      clearTimeout(rippleTimeout);
      rippleTimeout = setTimeout(() => {
        removeRipple();
        createRipple(rippleTarget, touchStartX, touchStartY);
      }, 80);
    }
  }

  function rippleTouchMove() {
    clearTimeout(rippleTimeout);
    removeRipple();
  }

  function rippleTouchEnd() {
    if (!rippleWave && rippleTarget && !isMoved) {
      clearTimeout(rippleTimeout);
      createRipple(rippleTarget, touchStartX, touchStartY);
      setTimeout(removeRipple, 0);
    } else {
      removeRipple();
    }
  } // Mouse Handlers


  function handleMouseDown(e) {
    const $activableEl = findActivableElement(e.target);

    if ($activableEl) {
      $activableEl.addClass('active-state');

      if ('which' in e && e.which === 3) {
        setTimeout(() => {
          (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.active-state').removeClass('active-state');
        }, 0);
      }
    }

    if (useRipple) {
      touchStartX = e.pageX;
      touchStartY = e.pageY;
      rippleTouchStart(e.target, e.pageX, e.pageY);
    }
  }

  function handleMouseMove() {
    if (!params.activeStateOnMouseMove) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.active-state').removeClass('active-state');
    }

    if (useRipple) {
      rippleTouchMove();
    }
  }

  function handleMouseUp() {
    (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.active-state').removeClass('active-state');

    if (useRipple) {
      rippleTouchEnd();
    }
  }

  function handleTouchCancel() {
    targetElement = null; // Remove Active State

    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);

    if (params.activeState) {
      removeActive();
    } // Remove Ripple


    if (useRipple) {
      rippleTouchEnd();
    }
  }

  let isScrolling;
  let isSegmentedStrong = false;
  let segmentedStrongEl = null;
  const touchMoveActivableIos = '.dialog-button, .actions-button';
  let isTouchMoveActivable = false;
  let touchmoveActivableEl = null;

  function handleTouchStart(e) {
    isMoved = false;
    tapHoldFired = false;
    preventClick = false;
    isScrolling = undefined;

    if (e.targetTouches.length > 1) {
      if (activableElement) removeActive();
      return true;
    }

    if (e.touches.length > 1 && activableElement) {
      removeActive();
    }

    if (params.tapHold) {
      if (tapHoldTimeout) clearTimeout(tapHoldTimeout);
      tapHoldTimeout = setTimeout(() => {
        if (e && e.touches && e.touches.length > 1) return;
        tapHoldFired = true;
        e.preventDefault();
        preventClick = true;
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).trigger('taphold', e);
        app.emit('taphold', e);
      }, params.tapHoldDelay);
    }

    targetElement = e.target;
    touchStartX = e.targetTouches[0].pageX;
    touchStartY = e.targetTouches[0].pageY;
    isSegmentedStrong = e.target.closest('.segmented-strong .button-active, .segmented-strong .tab-link-active');
    isTouchMoveActivable = app.theme === 'ios' && e.target.closest(touchMoveActivableIos);

    if (isSegmentedStrong) {
      segmentedStrongEl = isSegmentedStrong.closest('.segmented-strong');
    }

    if (params.activeState) {
      activableElement = findActivableElement(targetElement);

      if (activableElement && !isInsideScrollableView(activableElement)) {
        addActive();
      } else if (activableElement) {
        activeTimeout = setTimeout(addActive, 80);
      }
    }

    if (useRipple) {
      rippleTouchStart(targetElement, touchStartX, touchStartY);
    }

    return true;
  }

  function handleTouchMove(e) {
    let touch;
    let distance;
    let shouldRemoveActive = true;

    if (e.type === 'touchmove') {
      touch = e.targetTouches[0];
      distance = params.touchClicksDistanceThreshold;
    }

    const touchCurrentX = e.targetTouches[0].pageX;
    const touchCurrentY = e.targetTouches[0].pageY;

    if (typeof isScrolling === 'undefined') {
      isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
    }

    if (isTouchMoveActivable || !isScrolling && isSegmentedStrong && segmentedStrongEl) {
      if (e.cancelable) e.preventDefault();
    }

    if (!isScrolling && isSegmentedStrong && segmentedStrongEl) {
      const elementFromPoint = document.elementFromPoint(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
      const buttonEl = elementFromPoint.closest('.segmented-strong .button:not(.button-active):not(.tab-link-active)');

      if (buttonEl && segmentedStrongEl.contains(buttonEl)) {
        (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(buttonEl).trigger('click', 'f7Segmented');
        targetElement = buttonEl;
      }
    }

    if (distance && touch) {
      const pageX = touch.pageX;
      const pageY = touch.pageY;

      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
        isMoved = true;
      }
    } else {
      isMoved = true;
    }

    if (isMoved) {
      preventClick = true; // Keep active state on touchMove (for dialog and actions buttons)

      if (isTouchMoveActivable) {
        const elementFromPoint = document.elementFromPoint(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
        touchmoveActivableEl = elementFromPoint.closest(touchMoveActivableIos);

        if (touchmoveActivableEl && activableElement && activableElement[0] === touchmoveActivableEl) {
          shouldRemoveActive = false;
        } else if (touchmoveActivableEl) {
          setTimeout(() => {
            activableElement = findActivableElement(touchmoveActivableEl);
            addActive();
          });
        }
      }

      if (params.tapHold) {
        clearTimeout(tapHoldTimeout);
      }

      if (params.activeState && shouldRemoveActive) {
        clearTimeout(activeTimeout);
        removeActive();
      }

      if (useRipple) {
        rippleTouchMove();
      }
    }
  }

  function handleTouchEnd(e) {
    isScrolling = undefined;
    isSegmentedStrong = false;
    segmentedStrongEl = null;
    isTouchMoveActivable = false;
    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);

    if (touchmoveActivableEl) {
      (0,_shared_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(touchmoveActivableEl).trigger('click', 'f7TouchMoveActivable');
      touchmoveActivableEl = null;
    }

    if (document.activeElement === e.target) {
      if (params.activeState) removeActive();

      if (useRipple) {
        rippleTouchEnd();
      }

      return true;
    }

    if (params.activeState) {
      addActive();
      setTimeout(removeActive, 0);
    }

    if (useRipple) {
      rippleTouchEnd();
    }

    if (params.tapHoldPreventClicks && tapHoldFired || preventClick) {
      if (e.cancelable) e.preventDefault();
      preventClick = true;
      return false;
    }

    return true;
  }

  function handleClick(e) {
    const isOverswipe = e && e.detail && e.detail === 'f7Overswipe';
    const isSegmented = e && e.detail && e.detail === 'f7Segmented'; // eslint-disable-next-line

    const isTouchMoveActivable = e && e.detail && e.detail === 'f7TouchMoveActivable';
    let localPreventClick = preventClick;

    if (targetElement && e.target !== targetElement) {
      if (isOverswipe || isSegmented || isTouchMoveActivable) {
        localPreventClick = false;
      } else {
        localPreventClick = true;
      }
    } else if (isTouchMoveActivable) {
      localPreventClick = false;
    }

    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
      localPreventClick = true;
    }

    if (localPreventClick) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();
    }

    if (params.tapHold) {
      tapHoldTimeout = setTimeout(() => {
        tapHoldFired = false;
      }, device.ios || device.androidChrome ? 100 : 400);
    }

    preventClick = false;
    targetElement = null;
    return !localPreventClick;
  }

  function emitAppTouchEvent(name, e) {
    app.emit({
      events: name,
      data: [e]
    });
  }

  function appClick(e) {
    emitAppTouchEvent('click', e);
  }

  function appTouchStartActive(e) {
    emitAppTouchEvent('touchstart touchstart:active', e);
  }

  function appTouchMoveActive(e) {
    emitAppTouchEvent('touchmove touchmove:active', e);
  }

  function appTouchEndActive(e) {
    emitAppTouchEvent('touchend touchend:active', e);
  }

  function appTouchStartPassive(e) {
    emitAppTouchEvent('touchstart:passive', e);
  }

  function appTouchMovePassive(e) {
    emitAppTouchEvent('touchmove:passive', e);
  }

  function appTouchEndPassive(e) {
    emitAppTouchEvent('touchend:passive', e);
  }

  const passiveListener = support.passiveListener ? {
    passive: true
  } : false;
  const passiveListenerCapture = support.passiveListener ? {
    passive: true,
    capture: true
  } : true;
  const activeListener = support.passiveListener ? {
    passive: false
  } : false;
  const activeListenerCapture = support.passiveListener ? {
    passive: false,
    capture: true
  } : true;
  document.addEventListener('click', appClick, true);

  if (support.passiveListener) {
    document.addEventListener(app.touchEvents.start, appTouchStartActive, activeListenerCapture);
    document.addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);
    document.addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);
    document.addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListenerCapture);
    document.addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);
    document.addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);
  } else {
    document.addEventListener(app.touchEvents.start, e => {
      appTouchStartActive(e);
      appTouchStartPassive(e);
    }, true);
    document.addEventListener(app.touchEvents.move, e => {
      appTouchMoveActive(e);
      appTouchMovePassive(e);
    }, false);
    document.addEventListener(app.touchEvents.end, e => {
      appTouchEndActive(e);
      appTouchEndPassive(e);
    }, false);
  }

  if (support.touch) {
    app.on('click', handleClick);
    app.on('touchstart', handleTouchStart);
    app.on('touchmove', handleTouchMove);
    app.on('touchend', handleTouchEnd);
    document.addEventListener('touchcancel', handleTouchCancel, {
      passive: true
    });
  } else if (params.activeState) {
    app.on('touchstart', handleMouseDown);
    app.on('touchmove', handleMouseMove);
    app.on('touchend', handleMouseUp);
    document.addEventListener('pointercancel', handleMouseUp, {
      passive: true
    });
  }

  document.addEventListener('contextmenu', e => {
    if (params.disableContextMenu && (device.ios || device.android || device.cordova || window.Capacitor && window.Capacitor.isNative)) {
      e.preventDefault();
    }

    if (useRipple) {
      if (activableElement) removeActive();
      rippleTouchEnd();
    }
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'touch',
  params: {
    touch: {
      // Clicks
      touchClicksDistanceThreshold: 5,
      // ContextMenu
      disableContextMenu: false,
      // Tap Hold
      tapHold: false,
      tapHoldDelay: 750,
      tapHoldPreventClicks: true,
      // Active State
      activeState: true,
      activeStateElements: 'a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .menu-item, .link, .item-link, .accordion-item-toggle',
      activeStateOnMouseMove: false,
      mdTouchRipple: true,
      iosTouchRipple: false,
      auroraTouchRipple: false,
      touchRippleElements: '.ripple, .link, .item-link, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .menu-item-content, .list.accordion-list .accordion-item-toggle',
      touchRippleInsetElements: '.ripple-inset, .icon-only, .searchbar-disable-button, .input-clear-button, .notification-close-button, .md .navbar .link.back'
    }
  },

  create() {
    const app = this;
    const support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__.getSupport)();
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.extend)(app, {
      touchEvents: {
        start: support.touch ? 'touchstart' : support.pointerEvents ? 'pointerdown' : 'mousedown',
        move: support.touch ? 'touchmove' : support.pointerEvents ? 'pointermove' : 'mousemove',
        end: support.touch ? 'touchend' : support.pointerEvents ? 'pointerup' : 'mouseup'
      }
    });
  },

  on: {
    init: initTouch
  }
});

/***/ }),

/***/ "./node_modules/framework7/modules/utils/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7/modules/utils/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/framework7/shared/utils.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'utils',
  proto: {
    utils: _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__
  },
  static: {
    utils: _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__
  }
});

/***/ }),

/***/ "./node_modules/framework7/shared/$jsx.js":
/*!************************************************!*\
  !*** ./node_modules/framework7/shared/$jsx.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable prefer-rest-params */
const $jsx = function (tag, props) {
  const attrs = props || {};

  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  const children = args || [];
  const attrsString = Object.keys(attrs).map(attr => {
    if (attr[0] === '_') {
      if (attrs[attr]) return attr.replace('_', '');
      return '';
    }

    return `${attr}="${attrs[attr]}"`;
  }).filter(attr => !!attr).join(' ');

  if (['path', 'img', 'circle', 'polygon', 'line', 'input'].indexOf(tag) >= 0) {
    return `<${tag} ${attrsString} />`.trim();
  }

  const childrenContent = children.filter(c => !!c).map(c => Array.isArray(c) ? c.join('') : c).join('');
  return `<${tag} ${attrsString}>${childrenContent}</${tag}>`.trim();
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ($jsx);

/***/ }),

/***/ "./node_modules/framework7/shared/class.js":
/*!*************************************************!*\
  !*** ./node_modules/framework7/shared/class.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _events_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events-class.js */ "./node_modules/framework7/shared/events-class.js");



class Framework7Class extends _events_class_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(params, parents) {
    if (params === void 0) {
      params = {};
    }

    if (parents === void 0) {
      parents = [];
    }

    super(parents);
    const self = this;
    self.params = params;

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach(eventName => {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  } // eslint-disable-next-line


  useModuleParams(module, instanceParams) {
    if (module.params) {
      const originalParams = {};
      Object.keys(module.params).forEach(paramKey => {
        if (typeof instanceParams[paramKey] === 'undefined') return;
        originalParams[paramKey] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, instanceParams[paramKey]);
      });
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(instanceParams, module.params);
      Object.keys(originalParams).forEach(paramKey => {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(instanceParams[paramKey], originalParams[paramKey]);
      });
    }
  }

  useModulesParams(instanceParams) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(moduleName => {
      const module = instance.modules[moduleName]; // Extend params

      if (module.params) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(instanceParams, module.params);
      }
    });
  }

  useModule(moduleName, moduleParams) {
    if (moduleName === void 0) {
      moduleName = '';
    }

    if (moduleParams === void 0) {
      moduleParams = {};
    }

    const instance = this;
    if (!instance.modules) return;
    const module = typeof moduleName === 'string' ? instance.modules[moduleName] : moduleName;
    if (!module) return; // Extend instance methods and props

    if (module.instance) {
      Object.keys(module.instance).forEach(modulePropName => {
        const moduleProp = module.instance[modulePropName];

        if (typeof moduleProp === 'function') {
          instance[modulePropName] = moduleProp.bind(instance);
        } else {
          instance[modulePropName] = moduleProp;
        }
      });
    } // Add event listeners


    if (module.on && instance.on) {
      Object.keys(module.on).forEach(moduleEventName => {
        instance.on(moduleEventName, module.on[moduleEventName]);
      });
    } // Add vnode hooks


    if (module.vnode) {
      if (!instance.vnodeHooks) instance.vnodeHooks = {};
      Object.keys(module.vnode).forEach(vnodeId => {
        Object.keys(module.vnode[vnodeId]).forEach(hookName => {
          const handler = module.vnode[vnodeId][hookName];
          if (!instance.vnodeHooks[hookName]) instance.vnodeHooks[hookName] = {};
          if (!instance.vnodeHooks[hookName][vnodeId]) instance.vnodeHooks[hookName][vnodeId] = [];
          instance.vnodeHooks[hookName][vnodeId].push(handler.bind(instance));
        });
      });
    } // Module create callback


    if (module.create) {
      module.create.bind(instance)(moduleParams);
    }
  }

  useModules(modulesParams) {
    if (modulesParams === void 0) {
      modulesParams = {};
    }

    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(moduleName => {
      const moduleParams = modulesParams[moduleName] || {};
      instance.useModule(moduleName, moduleParams);
    });
  }

  static set components(components) {
    const Class = this;
    if (!Class.use) return;
    Class.use(components);
  }

  static installModule(module) {
    const Class = this;
    if (!Class.prototype.modules) Class.prototype.modules = {};
    const name = module.name || `${Object.keys(Class.prototype.modules).length}_${(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.now)()}`;
    Class.prototype.modules[name] = module; // Prototype

    if (module.proto) {
      Object.keys(module.proto).forEach(key => {
        Class.prototype[key] = module.proto[key];
      });
    } // Class


    if (module.static) {
      Object.keys(module.static).forEach(key => {
        Class[key] = module.static[key];
      });
    } // Callback


    if (module.install) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }

      module.install.apply(Class, params);
    }

    return Class;
  }

  static use(module) {
    const Class = this;

    if (Array.isArray(module)) {
      module.forEach(m => Class.installModule(m));
      return Class;
    }

    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }

    return Class.installModule(module, ...params);
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Framework7Class);

/***/ }),

/***/ "./node_modules/framework7/shared/constructor-methods.js":
/*!***************************************************************!*\
  !*** ./node_modules/framework7/shared/constructor-methods.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ConstructorMethods)
/* harmony export */ });
/* harmony import */ var _dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom7.js */ "./node_modules/framework7/shared/dom7.js");

function ConstructorMethods(parameters) {
  if (parameters === void 0) {
    parameters = {};
  }

  const {
    defaultSelector,
    constructor: Constructor,
    domProp,
    app,
    addMethods
  } = parameters;
  const methods = {
    create() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (app) return new Constructor(app, ...args);
      return new Constructor(...args);
    },

    get(el) {
      if (el === void 0) {
        el = defaultSelector;
      }

      if (el instanceof Constructor) return el;
      const $el = (0,_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
      if ($el.length === 0) return undefined;
      return $el[0][domProp];
    },

    destroy(el) {
      const instance = methods.get(el);
      if (instance && instance.destroy) return instance.destroy();
      return undefined;
    }

  };

  if (addMethods && Array.isArray(addMethods)) {
    addMethods.forEach(methodName => {
      methods[methodName] = function (el) {
        if (el === void 0) {
          el = defaultSelector;
        }

        const instance = methods.get(el);

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        if (instance && instance[methodName]) return instance[methodName](...args);
        return undefined;
      };
    });
  }

  return methods;
}

/***/ }),

/***/ "./node_modules/framework7/shared/dom7.js":
/*!************************************************!*\
  !*** ./node_modules/framework7/shared/dom7.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var dom7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dom7 */ "./node_modules/dom7/dom7.esm.js");
// eslint-disable-next-line

Object.keys(dom7__WEBPACK_IMPORTED_MODULE_0__).forEach(methodName => {
  if (methodName === '$') return;
  dom7__WEBPACK_IMPORTED_MODULE_0__.$.fn[methodName] = dom7__WEBPACK_IMPORTED_MODULE_0__[methodName];
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dom7__WEBPACK_IMPORTED_MODULE_0__.$);

/***/ }),

/***/ "./node_modules/framework7/shared/events-class.js":
/*!********************************************************!*\
  !*** ./node_modules/framework7/shared/events-class.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class EventsClass {
  constructor(parents) {
    if (parents === void 0) {
      parents = [];
    }

    const self = this;
    self.eventsParents = parents;
    self.eventsListeners = {};
  }

  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  }

  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;

    function onceHandler() {
      self.off(events, onceHandler);

      if (onceHandler.f7proxy) {
        delete onceHandler.f7proxy;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      handler.apply(self, args);
    }

    onceHandler.f7proxy = handler;
    return self.on(events, onceHandler, priority);
  }

  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.f7proxy && eventHandler.f7proxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  }

  emit() {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    let eventsParents;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
      eventsParents = self.eventsParents;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
      eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
    }

    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    const localEvents = eventsArray.map(eventName => eventName.replace('local::', ''));
    const parentEvents = eventsArray.filter(eventName => eventName.indexOf('local::') < 0);
    localEvents.forEach(event => {
      if (self.eventsListeners && self.eventsListeners[event]) {
        const handlers = [];
        self.eventsListeners[event].forEach(eventHandler => {
          handlers.push(eventHandler);
        });
        handlers.forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });

    if (eventsParents && eventsParents.length > 0) {
      eventsParents.forEach(eventsParent => {
        eventsParent.emit(parentEvents, ...data);
      });
    }

    return self;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventsClass);

/***/ }),

/***/ "./node_modules/framework7/shared/get-device.js":
/*!******************************************************!*\
  !*** ./node_modules/framework7/shared/get-device.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDevice": () => (/* binding */ getDevice)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _get_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-support.js */ "./node_modules/framework7/shared/get-support.js");
/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");


let deviceCalculated;

function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support = (0,_get_support_js__WEBPACK_IMPORTED_MODULE_1__.getSupport)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    iphone: false,
    ipod: false,
    ipad: false,
    edge: false,
    ie: false,
    firefox: false,
    macos: false,
    windows: false,
    cordova: !!window.cordova,
    electron: false,
    capacitor: !!window.Capacitor,
    nwjs: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS|iPhone;\sCPU\sOS)\s([\d_]+)/);
  const ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
  const edge = ua.indexOf('Edge/') >= 0;
  const firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
  const windows = platform === 'Win32';
  const electron = ua.toLowerCase().indexOf('electron') >= 0;
  const nwjs = typeof nw !== 'undefined' && typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.nw !== 'undefined';
  let macos = platform === 'MacIntel'; // iPadOs 13 fix

  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  }

  device.ie = ie;
  device.edge = edge;
  device.firefox = firefox; // Android

  if (android) {
    device.os = 'android';
    device.osVersion = android[2];
    device.android = true;
    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
  }

  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  } // iOS


  if (iphone && !ipod) {
    device.osVersion = iphone[2].replace(/_/g, '.');
    device.iphone = true;
  }

  if (ipad) {
    device.osVersion = ipad[2].replace(/_/g, '.');
    device.ipad = true;
  }

  if (ipod) {
    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    device.ipod = true;
  } // iOS 8+ changed UA


  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
    if (device.osVersion.split('.')[0] === '10') {
      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
    }
  } // Webview


  device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || window.navigator.standalone)) || window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
  device.webview = device.webView;
  device.standalone = device.webView; // Desktop

  device.desktop = !(device.ios || device.android) || electron || nwjs;

  if (device.desktop) {
    device.electron = electron;
    device.nwjs = nwjs;
    device.macos = macos;
    device.windows = windows;

    if (device.macos) {
      device.os = 'macos';
    }

    if (device.windows) {
      device.os = 'windows';
    }
  } // Pixel Ratio


  device.pixelRatio = window.devicePixelRatio || 1; // Color Scheme

  const DARK = '(prefers-color-scheme: dark)';
  const LIGHT = '(prefers-color-scheme: light)';

  device.prefersColorScheme = function prefersColorTheme() {
    let theme;

    if (window.matchMedia && window.matchMedia(LIGHT).matches) {
      theme = 'light';
    }

    if (window.matchMedia && window.matchMedia(DARK).matches) {
      theme = 'dark';
    }

    return theme;
  }; // Export object


  return device;
}

function getDevice(overrides, reset) {
  if (overrides === void 0) {
    overrides = {};
  }

  if (!deviceCalculated || reset) {
    deviceCalculated = calcDevice(overrides);
  }

  return deviceCalculated;
}



/***/ }),

/***/ "./node_modules/framework7/shared/get-support.js":
/*!*******************************************************!*\
  !*** ./node_modules/framework7/shared/get-support.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSupport": () => (/* binding */ getSupport)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

let support;

function calcSupport() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  return {
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
    passiveListener: function checkPassiveListener() {
      let supportsPassive = false;

      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          }

        });
        window.addEventListener('testPassiveListener', null, opts);
      } catch (e) {// No support
      }

      return supportsPassive;
    }(),
    intersectionObserver: function checkObserver() {
      return 'IntersectionObserver' in window;
    }()
  };
}

function getSupport() {
  if (!support) {
    support = calcSupport();
  }

  return support;
}



/***/ }),

/***/ "./node_modules/framework7/shared/history.js":
/*!***************************************************!*\
  !*** ./node_modules/framework7/shared/history.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _dom7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/framework7/shared/utils.js");



const History = {
  queue: [],

  clearQueue() {
    if (History.queue.length === 0) return;
    const currentQueue = History.queue.shift();
    currentQueue();
  },

  routerQueue: [],

  clearRouterQueue() {
    if (History.routerQueue.length === 0) return;
    const currentQueue = History.routerQueue.pop();
    const {
      router,
      stateUrl,
      action
    } = currentQueue;
    let animate = router.params.animate;
    if (router.params.browserHistoryAnimate === false) animate = false;

    if (action === 'back') {
      router.back({
        animate,
        browserHistory: false
      });
    }

    if (action === 'load') {
      router.navigate(stateUrl, {
        animate,
        browserHistory: false
      });
    }
  },

  handle(e) {
    if (History.blockPopstate) return;
    const app = this; // const mainView = app.views.main;

    let state = e.state;
    History.previousState = History.state;
    History.state = state;
    History.allowChange = true;
    History.clearQueue();
    state = History.state;
    if (!state) state = {};
    app.views.forEach(view => {
      const router = view.router;
      let viewState = state[view.id];

      if (!viewState && view.params.browserHistory) {
        viewState = {
          url: view.router.history[0]
        };
      }

      if (!viewState) return;
      const stateUrl = viewState.url || undefined;
      let animate = router.params.animate;
      if (router.params.browserHistoryAnimate === false) animate = false;

      if (stateUrl !== router.url) {
        if (router.history.indexOf(stateUrl) >= 0) {
          // Go Back
          if (router.allowPageChange) {
            router.back({
              animate,
              browserHistory: false
            });
          } else {
            History.routerQueue.push({
              action: 'back',
              router
            });
          }
        } else if (router.allowPageChange) {
          // Load page
          router.navigate(stateUrl, {
            animate,
            browserHistory: false
          });
        } else {
          History.routerQueue.unshift({
            action: 'load',
            stateUrl,
            router
          });
        }
      }
    });
  },

  initViewState(viewId, viewState) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const newState = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, History.state || {}, {
      [viewId]: viewState
    });
    History.state = newState;
    window.history.replaceState(newState, '');
  },

  push(viewId, viewState, url) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    /* eslint-disable no-param-reassign */

    if (url.substr(-3) === '#!/') {
      url = url.replace('#!/', '');

      if (url === '') {
        url = document.location.href;

        if (url.includes('#!/')) {
          url = document.location.href.split('#!/')[0];
        }
      }
    }
    /* eslint-enable no-param-reassign */


    if (!History.allowChange) {
      History.queue.push(() => {
        History.push(viewId, viewState, url);
      });
      return;
    }

    History.previousState = History.state;
    const newState = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, History.previousState || {}, {
      [viewId]: viewState
    });
    History.state = newState;
    window.history.pushState(newState, '', url);
  },

  replace(viewId, viewState, url) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

    if (url.substr(-3) === '#!/') {
      // eslint-disable-next-line
      url = url.replace('#!/', '');
    }

    if (!History.allowChange) {
      History.queue.push(() => {
        History.replace(viewId, viewState, url);
      });
      return;
    }

    History.previousState = History.state;
    const newState = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, History.previousState || {}, {
      [viewId]: viewState
    });
    History.state = newState;
    window.history.replaceState(newState, '', url);
  },

  go(index) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    History.allowChange = false;
    window.history.go(index);
  },

  back() {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    History.allowChange = false;
    window.history.back();
  },

  allowChange: true,
  previousState: {},
  state: {},
  blockPopstate: true,

  init(app) {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    History.state = window.history.state;
    (0,_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).on('load', () => {
      setTimeout(() => {
        History.blockPopstate = false;
      }, 0);
    });

    if (document.readyState && document.readyState === 'complete') {
      History.blockPopstate = false;
    }

    (0,_dom7_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).on('popstate', History.handle.bind(app));
  }

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (History);

/***/ }),

/***/ "./node_modules/framework7/shared/modal-methods.js":
/*!*********************************************************!*\
  !*** ./node_modules/framework7/shared/modal-methods.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ModalMethods)
/* harmony export */ });
/* harmony import */ var _dom7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom7.js */ "./node_modules/framework7/shared/dom7.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/framework7/shared/utils.js");
/* harmony import */ var _constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constructor-methods.js */ "./node_modules/framework7/shared/constructor-methods.js");



function ModalMethods(parameters) {
  if (parameters === void 0) {
    parameters = {};
  }

  const {
    defaultSelector,
    constructor: Constructor,
    app
  } = parameters;
  const methods = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_constructor_methods_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
    defaultSelector,
    constructor: Constructor,
    app,
    domProp: 'f7Modal'
  }), {
    open(el, animate, targetEl) {
      let $el = (0,_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);

      if ($el.length > 1 && targetEl) {
        // check if same modal in other page
        const $targetPage = (0,_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(targetEl).parents('.page');

        if ($targetPage.length) {
          $el.each(modalEl => {
            const $modalEl = (0,_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(modalEl);

            if ($modalEl.parents($targetPage)[0] === $targetPage[0]) {
              $el = $modalEl;
            }
          });
        }
      }

      if ($el.length > 1) {
        $el = $el.eq($el.length - 1);
      }

      if (!$el.length) return undefined;
      let instance = $el[0].f7Modal;

      if (!instance) {
        const params = $el.dataset();
        instance = new Constructor(app, {
          el: $el,
          ...params
        });
      }

      return instance.open(animate);
    },

    close(el, animate, targetEl) {
      if (el === void 0) {
        el = defaultSelector;
      }

      let $el = (0,_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
      if (!$el.length) return undefined;

      if ($el.length > 1) {
        // check if close link (targetEl) in this modal
        let $parentEl;

        if (targetEl) {
          const $targetEl = (0,_dom7_js__WEBPACK_IMPORTED_MODULE_0__["default"])(targetEl);

          if ($targetEl.length) {
            $parentEl = $targetEl.parents($el);
          }
        }

        if ($parentEl && $parentEl.length > 0) {
          $el = $parentEl;
        } else {
          $el = $el.eq($el.length - 1);
        }
      }

      let instance = $el[0].f7Modal;

      if (!instance) {
        const params = $el.dataset();
        instance = new Constructor(app, {
          el: $el,
          ...params
        });
      }

      return instance.close(animate);
    }

  });
  return methods;
}

/***/ }),

/***/ "./node_modules/framework7/shared/request.js":
/*!***************************************************!*\
  !*** ./node_modules/framework7/shared/request.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/framework7/shared/utils.js");
/* eslint-disable max-classes-per-file */


const globals = {};
let jsonpRequests = 0;

class RequestResponse {
  constructor(obj) {
    Object.assign(this, obj);
  }

}

class RequestError extends Error {
  constructor(obj) {
    super();
    Object.assign(this, obj);
  }

}

const request = requestOptions => new Promise((resolve, reject) => {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const globalsNoCallbacks = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, globals);
  'beforeCreate beforeOpen beforeSend error complete success statusCode'.split(' ').forEach(callbackName => {
    delete globalsNoCallbacks[callbackName];
  });
  const defaults = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({
    url: window.location.toString(),
    method: 'GET',
    data: false,
    async: true,
    cache: true,
    user: '',
    password: '',
    headers: {},
    xhrFields: {},
    statusCode: {},
    processData: true,
    dataType: 'text',
    contentType: 'application/x-www-form-urlencoded',
    timeout: 0
  }, globalsNoCallbacks);
  let proceedRequest;
  const options = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, defaults, requestOptions);

  if (requestOptions.abortController) {
    options.abortController = requestOptions.abortController;
  }

  if (options.abortController && options.abortController.canceled) {
    reject(new RequestError({
      options,
      status: 'canceled',
      message: 'canceled'
    }));
    return;
  } // Function to run XHR callbacks and events


  function fireCallback(callbackName) {
    /*
    Callbacks:
    beforeCreate (options),
    beforeOpen (xhr, options),
    beforeSend (xhr, options),
    error (xhr, status, message),
    complete (xhr, status),
    success (response, status, xhr),
    statusCode ()
    */
    let globalCallbackValue;
    let optionCallbackValue;

    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    if (globals[callbackName]) {
      globalCallbackValue = globals[callbackName](...data);
    }

    if (options[callbackName]) {
      optionCallbackValue = options[callbackName](...data);
    }

    if (typeof globalCallbackValue !== 'boolean') globalCallbackValue = true;
    if (typeof optionCallbackValue !== 'boolean') optionCallbackValue = true;

    if (options.abortController && options.abortController.canceled && (callbackName === 'beforeCreate' || callbackName === 'beforeOpen' || callbackName === 'beforeSend')) {
      return false;
    }

    return globalCallbackValue && optionCallbackValue;
  } // Before create callback


  proceedRequest = fireCallback('beforeCreate', options);

  if (proceedRequest === false) {
    reject(new RequestError({
      options,
      status: 'canceled',
      message: 'canceled'
    }));
    return;
  } // For jQuery guys


  if (options.type) options.method = options.type; // Parameters Prefix

  let paramsPrefix = options.url.indexOf('?') >= 0 ? '&' : '?'; // UC method

  const method = options.method.toUpperCase(); // Data to modify GET URL

  if ((method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') && options.data) {
    let stringData;

    if (typeof options.data === 'string') {
      // Should be key=value string
      if (options.data.indexOf('?') >= 0) stringData = options.data.split('?')[1];else stringData = options.data;
    } else {
      // Should be key=value object
      stringData = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.serializeObject)(options.data);
    }

    if (stringData.length) {
      options.url += paramsPrefix + stringData;
      if (paramsPrefix === '?') paramsPrefix = '&';
    }
  } // JSONP


  if (options.dataType === 'json' && options.url.indexOf('callback=') >= 0) {
    const callbackName = `f7jsonp_${Date.now() + (jsonpRequests += 1)}`;
    let abortTimeout;
    const callbackSplit = options.url.split('callback=');
    let requestUrl = `${callbackSplit[0]}callback=${callbackName}`;

    if (callbackSplit[1].indexOf('&') >= 0) {
      const addVars = callbackSplit[1].split('&').filter(el => el.indexOf('=') > 0).join('&');
      if (addVars.length > 0) requestUrl += `&${addVars}`;
    } // Create script


    let script = document.createElement('script');
    script.type = 'text/javascript';

    script.onerror = function onerror() {
      clearTimeout(abortTimeout);
      fireCallback('error', null, 'scripterror', 'scripterror');
      reject(new RequestError({
        options,
        status: 'scripterror',
        message: 'scripterror'
      }));
      fireCallback('complete', null, 'scripterror');
    };

    script.src = requestUrl; // Handler

    window[callbackName] = function jsonpCallback(data) {
      clearTimeout(abortTimeout);
      fireCallback('success', data);
      script.parentNode.removeChild(script);
      script = null;
      delete window[callbackName];
      resolve(new RequestResponse({
        options,
        data
      }));
    };

    document.querySelector('head').appendChild(script);

    if (options.timeout > 0) {
      abortTimeout = setTimeout(() => {
        script.parentNode.removeChild(script);
        script = null;
        fireCallback('error', null, 'timeout', 'timeout');
        reject(new RequestError({
          options,
          status: 'timeout',
          message: 'timeout'
        }));
      }, options.timeout);
    }

    return;
  } // Cache for GET/HEAD requests


  if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') {
    if (options.cache === false) {
      options.url += `${paramsPrefix}_nocache${Date.now()}`;
    }
  } // Create XHR


  const xhr = new XMLHttpRequest();

  if (options.abortController) {
    let aborted = false;

    options.abortController.onAbort = () => {
      if (aborted) return;
      aborted = true;
      xhr.abort();
      reject(new RequestError({
        options,
        xhr,
        status: 'canceled',
        message: 'canceled'
      }));
    };
  } // Save Request URL


  xhr.requestUrl = options.url;
  xhr.requestParameters = options; // Before open callback

  proceedRequest = fireCallback('beforeOpen', xhr, options);

  if (proceedRequest === false) {
    reject(new RequestError({
      options,
      xhr,
      status: 'canceled',
      message: 'canceled'
    }));
    return;
  } // Open XHR


  xhr.open(method, options.url, options.async, options.user, options.password); // Create POST Data

  let postData = null;

  if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && options.data) {
    if (options.processData) {
      const postDataInstances = [ArrayBuffer, Blob, Document, FormData]; // Post Data

      if (postDataInstances.indexOf(options.data.constructor) >= 0) {
        postData = options.data;
      } else {
        // POST Headers
        const boundary = `---------------------------${Date.now().toString(16)}`;

        if (options.contentType === 'multipart/form-data') {
          xhr.setRequestHeader('Content-Type', `multipart/form-data; boundary=${boundary}`);
        } else {
          xhr.setRequestHeader('Content-Type', options.contentType);
        }

        postData = '';
        let data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.serializeObject)(options.data);

        if (options.contentType === 'multipart/form-data') {
          data = data.split('&');
          const newData = [];

          for (let i = 0; i < data.length; i += 1) {
            newData.push(`Content-Disposition: form-data; name="${data[i].split('=')[0]}"\r\n\r\n${data[i].split('=')[1]}\r\n`);
          }

          postData = `--${boundary}\r\n${newData.join(`--${boundary}\r\n`)}--${boundary}--\r\n`;
        } else if (options.contentType === 'application/json') {
          postData = JSON.stringify(options.data);
        } else {
          postData = data;
        }
      }
    } else {
      postData = options.data;
      xhr.setRequestHeader('Content-Type', options.contentType);
    }
  }

  if (options.dataType === 'json' && (!options.headers || !options.headers.Accept)) {
    xhr.setRequestHeader('Accept', 'application/json');
  } // Additional headers


  if (options.headers) {
    Object.keys(options.headers).forEach(headerName => {
      if (typeof options.headers[headerName] === 'undefined') return;
      xhr.setRequestHeader(headerName, options.headers[headerName]);
    });
  } // Check for crossDomain


  if (typeof options.crossDomain === 'undefined') {
    options.crossDomain = // eslint-disable-next-line
    /^([\w-]+:)?\/\/([^\/]+)/.test(options.url) && RegExp.$2 !== window.location.host;
  }

  if (!options.crossDomain) {
    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  }

  if (options.xhrFields) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(xhr, options.xhrFields);
  } // Handle XHR


  xhr.onload = function onload() {
    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) {
      let responseData;

      if (options.dataType === 'json') {
        let parseError;

        try {
          responseData = JSON.parse(xhr.responseText);
        } catch (err) {
          parseError = true;
        }

        if (!parseError) {
          fireCallback('success', responseData, xhr.status, xhr);
          resolve(new RequestResponse({
            options,
            data: responseData,
            status: xhr.status,
            xhr
          }));
        } else {
          fireCallback('error', xhr, 'parseerror', 'parseerror');
          reject(new RequestError({
            options,
            xhr,
            status: 'parseerror',
            message: 'parseerror'
          }));
        }
      } else {
        responseData = xhr.responseType === 'text' || xhr.responseType === '' ? xhr.responseText : xhr.response;
        fireCallback('success', responseData, xhr.status, xhr);
        resolve(new RequestResponse({
          options,
          data: responseData,
          status: xhr.status,
          xhr
        }));
      }
    } else {
      fireCallback('error', xhr, xhr.status, xhr.statusText);
      reject(new RequestError({
        options,
        xhr,
        status: xhr.status,
        message: xhr.statusText
      }));
    }

    if (options.statusCode) {
      if (globals.statusCode && globals.statusCode[xhr.status]) globals.statusCode[xhr.status](xhr);
      if (options.statusCode[xhr.status]) options.statusCode[xhr.status](xhr);
    }

    fireCallback('complete', xhr, xhr.status);
  };

  xhr.onerror = function onerror() {
    fireCallback('error', xhr, xhr.status, xhr.status);
    reject(new RequestError({
      options,
      xhr,
      status: xhr.status,
      message: xhr.statusText
    }));
    fireCallback('complete', xhr, 'error');
  }; // Timeout


  if (options.timeout > 0) {
    xhr.timeout = options.timeout;

    xhr.ontimeout = () => {
      fireCallback('error', xhr, 'timeout', 'timeout');
      reject(new RequestError({
        options,
        xhr,
        status: 'timeout',
        message: 'timeout'
      }));
      fireCallback('complete', xhr, 'timeout');
    };
  } // Ajax start callback


  proceedRequest = fireCallback('beforeSend', xhr, options);

  if (proceedRequest === false) {
    reject(new RequestError({
      options,
      xhr,
      status: 'canceled',
      message: 'canceled'
    }));
    return;
  } // Send XHR


  xhr.send(postData);
});

function requestShortcut(method) {
  let [url, data, success, error, dataType] = [];

  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  if (typeof args[1] === 'function') {
    [url, success, error, dataType] = args;
  } else {
    [url, data, success, error, dataType] = args;
  }

  [success, error].forEach(callback => {
    if (typeof callback === 'string') {
      dataType = callback;
      if (callback === success) success = undefined;else error = undefined;
    }
  });
  dataType = dataType || (method === 'json' || method === 'postJSON' ? 'json' : undefined);
  const requestOptions = {
    url,
    method: method === 'post' || method === 'postJSON' ? 'POST' : 'GET',
    data,
    success,
    error,
    dataType
  };

  if (method === 'postJSON') {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(requestOptions, {
      contentType: 'application/json',
      processData: false,
      crossDomain: true,
      data: typeof data === 'string' ? data : JSON.stringify(data)
    });
  }

  return request(requestOptions);
}

Object.assign(request, {
  get: function () {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return requestShortcut('get', ...args);
  },
  post: function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return requestShortcut('post', ...args);
  },
  json: function () {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return requestShortcut('json', ...args);
  },
  getJSON: function () {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return requestShortcut('json', ...args);
  },
  postJSON: function () {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    return requestShortcut('postJSON', ...args);
  }
});

request.abortController = () => {
  const contoller = {
    canceled: false,
    onAbort: null,

    abort() {
      contoller.canceled = true;
      if (contoller.onAbort) contoller.onAbort();
    }

  };
  return contoller;
};

request.setup = function setup(options) {
  if (options.type && !options.method) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(options, {
      method: options.type
    });
  }

  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(globals, options);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (request);

/***/ }),

/***/ "./node_modules/framework7/shared/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/framework7/shared/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "auroraPreloaderContent": () => (/* binding */ auroraPreloaderContent),
/* harmony export */   "bindMethods": () => (/* binding */ bindMethods),
/* harmony export */   "cancelAnimationFrame": () => (/* binding */ cancelAnimationFrame),
/* harmony export */   "colorHexToRgb": () => (/* binding */ colorHexToRgb),
/* harmony export */   "colorHsbToHsl": () => (/* binding */ colorHsbToHsl),
/* harmony export */   "colorHslToHsb": () => (/* binding */ colorHslToHsb),
/* harmony export */   "colorHslToRgb": () => (/* binding */ colorHslToRgb),
/* harmony export */   "colorRgbToHex": () => (/* binding */ colorRgbToHex),
/* harmony export */   "colorRgbToHsl": () => (/* binding */ colorRgbToHsl),
/* harmony export */   "colorThemeCSSProperties": () => (/* binding */ colorThemeCSSProperties),
/* harmony export */   "deleteProps": () => (/* binding */ deleteProps),
/* harmony export */   "eventNameToColonCase": () => (/* binding */ eventNameToColonCase),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "flattenArray": () => (/* binding */ flattenArray),
/* harmony export */   "getTranslate": () => (/* binding */ getTranslate),
/* harmony export */   "id": () => (/* binding */ id),
/* harmony export */   "iosPreloaderContent": () => (/* binding */ iosPreloaderContent),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "mdPreloaderContent": () => (/* binding */ mdPreloaderContent),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "nextFrame": () => (/* binding */ nextFrame),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "parseUrlQuery": () => (/* binding */ parseUrlQuery),
/* harmony export */   "requestAnimationFrame": () => (/* binding */ requestAnimationFrame),
/* harmony export */   "serializeObject": () => (/* binding */ serializeObject),
/* harmony export */   "uniqueNumber": () => (/* binding */ uniqueNumber)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

let uniqueNum = 0;
function uniqueNumber() {
  uniqueNum += 1;
  return uniqueNum;
}
function id(mask, map) {
  if (mask === void 0) {
    mask = 'xxxxxxxxxx';
  }

  if (map === void 0) {
    map = '0123456789abcdef';
  }

  const length = map.length;
  return mask.replace(/x/g, () => map[Math.floor(Math.random() * length)]);
}
const mdPreloaderContent = `
  <span class="preloader-inner">
    <svg viewBox="0 0 36 36">
      <circle cx="18" cy="18" r="16"></circle>
    </svg>
  </span>
`.trim();
const iosPreloaderContent = `
  <span class="preloader-inner">
    ${[0, 1, 2, 3, 4, 5, 6, 7].map(() => '<span class="preloader-inner-line"></span>').join('')}
  </span>
`.trim();
const auroraPreloaderContent = `
  <span class="preloader-inner">
    <span class="preloader-inner-circle"></span>
  </span>
`;
function eventNameToColonCase(eventName) {
  let hasColon;
  return eventName.split('').map((char, index) => {
    if (char.match(/[A-Z]/) && index !== 0 && !hasColon) {
      hasColon = true;
      return `:${char.toLowerCase()}`;
    }

    return char.toLowerCase();
  }).join('');
}
function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {// no setter for object
    }

    try {
      delete object[key];
    } catch (e) {// something got wrong
    }
  });
}
function requestAnimationFrame(callback) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  return window.requestAnimationFrame(callback);
}
function cancelAnimationFrame(frameId) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  return window.cancelAnimationFrame(frameId);
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return setTimeout(callback, delay);
}
function nextFrame(callback) {
  return requestAnimationFrame(() => {
    requestAnimationFrame(callback);
  });
}
function now() {
  return Date.now();
}
function parseUrlQuery(url) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const query = {};
  let urlToParse = url || window.location.href;
  let i;
  let params;
  let param;
  let length;

  if (typeof urlToParse === 'string' && urlToParse.length) {
    urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
    params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');
    length = params.length;

    for (i = 0; i < length; i += 1) {
      param = params[i].replace(/#\S+/g, '').split('=');
      query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param.slice(1).join('=')) || '';
    }
  }

  return query;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }

  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = window.getComputedStyle(el, null);

  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;

    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    } // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case


    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }

  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }

  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }

  return curTransform || 0;
}
function serializeObject(obj, parents) {
  if (parents === void 0) {
    parents = [];
  }

  if (typeof obj === 'string') return obj;
  const resultArray = [];
  const separator = '&';
  let newParents;

  function varName(name) {
    if (parents.length > 0) {
      let parentParts = '';

      for (let j = 0; j < parents.length; j += 1) {
        if (j === 0) parentParts += parents[j];else parentParts += `[${encodeURIComponent(parents[j])}]`;
      }

      return `${parentParts}[${encodeURIComponent(name)}]`;
    }

    return encodeURIComponent(name);
  }

  function varValue(value) {
    return encodeURIComponent(value);
  }

  Object.keys(obj).forEach(prop => {
    let toPush;

    if (Array.isArray(obj[prop])) {
      toPush = [];

      for (let i = 0; i < obj[prop].length; i += 1) {
        if (!Array.isArray(obj[prop][i]) && typeof obj[prop][i] === 'object') {
          newParents = parents.slice();
          newParents.push(prop);
          newParents.push(String(i));
          toPush.push(serializeObject(obj[prop][i], newParents));
        } else {
          toPush.push(`${varName(prop)}[]=${varValue(obj[prop][i])}`);
        }
      }

      if (toPush.length > 0) resultArray.push(toPush.join(separator));
    } else if (obj[prop] === null || obj[prop] === '') {
      resultArray.push(`${varName(prop)}=`);
    } else if (typeof obj[prop] === 'object') {
      // Object, convert to named array
      newParents = parents.slice();
      newParents.push(prop);
      toPush = serializeObject(obj[prop], newParents);
      if (toPush !== '') resultArray.push(toPush);
    } else if (typeof obj[prop] !== 'undefined' && obj[prop] !== '') {
      // Should be string or plain value
      resultArray.push(`${varName(prop)}=${varValue(obj[prop])}`);
    } else if (obj[prop] === '') resultArray.push(varName(prop));
  });
  return resultArray.join(separator);
}
function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
}
function merge() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  const to = args[0];
  args.splice(0, 1);
  const from = args;

  for (let i = 0; i < from.length; i += 1) {
    const nextSource = args[i];

    if (nextSource !== undefined && nextSource !== null) {
      const keysArray = Object.keys(Object(nextSource));

      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
  }

  return to;
}
function extend() {
  let deep = true;
  let to;
  let from;

  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  if (typeof args[0] === 'boolean') {
    deep = args[0];
    to = args[1];
    args.splice(0, 2);
    from = args;
  } else {
    to = args[0];
    args.splice(0, 1);
    from = args;
  }

  for (let i = 0; i < from.length; i += 1) {
    const nextSource = args[i];

    if (nextSource !== undefined && nextSource !== null) {
      const keysArray = Object.keys(Object(nextSource));

      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          if (!deep) {
            to[nextKey] = nextSource[nextKey];
          } else if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            extend(to[nextKey], nextSource[nextKey]);
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            extend(to[nextKey], nextSource[nextKey]);
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }

  return to;
}
function colorHexToRgb(hex) {
  const h = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => r + r + g + g + b + b);
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
  return result ? result.slice(1).map(n => parseInt(n, 16)) : null;
}
function colorRgbToHex(r, g, b) {
  const result = [r, g, b].map(n => {
    const hex = n.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  }).join('');
  return `#${result}`;
}
function colorRgbToHsl(r, g, b) {
  r /= 255; // eslint-disable-line

  g /= 255; // eslint-disable-line

  b /= 255; // eslint-disable-line

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;
  let h;
  if (d === 0) h = 0;else if (max === r) h = (g - b) / d % 6;else if (max === g) h = (b - r) / d + 2;else if (max === b) h = (r - g) / d + 4;
  const l = (min + max) / 2;
  const s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
  if (h < 0) h = 360 / 60 + h;
  return [h * 60, s, l];
}
function colorHslToRgb(h, s, l) {
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const hp = h / 60;
  const x = c * (1 - Math.abs(hp % 2 - 1));
  let rgb1;

  if (Number.isNaN(h) || typeof h === 'undefined') {
    rgb1 = [0, 0, 0];
  } else if (hp <= 1) rgb1 = [c, x, 0];else if (hp <= 2) rgb1 = [x, c, 0];else if (hp <= 3) rgb1 = [0, c, x];else if (hp <= 4) rgb1 = [0, x, c];else if (hp <= 5) rgb1 = [x, 0, c];else if (hp <= 6) rgb1 = [c, 0, x];

  const m = l - c / 2;
  return rgb1.map(n => Math.max(0, Math.min(255, Math.round(255 * (n + m)))));
}
function colorHsbToHsl(h, s, b) {
  const HSL = {
    h,
    s: 0,
    l: 0
  };
  const HSB = {
    h,
    s,
    b
  };
  HSL.l = (2 - HSB.s) * HSB.b / 2;
  HSL.s = HSL.l && HSL.l < 1 ? HSB.s * HSB.b / (HSL.l < 0.5 ? HSL.l * 2 : 2 - HSL.l * 2) : HSL.s;
  return [HSL.h, HSL.s, HSL.l];
}
function colorHslToHsb(h, s, l) {
  const HSB = {
    h,
    s: 0,
    b: 0
  };
  const HSL = {
    h,
    s,
    l
  };
  const t = HSL.s * (HSL.l < 0.5 ? HSL.l : 1 - HSL.l);
  HSB.b = HSL.l + t;
  HSB.s = HSL.l > 0 ? 2 * t / HSB.b : HSB.s;
  return [HSB.h, HSB.s, HSB.b];
}
function colorThemeCSSProperties() {
  let hex;
  let rgb;

  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  if (args.length === 1) {
    hex = args[0];
    rgb = colorHexToRgb(hex);
  } else if (args.length === 3) {
    rgb = args;
    hex = colorRgbToHex(...rgb);
  }

  if (!rgb) return {};
  const hsl = colorRgbToHsl(...rgb);
  const hslShade = [hsl[0], hsl[1], Math.max(0, hsl[2] - 0.08)];
  const hslTint = [hsl[0], hsl[1], Math.max(0, hsl[2] + 0.08)];
  const shade = colorRgbToHex(...colorHslToRgb(...hslShade));
  const tint = colorRgbToHex(...colorHslToRgb(...hslTint));
  return {
    '--f7-theme-color': hex,
    '--f7-theme-color-rgb': rgb.join(', '),
    '--f7-theme-color-shade': shade,
    '--f7-theme-color-tint': tint
  };
}
function bindMethods(instance, obj) {
  Object.keys(obj).forEach(key => {
    if (isObject(obj[key])) {
      Object.keys(obj[key]).forEach(subKey => {
        if (typeof obj[key][subKey] === 'function') {
          obj[key][subKey] = obj[key][subKey].bind(instance);
        }
      });
    }

    instance[key] = obj[key];
  });
}
function flattenArray() {
  const arr = [];

  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  args.forEach(arg => {
    if (Array.isArray(arg)) arr.push(...flattenArray(...arg));else arr.push(arg);
  });
  return arr;
}

/***/ }),

/***/ "./node_modules/skeleton-elements/utils/multiply-svg-points.js":
/*!*********************************************************************!*\
  !*** ./node_modules/skeleton-elements/utils/multiply-svg-points.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function multiplySvgPoints(pointsString, iconSize, width, height) {
  const iconMaxSize = Math.min(width, height) * 0.5;
  const scale = iconMaxSize / iconSize;
  // eslint-disable-next-line
  return pointsString.replace(/([0-9,\.]{1,})/g, (coords) => {
    // eslint-disable-next-line
    coords = coords.split(',').map((p) => parseFloat(p));
    const x = coords[0] * scale + width / 2 - (iconSize * scale) / 2;
    const y = coords[1] * scale + height / 2 - (iconSize * scale) / 2;
    if (iconMaxSize >= 100) {
      return `${Math.round(x)},${Math.round(y)}`;
    }
    return `${x},${y}`;
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (multiplySvgPoints);


/***/ }),

/***/ "./node_modules/skeleton-elements/vue/SkeletonAvatar.js":
/*!**************************************************************!*\
  !*** ./node_modules/skeleton-elements/vue/SkeletonAvatar.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _utils_multiply_svg_points_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/multiply-svg-points.js */ "./node_modules/skeleton-elements/utils/multiply-svg-points.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'skeleton-avatar',
  props: {
    tag: {
      type: String,
      default: 'span'
    },
    size: {
      type: Number,
      default: 48
    },
    borderRadius: {
      type: [String, Number],
      default: '50%'
    },
    color: String,
    iconColor: String,
    showIcon: {
      type: Boolean,
      default: true
    },
    effect: String
  },

  render() {
    const {
      tag,
      color,
      iconColor,
      showIcon,
      size,
      borderRadius,
      effect
    } = this;
    return (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)(tag, {
      class: {
        'skeleton-avatar': true,
        [`skeleton-effect-${effect}`]: effect
      }
    }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('svg', {
      xmlns: 'http://www.w3.org/2000/svg',
      width: size,
      height: size,
      viewBox: `0 0 ${size} ${size}`,
      preserveAspectRatio: 'none'
    }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('rect', {
      style: {
        fill: color
      },
      fillRule: 'evenodd',
      width: size,
      height: size,
      rx: borderRadius
    }), showIcon && (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('path', {
      style: {
        fill: iconColor
      },
      d: (0,_utils_multiply_svg_points_js__WEBPACK_IMPORTED_MODULE_0__["default"])('M28.22461,27.1590817 C34.9209931,27.1590817 40.6829044,21.1791004 40.6829044,13.3926332 C40.6829044,5.69958662 34.8898972,0 28.22461,0 C21.5594557,0 15.7663156,5.82423601 15.7663156,13.4549579 C15.7663156,21.1791004 21.5594557,27.1590817 28.22461,27.1590817 Z M8.66515427,56 L47.7841986,56 C52.6739629,56 54.4181241,54.5984253 54.4181241,51.8576005 C54.4181241,43.8219674 44.358068,32.7341519 28.22461,32.7341519 C12.0600561,32.7341519 2,43.8219674 2,51.8576005 C2,54.5984253 3.74402832,56 8.66515427,56 Z', 56, size, size)
    })]), this.$slots.default && this.$slots.default()]);
  }

});

/***/ }),

/***/ "./node_modules/skeleton-elements/vue/SkeletonBlock.js":
/*!*************************************************************!*\
  !*** ./node_modules/skeleton-elements/vue/SkeletonBlock.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'skeleton-block',
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    width: [String, Number],
    height: [String, Number],
    borderRadius: String,
    effect: String
  },

  render() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(this.tag, {
      class: {
        'skeleton-block': true,
        [`skeleton-effect-${this.effect}`]: this.effect
      },
      style: {
        width: this.width,
        height: this.height,
        borderRadius: this.borderRadius
      }
    }, this.$slots.default && this.$slots.default());
  }

});

/***/ }),

/***/ "./node_modules/skeleton-elements/vue/SkeletonImage.js":
/*!*************************************************************!*\
  !*** ./node_modules/skeleton-elements/vue/SkeletonImage.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _utils_multiply_svg_points_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/multiply-svg-points.js */ "./node_modules/skeleton-elements/utils/multiply-svg-points.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'skeleton-image',
  props: {
    tag: {
      type: String,
      default: 'span'
    },
    width: {
      type: Number,
      default: 1200
    },
    height: {
      type: Number,
      default: 600
    },
    color: String,
    iconColor: String,
    showIcon: {
      type: Boolean,
      default: true
    },
    effect: String,
    borderRadius: String
  },

  render() {
    const {
      tag,
      color,
      iconColor,
      showIcon,
      width,
      height,
      effect,
      borderRadius
    } = this;
    return (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)(tag, {
      class: {
        'skeleton-image': true,
        [`skeleton-effect-${effect}`]: effect
      }
    }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('svg', {
      xmlns: 'http://www.w3.org/2000/svg',
      width,
      height,
      viewBox: `0 0 ${width} ${height}`,
      style: {
        borderRadius
      },
      preserveAspectRatio: 'none'
    }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('polygon', {
      style: {
        fill: color
      },
      fillRule: 'evenodd',
      points: `0 0 ${width} 0 ${width} ${height} 0 ${height}`
    }), showIcon && (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('path', {
      style: {
        fill: iconColor
      },
      d: (0,_utils_multiply_svg_points_js__WEBPACK_IMPORTED_MODULE_0__["default"])('M7.7148,49.5742 L48.2852,49.5742 C53.1836,49.5742 55.6446,47.1367 55.6446,42.3086 L55.6446,13.6914 C55.6446,8.8633 53.1836,6.4258 48.2852,6.4258 L7.7148,6.4258 C2.8398,6.4258 0.3554,8.8398 0.3554,13.6914 L0.3554,42.3086 C0.3554,47.1602 2.8398,49.5742 7.7148,49.5742 Z M39.2851,27.9414 C38.2304,27.0039 37.0351,26.5118 35.7695,26.5118 C34.457,26.5118 33.3085,26.9571 32.2304,27.918 L21.6366,37.3867 L17.3007,33.4492 C16.3163,32.582 15.2617,32.1133 14.1366,32.1133 C13.1054,32.1133 12.0976,32.5586 11.1366,33.4258 L4.1288,39.7305 L4.1288,13.8789 C4.1288,11.4414 5.4413,10.1992 7.7851,10.1992 L48.2147,10.1992 C50.535,10.1992 51.8708,11.4414 51.8708,13.8789 L51.8708,39.7539 L39.2851,27.9414 Z M17.8163,28.1992 C20.8398,28.1992 23.3241,25.7149 23.3241,22.668 C23.3241,19.6445 20.8398,17.1367 17.8163,17.1367 C14.7695,17.1367 12.2851,19.6445 12.2851,22.668 C12.2851,25.7149 14.7695,28.1992 17.8163,28.1992 Z', 56, width, height)
    })]), this.$slots.default && this.$slots.default()]);
  }

});

/***/ }),

/***/ "./node_modules/skeleton-elements/vue/SkeletonText.js":
/*!************************************************************!*\
  !*** ./node_modules/skeleton-elements/vue/SkeletonText.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'skeleton-text',
  props: {
    tag: {
      type: String,
      default: 'span'
    },
    effect: String
  },

  render() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(this.tag, {
      class: {
        'skeleton-text': true,
        [`skeleton-effect-${this.effect}`]: this.effect
      }
    }, this.$slots.default && this.$slots.default());
  }

});

/***/ }),

/***/ "./node_modules/skeleton-elements/vue/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/skeleton-elements/vue/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonAvatar": () => (/* reexport safe */ _SkeletonAvatar_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "SkeletonBlock": () => (/* reexport safe */ _SkeletonBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "SkeletonImage": () => (/* reexport safe */ _SkeletonImage_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "SkeletonText": () => (/* reexport safe */ _SkeletonText_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _SkeletonBlock_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SkeletonBlock.js */ "./node_modules/skeleton-elements/vue/SkeletonBlock.js");
/* harmony import */ var _SkeletonText_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SkeletonText.js */ "./node_modules/skeleton-elements/vue/SkeletonText.js");
/* harmony import */ var _SkeletonImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SkeletonImage.js */ "./node_modules/skeleton-elements/vue/SkeletonImage.js");
/* harmony import */ var _SkeletonAvatar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SkeletonAvatar.js */ "./node_modules/skeleton-elements/vue/SkeletonAvatar.js");






/***/ }),

/***/ "./node_modules/ssr-window/ssr-window.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/ssr-window/ssr-window.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "getDocument": () => (/* binding */ getDocument),
/* harmony export */   "getWindow": () => (/* binding */ getWindow),
/* harmony export */   "ssrDocument": () => (/* binding */ ssrDocument),
/* harmony export */   "ssrWindow": () => (/* binding */ ssrWindow)
/* harmony export */ });
/**
 * SSR Window 4.0.2
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: December 13, 2021
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend(target = {}, src = {}) {
    Object.keys(src).forEach((key) => {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (isObject(src[key]) &&
            isObject(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}

const ssrDocument = {
    body: {},
    addEventListener() { },
    removeEventListener() { },
    activeElement: {
        blur() { },
        nodeName: '',
    },
    querySelector() {
        return null;
    },
    querySelectorAll() {
        return [];
    },
    getElementById() {
        return null;
    },
    createEvent() {
        return {
            initEvent() { },
        };
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() { },
            getElementsByTagName() {
                return [];
            },
        };
    },
    createElementNS() {
        return {};
    },
    importNode() {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
function getDocument() {
    const doc = typeof document !== 'undefined' ? document : {};
    extend(doc, ssrDocument);
    return doc;
}

const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState() { },
        pushState() { },
        go() { },
        back() { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener() { },
    removeEventListener() { },
    getComputedStyle() {
        return {
            getPropertyValue() {
                return '';
            },
        };
    },
    Image() { },
    Date() { },
    screen: {},
    setTimeout() { },
    clearTimeout() { },
    matchMedia() {
        return {};
    },
    requestAnimationFrame(callback) {
        if (typeof setTimeout === 'undefined') {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
        if (typeof setTimeout === 'undefined') {
            return;
        }
        clearTimeout(id);
    },
};
function getWindow() {
    const win = typeof window !== 'undefined' ? window : {};
    extend(win, ssrWindow);
    return win;
}




/***/ }),

/***/ "./node_modules/swiper/components-shared/get-changed-params.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/components-shared/get-changed-params.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getChangedParams": () => (/* binding */ getChangedParams)
/* harmony export */ });
/* harmony import */ var _params_list_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./params-list.js */ "./node_modules/swiper/components-shared/params-list.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/swiper/components-shared/utils.js");



function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
  const keys = [];
  if (!oldParams) return keys;

  const addKey = key => {
    if (keys.indexOf(key) < 0) keys.push(key);
  };

  if (children && oldChildren) {
    const oldChildrenKeys = oldChildren.map(getKey);
    const childrenKeys = children.map(getKey);
    if (oldChildrenKeys.join('') !== childrenKeys.join('')) addKey('children');
    if (oldChildren.length !== children.length) addKey('children');
  }

  const watchParams = _params_list_js__WEBPACK_IMPORTED_MODULE_0__.paramsList.filter(key => key[0] === '_').map(key => key.replace(/_/, ''));
  watchParams.forEach(key => {
    if (key in swiperParams && key in oldParams) {
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(swiperParams[key]) && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);

        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach(newKey => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach(oldKey => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys;
}



/***/ }),

/***/ "./node_modules/swiper/components-shared/get-params.js":
/*!*************************************************************!*\
  !*** ./node_modules/swiper/components-shared/get-params.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getParams": () => (/* binding */ getParams)
/* harmony export */ });
/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ "./node_modules/swiper/swiper.esm.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/swiper/components-shared/utils.js");
/* harmony import */ var _params_list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./params-list.js */ "./node_modules/swiper/components-shared/params-list.js");




function getParams(obj = {}, splitEvents = true) {
  const params = {
    on: {}
  };
  const events = {};
  const passedParams = {};
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(params, swiper__WEBPACK_IMPORTED_MODULE_0__["default"].defaults);
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(params, swiper__WEBPACK_IMPORTED_MODULE_0__["default"].extendedDefaults);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = _params_list_js__WEBPACK_IMPORTED_MODULE_2__.paramsList.map(key => key.replace(/_/, ''));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach(key => {
    if (typeof obj[key] === 'undefined') return;

    if (allowedParams.indexOf(key) >= 0) {
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(params[key], obj[key]);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.extend)(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {
      if (splitEvents) {
        events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      } else {
        params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      }
    } else {
      rest[key] = obj[key];
    }
  });
  ['navigation', 'pagination', 'scrollbar'].forEach(key => {
    if (params[key] === true) params[key] = {};
    if (params[key] === false) delete params[key];
  });
  return {
    params,
    passedParams,
    rest,
    events
  };
}



/***/ }),

/***/ "./node_modules/swiper/components-shared/mount-swiper.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/components-shared/mount-swiper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mountSwiper": () => (/* binding */ mountSwiper)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/swiper/components-shared/utils.js");


function mountSwiper({
  el,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl,
  swiper
}, swiperParams) {
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.needsNavigation)(swiperParams) && nextEl && prevEl) {
    swiper.params.navigation.nextEl = nextEl;
    swiper.originalParams.navigation.nextEl = nextEl;
    swiper.params.navigation.prevEl = prevEl;
    swiper.originalParams.navigation.prevEl = prevEl;
  }

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.needsPagination)(swiperParams) && paginationEl) {
    swiper.params.pagination.el = paginationEl;
    swiper.originalParams.pagination.el = paginationEl;
  }

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.needsScrollbar)(swiperParams) && scrollbarEl) {
    swiper.params.scrollbar.el = scrollbarEl;
    swiper.originalParams.scrollbar.el = scrollbarEl;
  }

  swiper.init(el);
}



/***/ }),

/***/ "./node_modules/swiper/components-shared/params-list.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/components-shared/params-list.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "paramsList": () => (/* binding */ paramsList)
/* harmony export */ });
/* underscore in name -> watch for changes */
const paramsList = ['modules', 'init', '_direction', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', '_spaceBetween', '_slidesPerView', 'maxBackfaceHiddenSlides', '_grid', '_slidesPerGroup', '_slidesPerGroupSkip', '_slidesPerGroupAuto', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_preloadImages', 'updateOnImagesReady', '_loop', '_loopAdditionalSlides', '_loopedSlides', '_loopedSlidesLimit', '_loopFillGroupWithBlank', 'loopPreventsSlide', '_rewind', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideBlankClass', 'slideActiveClass', 'slideDuplicateActiveClass', 'slideVisibleClass', 'slideDuplicateClass', 'slideNextClass', 'slideDuplicateNextClass', 'slidePrevClass', 'slideDuplicatePrevClass', 'wrapperClass', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren', // modules
'a11y', '_autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'creativeEffect', 'cardsEffect', 'hashNavigation', 'history', 'keyboard', 'lazy', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', 'virtual', 'zoom'];


/***/ }),

/***/ "./node_modules/swiper/components-shared/update-on-virtual-data.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swiper/components-shared/update-on-virtual-data.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateOnVirtualData": () => (/* binding */ updateOnVirtualData)
/* harmony export */ });
const updateOnVirtualData = swiper => {
  if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;
  swiper.updateSlides();
  swiper.updateProgress();
  swiper.updateSlidesClasses();

  if (swiper.lazy && swiper.params.lazy.enabled) {
    swiper.lazy.load();
  }

  if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
    swiper.parallax.setTranslate();
  }
};

/***/ }),

/***/ "./node_modules/swiper/components-shared/update-swiper.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/components-shared/update-swiper.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateSwiper": () => (/* binding */ updateSwiper)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/swiper/components-shared/utils.js");


function updateSwiper({
  swiper,
  slides,
  passedParams,
  changedParams,
  nextEl,
  prevEl,
  scrollbarEl,
  paginationEl
}) {
  const updateParams = changedParams.filter(key => key !== 'children' && key !== 'direction');
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;

  if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }

  if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }

  if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }

  if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }

  if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }

  const destroyModule = mod => {
    if (!swiper[mod]) return;
    swiper[mod].destroy();

    if (mod === 'navigation') {
      currentParams[mod].prevEl = undefined;
      currentParams[mod].nextEl = undefined;
      swiper[mod].prevEl = undefined;
      swiper[mod].nextEl = undefined;
    } else {
      currentParams[mod].el = undefined;
      swiper[mod].el = undefined;
    }
  };

  updateParams.forEach(key => {
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(currentParams[key]) && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(passedParams[key])) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(currentParams[key], passedParams[key]);
    } else {
      const newValue = passedParams[key];

      if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });

  if (updateParams.includes('controller') && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper.controller.control = currentParams.controller.control;
  }

  if (changedParams.includes('children') && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  } else if (changedParams.includes('children') && swiper.lazy && swiper.params.lazy.enabled) {
    swiper.lazy.load();
  }

  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized) thumbs.update(true);
  }

  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }

  if (needPaginationInit) {
    if (paginationEl) currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }

  if (needScrollbarInit) {
    if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }

  if (needNavigationInit) {
    if (nextEl) currentParams.navigation.nextEl = nextEl;
    if (prevEl) currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }

  if (changedParams.includes('allowSlideNext')) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }

  if (changedParams.includes('allowSlidePrev')) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }

  if (changedParams.includes('direction')) {
    swiper.changeDirection(passedParams.direction, false);
  }

  swiper.update();
}



/***/ }),

/***/ "./node_modules/swiper/components-shared/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/components-shared/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "needsNavigation": () => (/* binding */ needsNavigation),
/* harmony export */   "needsPagination": () => (/* binding */ needsPagination),
/* harmony export */   "needsScrollbar": () => (/* binding */ needsScrollbar),
/* harmony export */   "uniqueClasses": () => (/* binding */ uniqueClasses)
/* harmony export */ });
function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}

function extend(target, src) {
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__) target[key] = src[key];else extend(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}

function needsNavigation(params = {}) {
  return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
}

function needsPagination(params = {}) {
  return params.pagination && typeof params.pagination.el === 'undefined';
}

function needsScrollbar(params = {}) {
  return params.scrollbar && typeof params.scrollbar.el === 'undefined';
}

function uniqueClasses(classNames = '') {
  const classes = classNames.split(' ').map(c => c.trim()).filter(c => !!c);
  const unique = [];
  classes.forEach(c => {
    if (unique.indexOf(c) < 0) unique.push(c);
  });
  return unique.join(' ');
}



/***/ }),

/***/ "./node_modules/swiper/core/breakpoints/getBreakpoint.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/breakpoints/getBreakpoint.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBreakpoint)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function getBreakpoint(breakpoints, base = 'window', containerEl) {
  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  let breakpoint = false;
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map(point => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }

    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));

  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];

    if (base === 'window') {
      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }

  return breakpoint || 'max';
}

/***/ }),

/***/ "./node_modules/swiper/core/breakpoints/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/breakpoints/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _setBreakpoint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setBreakpoint.js */ "./node_modules/swiper/core/breakpoints/setBreakpoint.js");
/* harmony import */ var _getBreakpoint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getBreakpoint.js */ "./node_modules/swiper/core/breakpoints/getBreakpoint.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setBreakpoint: _setBreakpoint_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  getBreakpoint: _getBreakpoint_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/breakpoints/setBreakpoint.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/breakpoints/setBreakpoint.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setBreakpoint)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");


const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};

function setBreakpoint() {
  const swiper = this;
  const {
    activeIndex,
    initialized,
    loopedSlides = 0,
    params,
    $el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasEnabled = params.enabled;

  if (wasMultiRow && !isMultiRow) {
    $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    $el.addClass(`${params.containerModifierClass}grid`);

    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      $el.addClass(`${params.containerModifierClass}grid-column`);
    }

    swiper.emitContainerClasses();
  } // Toggle navigation, pagination, scrollbar


  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;

    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }

    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

  if (directionChanged && initialized) {
    swiper.changeDirection();
  }

  (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });

  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }

  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);

  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate();
    swiper.updateSlides();
    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
  }

  swiper.emit('breakpoint', breakpointParams);
}

/***/ }),

/***/ "./node_modules/swiper/core/check-overflow/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/core/check-overflow/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;

  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }

  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }

  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  checkOverflow
});

/***/ }),

/***/ "./node_modules/swiper/core/classes/addClasses.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/core/classes/addClasses.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addClasses)
/* harmony export */ });
function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach(item => {
    if (typeof item === 'object') {
      Object.keys(item).forEach(classNames => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}

function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    $el,
    device,
    support
  } = swiper; // prettier-ignore

  const suffixes = prepareClasses(['initialized', params.direction, {
    'pointer-events': !support.touch
  }, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'grid': params.grid && params.grid.rows > 1
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }, {
    'centered': params.cssMode && params.centeredSlides
  }, {
    'watch-progress': params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  $el.addClass([...classNames].join(' '));
  swiper.emitContainerClasses();
}

/***/ }),

/***/ "./node_modules/swiper/core/classes/index.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/core/classes/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _addClasses_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addClasses.js */ "./node_modules/swiper/core/classes/addClasses.js");
/* harmony import */ var _removeClasses_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./removeClasses.js */ "./node_modules/swiper/core/classes/removeClasses.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  addClasses: _addClasses_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  removeClasses: _removeClasses_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/classes/removeClasses.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/core/classes/removeClasses.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ removeClasses)
/* harmony export */ });
function removeClasses() {
  const swiper = this;
  const {
    $el,
    classNames
  } = swiper;
  $el.removeClass(classNames.join(' '));
  swiper.emitContainerClasses();
}

/***/ }),

/***/ "./node_modules/swiper/core/core.js":
/*!******************************************!*\
  !*** ./node_modules/swiper/core/core.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* harmony import */ var _shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/get-support.js */ "./node_modules/swiper/shared/get-support.js");
/* harmony import */ var _shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/get-device.js */ "./node_modules/swiper/shared/get-device.js");
/* harmony import */ var _shared_get_browser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/get-browser.js */ "./node_modules/swiper/shared/get-browser.js");
/* harmony import */ var _modules_resize_resize_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/resize/resize.js */ "./node_modules/swiper/core/modules/resize/resize.js");
/* harmony import */ var _modules_observer_observer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/observer/observer.js */ "./node_modules/swiper/core/modules/observer/observer.js");
/* harmony import */ var _events_emitter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./events-emitter.js */ "./node_modules/swiper/core/events-emitter.js");
/* harmony import */ var _update_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./update/index.js */ "./node_modules/swiper/core/update/index.js");
/* harmony import */ var _translate_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./translate/index.js */ "./node_modules/swiper/core/translate/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/swiper/core/transition/index.js");
/* harmony import */ var _slide_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./slide/index.js */ "./node_modules/swiper/core/slide/index.js");
/* harmony import */ var _loop_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./loop/index.js */ "./node_modules/swiper/core/loop/index.js");
/* harmony import */ var _grab_cursor_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./grab-cursor/index.js */ "./node_modules/swiper/core/grab-cursor/index.js");
/* harmony import */ var _events_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./events/index.js */ "./node_modules/swiper/core/events/index.js");
/* harmony import */ var _breakpoints_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./breakpoints/index.js */ "./node_modules/swiper/core/breakpoints/index.js");
/* harmony import */ var _classes_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./classes/index.js */ "./node_modules/swiper/core/classes/index.js");
/* harmony import */ var _images_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./images/index.js */ "./node_modules/swiper/core/images/index.js");
/* harmony import */ var _check_overflow_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./check-overflow/index.js */ "./node_modules/swiper/core/check-overflow/index.js");
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/swiper/core/defaults.js");
/* harmony import */ var _moduleExtendParams_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./moduleExtendParams.js */ "./node_modules/swiper/core/moduleExtendParams.js");
/* eslint no-param-reassign: "off" */






















const prototypes = {
  eventsEmitter: _events_emitter_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  update: _update_index_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  translate: _translate_index_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  transition: _transition_index_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  slide: _slide_index_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  loop: _loop_index_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  grabCursor: _grab_cursor_index_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  events: _events_index_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  breakpoints: _breakpoints_index_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  checkOverflow: _check_overflow_index_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  classes: _classes_index_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  images: _images_index_js__WEBPACK_IMPORTED_MODULE_18__["default"]
};
const extendedDefaults = {};

class Swiper {
  constructor(...args) {
    let el;
    let params;

    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }

    if (!params) params = {};
    params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, params);
    if (el && !params.el) params.el = el;

    if (params.el && (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.el).length > 1) {
      const swipers = [];
      (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.el).each(containerEl => {
        const newParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      }); // eslint-disable-next-line no-constructor-return

      return swipers;
    } // Swiper Instance


    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = (0,_shared_get_support_js__WEBPACK_IMPORTED_MODULE_3__.getSupport)();
    swiper.device = (0,_shared_get_device_js__WEBPACK_IMPORTED_MODULE_4__.getDevice)({
      userAgent: params.userAgent
    });
    swiper.browser = (0,_shared_get_browser_js__WEBPACK_IMPORTED_MODULE_5__.getBrowser)();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];

    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }

    const allModulesParams = {};
    swiper.modules.forEach(mod => {
      mod({
        swiper,
        extendParams: (0,_moduleExtendParams_js__WEBPACK_IMPORTED_MODULE_21__["default"])(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    }); // Extend defaults with modules params

    const swiperParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, _defaults_js__WEBPACK_IMPORTED_MODULE_20__["default"], allModulesParams); // Extend defaults with passed params

    swiper.params = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, swiper.params);
    swiper.passedParams = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, params); // add event listeners

    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(eventName => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }

    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    } // Save Dom lib


    swiper.$ = _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"]; // Extend Swiper

    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },

      isVertical() {
        return swiper.params.direction === 'vertical';
      },

      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEvents: function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        const desktop = ['pointerdown', 'pointermove', 'pointerup'];
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit('_swiper'); // Init

    if (swiper.params.init) {
      swiper.init();
    } // Return app instance
    // eslint-disable-next-line no-constructor-return


    return swiper;
  }

  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;

    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    swiper.emit('enable');
  }

  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;

    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }

    swiper.emit('disable');
  }

  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(' ').filter(className => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }

  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed) return '';
    return slideEl.className.split(' ').filter(className => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }

  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.each(slideEl => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }

  slidesPerViewDynamic(view = 'current', exact = false) {
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;

    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;

      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }

      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      // eslint-disable-next-line
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;

          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        // previous
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;

          if (slideInView) {
            spv += 1;
          }
        }
      }
    }

    return spv;
  }

  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper; // Breakpoints

    if (params.breakpoints) {
      swiper.setBreakpoint();
    }

    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    let translated;

    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
      setTranslate();

      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (!translated) {
        setTranslate();
      }
    }

    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }

    swiper.emit('update');
  }

  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;

    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }

    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }

    swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each(slideEl => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  }

  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
    swiper.rtl = direction === 'rtl';
    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;

    if (swiper.rtl) {
      swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'rtl';
    } else {
      swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'ltr';
    }

    swiper.update();
  }

  mount(el) {
    const swiper = this;
    if (swiper.mounted) return true; // Find el

    const $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el || swiper.params.el);
    el = $el[0];

    if (!el) {
      return false;
    }

    el.swiper = swiper;

    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };

    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

        res.children = options => $el.children(options);

        return res;
      }

      if (!$el.children) {
        return (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])($el).children(getWrapperSelector());
      }

      return $el.children(getWrapperSelector());
    }; // Find Wrapper


    let $wrapperEl = getWrapper();

    if ($wrapperEl.length === 0 && swiper.params.createElements) {
      const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
      const wrapper = document.createElement('div');
      $wrapperEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(wrapper);
      wrapper.className = swiper.params.wrapperClass;
      $el.append(wrapper);
      $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
        $wrapperEl.append(slideEl);
      });
    }

    Object.assign(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box'
    });
    return true;
  }

  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit'); // Set breakpoint

    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    } // Add Classes


    swiper.addClasses(); // Create loop

    if (swiper.params.loop) {
      swiper.loopCreate();
    } // Update size


    swiper.updateSize(); // Update slides

    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    } // Set Grab Cursor


    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    } // Slide To Initial Slide


    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    } // Attach events


    swiper.attachEvents(); // Init Flag

    swiper.initialized = true; // Emit

    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }

  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params,
      $el,
      $wrapperEl,
      slides
    } = swiper;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy'); // Init Flag

    swiper.initialized = false; // Detach events

    swiper.detachEvents(); // Destroy loop

    if (params.loop) {
      swiper.loopDestroy();
    } // Cleanup styles


    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');

      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
      }
    }

    swiper.emit('destroy'); // Detach emitter events

    Object.keys(swiper.eventsListeners).forEach(eventName => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.deleteProps)(swiper);
    }

    swiper.destroyed = true;
    return null;
  }

  static extendDefaults(newDefaults) {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.extend)(extendedDefaults, newDefaults);
  }

  static get extendedDefaults() {
    return extendedDefaults;
  }

  static get defaults() {
    return _defaults_js__WEBPACK_IMPORTED_MODULE_20__["default"];
  }

  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;

    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }

  static use(module) {
    if (Array.isArray(module)) {
      module.forEach(m => Swiper.installModule(m));
      return Swiper;
    }

    Swiper.installModule(module);
    return Swiper;
  }

}

Object.keys(prototypes).forEach(prototypeGroup => {
  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([_modules_resize_resize_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modules_observer_observer_js__WEBPACK_IMPORTED_MODULE_7__["default"]]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Swiper);

/***/ }),

/***/ "./node_modules/swiper/core/defaults.js":
/*!**********************************************!*\
  !*** ./node_modules/swiper/core/defaults.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // Images
  preloadImages: true,
  updateOnImagesReady: true,
  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopedSlidesLimit: true,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
});

/***/ }),

/***/ "./node_modules/swiper/core/events-emitter.js":
/*!****************************************************!*\
  !*** ./node_modules/swiper/core/events-emitter.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable no-underscore-dangle */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  on(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },

  once(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;

    function onceHandler(...args) {
      self.off(events, onceHandler);

      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }

      handler.apply(self, args);
    }

    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },

  onAny(handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';

    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }

    return self;
  },

  offAny(handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);

    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }

    return self;
  },

  off(events, handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },

  emit(...args) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }

    data.unshift(context);
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(event => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(eventHandler => {
          eventHandler.apply(context, [event, ...data]);
        });
      }

      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }

});

/***/ }),

/***/ "./node_modules/swiper/core/events/index.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/core/events/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _onTouchStart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./onTouchStart.js */ "./node_modules/swiper/core/events/onTouchStart.js");
/* harmony import */ var _onTouchMove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./onTouchMove.js */ "./node_modules/swiper/core/events/onTouchMove.js");
/* harmony import */ var _onTouchEnd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./onTouchEnd.js */ "./node_modules/swiper/core/events/onTouchEnd.js");
/* harmony import */ var _onResize_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./onResize.js */ "./node_modules/swiper/core/events/onResize.js");
/* harmony import */ var _onClick_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./onClick.js */ "./node_modules/swiper/core/events/onClick.js");
/* harmony import */ var _onScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./onScroll.js */ "./node_modules/swiper/core/events/onScroll.js");







let dummyEventAttached = false;

function dummyEventListener() {}

const events = (swiper, method) => {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const {
    params,
    touchEvents,
    el,
    wrapperEl,
    device,
    support
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method; // Touch Events

  if (!support.touch) {
    el[domMethod](touchEvents.start, swiper.onTouchStart, false);
    document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
    document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
  } else {
    const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
    el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
      passive: false,
      capture
    } : capture);
    el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);

    if (touchEvents.cancel) {
      el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  } // Resize handler


  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', _onResize_js__WEBPACK_IMPORTED_MODULE_4__["default"], true);
  } else {
    swiper[swiperMethod]('observerUpdate', _onResize_js__WEBPACK_IMPORTED_MODULE_4__["default"], true);
  }
};

function attachEvents() {
  const swiper = this;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const {
    params,
    support
  } = swiper;
  swiper.onTouchStart = _onTouchStart_js__WEBPACK_IMPORTED_MODULE_1__["default"].bind(swiper);
  swiper.onTouchMove = _onTouchMove_js__WEBPACK_IMPORTED_MODULE_2__["default"].bind(swiper);
  swiper.onTouchEnd = _onTouchEnd_js__WEBPACK_IMPORTED_MODULE_3__["default"].bind(swiper);

  if (params.cssMode) {
    swiper.onScroll = _onScroll_js__WEBPACK_IMPORTED_MODULE_6__["default"].bind(swiper);
  }

  swiper.onClick = _onClick_js__WEBPACK_IMPORTED_MODULE_5__["default"].bind(swiper);

  if (support.touch && !dummyEventAttached) {
    document.addEventListener('touchstart', dummyEventListener);
    dummyEventAttached = true;
  }

  events(swiper, 'on');
}

function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  attachEvents,
  detachEvents
});

/***/ }),

/***/ "./node_modules/swiper/core/events/onClick.js":
/*!****************************************************!*\
  !*** ./node_modules/swiper/core/events/onClick.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onClick)
/* harmony export */ });
function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;

  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();

    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onResize.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/events/onResize.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onResize)
/* harmony export */ });
function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return; // Breakpoints

  if (params.breakpoints) {
    swiper.setBreakpoint();
  } // Save locks


  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper; // Disable locks on resize

  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();

  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  } // Return locks after resize


  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onScroll.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/events/onScroll.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onScroll)
/* harmony export */ });
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;

  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  } // eslint-disable-next-line


  if (swiper.translate === 0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onTouchEnd.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/events/onTouchEnd.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onTouchEnd)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }

  data.allowTouchCallbacks = false;

  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }

    data.isMoved = false;
    data.startMoving = false;
    return;
  } // Return Grab Cursor


  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  } // Time diff


  const touchEndTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)();
  const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
    swiper.emit('tap click', e);

    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)();
  (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;

  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (swiper.params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  } // Find current slide


  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];

  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  let rewindFirstIndex = null;
  let rewindLastIndex = null;

  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  } // Find current slide size


  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
    }

    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }

      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onTouchMove.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/core/events/onTouchMove.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onTouchMove)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");



function onTouchMove(event) {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    return;
  }

  if (data.isTouchEvent && e.type !== 'touchmove') return;
  const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }

  if (!swiper.allowTouchMove) {
    if (!(0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).is(data.focusableElements)) {
      swiper.allowClick = false;
    }

    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)();
    }

    return;
  }

  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }

  if (data.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).is(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }

  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }

  if (e.targetTouches && e.targetTouches.length > 1) return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;

    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }

  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }

  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }

  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }

  if (!data.startMoving) {
    return;
  }

  swiper.allowClick = false;

  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }

  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop && !params.cssMode) {
      swiper.loopFix();
    }

    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);

    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }

    data.allowMomentumBounce = false; // Grab Cursor

    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }

    swiper.emit('sliderFirstMove', e);
  }

  swiper.emit('sliderMove', e);
  data.isMoved = true;
  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) diff = -diff;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;

  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }

  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  } // Directions locks


  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  } // Threshold


  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return; // Update active index in free mode

  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  } // Update progress


  swiper.updateProgress(data.currentTranslate); // Update translate

  swiper.setTranslate(data.currentTranslate);
}

/***/ }),

/***/ "./node_modules/swiper/core/events/onTouchStart.js":
/*!*********************************************************!*\
  !*** ./node_modules/swiper/core/events/onTouchStart.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onTouchStart)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");


 // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd

function closestElement(selector, base = this) {
  function __closestFrom(el) {
    if (!el || el === (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)() || el === (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);

    if (!found && !el.getRootNode) {
      return null;
    }

    return found || __closestFrom(el.getRootNode().host);
  }

  return __closestFrom(base);
}

function onTouchStart(event) {
  const swiper = this;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }

  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }

  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let $targetEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }

  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return; // change target el for shadow root component

  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== ''; // eslint-disable-next-line

  const eventPath = event.composedPath ? event.composedPath() : event.path;

  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    $targetEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(eventPath[0]);
  }

  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
    swiper.allowClick = true;
    return;
  }

  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
    } else {
      return;
    }
  }

  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;

  if (e.type !== 'touchstart') {
    let preventDefault = true;

    if ($targetEl.is(data.focusableElements)) {
      preventDefault = false;

      if ($targetEl[0].nodeName === 'SELECT') {
        data.isTouched = false;
      }
    }

    if (document.activeElement && (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
      document.activeElement.blur();
    }

    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }

  if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }

  swiper.emit('touchStart', e);
}

/***/ }),

/***/ "./node_modules/swiper/core/grab-cursor/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/grab-cursor/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _setGrabCursor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setGrabCursor.js */ "./node_modules/swiper/core/grab-cursor/setGrabCursor.js");
/* harmony import */ var _unsetGrabCursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unsetGrabCursor.js */ "./node_modules/swiper/core/grab-cursor/unsetGrabCursor.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setGrabCursor: _setGrabCursor_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  unsetGrabCursor: _unsetGrabCursor_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/grab-cursor/setGrabCursor.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/grab-cursor/setGrabCursor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setGrabCursor)
/* harmony export */ });
function setGrabCursor(moving) {
  const swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  el.style.cursor = 'move';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

/***/ }),

/***/ "./node_modules/swiper/core/grab-cursor/unsetGrabCursor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swiper/core/grab-cursor/unsetGrabCursor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unsetGrabCursor)
/* harmony export */ });
function unsetGrabCursor() {
  const swiper = this;

  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }

  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
}

/***/ }),

/***/ "./node_modules/swiper/core/images/index.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/core/images/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _loadImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadImage.js */ "./node_modules/swiper/core/images/loadImage.js");
/* harmony import */ var _preloadImages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./preloadImages.js */ "./node_modules/swiper/core/images/preloadImages.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  loadImage: _loadImage_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  preloadImages: _preloadImages_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/images/loadImage.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/core/images/loadImage.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ loadImage)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let image;

  function onReady() {
    if (callback) callback();
  }

  const isPicture = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window.Image();
      image.onload = onReady;
      image.onerror = onReady;

      if (sizes) {
        image.sizes = sizes;
      }

      if (srcset) {
        image.srcset = srcset;
      }

      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/images/preloadImages.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/core/images/preloadImages.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ preloadImages)
/* harmony export */ });
function preloadImages() {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');

  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }

  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/loop/index.js":
/*!************************************************!*\
  !*** ./node_modules/swiper/core/loop/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _loopCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loopCreate.js */ "./node_modules/swiper/core/loop/loopCreate.js");
/* harmony import */ var _loopFix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loopFix.js */ "./node_modules/swiper/core/loop/loopFix.js");
/* harmony import */ var _loopDestroy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loopDestroy.js */ "./node_modules/swiper/core/loop/loopDestroy.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  loopCreate: _loopCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  loopFix: _loopFix_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  loopDestroy: _loopDestroy_js__WEBPACK_IMPORTED_MODULE_2__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/loop/loopCreate.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/loop/loopCreate.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ loopCreate)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function loopCreate() {
  const swiper = this;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const {
    params,
    $wrapperEl
  } = swiper; // Remove duplicated slides

  const $selector = $wrapperEl.children().length > 0 ? (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])($wrapperEl.children()[0].parentNode) : $wrapperEl;
  $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
  let slides = $selector.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $selector.append(blankNode);
      }

      slides = $selector.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;

  if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((el, index) => {
    const slide = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
    slide.attr('data-swiper-slide-index', index);
  });

  for (let i = 0; i < swiper.loopedSlides; i += 1) {
    const index = i - Math.floor(i / slides.length) * slides.length;
    appendSlides.push(slides.eq(index)[0]);
    prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);
  }

  for (let i = 0; i < appendSlides.length; i += 1) {
    $selector.append((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }

  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $selector.prepend((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/loop/loopDestroy.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/core/loop/loopDestroy.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ loopDestroy)
/* harmony export */ });
function loopDestroy() {
  const swiper = this;
  const {
    $wrapperEl,
    params,
    slides
  } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
}

/***/ }),

/***/ "./node_modules/swiper/core/loop/loopFix.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/core/loop/loopFix.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ loopFix)
/* harmony export */ });
function loopFix() {
  const swiper = this;
  swiper.emit('beforeLoopFix');
  const {
    activeIndex,
    slides,
    loopedSlides,
    allowSlidePrev,
    allowSlideNext,
    snapGrid,
    rtlTranslate: rtl
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }

  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit('loopFix');
}

/***/ }),

/***/ "./node_modules/swiper/core/moduleExtendParams.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/core/moduleExtendParams.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ moduleExtendParams)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj = {}) {
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];

    if (typeof moduleParams !== 'object' || moduleParams === null) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(allModulesParams, obj);
      return;
    }

    if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
      params[moduleParamName] = {
        auto: true
      };
    }

    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(allModulesParams, obj);
      return;
    }

    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }

    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }

    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(allModulesParams, obj);
  };
}

/***/ }),

/***/ "./node_modules/swiper/core/modules/observer/observer.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/modules/observer/observer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Observer)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function Observer({
  swiper,
  extendParams,
  on,
  emit
}) {
  const observers = [];
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  const attach = (target, options = {}) => {
    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    const observer = new ObserverFunc(mutations => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }

      const observerUpdate = function observerUpdate() {
        emit('observerUpdate', mutations[0]);
      };

      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    observers.push(observer);
  };

  const init = () => {
    if (!swiper.params.observer) return;

    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();

      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    } // Observe container


    attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    }); // Observe wrapper

    attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  };

  const destroy = () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };

  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on('init', init);
  on('destroy', destroy);
}

/***/ }),

/***/ "./node_modules/swiper/core/modules/resize/resize.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/core/modules/resize/resize.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Resize)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function Resize({
  swiper,
  on,
  emit
}) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let observer = null;
  let animationFrame = null;

  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('beforeResize');
    emit('resize');
  };

  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver(entries => {
      animationFrame = window.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(({
          contentBoxSize,
          contentRect,
          target
        }) => {
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });

        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };

  const removeObserver = () => {
    if (animationFrame) {
      window.cancelAnimationFrame(animationFrame);
    }

    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };

  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('orientationchange');
  };

  on('init', () => {
    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }

    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window.removeEventListener('resize', resizeHandler);
    window.removeEventListener('orientationchange', orientationChangeHandler);
  });
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/index.js":
/*!*************************************************!*\
  !*** ./node_modules/swiper/core/slide/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _slideTo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slideTo.js */ "./node_modules/swiper/core/slide/slideTo.js");
/* harmony import */ var _slideToLoop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slideToLoop.js */ "./node_modules/swiper/core/slide/slideToLoop.js");
/* harmony import */ var _slideNext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slideNext.js */ "./node_modules/swiper/core/slide/slideNext.js");
/* harmony import */ var _slidePrev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slidePrev.js */ "./node_modules/swiper/core/slide/slidePrev.js");
/* harmony import */ var _slideReset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./slideReset.js */ "./node_modules/swiper/core/slide/slideReset.js");
/* harmony import */ var _slideToClosest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./slideToClosest.js */ "./node_modules/swiper/core/slide/slideToClosest.js");
/* harmony import */ var _slideToClickedSlide_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./slideToClickedSlide.js */ "./node_modules/swiper/core/slide/slideToClickedSlide.js");







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  slideTo: _slideTo_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  slideToLoop: _slideToLoop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  slideNext: _slideNext_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  slidePrev: _slidePrev_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  slideReset: _slideReset_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  slideToClosest: _slideToClosest_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  slideToClickedSlide: _slideToClickedSlide_js__WEBPACK_IMPORTED_MODULE_6__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideNext.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideNext.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideNext)
/* harmony export */ });
/* eslint no-unused-vars: "off" */
function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    animating,
    enabled,
    params
  } = swiper;
  if (!enabled) return swiper;
  let perGroup = params.slidesPerGroup;

  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }

  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }

  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slidePrev.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/slide/slidePrev.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slidePrev)
/* harmony export */ });
/* eslint no-unused-vars: "off" */
function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params,
    animating,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return swiper;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  const translate = rtlTranslate ? swiper.translate : -swiper.translate;

  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }

  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        // prevSnap = snap;
        prevSnapIndex = snapIndex;
      }
    });

    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }

  let prevIndex = 0;

  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;

    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }

  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  }

  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideReset.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideReset.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideReset)
/* harmony export */ });
/* eslint no-unused-vars: "off" */
function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideTo.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideTo.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideTo)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
  if (typeof index !== 'number' && typeof index !== 'string') {
    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
  }

  if (typeof index === 'string') {
    /**
     * The `index` argument converted from `string` to `number`.
     * @type {number}
     */
    const indexAsNumber = parseInt(index, 10);
    /**
     * Determines whether the `index` argument is a valid `number`
     * after being converted from the `string` type.
     * @type {boolean}
     */

    const isValidNumber = isFinite(indexAsNumber);

    if (!isValidNumber) {
      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
    } // Knowing that the converted `index` is a valid number,
    // we can update the original argument's value.


    index = indexAsNumber;
  }

  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }

  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  const translate = -snapGrid[snapIndex]; // Normalize slideIndex

  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  } // Directions locks


  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }

    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  } // Update progress


  swiper.updateProgress(translate);
  let direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex); // Update Height

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    swiper.updateSlidesClasses();

    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }

    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }

    return false;
  }

  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;

    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }

      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;

      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._swiperImmediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.animateCSSModeScroll)({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top'
        });
        return true;
      }

      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth'
      });
    }

    return true;
  }

  swiper.setTransition(speed);
  swiper.setTranslate(translate);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks, direction);

  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;

    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
        if (!swiper || swiper.destroyed) return;
        if (e.target !== this) return;
        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }

    swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
    swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
  }

  return true;
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideToClickedSlide.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideToClickedSlide.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideToClickedSlide)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");


function slideToClickedSlide() {
  const swiper = this;
  const {
    params,
    $wrapperEl
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;

  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideToClosest.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideToClosest.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideToClosest)
/* harmony export */ });
/* eslint no-unused-vars: "off" */
function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
  const swiper = this;
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];

    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];

    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }

  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/slide/slideToLoop.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/slide/slideToLoop.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideToLoop)
/* harmony export */ });
function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  if (typeof index === 'string') {
    /**
     * The `index` argument converted from `string` to `number`.
     * @type {number}
     */
    const indexAsNumber = parseInt(index, 10);
    /**
     * Determines whether the `index` argument is a valid `number`
     * after being converted from the `string` type.
     * @type {boolean}
     */

    const isValidNumber = isFinite(indexAsNumber);

    if (!isValidNumber) {
      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
    } // Knowing that the converted `index` is a valid number,
    // we can update the original argument's value.


    index = indexAsNumber;
  }

  const swiper = this;
  let newIndex = index;

  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/***/ }),

/***/ "./node_modules/swiper/core/transition/index.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/core/transition/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _setTransition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setTransition.js */ "./node_modules/swiper/core/transition/setTransition.js");
/* harmony import */ var _transitionStart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transitionStart.js */ "./node_modules/swiper/core/transition/transitionStart.js");
/* harmony import */ var _transitionEnd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transitionEnd.js */ "./node_modules/swiper/core/transition/transitionEnd.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setTransition: _setTransition_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  transitionStart: _transitionStart_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  transitionEnd: _transitionEnd_js__WEBPACK_IMPORTED_MODULE_2__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/transition/setTransition.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/core/transition/setTransition.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setTransition)
/* harmony export */ });
function setTransition(duration, byController) {
  const swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}

/***/ }),

/***/ "./node_modules/swiper/core/transition/transitionEmit.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/transition/transitionEmit.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transitionEmit)
/* harmony export */ });
function transitionEmit({
  swiper,
  runCallbacks,
  direction,
  step
}) {
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit(`transition${step}`);

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }

    swiper.emit(`slideChangeTransition${step}`);

    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/transition/transitionEnd.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/core/transition/transitionEnd.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transitionEnd)
/* harmony export */ });
/* harmony import */ var _transitionEmit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transitionEmit.js */ "./node_modules/swiper/core/transition/transitionEmit.js");

function transitionEnd(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  (0,_transitionEmit_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    swiper,
    runCallbacks,
    direction,
    step: 'End'
  });
}

/***/ }),

/***/ "./node_modules/swiper/core/transition/transitionStart.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/core/transition/transitionStart.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transitionStart)
/* harmony export */ });
/* harmony import */ var _transitionEmit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transitionEmit.js */ "./node_modules/swiper/core/transition/transitionEmit.js");

function transitionStart(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;

  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  (0,_transitionEmit_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    swiper,
    runCallbacks,
    direction,
    step: 'Start'
  });
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/getTranslate.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/core/translate/getTranslate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getSwiperTranslate)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    $wrapperEl
  } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  if (params.cssMode) {
    return translate;
  }

  let currentTranslate = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.getTranslate)($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/core/translate/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getTranslate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getTranslate.js */ "./node_modules/swiper/core/translate/getTranslate.js");
/* harmony import */ var _setTranslate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setTranslate.js */ "./node_modules/swiper/core/translate/setTranslate.js");
/* harmony import */ var _minTranslate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./minTranslate.js */ "./node_modules/swiper/core/translate/minTranslate.js");
/* harmony import */ var _maxTranslate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./maxTranslate.js */ "./node_modules/swiper/core/translate/maxTranslate.js");
/* harmony import */ var _translateTo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./translateTo.js */ "./node_modules/swiper/core/translate/translateTo.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  getTranslate: _getTranslate_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  setTranslate: _setTranslate_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  minTranslate: _minTranslate_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  maxTranslate: _maxTranslate_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  translateTo: _translateTo_js__WEBPACK_IMPORTED_MODULE_4__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/translate/maxTranslate.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/core/translate/maxTranslate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ maxTranslate)
/* harmony export */ });
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/minTranslate.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/core/translate/minTranslate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ minTranslate)
/* harmony export */ });
function minTranslate() {
  return -this.snapGrid[0];
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/setTranslate.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/core/translate/setTranslate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setTranslate)
/* harmony export */ });
function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    $wrapperEl,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
  }

  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

/***/ }),

/***/ "./node_modules/swiper/core/translate/translateTo.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/core/translate/translateTo.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ translateTo)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    const isH = swiper.isHorizontal();

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.animateCSSModeScroll)({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top'
        });
        return true;
      }

      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth'
      });
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;

          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}

/***/ }),

/***/ "./node_modules/swiper/core/update/index.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/core/update/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _updateSize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./updateSize.js */ "./node_modules/swiper/core/update/updateSize.js");
/* harmony import */ var _updateSlides_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./updateSlides.js */ "./node_modules/swiper/core/update/updateSlides.js");
/* harmony import */ var _updateAutoHeight_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateAutoHeight.js */ "./node_modules/swiper/core/update/updateAutoHeight.js");
/* harmony import */ var _updateSlidesOffset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./updateSlidesOffset.js */ "./node_modules/swiper/core/update/updateSlidesOffset.js");
/* harmony import */ var _updateSlidesProgress_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./updateSlidesProgress.js */ "./node_modules/swiper/core/update/updateSlidesProgress.js");
/* harmony import */ var _updateProgress_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./updateProgress.js */ "./node_modules/swiper/core/update/updateProgress.js");
/* harmony import */ var _updateSlidesClasses_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./updateSlidesClasses.js */ "./node_modules/swiper/core/update/updateSlidesClasses.js");
/* harmony import */ var _updateActiveIndex_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./updateActiveIndex.js */ "./node_modules/swiper/core/update/updateActiveIndex.js");
/* harmony import */ var _updateClickedSlide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./updateClickedSlide.js */ "./node_modules/swiper/core/update/updateClickedSlide.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  updateSize: _updateSize_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  updateSlides: _updateSlides_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  updateAutoHeight: _updateAutoHeight_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  updateSlidesOffset: _updateSlidesOffset_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  updateSlidesProgress: _updateSlidesProgress_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  updateProgress: _updateProgress_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  updateSlidesClasses: _updateSlidesClasses_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  updateActiveIndex: _updateActiveIndex_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  updateClickedSlide: _updateClickedSlide_js__WEBPACK_IMPORTED_MODULE_8__["default"]
});

/***/ }),

/***/ "./node_modules/swiper/core/update/updateActiveIndex.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateActiveIndex.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateActiveIndex)
/* harmony export */ });
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid,
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;

  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    } // Normalize slideIndex


    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }

  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }

  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }

    return;
  } // Get real index


  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
  Object.assign(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');

  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }

  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateAutoHeight.js":
/*!*************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateAutoHeight.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateAutoHeight)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");

function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;

  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }

  const getSlideByIndex = index => {
    if (isVirtual) {
      return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
    }

    return swiper.slides.eq(index)[0];
  }; // Find slides currently in view


  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])([])).each(slide => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  } // Find new height from highest slide in view


  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  } // Update Height


  if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateClickedSlide.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateClickedSlide.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateClickedSlide)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");

function updateClickedSlide(e) {
  const swiper = this;
  const params = swiper.params;
  const slide = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  let slideIndex;

  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;

    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }

  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateProgress.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/core/update/updateProgress.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateProgress)
/* harmony export */ });
function updateProgress(translate) {
  const swiper = this;

  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }

  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;

  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }

  Object.assign(swiper, {
    progress,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }

  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }

  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSize.js":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSize.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSize)
/* harmony export */ });
function updateSize() {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;

  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }

  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }

  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  } // Subtract paddings


  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSlides.js":
/*!*********************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSlides.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSlides)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function updateSlides() {
  const swiper = this;

  function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    } // prettier-ignore


    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }

  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }

  const params = swiper.params;
  const {
    $wrapperEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;

  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;

  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;

  if (typeof swiperSize === 'undefined') {
    return;
  }

  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  }

  swiper.virtualSize = -spaceBetween; // reset margins

  if (rtl) slides.css({
    marginLeft: '',
    marginBottom: '',
    marginTop: ''
  });else slides.css({
    marginRight: '',
    marginBottom: '',
    marginTop: ''
  }); // reset cssMode offsets

  if (params.centeredSlides && params.cssMode) {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCSSProperty)(swiper.wrapperEl, '--swiper-centered-offset-before', '');
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCSSProperty)(swiper.wrapperEl, '--swiper-centered-offset-after', '');
  }

  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;

  if (gridEnabled) {
    swiper.grid.initSlides(slidesLength);
  } // Calc slides


  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;

  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);

    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
    }

    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[getDirectionLabel('width')] = ``;
      }

      const slideStyles = getComputedStyle(slide[0]);
      const currentTransform = slide[0].style.transform;
      const currentWebKitTransform = slide[0].style.webkitTransform;

      if (currentTransform) {
        slide[0].style.transform = 'none';
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }

      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');

        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide[0];
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }

      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }

      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
      }
    }

    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }

    slidesSizesGrid.push(slideSize);

    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }

  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;

  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({
      width: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }

  if (params.setWrapperSize) {
    $wrapperEl.css({
      [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }

  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
  } // Remove last grid elements depending on width


  if (!params.centeredSlides) {
    const newSlidesGrid = [];

    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);

      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }

    snapGrid = newSlidesGrid;

    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }

  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode) return true;

      if (slideIndex === slides.length - 1) {
        return false;
      }

      return true;
    }).css({
      [key]: `${spaceBetween}px`
    });
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(snap => {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;

    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });

  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCSSProperty)(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCSSProperty)(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
  }

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }

  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }

  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }

  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);

    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.$el.removeClass(backFaceHiddenClass);
    }
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSlidesClasses.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSlidesClasses.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSlidesClasses)
/* harmony export */ });
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    $wrapperEl,
    activeIndex,
    realIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
  let activeSlide;

  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  } // Active classes


  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    }
  } // Next Slide


  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);

  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  } // Prev Slide


  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);

  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }

  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
    }

    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
    }
  }

  swiper.emitSlidesClasses();
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSlidesOffset.js":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSlidesOffset.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSlidesOffset)
/* harmony export */ });
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;

  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

/***/ }),

/***/ "./node_modules/swiper/core/update/updateSlidesProgress.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swiper/core/update/updateSlidesProgress.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateSlidesProgress)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");

function updateSlidesProgress(translate = this && this.translate || 0) {
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate; // Visible Slides

  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;

    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }

    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
      slides.eq(i).addClass(params.slideVisibleClass);
    }

    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }

  swiper.visibleSlides = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.visibleSlides);
}

/***/ }),

/***/ "./node_modules/swiper/modules/a11y/a11y.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/a11y/a11y.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ A11y)
/* harmony export */ });
/* harmony import */ var _shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/classes-to-selector.js */ "./node_modules/swiper/shared/classes-to-selector.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function A11y({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group',
      id: null
    }
  });
  swiper.a11y = {
    clicked: false
  };
  let liveRegion = null;

  function notify(message) {
    const notification = liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  }

  function getRandomNumber(size = 16) {
    const randomChar = () => Math.round(16 * Math.random()).toString(16);

    return 'x'.repeat(size).replace(/x/g, randomChar);
  }

  function makeElFocusable($el) {
    $el.attr('tabIndex', '0');
  }

  function makeElNotFocusable($el) {
    $el.attr('tabIndex', '-1');
  }

  function addElRole($el, role) {
    $el.attr('role', role);
  }

  function addElRoleDescription($el, description) {
    $el.attr('aria-roledescription', description);
  }

  function addElControls($el, controls) {
    $el.attr('aria-controls', controls);
  }

  function addElLabel($el, label) {
    $el.attr('aria-label', label);
  }

  function addElId($el, id) {
    $el.attr('id', id);
  }

  function addElLive($el, live) {
    $el.attr('aria-live', live);
  }

  function disableEl($el) {
    $el.attr('aria-disabled', true);
  }

  function enableEl($el) {
    $el.attr('aria-disabled', false);
  }

  function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    const params = swiper.params.a11y;
    const $targetEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target);

    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }

      if (swiper.isEnd) {
        notify(params.lastSlideMessage);
      } else {
        notify(params.nextSlideMessage);
      }
    }

    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }

      if (swiper.isBeginning) {
        notify(params.firstSlideMessage);
      } else {
        notify(params.prevSlideMessage);
      }
    }

    if (swiper.pagination && $targetEl.is((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.params.pagination.bulletClass))) {
      $targetEl[0].click();
    }
  }

  function updateNavigation() {
    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        disableEl($prevEl);
        makeElNotFocusable($prevEl);
      } else {
        enableEl($prevEl);
        makeElFocusable($prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        disableEl($nextEl);
        makeElNotFocusable($nextEl);
      } else {
        enableEl($nextEl);
        makeElFocusable($nextEl);
      }
    }
  }

  function hasPagination() {
    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
  }

  function hasClickablePagination() {
    return hasPagination() && swiper.params.pagination.clickable;
  }

  function updatePagination() {
    const params = swiper.params.a11y;
    if (!hasPagination()) return;
    swiper.pagination.bullets.each(bulletEl => {
      const $bulletEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bulletEl);

      if (swiper.params.pagination.clickable) {
        makeElFocusable($bulletEl);

        if (!swiper.params.pagination.renderBullet) {
          addElRole($bulletEl, 'button');
          addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
        }
      }

      if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {
        $bulletEl.attr('aria-current', 'true');
      } else {
        $bulletEl.removeAttr('aria-current');
      }
    });
  }

  const initNavEl = ($el, wrapperId, message) => {
    makeElFocusable($el);

    if ($el[0].tagName !== 'BUTTON') {
      addElRole($el, 'button');
      $el.on('keydown', onEnterOrSpaceKey);
    }

    addElLabel($el, message);
    addElControls($el, wrapperId);
  };

  const handlePointerDown = () => {
    swiper.a11y.clicked = true;
  };

  const handlePointerUp = () => {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (!swiper.destroyed) {
          swiper.a11y.clicked = false;
        }
      });
    });
  };

  const handleFocus = e => {
    if (swiper.a11y.clicked) return;
    const slideEl = e.target.closest(`.${swiper.params.slideClass}`);
    if (!slideEl || !swiper.slides.includes(slideEl)) return;
    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
    if (isActive || isVisible) return;
    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;

    if (swiper.isHorizontal()) {
      swiper.el.scrollLeft = 0;
    } else {
      swiper.el.scrollTop = 0;
    }

    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
  };

  const initSlides = () => {
    const params = swiper.params.a11y;

    if (params.itemRoleDescriptionMessage) {
      addElRoleDescription((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.slides), params.itemRoleDescriptionMessage);
    }

    if (params.slideRole) {
      addElRole((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.slides), params.slideRole);
    }

    const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;

    if (params.slideLabelMessage) {
      swiper.slides.each((slideEl, index) => {
        const $slideEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl);
        const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
        const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
        addElLabel($slideEl, ariaLabelMessage);
      });
    }
  };

  const init = () => {
    const params = swiper.params.a11y;
    swiper.$el.append(liveRegion); // Container

    const $containerEl = swiper.$el;

    if (params.containerRoleDescriptionMessage) {
      addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
    }

    if (params.containerMessage) {
      addElLabel($containerEl, params.containerMessage);
    } // Wrapper


    const $wrapperEl = swiper.$wrapperEl;
    const wrapperId = params.id || $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;
    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
    addElId($wrapperEl, wrapperId);
    addElLive($wrapperEl, live); // Slide

    initSlides(); // Navigation

    let $nextEl;
    let $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl && $nextEl.length) {
      initNavEl($nextEl, wrapperId, params.nextSlideMessage);
    }

    if ($prevEl && $prevEl.length) {
      initNavEl($prevEl, wrapperId, params.prevSlideMessage);
    } // Pagination


    if (hasClickablePagination()) {
      swiper.pagination.$el.on('keydown', (0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
    } // Tab focus


    swiper.$el.on('focus', handleFocus, true);
    swiper.$el.on('pointerdown', handlePointerDown, true);
    swiper.$el.on('pointerup', handlePointerUp, true);
  };

  function destroy() {
    if (liveRegion && liveRegion.length > 0) liveRegion.remove();
    let $nextEl;
    let $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl) {
      $nextEl.off('keydown', onEnterOrSpaceKey);
    }

    if ($prevEl) {
      $prevEl.off('keydown', onEnterOrSpaceKey);
    } // Pagination


    if (hasClickablePagination()) {
      swiper.pagination.$el.off('keydown', (0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
    } // Tab focus


    swiper.$el.off('focus', handleFocus, true);
    swiper.$el.off('pointerdown', handlePointerDown, true);
    swiper.$el.off('pointerup', handlePointerUp, true);
  }

  on('beforeInit', () => {
    liveRegion = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
  });
  on('afterInit', () => {
    if (!swiper.params.a11y.enabled) return;
    init();
  });
  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {
    if (!swiper.params.a11y.enabled) return;
    initSlides();
  });
  on('fromEdge toEdge afterInit lock unlock', () => {
    if (!swiper.params.a11y.enabled) return;
    updateNavigation();
  });
  on('paginationUpdate', () => {
    if (!swiper.params.a11y.enabled) return;
    updatePagination();
  });
  on('destroy', () => {
    if (!swiper.params.a11y.enabled) return;
    destroy();
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/autoplay/autoplay.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/modules/autoplay/autoplay.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Autoplay)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* eslint no-underscore-dangle: "off" */

/* eslint no-use-before-define: "off" */


function Autoplay({
  swiper,
  extendParams,
  on,
  emit
}) {
  let timeout;
  swiper.autoplay = {
    running: false,
    paused: false
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });

  function run() {
    if (!swiper.size) {
      swiper.autoplay.running = false;
      swiper.autoplay.paused = false;
      return;
    }

    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;

    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }

    clearTimeout(timeout);
    timeout = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {
      let autoplayResult;

      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          emit('autoplay');
        } else {
          stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit('autoplay');
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        emit('autoplay');
      } else {
        stop();
      }

      if (swiper.params.cssMode && swiper.autoplay.running) run();else if (autoplayResult === false) {
        run();
      }
    }, delay);
  }

  function start() {
    if (typeof timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    emit('autoplayStart');
    run();
    return true;
  }

  function stop() {
    if (!swiper.autoplay.running) return false;
    if (typeof timeout === 'undefined') return false;

    if (timeout) {
      clearTimeout(timeout);
      timeout = undefined;
    }

    swiper.autoplay.running = false;
    emit('autoplayStop');
    return true;
  }

  function pause(speed) {
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (timeout) clearTimeout(timeout);
    swiper.autoplay.paused = true;

    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      run();
    } else {
      ['transitionend', 'webkitTransitionEnd'].forEach(event => {
        swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
      });
    }
  }

  function onVisibilityChange() {
    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
      pause();
    }

    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
      run();
      swiper.autoplay.paused = false;
    }
  }

  function onTransitionEnd(e) {
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
    if (e.target !== swiper.$wrapperEl[0]) return;
    ['transitionend', 'webkitTransitionEnd'].forEach(event => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
    swiper.autoplay.paused = false;

    if (!swiper.autoplay.running) {
      stop();
    } else {
      run();
    }
  }

  function onMouseEnter() {
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
    } else {
      emit('autoplayPause');
      pause();
    }

    ['transitionend', 'webkitTransitionEnd'].forEach(event => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
  }

  function onMouseLeave() {
    if (swiper.params.autoplay.disableOnInteraction) {
      return;
    }

    swiper.autoplay.paused = false;
    emit('autoplayResume');
    run();
  }

  function attachMouseEvents() {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.$el.on('mouseenter', onMouseEnter);
      swiper.$el.on('mouseleave', onMouseLeave);
    }
  }

  function detachMouseEvents() {
    swiper.$el.off('mouseenter', onMouseEnter);
    swiper.$el.off('mouseleave', onMouseLeave);
  }

  on('init', () => {
    if (swiper.params.autoplay.enabled) {
      start();
      const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
      document.addEventListener('visibilitychange', onVisibilityChange);
      attachMouseEvents();
    }
  });
  on('beforeTransitionStart', (_s, speed, internal) => {
    if (swiper.autoplay.running) {
      if (internal || !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.pause(speed);
      } else {
        stop();
      }
    }
  });
  on('sliderFirstMove', () => {
    if (swiper.autoplay.running) {
      if (swiper.params.autoplay.disableOnInteraction) {
        stop();
      } else {
        pause();
      }
    }
  });
  on('touchEnd', () => {
    if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
      run();
    }
  });
  on('destroy', () => {
    detachMouseEvents();

    if (swiper.autoplay.running) {
      stop();
    }

    const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    document.removeEventListener('visibilitychange', onVisibilityChange);
  });
  Object.assign(swiper.autoplay, {
    pause,
    run,
    start,
    stop
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/controller/controller.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/modules/controller/controller.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

function Controller({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide' // or 'container'

    }
  });
  swiper.controller = {
    control: undefined
  };

  function LinearSpline(x, y) {
    const binarySearch = function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;

        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;

          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }

        return maxIndex;
      };
    }();

    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.

    let i1;
    let i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };

    return this;
  } // xxx: for now i will just save one spline function to to


  function getInterpolateFunction(c) {
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  }

  function setTranslate(_t, byController) {
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    const Swiper = swiper.constructor;

    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

      if (swiper.params.controller.by === 'slide') {
        getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out

        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }

      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }

    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  }

  function setTransition(duration, byController) {
    const Swiper = swiper.constructor;
    const controlled = swiper.controller.control;
    let i;

    function setControlledTransition(c) {
      c.setTransition(duration, swiper);

      if (duration !== 0) {
        c.transitionStart();

        if (c.params.autoHeight) {
          (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
            c.updateAutoHeight();
          });
        }

        c.$wrapperEl.transitionEnd(() => {
          if (!controlled) return;

          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }

          c.transitionEnd();
        });
      }
    }

    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }

  function removeSpline() {
    if (!swiper.controller.control) return;

    if (swiper.controller.spline) {
      swiper.controller.spline = undefined;
      delete swiper.controller.spline;
    }
  }

  on('beforeInit', () => {
    swiper.controller.control = swiper.params.controller.control;
  });
  on('update', () => {
    removeSpline();
  });
  on('resize', () => {
    removeSpline();
  });
  on('observerUpdate', () => {
    removeSpline();
  });
  on('setTranslate', (_s, translate, byController) => {
    if (!swiper.controller.control) return;
    swiper.controller.setTranslate(translate, byController);
  });
  on('setTransition', (_s, duration, byController) => {
    if (!swiper.controller.control) return;
    swiper.controller.setTransition(duration, byController);
  });
  Object.assign(swiper.controller, {
    setTranslate,
    setTransition
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-cards/effect-cards.js":
/*!******************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-cards/effect-cards.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCards)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/create-shadow.js */ "./node_modules/swiper/shared/create-shadow.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");
/* harmony import */ var _shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/effect-virtual-transition-end.js */ "./node_modules/swiper/shared/effect-virtual-transition-end.js");




function EffectCards({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    cardsEffect: {
      slideShadows: true,
      transformEl: null,
      rotate: true,
      perSlideRotate: 2,
      perSlideOffset: 8
    }
  });

  const setTranslate = () => {
    const {
      slides,
      activeIndex
    } = swiper;
    const params = swiper.params.cardsEffect;
    const {
      startTranslate,
      isTouched
    } = swiper.touchEventsData;
    const currentTranslate = swiper.translate;

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideProgress = $slideEl[0].progress;
      const progress = Math.min(Math.max(slideProgress, -4), 4);
      let offset = $slideEl[0].swiperSlideOffset;

      if (swiper.params.centeredSlides && !swiper.params.cssMode) {
        swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
      }

      if (swiper.params.centeredSlides && swiper.params.cssMode) {
        offset -= slides[0].swiperSlideOffset;
      }

      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let tY = 0;
      const tZ = -100 * Math.abs(progress);
      let scale = 1;
      let rotate = -params.perSlideRotate * progress;
      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;

      if (isSwipeToNext || isSwipeToPrev) {
        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
        rotate += -28 * progress * subProgress;
        scale += -0.5 * subProgress;
        tXAdd += 96 * subProgress;
        tY = `${-25 * subProgress * Math.abs(progress)}%`;
      }

      if (progress < 0) {
        // next
        tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
      } else if (progress > 0) {
        // prev
        tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
      } else {
        tX = `${tX}px`;
      }

      if (!swiper.isHorizontal()) {
        const prevY = tY;
        tY = tX;
        tX = prevY;
      }

      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
      const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rotate : 0}deg)
        scale(${scaleString})
      `;

      if (params.slideShadows) {
        // Set shadows
        let $shadowEl = $slideEl.find('.swiper-slide-shadow');

        if ($shadowEl.length === 0) {
          $shadowEl = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl);
        }

        if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__["default"])(params, $slideEl);
      $targetEl.transform(transform);
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.cardsEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
    (0,_shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
      swiper,
      duration,
      transformEl
    });
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    effect: 'cards',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-coverflow/effect-coverflow.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-coverflow/effect-coverflow.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCoverflow)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/create-shadow.js */ "./node_modules/swiper/shared/create-shadow.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");



function EffectCoverflow({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true,
      transformEl: null
    }
  });

  const setTranslate = () => {
    const {
      width: swiperWidth,
      height: swiperHeight,
      slides,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth; // Each slide offset from center

    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
      const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

      let translateZ = -translate * Math.abs(offsetMultiplier);
      let stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }

      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values

      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;
      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__["default"])(params, $slideEl);
      $targetEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

      if (params.slideShadows) {
        // Set shadows
        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl, isHorizontal ? 'left' : 'top');
        }

        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl, isHorizontal ? 'right' : 'bottom');
        }

        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.coverflowEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    effect: 'coverflow',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-creative/effect-creative.js":
/*!************************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-creative/effect-creative.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCreative)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/create-shadow.js */ "./node_modules/swiper/shared/create-shadow.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");
/* harmony import */ var _shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/effect-virtual-transition-end.js */ "./node_modules/swiper/shared/effect-virtual-transition-end.js");




function EffectCreative({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    creativeEffect: {
      transformEl: null,
      limitProgress: 1,
      shadowPerProgress: false,
      progressMultiplier: 1,
      perspective: true,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });

  const getTranslateValue = value => {
    if (typeof value === 'string') return value;
    return `${value}px`;
  };

  const setTranslate = () => {
    const {
      slides,
      $wrapperEl,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.creativeEffect;
    const {
      progressMultiplier: multiplier
    } = params;
    const isCenteredSlides = swiper.params.centeredSlides;

    if (isCenteredSlides) {
      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
      $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
    }

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideProgress = $slideEl[0].progress;
      const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
      let originalProgress = progress;

      if (!isCenteredSlides) {
        originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
      }

      const offset = $slideEl[0].swiperSlideOffset;
      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
      const r = [0, 0, 0];
      let custom = false;

      if (!swiper.isHorizontal()) {
        t[1] = t[0];
        t[0] = 0;
      }

      let data = {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        scale: 1,
        opacity: 1
      };

      if (progress < 0) {
        data = params.next;
        custom = true;
      } else if (progress > 0) {
        data = params.prev;
        custom = true;
      } // set translate


      t.forEach((value, index) => {
        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
      }); // set rotates

      r.forEach((value, index) => {
        r[index] = data.rotate[index] * Math.abs(progress * multiplier);
      });
      $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const translateString = t.join(', ');
      const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; // Set shadows

      if (custom && data.shadow || !custom) {
        let $shadowEl = $slideEl.children('.swiper-slide-shadow');

        if ($shadowEl.length === 0 && data.shadow) {
          $shadowEl = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, $slideEl);
        }

        if ($shadowEl.length) {
          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
          $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
        }
      }

      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_2__["default"])(params, $slideEl);
      $targetEl.transform(transform).css({
        opacity: opacityString
      });

      if (data.origin) {
        $targetEl.css('transform-origin', data.origin);
      }
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.creativeEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
    (0,_shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
      swiper,
      duration,
      transformEl,
      allSlides: true
    });
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    effect: 'creative',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => swiper.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-cube/effect-cube.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-cube/effect-cube.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCube)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");


function EffectCube({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });

  const createSlideShadows = ($slideEl, progress, isHorizontal) => {
    let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
    let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

    if (shadowBefore.length === 0) {
      shadowBefore = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
      $slideEl.append(shadowBefore);
    }

    if (shadowAfter.length === 0) {
      shadowAfter = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
      $slideEl.append(shadowAfter);
    }

    if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
    if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
  };

  const recreateShadows = () => {
    // create new ones
    const isHorizontal = swiper.isHorizontal();
    swiper.slides.each(slideEl => {
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      createSlideShadows((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(slideEl), progress, isHorizontal);
    });
  };

  const setTranslate = () => {
    const {
      $el,
      $wrapperEl,
      slides,
      width: swiperWidth,
      height: swiperHeight,
      rtlTranslate: rtl,
      size: swiperSize,
      browser
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }

        $cubeShadowEl.css({
          height: `${swiperWidth}px`
        });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');

        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;

      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }

      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);

      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }

      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;

      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }

      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;

      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
      }

      $slideEl.transform(transform);

      if (params.slideShadows) {
        createSlideShadows($slideEl, progress, isHorizontal);
      }
    }

    $wrapperEl.css({
      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
      'transform-origin': `50% 50% -${swiperSize / 2}px`
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }

    const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
    $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
    $wrapperEl[0].style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
  };

  const setTransition = duration => {
    const {
      $el,
      slides
    } = swiper;
    slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    effect: 'cube',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.cubeEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: false,
      virtualTranslate: true
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-fade/effect-fade.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-fade/effect-fade.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectFade)
/* harmony export */ });
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");
/* harmony import */ var _shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-virtual-transition-end.js */ "./node_modules/swiper/shared/effect-virtual-transition-end.js");



function EffectFade({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    fadeEffect: {
      crossFade: false,
      transformEl: null
    }
  });

  const setTranslate = () => {
    const {
      slides
    } = swiper;
    const params = swiper.params.fadeEffect;

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset = $slideEl[0].swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }

      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params, $slideEl);
      $targetEl.css({
        opacity: slideOpacity
      }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.fadeEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration);
    (0,_shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
      swiper,
      duration,
      transformEl,
      allSlides: true
    });
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    effect: 'fade',
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/effect-flip/effect-flip.js":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/modules/effect-flip/effect-flip.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectFlip)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/create-shadow.js */ "./node_modules/swiper/shared/create-shadow.js");
/* harmony import */ var _shared_effect_init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/effect-init.js */ "./node_modules/swiper/shared/effect-init.js");
/* harmony import */ var _shared_effect_target_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/effect-target.js */ "./node_modules/swiper/shared/effect-target.js");
/* harmony import */ var _shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/effect-virtual-transition-end.js */ "./node_modules/swiper/shared/effect-virtual-transition-end.js");





function EffectFlip({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
      transformEl: null
    }
  });

  const createSlideShadows = ($slideEl, progress, params) => {
    let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
    let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

    if (shadowBefore.length === 0) {
      shadowBefore = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
    }

    if (shadowAfter.length === 0) {
      shadowAfter = (0,_shared_create_shadow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
    }

    if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
    if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
  };

  const recreateShadows = () => {
    // Set shadows
    const params = swiper.params.flipEffect;
    swiper.slides.each(slideEl => {
      const $slideEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(slideEl);
      let progress = $slideEl[0].progress;

      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }

      createSlideShadows($slideEl, progress, params);
    });
  };

  const setTranslate = () => {
    const {
      slides,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.flipEffect;

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;

      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }

      const offset = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (params.slideShadows) {
        createSlideShadows($slideEl, progress, params);
      }

      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      const $targetEl = (0,_shared_effect_target_js__WEBPACK_IMPORTED_MODULE_3__["default"])(params, $slideEl);
      $targetEl.transform(transform);
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.flipEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
    (0,_shared_effect_virtual_transition_end_js__WEBPACK_IMPORTED_MODULE_4__["default"])({
      swiper,
      duration,
      transformEl
    });
  };

  (0,_shared_effect_init_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
    effect: 'flip',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.flipEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/free-mode/free-mode.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/modules/free-mode/free-mode.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ freeMode)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");

function freeMode({
  swiper,
  extendParams,
  emit,
  once
}) {
  extendParams({
    freeMode: {
      enabled: false,
      momentum: true,
      momentumRatio: 1,
      momentumBounce: true,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: false,
      minimumVelocity: 0.02
    }
  });

  function onTouchStart() {
    const translate = swiper.getTranslate();
    swiper.setTranslate(translate);
    swiper.setTransition(0);
    swiper.touchEventsData.velocities.length = 0;
    swiper.freeMode.onTouchEnd({
      currentPos: swiper.rtl ? swiper.translate : -swiper.translate
    });
  }

  function onTouchMove() {
    const {
      touchEventsData: data,
      touches
    } = swiper; // Velocity

    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }

    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)()
    });
  }

  function onTouchEnd({
    currentPos
  }) {
    const {
      params,
      $wrapperEl,
      rtlTranslate: rtl,
      snapGrid,
      touchEventsData: data
    } = swiper; // Time diff

    const touchEndTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)();
    const timeDiff = touchEndTime - data.touchStartTime;

    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }

      return;
    }

    if (params.freeMode.momentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();
        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;

        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
          swiper.velocity = 0;
        } // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.


        if (time > 150 || (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }

      swiper.velocity *= params.freeMode.momentumVelocityRatio;
      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeMode.momentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;
      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
      let needsLoopFix;

      if (newPosition < swiper.maxTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }

          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }

          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeMode.sticky) {
        let nextSlide;

        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }

        newPosition = -newPosition;
      }

      if (needsLoopFix) {
        once('transitionEnd', () => {
          swiper.loopFix();
        });
      } // Fix duration


      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }

        if (params.freeMode.sticky) {
          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeMode.momentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);

        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeMode.sticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      emit('_freeModeNoMomentumRelease');
    }

    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
  }

  Object.assign(swiper, {
    freeMode: {
      onTouchStart,
      onTouchMove,
      onTouchEnd
    }
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/grid/grid.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/grid/grid.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Grid)
/* harmony export */ });
function Grid({
  swiper,
  extendParams
}) {
  extendParams({
    grid: {
      rows: 1,
      fill: 'column'
    }
  });
  let slidesNumberEvenToRows;
  let slidesPerRow;
  let numFullColumns;

  const initSlides = slidesLength => {
    const {
      slidesPerView
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid;
    slidesPerRow = slidesNumberEvenToRows / rows;
    numFullColumns = Math.floor(slidesLength / rows);

    if (Math.floor(slidesLength / rows) === slidesLength / rows) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
    }

    if (slidesPerView !== 'auto' && fill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
    }
  };

  const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
    const {
      slidesPerGroup,
      spaceBetween
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid; // Set slides order

    let newSlideOrderIndex;
    let column;
    let row;

    if (fill === 'row' && slidesPerGroup > 1) {
      const groupIndex = Math.floor(i / (slidesPerGroup * rows));
      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
      row = Math.floor(slideIndexInGroup / columnsInGroup);
      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
      slide.css({
        '-webkit-order': newSlideOrderIndex,
        order: newSlideOrderIndex
      });
    } else if (fill === 'column') {
      column = Math.floor(i / rows);
      row = i - column * rows;

      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
        row += 1;

        if (row >= rows) {
          row = 0;
          column += 1;
        }
      }
    } else {
      row = Math.floor(i / slidesPerRow);
      column = i - row * slidesPerRow;
    }

    slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');
  };

  const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
    const {
      spaceBetween,
      centeredSlides,
      roundLengths
    } = swiper.params;
    const {
      rows
    } = swiper.params.grid;
    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
    swiper.$wrapperEl.css({
      [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`
    });

    if (centeredSlides) {
      snapGrid.splice(0, snapGrid.length);
      const newSlidesGrid = [];

      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }

      snapGrid.push(...newSlidesGrid);
    }
  };

  swiper.grid = {
    initSlides,
    updateSlide,
    updateWrapperSize
  };
}

/***/ }),

/***/ "./node_modules/swiper/modules/hash-navigation/hash-navigation.js":
/*!************************************************************************!*\
  !*** ./node_modules/swiper/modules/hash-navigation/hash-navigation.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HashNavigation)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function HashNavigation({
  swiper,
  extendParams,
  emit,
  on
}) {
  let initialized = false;
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  extendParams({
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false
    }
  });

  const onHashChange = () => {
    emit('hashChange');
    const newHash = document.location.hash.replace('#', '');
    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

    if (newHash !== activeSlideHash) {
      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
      if (typeof newIndex === 'undefined') return;
      swiper.slideTo(newIndex);
    }
  };

  const setHash = () => {
    if (!initialized || !swiper.params.hashNavigation.enabled) return;

    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
      window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');
      emit('hashSet');
    } else {
      const slide = swiper.slides.eq(swiper.activeIndex);
      const hash = slide.attr('data-hash') || slide.attr('data-history');
      document.location.hash = hash || '';
      emit('hashSet');
    }
  };

  const init = () => {
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
    initialized = true;
    const hash = document.location.hash.replace('#', '');

    if (hash) {
      const speed = 0;

      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHash = slide.attr('data-hash') || slide.attr('data-history');

        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }

    if (swiper.params.hashNavigation.watchState) {
      (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).on('hashchange', onHashChange);
    }
  };

  const destroy = () => {
    if (swiper.params.hashNavigation.watchState) {
      (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window).off('hashchange', onHashChange);
    }
  };

  on('init', () => {
    if (swiper.params.hashNavigation.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.hashNavigation.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHash();
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHash();
    }
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/history/history.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/modules/history/history.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ History)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function History({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    history: {
      enabled: false,
      root: '',
      replaceState: false,
      key: 'slides',
      keepQuery: false
    }
  });
  let initialized = false;
  let paths = {};

  const slugify = text => {
    return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  };

  const getPathValues = urlOverride => {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    let location;

    if (urlOverride) {
      location = new URL(urlOverride);
    } else {
      location = window.location;
    }

    const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return {
      key,
      value
    };
  };

  const setHistory = (key, index) => {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    if (!initialized || !swiper.params.history.enabled) return;
    let location;

    if (swiper.params.url) {
      location = new URL(swiper.params.url);
    } else {
      location = window.location;
    }

    const slide = swiper.slides.eq(index);
    let value = slugify(slide.attr('data-history'));

    if (swiper.params.history.root.length > 0) {
      let root = swiper.params.history.root;
      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
      value = `${root}/${key}/${value}`;
    } else if (!location.pathname.includes(key)) {
      value = `${key}/${value}`;
    }

    if (swiper.params.history.keepQuery) {
      value += location.search;
    }

    const currentState = window.history.state;

    if (currentState && currentState.value === value) {
      return;
    }

    if (swiper.params.history.replaceState) {
      window.history.replaceState({
        value
      }, null, value);
    } else {
      window.history.pushState({
        value
      }, null, value);
    }
  };

  const scrollToSlide = (speed, value, runCallbacks) => {
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHistory = slugify(slide.attr('data-history'));

        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  };

  const setHistoryPopState = () => {
    paths = getPathValues(swiper.params.url);
    scrollToSlide(swiper.params.speed, paths.value, false);
  };

  const init = () => {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    if (!swiper.params.history) return;

    if (!window.history || !window.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }

    initialized = true;
    paths = getPathValues(swiper.params.url);
    if (!paths.key && !paths.value) return;
    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);

    if (!swiper.params.history.replaceState) {
      window.addEventListener('popstate', setHistoryPopState);
    }
  };

  const destroy = () => {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

    if (!swiper.params.history.replaceState) {
      window.removeEventListener('popstate', setHistoryPopState);
    }
  };

  on('init', () => {
    if (swiper.params.history.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.history.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/keyboard/keyboard.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/modules/keyboard/keyboard.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Keyboard)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* eslint-disable consistent-return */


function Keyboard({
  swiper,
  extendParams,
  on,
  emit
}) {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  swiper.keyboard = {
    enabled: false
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  });

  function handle(event) {
    if (!swiper.enabled) return;
    const {
      rtlTranslate: rtl
    } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix

    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40; // Directions locks

    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }

    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }

    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }

    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }

    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false; // Check that swiper should be inside of visible area of window

      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }

      const $el = swiper.$el;
      const swiperWidth = $el[0].clientWidth;
      const swiperHeight = $el[0].clientHeight;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];

      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];

        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

          inView = true;
        }
      }

      if (!inView) return undefined;
    }

    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }

      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }

      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }

    emit('keyPress', kc);
    return undefined;
  }

  function enable() {
    if (swiper.keyboard.enabled) return;
    (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).on('keydown', handle);
    swiper.keyboard.enabled = true;
  }

  function disable() {
    if (!swiper.keyboard.enabled) return;
    (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(document).off('keydown', handle);
    swiper.keyboard.enabled = false;
  }

  on('init', () => {
    if (swiper.params.keyboard.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    if (swiper.keyboard.enabled) {
      disable();
    }
  });
  Object.assign(swiper.keyboard, {
    enable,
    disable
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/lazy/lazy.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/lazy/lazy.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Lazy)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function Lazy({
  swiper,
  extendParams,
  on,
  emit
}) {
  extendParams({
    lazy: {
      checkInView: false,
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,
      scrollingElement: '',
      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader'
    }
  });
  swiper.lazy = {};
  let scrollHandlerAttached = false;
  let initialImageLoaded = false;

  function loadInSlide(index, loadInDuplicate = true) {
    const params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`) : swiper.slides.eq(index);
    const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);

    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images.push($slideEl[0]);
    }

    if ($images.length === 0) return;
    $images.each(imageEl => {
      const $imageEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(imageEl);
      $imageEl.addClass(params.loadingClass);
      const background = $imageEl.attr('data-background');
      const src = $imageEl.attr('data-src');
      const srcset = $imageEl.attr('data-srcset');
      const sizes = $imageEl.attr('data-sizes');
      const $pictureEl = $imageEl.parent('picture');
      swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;

        if (background) {
          $imageEl.css('background-image', `url("${background}")`);
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }

          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }

          if ($pictureEl.length) {
            $pictureEl.children('source').each(sourceEl => {
              const $source = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sourceEl);

              if ($source.attr('data-srcset')) {
                $source.attr('srcset', $source.attr('data-srcset'));
                $source.removeAttr('data-srcset');
              }
            });
          }

          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();

        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            loadInSlide(duplicatedSlide.index(), false);
          }
        }

        emit('lazyImageReady', $slideEl[0], $imageEl[0]);

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      });
      emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  }

  function load() {
    const {
      $wrapperEl,
      params: swiperParams,
      slides,
      activeIndex
    } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;
    let slidesPerView = swiperParams.slidesPerView;

    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
          return true;
        }
      } else if (slides[index]) return true;

      return false;
    }

    function slideIndex(slideEl) {
      if (isVirtual) {
        return (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl).attr('data-swiper-slide-index');
      }

      return (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl).index();
    }

    if (!initialImageLoaded) initialImageLoaded = true;

    if (swiper.params.watchSlidesProgress) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each(slideEl => {
        const index = isVirtual ? (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl).attr('data-swiper-slide-index') : (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(slideEl).index();
        loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) loadInSlide(i);
      }
    } else {
      loadInSlide(activeIndex);
    }

    if (params.loadPrevNext) {
      if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
        const amount = params.loadPrevNextAmount;
        const spv = Math.ceil(slidesPerView);
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

        for (let i = activeIndex + spv; i < maxIndex; i += 1) {
          if (slideExist(i)) loadInSlide(i);
        } // Prev Slides


        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i)) loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
      }
    }
  }

  function checkInViewOnLoad() {
    const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    if (!swiper || swiper.destroyed) return;
    const $scrollElement = swiper.params.lazy.scrollingElement ? (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.params.lazy.scrollingElement) : (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(window);
    const isWindow = $scrollElement[0] === window;
    const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
    const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
    const swiperOffset = swiper.$el.offset();
    const {
      rtlTranslate: rtl
    } = swiper;
    let inView = false;
    if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
    const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

    for (let i = 0; i < swiperCoord.length; i += 1) {
      const point = swiperCoord[i];

      if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

        inView = true;
      }
    }

    const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;

    if (inView) {
      load();
      $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
    } else if (!scrollHandlerAttached) {
      scrollHandlerAttached = true;
      $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
    }
  }

  on('beforeInit', () => {
    if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
      swiper.params.preloadImages = false;
    }
  });
  on('init', () => {
    if (swiper.params.lazy.enabled) {
      if (swiper.params.lazy.checkInView) {
        checkInViewOnLoad();
      } else {
        load();
      }
    }
  });
  on('scroll', () => {
    if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
      load();
    }
  });
  on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {
    if (swiper.params.lazy.enabled) {
      if (swiper.params.lazy.checkInView) {
        checkInViewOnLoad();
      } else {
        load();
      }
    }
  });
  on('transitionStart', () => {
    if (swiper.params.lazy.enabled) {
      if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
        if (swiper.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    }
  });
  on('transitionEnd', () => {
    if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
      if (swiper.params.lazy.checkInView) {
        checkInViewOnLoad();
      } else {
        load();
      }
    }
  });
  on('slideChange', () => {
    const {
      lazy,
      cssMode,
      watchSlidesProgress,
      touchReleaseOnEdges,
      resistanceRatio
    } = swiper.params;

    if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
      load();
    }
  });
  on('destroy', () => {
    if (!swiper.$el) return;
    swiper.$el.find(`.${swiper.params.lazy.loadingClass}`).removeClass(swiper.params.lazy.loadingClass);
  });
  Object.assign(swiper.lazy, {
    load,
    loadInSlide
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/manipulation.js":
/*!******************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/manipulation.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Manipulation)
/* harmony export */ });
/* harmony import */ var _methods_appendSlide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods/appendSlide.js */ "./node_modules/swiper/modules/manipulation/methods/appendSlide.js");
/* harmony import */ var _methods_prependSlide_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods/prependSlide.js */ "./node_modules/swiper/modules/manipulation/methods/prependSlide.js");
/* harmony import */ var _methods_addSlide_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods/addSlide.js */ "./node_modules/swiper/modules/manipulation/methods/addSlide.js");
/* harmony import */ var _methods_removeSlide_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods/removeSlide.js */ "./node_modules/swiper/modules/manipulation/methods/removeSlide.js");
/* harmony import */ var _methods_removeAllSlides_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./methods/removeAllSlides.js */ "./node_modules/swiper/modules/manipulation/methods/removeAllSlides.js");





function Manipulation({
  swiper
}) {
  Object.assign(swiper, {
    appendSlide: _methods_appendSlide_js__WEBPACK_IMPORTED_MODULE_0__["default"].bind(swiper),
    prependSlide: _methods_prependSlide_js__WEBPACK_IMPORTED_MODULE_1__["default"].bind(swiper),
    addSlide: _methods_addSlide_js__WEBPACK_IMPORTED_MODULE_2__["default"].bind(swiper),
    removeSlide: _methods_removeSlide_js__WEBPACK_IMPORTED_MODULE_3__["default"].bind(swiper),
    removeAllSlides: _methods_removeAllSlides_js__WEBPACK_IMPORTED_MODULE_4__["default"].bind(swiper)
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/addSlide.js":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/addSlide.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addSlide)
/* harmony export */ });
function addSlide(index, slides) {
  const swiper = this;
  const {
    $wrapperEl,
    params,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }

  const baseLength = swiper.slides.length;

  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }

  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }

  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  const slidesBuffer = [];

  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }

    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (let i = 0; i < slidesBuffer.length; i += 1) {
    $wrapperEl.append(slidesBuffer[i]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!params.observer) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/appendSlide.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/appendSlide.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ appendSlide)
/* harmony export */ });
function appendSlide(slides) {
  const swiper = this;
  const {
    $wrapperEl,
    params
  } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!params.observer) {
    swiper.update();
  }
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/prependSlide.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/prependSlide.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ prependSlide)
/* harmony export */ });
function prependSlide(slides) {
  const swiper = this;
  const {
    params,
    $wrapperEl,
    activeIndex
  } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }

  let newActiveIndex = activeIndex + 1;

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }

    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!params.observer) {
    swiper.update();
  }

  swiper.slideTo(newActiveIndex, 0, false);
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/removeAllSlides.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/removeAllSlides.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ removeAllSlides)
/* harmony export */ });
function removeAllSlides() {
  const swiper = this;
  const slidesIndexes = [];

  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }

  swiper.removeSlide(slidesIndexes);
}

/***/ }),

/***/ "./node_modules/swiper/modules/manipulation/methods/removeSlide.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation/methods/removeSlide.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ removeSlide)
/* harmony export */ });
function removeSlide(slidesIndexes) {
  const swiper = this;
  const {
    params,
    $wrapperEl,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }

  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }

    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!params.observer) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

/***/ }),

/***/ "./node_modules/swiper/modules/mousewheel/mousewheel.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/modules/mousewheel/mousewheel.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mousewheel)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* eslint-disable consistent-return */



function Mousewheel({
  swiper,
  extendParams,
  on,
  emit
}) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: 'container',
      thresholdDelta: null,
      thresholdTime: null
    }
  });
  swiper.mousewheel = {
    enabled: false
  };
  let timeout;
  let lastScrollTime = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];

  function normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0; // spinX, spinY

    let pX = 0;
    let pY = 0; // pixelX, pixelY
    // Legacy

    if ('detail' in e) {
      sY = e.detail;
    }

    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }

    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }

    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    } // side scrolling on FF with DOMMouseScroll


    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }

    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if (e.shiftKey && !pX) {
      // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    } // Fall-back if spin cannot be determined


    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }

    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  }

  function handleMouseEnter() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = true;
  }

  function handleMouseLeave() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = false;
  }

  function animateSlider(newEvent) {
    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
      // Prevent if delta of wheel scroll delta is below configured threshold
      return false;
    }

    if (swiper.params.mousewheel.thresholdTime && (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
      // Prevent if time between scrolls is below configured threshold
      return false;
    } // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).


    if (newEvent.delta >= 6 && (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)() - lastScrollTime < 60) {
      // Return false as a default
      return true;
    } // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.


    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      emit('scroll', newEvent.raw);
    } // If you got here is because an animation has been triggered so store the current time


    lastScrollTime = new window.Date().getTime(); // Return false as a default

    return false;
  }

  function releaseScroll(newEvent) {
    const params = swiper.params.mousewheel;

    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }

    return false;
  }

  function handle(event) {
    let e = event;
    let disableParentSwiper = true;
    if (!swiper.enabled) return;
    const params = swiper.params.mousewheel;

    if (swiper.params.cssMode) {
      e.preventDefault();
    }

    let target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.params.mousewheel.eventsTarget);
    }

    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
    if (e.originalEvent) e = e.originalEvent; // jquery fix

    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    const data = normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }

    if (delta === 0) return true;
    if (params.invert) delta = -delta; // Get the scroll positions

    let positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
    //     the disableParentSwiper will be true.
    // When loop is false:
    //     if the scroll positions is not on edge,
    //     then the disableParentSwiper will be true.
    //     if the scroll on edge positions,
    //     then the disableParentSwiper will be false.

    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();

    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
      // Register the new event in a variable which stores the relevant data
      const newEvent = {
        time: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event
      }; // Keep the most recent events

      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }

      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.

      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      } // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.


      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:
      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      const newEvent = {
        time: (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.now)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;

      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = undefined;

        if (swiper.params.loop) {
          swiper.loopFix();
        }

        let position = swiper.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();

        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }

        if (swiper.params.freeMode.sticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(timeout);
          timeout = undefined;

          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift(); // only store the last N events
          }

          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);

          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }

          if (!timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            timeout = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        } // Emit event


        if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay

        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
      }
    }

    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    return false;
  }

  function events(method) {
    let target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(swiper.params.mousewheel.eventsTarget);
    }

    target[method]('mouseenter', handleMouseEnter);
    target[method]('mouseleave', handleMouseLeave);
    target[method]('wheel', handle);
  }

  function enable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener('wheel', handle);
      return true;
    }

    if (swiper.mousewheel.enabled) return false;
    events('on');
    swiper.mousewheel.enabled = true;
    return true;
  }

  function disable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, handle);
      return true;
    }

    if (!swiper.mousewheel.enabled) return false;
    events('off');
    swiper.mousewheel.enabled = false;
    return true;
  }

  on('init', () => {
    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
      disable();
    }

    if (swiper.params.mousewheel.enabled) enable();
  });
  on('destroy', () => {
    if (swiper.params.cssMode) {
      enable();
    }

    if (swiper.mousewheel.enabled) disable();
  });
  Object.assign(swiper.mousewheel, {
    enable,
    disable
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/navigation/navigation.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/modules/navigation/navigation.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Navigation)
/* harmony export */ });
/* harmony import */ var _shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/create-element-if-not-defined.js */ "./node_modules/swiper/shared/create-element-if-not-defined.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function Navigation({
  swiper,
  extendParams,
  on,
  emit
}) {
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
      navigationDisabledClass: 'swiper-navigation-disabled'
    }
  });
  swiper.navigation = {
    nextEl: null,
    $nextEl: null,
    prevEl: null,
    $prevEl: null
  };

  function getEl(el) {
    let $el;

    if (el) {
      $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(el);

      if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
        $el = swiper.$el.find(el);
      }
    }

    return $el;
  }

  function toggleEl($el, disabled) {
    const params = swiper.params.navigation;

    if ($el && $el.length > 0) {
      $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
      if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;

      if (swiper.params.watchOverflow && swiper.enabled) {
        $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }
  }

  function update() {
    // Update Navigation Buttons
    if (swiper.params.loop) return;
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
  }

  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slidePrev();
    emit('navigationPrev');
  }

  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slideNext();
    emit('navigationNext');
  }

  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = (0,_shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_0__["default"])(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    const $nextEl = getEl(params.nextEl);
    const $prevEl = getEl(params.prevEl);

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', onNextClick);
    }

    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', onPrevClick);
    }

    Object.assign(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0]
    });

    if (!swiper.enabled) {
      if ($nextEl) $nextEl.addClass(params.lockClass);
      if ($prevEl) $prevEl.addClass(params.lockClass);
    }
  }

  function destroy() {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;

    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }

    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  }

  on('init', () => {
    if (swiper.params.navigation.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      update();
    }
  });
  on('toEdge fromEdge lock unlock', () => {
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;

    if ($nextEl) {
      $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
    }

    if ($prevEl) {
      $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
    }
  });
  on('click', (_s, e) => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    const targetEl = e.target;

    if (swiper.params.navigation.hideOnClick && !(0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(targetEl).is($prevEl) && !(0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(targetEl).is($nextEl)) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;

      if ($nextEl) {
        isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
      } else if ($prevEl) {
        isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
      }

      if (isHidden === true) {
        emit('navigationShow');
      } else {
        emit('navigationHide');
      }

      if ($nextEl) {
        $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
      }

      if ($prevEl) {
        $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
      }
    }
  });

  const enable = () => {
    swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);
    init();
    update();
  };

  const disable = () => {
    swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);
    destroy();
  };

  Object.assign(swiper.navigation, {
    enable,
    disable,
    update,
    init,
    destroy
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/pagination/pagination.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiper/modules/pagination/pagination.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pagination)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/classes-to-selector.js */ "./node_modules/swiper/shared/classes-to-selector.js");
/* harmony import */ var _shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/create-element-if-not-defined.js */ "./node_modules/swiper/shared/create-element-if-not-defined.js");



function Pagination({
  swiper,
  extendParams,
  on,
  emit
}) {
  const pfx = 'swiper-pagination';
  extendParams({
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: number => number,
      formatFractionTotal: number => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`
    }
  });
  swiper.pagination = {
    el: null,
    $el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;

  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
  }

  function setSideBullets($bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
  }

  function update() {
    // Render || Update Pagination bullets/items
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el; // Current/Total

    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
        current -= slidesLength - swiper.loopedSlides * 2;
      }

      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    } // Types


    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;

      if (params.dynamicBullets) {
        bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);

        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);

          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }

        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }

      bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));

      if ($el.length > 1) {
        bullets.each(bullet => {
          const $bullet = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(bullet);
          const bulletIndex = $bullet.index();

          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }

          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }

            if (bulletIndex === firstIndex) {
              setSideBullets($bullet, 'prev');
            }

            if (bulletIndex === lastIndex) {
              setSideBullets($bullet, 'next');
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        const bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);

        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);

          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }

          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length) {
              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
              }

              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
            } else {
              setSideBullets($firstDisplayedBullet, 'prev');
              setSideBullets($lastDisplayedBullet, 'next');
            }
          } else {
            setSideBullets($firstDisplayedBullet, 'prev');
            setSideBullets($lastDisplayedBullet, 'next');
          }
        }
      }

      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
      }
    }

    if (params.type === 'fraction') {
      $el.find((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.currentClass)).text(params.formatFractionCurrent(current + 1));
      $el.find((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.totalClass)).text(params.formatFractionTotal(total));
    }

    if (params.type === 'progressbar') {
      let progressbarDirection;

      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }

      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;

      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }

      $el.find((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }

    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      emit('paginationRender', $el[0]);
    } else {
      emit('paginationUpdate', $el[0]);
    }

    if (swiper.params.watchOverflow && swiper.enabled) {
      $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  }

  function render() {
    // Render Container
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    let paginationHTML = '';

    if (params.type === 'bullets') {
      let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }

      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }

      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find((0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.bulletClass));
    }

    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
      }

      $el.html(paginationHTML);
    }

    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }

      $el.html(paginationHTML);
    }

    if (params.type !== 'custom') {
      emit('paginationRender', swiper.pagination.$el[0]);
    }
  }

  function init() {
    swiper.params.pagination = (0,_shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_2__["default"])(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: 'swiper-pagination'
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params.el);
    if ($el.length === 0) return;

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
      $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

      if ($el.length > 1) {
        $el = $el.filter(el => {
          if ((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el).parents('.swiper')[0] !== swiper.el) return false;
          return true;
        });
      }
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);
    $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      dynamicBulletIndex = 0;

      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }

    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', (0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.bulletClass), function onClick(e) {
        e.preventDefault();
        let index = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    Object.assign(swiper.pagination, {
      $el,
      el: $el[0]
    });

    if (!swiper.enabled) {
      $el.addClass(params.lockClass);
    }
  }

  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const $el = swiper.pagination.$el;
    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

    if (params.clickable) {
      $el.off('click', (0,_shared_classes_to_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.bulletClass));
    }
  }

  on('init', () => {
    if (swiper.params.pagination.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      render();
      update();
    }
  });
  on('activeIndexChange', () => {
    if (swiper.params.loop) {
      update();
    } else if (typeof swiper.snapIndex === 'undefined') {
      update();
    }
  });
  on('snapIndexChange', () => {
    if (!swiper.params.loop) {
      update();
    }
  });
  on('slidesLengthChange', () => {
    if (swiper.params.loop) {
      render();
      update();
    }
  });
  on('snapGridLengthChange', () => {
    if (!swiper.params.loop) {
      render();
      update();
    }
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    const {
      $el
    } = swiper.pagination;

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
    }
  });
  on('lock unlock', () => {
    update();
  });
  on('click', (_s, e) => {
    const targetEl = e.target;
    const {
      $el
    } = swiper.pagination;

    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !(0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);

      if (isHidden === true) {
        emit('paginationShow');
      } else {
        emit('paginationHide');
      }

      $el.toggleClass(swiper.params.pagination.hiddenClass);
    }
  });

  const enable = () => {
    swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);

    if (swiper.pagination.$el) {
      swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
    }

    init();
    render();
    update();
  };

  const disable = () => {
    swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);

    if (swiper.pagination.$el) {
      swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);
    }

    destroy();
  };

  Object.assign(swiper.pagination, {
    enable,
    disable,
    render,
    update,
    init,
    destroy
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/parallax/parallax.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/modules/parallax/parallax.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Parallax)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");

function Parallax({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    parallax: {
      enabled: false
    }
  });

  const setTransform = (el, progress) => {
    const {
      rtl
    } = swiper;
    const $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(el);
    const rtlFactor = rtl ? -1 : 1;
    const p = $el.attr('data-swiper-parallax') || '0';
    let x = $el.attr('data-swiper-parallax-x');
    let y = $el.attr('data-swiper-parallax-y');
    const scale = $el.attr('data-swiper-parallax-scale');
    const opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if (x.indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }

    if (y.indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      $el[0].style.opacity = currentOpacity;
    }

    if (typeof scale === 'undefined' || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  };

  const setTranslate = () => {
    const {
      $el,
      slides,
      progress,
      snapGrid
    } = swiper;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
      setTransform(el, progress);
    });
    slides.each((slideEl, slideIndex) => {
      let slideProgress = slideEl.progress;

      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }

      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
        setTransform(el, slideProgress);
      });
    });
  };

  const setTransition = (duration = swiper.params.speed) => {
    const {
      $el
    } = swiper;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
      const $parallaxEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(parallaxEl);
      let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
      if (duration === 0) parallaxDuration = 0;
      $parallaxEl.transition(parallaxDuration);
    });
  };

  on('beforeInit', () => {
    if (!swiper.params.parallax.enabled) return;
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
  });
  on('init', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTranslate', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTransition', (_swiper, duration) => {
    if (!swiper.params.parallax.enabled) return;
    setTransition(duration);
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/scrollbar/scrollbar.js":
/*!************************************************************!*\
  !*** ./node_modules/swiper/modules/scrollbar/scrollbar.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Scrollbar)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* harmony import */ var _shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/create-element-if-not-defined.js */ "./node_modules/swiper/shared/create-element-if-not-defined.js");




function Scrollbar({
  swiper,
  extendParams,
  on,
  emit
}) {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
      scrollbarDisabledClass: 'swiper-scrollbar-disabled',
      horizontalClass: `swiper-scrollbar-horizontal`,
      verticalClass: `swiper-scrollbar-vertical`
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null,
    $el: null,
    $dragEl: null
  };

  function setTranslate() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar,
      rtlTranslate: rtl,
      progress
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;

    if (rtl) {
      newPos = -newPos;

      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }

    if (swiper.isHorizontal()) {
      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      $dragEl[0].style.height = `${newSize}px`;
    }

    if (params.hide) {
      clearTimeout(timeout);
      $el[0].style.opacity = 1;
      timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  }

  function setTransition(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  }

  function updateSize() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));

    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }

    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }

    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
    }
  }

  function getPointerPosition(e) {
    if (swiper.isHorizontal()) {
      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
    }

    return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
  }

  function setDragPosition(e) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      $el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);

    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  function onDragStart(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    $wrapperEl.transition(100);
    $dragEl.transition(100);
    setDragPosition(e);
    clearTimeout(dragTimeout);
    $el.transition(0);

    if (params.hide) {
      $el.css('opacity', 1);
    }

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', 'none');
    }

    emit('scrollbarDragStart', e);
  }

  function onDragMove(e) {
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    if (!isTouched) return;
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    emit('scrollbarDragMove', e);
  }

  function onDragEnd(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el
    } = scrollbar;
    if (!isTouched) return;
    isTouched = false;

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', '');
      $wrapperEl.transition('');
    }

    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }

    emit('scrollbarDragEnd', e);

    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }

  function events(method) {
    const {
      scrollbar,
      touchEventsTouch,
      touchEventsDesktop,
      params,
      support
    } = swiper;
    const $el = scrollbar.$el;
    if (!$el) return;
    const target = $el[0];
    const activeListener = support.passiveListener && params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;
    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';

    if (!support.touch) {
      target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
      document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
      document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
    } else {
      target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
      target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
      target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
    }
  }

  function enableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('on');
  }

  function disableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('off');
  }

  function init() {
    const {
      scrollbar,
      $el: $swiperEl
    } = swiper;
    swiper.params.scrollbar = (0,_shared_create_element_if_not_defined_js__WEBPACK_IMPORTED_MODULE_3__["default"])(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: 'swiper-scrollbar'
    });
    const params = swiper.params.scrollbar;
    if (!params.el) return;
    let $el = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(params.el);

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);

    if ($dragEl.length === 0) {
      $dragEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }

    Object.assign(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0]
    });

    if (params.draggable) {
      enableDraggable();
    }

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
    }
  }

  function destroy() {
    const params = swiper.params.scrollbar;
    const $el = swiper.scrollbar.$el;

    if ($el) {
      $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    }

    disableDraggable();
  }

  on('init', () => {
    if (swiper.params.scrollbar.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      updateSize();
      setTranslate();
    }
  });
  on('update resize observerUpdate lock unlock', () => {
    updateSize();
  });
  on('setTranslate', () => {
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    setTransition(duration);
  });
  on('enable disable', () => {
    const {
      $el
    } = swiper.scrollbar;

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
    }
  });
  on('destroy', () => {
    destroy();
  });

  const enable = () => {
    swiper.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);

    if (swiper.scrollbar.$el) {
      swiper.scrollbar.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);
    }

    init();
    updateSize();
    setTranslate();
  };

  const disable = () => {
    swiper.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);

    if (swiper.scrollbar.$el) {
      swiper.scrollbar.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);
    }

    destroy();
  };

  Object.assign(swiper.scrollbar, {
    enable,
    disable,
    updateSize,
    setTranslate,
    init,
    destroy
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/thumbs/thumbs.js":
/*!******************************************************!*\
  !*** ./node_modules/swiper/modules/thumbs/thumbs.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Thumb)
/* harmony export */ });
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");


function Thumb({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-thumbs'
    }
  });
  let initialized = false;
  let swiperCreated = false;
  swiper.thumbs = {
    swiper: null
  };

  function onThumbClick() {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;

    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt((0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }

    if (swiper.params.loop) {
      let currentIndex = swiper.activeIndex;

      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }

      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
    }

    swiper.slideTo(slideToIndex);
  }

  function init() {
    const {
      thumbs: thumbsParams
    } = swiper.params;
    if (initialized) return false;
    initialized = true;
    const SwiperClass = swiper.constructor;

    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Object.assign(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      Object.assign(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
    } else if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(thumbsParams.swiper)) {
      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
      Object.assign(thumbsSwiperParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
      swiperCreated = true;
    }

    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', onThumbClick);
    return true;
  }

  function update(initial) {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView; // Activate thumbs

    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }

    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.removeClass(thumbActiveClass);

    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
      }
    }

    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;

    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      let currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;

      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix(); // eslint-disable-next-line

          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        } // Find actual thumbs index to slide to


        const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();

        if (typeof prevThumbsIndex === 'undefined') {
          newThumbsIndex = nextThumbsIndex;
        } else if (typeof nextThumbsIndex === 'undefined') {
          newThumbsIndex = prevThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = nextThumbsIndex;
        } else {
          newThumbsIndex = prevThumbsIndex;
        }

        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }

      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }

      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {// newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }

        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }
  }

  on('beforeInit', () => {
    const {
      thumbs
    } = swiper.params;
    if (!thumbs || !thumbs.swiper) return;
    init();
    update(true);
  });
  on('slideChange update resize observerUpdate', () => {
    update();
  });
  on('setTransition', (_s, duration) => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    thumbsSwiper.setTransition(duration);
  });
  on('beforeDestroy', () => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;

    if (swiperCreated) {
      thumbsSwiper.destroy();
    }
  });
  Object.assign(swiper.thumbs, {
    init,
    update
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/virtual/virtual.js":
/*!********************************************************!*\
  !*** ./node_modules/swiper/modules/virtual/virtual.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Virtual)
/* harmony export */ });
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");


function Virtual({
  swiper,
  extendParams,
  on,
  emit
}) {
  extendParams({
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let cssModeTimeout;
  swiper.virtual = {
    cache: {},
    from: undefined,
    to: undefined,
    slides: [],
    offset: 0,
    slidesGrid: []
  };

  function renderSlide(slide, index) {
    const params = swiper.params.virtual;

    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }

    const $slideEl = params.renderSlide ? (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params.renderSlide.call(swiper, slide, index)) : (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  }

  function update(force) {
    const {
      slidesPerView,
      slidesPerGroup,
      centeredSlides
    } = swiper.params;
    const {
      addSlidesBefore,
      addSlidesAfter
    } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      offset: previousOffset
    } = swiper.virtual;

    if (!swiper.params.cssMode) {
      swiper.updateActiveIndex();
    }

    const activeIndex = swiper.activeIndex || 0;
    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
    let slidesAfter;
    let slidesBefore;

    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = slidesPerGroup + addSlidesBefore;
    }

    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    Object.assign(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }

      emit('virtualUpdate');
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset}px`);
      }

      swiper.updateProgress();
      emit('virtualUpdate');
      return;
    }

    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: function getSlides() {
          const slidesToRender = [];

          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }

          return slidesToRender;
        }()
      });

      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      } else {
        emit('virtualUpdate');
      }

      return;
    }

    const prependIndexes = [];
    const appendIndexes = [];

    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }

    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo) appendIndexes.push(i);
          if (i < previousFrom) prependIndexes.push(i);
        }
      }
    }

    appendIndexes.forEach(index => {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort((a, b) => b - a).forEach(index => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
    onRendered();
  }

  function appendSlide(slides) {
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }

    update(true);
  }

  function prependSlide(slides) {
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;

    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }

      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }

    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach(cachedIndex => {
        const $cachedEl = cache[cachedIndex];
        const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');

        if (cachedElIndex) {
          $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
        }

        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
      });
      swiper.virtual.cache = newCache;
    }

    update(true);
    swiper.slideTo(newActiveIndex, 0);
  }

  function removeSlide(slidesIndexes) {
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;

    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);

        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }

        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);

      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }

      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }

    update(true);
    swiper.slideTo(activeIndex, 0);
  }

  function removeAllSlides() {
    swiper.virtual.slides = [];

    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }

    update(true);
    swiper.slideTo(0, 0);
  }

  on('beforeInit', () => {
    if (!swiper.params.virtual.enabled) return;
    swiper.virtual.slides = swiper.params.virtual.slides;
    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;

    if (!swiper.params.initialSlide) {
      update();
    }
  });
  on('setTranslate', () => {
    if (!swiper.params.virtual.enabled) return;

    if (swiper.params.cssMode && !swiper._immediateVirtual) {
      clearTimeout(cssModeTimeout);
      cssModeTimeout = setTimeout(() => {
        update();
      }, 100);
    } else {
      update();
    }
  });
  on('init update resize', () => {
    if (!swiper.params.virtual.enabled) return;

    if (swiper.params.cssMode) {
      (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_1__.setCSSProperty)(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
    }
  });
  Object.assign(swiper.virtual, {
    appendSlide,
    prependSlide,
    removeSlide,
    removeAllSlides,
    update
  });
}

/***/ }),

/***/ "./node_modules/swiper/modules/zoom/zoom.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/zoom/zoom.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Zoom)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _shared_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/dom.js */ "./node_modules/swiper/shared/dom.js");
/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils.js */ "./node_modules/swiper/shared/utils.js");



function Zoom({
  swiper,
  extendParams,
  on,
  emit
}) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  extendParams({
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed'
    }
  });
  swiper.zoom = {
    enabled: false
  };
  let currentScale = 1;
  let isScaling = false;
  let gesturesEnabled;
  let fakeGestureTouched;
  let fakeGestureMoved;
  const gesture = {
    $slideEl: undefined,
    slideWidth: undefined,
    slideHeight: undefined,
    $imageEl: undefined,
    $imageWrapEl: undefined,
    maxRatio: 3
  };
  const image = {
    isTouched: undefined,
    isMoved: undefined,
    currentX: undefined,
    currentY: undefined,
    minX: undefined,
    minY: undefined,
    maxX: undefined,
    maxY: undefined,
    width: undefined,
    height: undefined,
    startX: undefined,
    startY: undefined,
    touchesStart: {},
    touchesCurrent: {}
  };
  const velocity = {
    x: undefined,
    y: undefined,
    prevPositionX: undefined,
    prevPositionY: undefined,
    prevTime: undefined
  };
  let scale = 1;
  Object.defineProperty(swiper.zoom, 'scale', {
    get() {
      return scale;
    },

    set(value) {
      if (scale !== value) {
        const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
        const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
        emit('zoomChange', value, imageEl, slideEl);
      }

      scale = value;
    }

  });

  function getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    return distance;
  } // Events


  function onGestureStart(e) {
    const support = swiper.support;
    const params = swiper.params.zoom;
    fakeGestureTouched = false;
    fakeGestureMoved = false;

    if (!support.gestures) {
      if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
        return;
      }

      fakeGestureTouched = true;
      gesture.scaleStart = getDistanceBetweenTouches(e);
    }

    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest(`.${swiper.params.slideClass}`);
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }

    if (gesture.$imageEl) {
      gesture.$imageEl.transition(0);
    }

    isScaling = true;
  }

  function onGestureChange(e) {
    const support = swiper.support;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;

    if (!support.gestures) {
      if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
        return;
      }

      fakeGestureMoved = true;
      gesture.scaleMove = getDistanceBetweenTouches(e);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
      if (e.type === 'gesturechange') onGestureStart(e);
      return;
    }

    if (support.gestures) {
      zoom.scale = e.scale * currentScale;
    } else {
      zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
    }

    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
    }

    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
    }

    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  }

  function onGestureEnd(e) {
    const device = swiper.device;
    const support = swiper.support;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;

    if (!support.gestures) {
      if (!fakeGestureTouched || !fakeGestureMoved) {
        return;
      }

      if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
        return;
      }

      fakeGestureTouched = false;
      fakeGestureMoved = false;
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    currentScale = zoom.scale;
    isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  }

  function onTouchStart(e) {
    const device = swiper.device;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  }

  function onTouchMove(e) {
    const zoom = swiper.zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.getTranslate)(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_2__.getTranslate)(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
    } // Define if we need image drag


    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        return;
      }

      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        return;
      }
    }

    if (e.cancelable) {
      e.preventDefault();
    }

    e.stopPropagation();
    image.isMoved = true;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
    }

    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
    }

    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
    }

    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
    } // Velocity


    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  }

  function onTouchEnd() {
    const zoom = swiper.zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }

    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY; // Fix duration

    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY; // Define if we need image drag

    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  }

  function onTransitionEnd() {
    const zoom = swiper.zoom;

    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      if (gesture.$imageEl) {
        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      }

      if (gesture.$imageWrapEl) {
        gesture.$imageWrapEl.transform('translate3d(0,0,0)');
      }

      zoom.scale = 1;
      currentScale = 1;
      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;
    }
  }

  function zoomIn(e) {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;

    if (!gesture.$slideEl) {
      if (e && e.target) {
        gesture.$slideEl = (0,_shared_dom_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e.target).closest(`.${swiper.params.slideClass}`);
      }

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }
      }

      gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;

    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.touchAction = 'none';
    }

    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left + window.scrollX;
      offsetY = gesture.$slideEl.offset().top + window.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }

      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }

      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }

    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  }

  function zoomOut() {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }

      gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;

    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = '';
      swiper.wrapperEl.style.touchAction = '';
    }

    zoom.scale = 1;
    currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = undefined;
  } // Toggle Zoom


  function zoomToggle(e) {
    const zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoomOut();
    } else {
      // Zoom In
      zoomIn(e);
    }
  }

  function getListeners() {
    const support = swiper.support;
    const passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    const activeListenerWithCapture = support.passiveListener ? {
      passive: false,
      capture: true
    } : true;
    return {
      passiveListener,
      activeListenerWithCapture
    };
  }

  function getSlideSelector() {
    return `.${swiper.params.slideClass}`;
  }

  function toggleGestures(method) {
    const {
      passiveListener
    } = getListeners();
    const slideSelector = getSlideSelector();
    swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
    swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
    swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
  }

  function enableGestures() {
    if (gesturesEnabled) return;
    gesturesEnabled = true;
    toggleGestures('on');
  }

  function disableGestures() {
    if (!gesturesEnabled) return;
    gesturesEnabled = false;
    toggleGestures('off');
  } // Attach/Detach Events


  function enable() {
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;
    const support = swiper.support;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();
    const slideSelector = getSlideSelector(); // Scale image

    if (support.gestures) {
      swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);

      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
      }
    } // Move image


    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
  }

  function disable() {
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;
    const support = swiper.support;
    zoom.enabled = false;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();
    const slideSelector = getSlideSelector(); // Scale image

    if (support.gestures) {
      swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);

      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
      }
    } // Move image


    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
  }

  on('init', () => {
    if (swiper.params.zoom.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    disable();
  });
  on('touchStart', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchStart(e);
  });
  on('touchEnd', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchEnd(e);
  });
  on('doubleTap', (_s, e) => {
    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
      zoomToggle(e);
    }
  });
  on('transitionEnd', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
      onTransitionEnd();
    }
  });
  on('slideChange', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
      onTransitionEnd();
    }
  });
  Object.assign(swiper.zoom, {
    enable,
    disable,
    in: zoomIn,
    out: zoomOut,
    toggle: zoomToggle
  });
}

/***/ }),

/***/ "./node_modules/swiper/shared/calc-looped-slides.js":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/shared/calc-looped-slides.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calcLoopedSlides": () => (/* binding */ calcLoopedSlides)
/* harmony export */ });
/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ "./node_modules/swiper/swiper.esm.js");

const calcLoopedSlides = (slides, swiperParams) => {
  let slidesPerViewParams = swiperParams.slidesPerView;

  if (swiperParams.breakpoints) {
    const breakpoint = swiper__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.getBreakpoint(swiperParams.breakpoints);
    const breakpointOnlyParams = breakpoint in swiperParams.breakpoints ? swiperParams.breakpoints[breakpoint] : undefined;

    if (breakpointOnlyParams && breakpointOnlyParams.slidesPerView) {
      slidesPerViewParams = breakpointOnlyParams.slidesPerView;
    }
  }

  let loopedSlides = Math.ceil(parseFloat(swiperParams.loopedSlides || slidesPerViewParams, 10));
  loopedSlides += swiperParams.loopAdditionalSlides;

  if (loopedSlides > slides.length && swiperParams.loopedSlidesLimit) {
    loopedSlides = slides.length;
  }

  return loopedSlides;
};

/***/ }),

/***/ "./node_modules/swiper/shared/classes-to-selector.js":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/shared/classes-to-selector.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ classesToSelector)
/* harmony export */ });
function classesToSelector(classes = '') {
  return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
}

/***/ }),

/***/ "./node_modules/swiper/shared/create-element-if-not-defined.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/shared/create-element-if-not-defined.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createElementIfNotDefined)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();

  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach(key => {
      if (!params[key] && params.auto === true) {
        let element = swiper.$el.children(`.${checkProps[key]}`)[0];

        if (!element) {
          element = document.createElement('div');
          element.className = checkProps[key];
          swiper.$el.append(element);
        }

        params[key] = element;
        originalParams[key] = element;
      }
    });
  }

  return params;
}

/***/ }),

/***/ "./node_modules/swiper/shared/create-shadow.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/shared/create-shadow.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createShadow)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/swiper/shared/dom.js");

function createShadow(params, $slideEl, side) {
  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
  const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
  let $shadowEl = $shadowContainer.children(`.${shadowClass}`);

  if (!$shadowEl.length) {
    $shadowEl = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__["default"])(`<div class="swiper-slide-shadow${side ? `-${side}` : ''}"></div>`);
    $shadowContainer.append($shadowEl);
  }

  return $shadowEl;
}

/***/ }),

/***/ "./node_modules/swiper/shared/dom.js":
/*!*******************************************!*\
  !*** ./node_modules/swiper/shared/dom.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var dom7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dom7 */ "./node_modules/dom7/dom7.esm.js");

const Methods = {
  addClass: dom7__WEBPACK_IMPORTED_MODULE_0__.addClass,
  removeClass: dom7__WEBPACK_IMPORTED_MODULE_0__.removeClass,
  hasClass: dom7__WEBPACK_IMPORTED_MODULE_0__.hasClass,
  toggleClass: dom7__WEBPACK_IMPORTED_MODULE_0__.toggleClass,
  attr: dom7__WEBPACK_IMPORTED_MODULE_0__.attr,
  removeAttr: dom7__WEBPACK_IMPORTED_MODULE_0__.removeAttr,
  transform: dom7__WEBPACK_IMPORTED_MODULE_0__.transform,
  transition: dom7__WEBPACK_IMPORTED_MODULE_0__.transition,
  on: dom7__WEBPACK_IMPORTED_MODULE_0__.on,
  off: dom7__WEBPACK_IMPORTED_MODULE_0__.off,
  trigger: dom7__WEBPACK_IMPORTED_MODULE_0__.trigger,
  transitionEnd: dom7__WEBPACK_IMPORTED_MODULE_0__.transitionEnd,
  outerWidth: dom7__WEBPACK_IMPORTED_MODULE_0__.outerWidth,
  outerHeight: dom7__WEBPACK_IMPORTED_MODULE_0__.outerHeight,
  styles: dom7__WEBPACK_IMPORTED_MODULE_0__.styles,
  offset: dom7__WEBPACK_IMPORTED_MODULE_0__.offset,
  css: dom7__WEBPACK_IMPORTED_MODULE_0__.css,
  each: dom7__WEBPACK_IMPORTED_MODULE_0__.each,
  html: dom7__WEBPACK_IMPORTED_MODULE_0__.html,
  text: dom7__WEBPACK_IMPORTED_MODULE_0__.text,
  is: dom7__WEBPACK_IMPORTED_MODULE_0__.is,
  index: dom7__WEBPACK_IMPORTED_MODULE_0__.index,
  eq: dom7__WEBPACK_IMPORTED_MODULE_0__.eq,
  append: dom7__WEBPACK_IMPORTED_MODULE_0__.append,
  prepend: dom7__WEBPACK_IMPORTED_MODULE_0__.prepend,
  next: dom7__WEBPACK_IMPORTED_MODULE_0__.next,
  nextAll: dom7__WEBPACK_IMPORTED_MODULE_0__.nextAll,
  prev: dom7__WEBPACK_IMPORTED_MODULE_0__.prev,
  prevAll: dom7__WEBPACK_IMPORTED_MODULE_0__.prevAll,
  parent: dom7__WEBPACK_IMPORTED_MODULE_0__.parent,
  parents: dom7__WEBPACK_IMPORTED_MODULE_0__.parents,
  closest: dom7__WEBPACK_IMPORTED_MODULE_0__.closest,
  find: dom7__WEBPACK_IMPORTED_MODULE_0__.find,
  children: dom7__WEBPACK_IMPORTED_MODULE_0__.children,
  filter: dom7__WEBPACK_IMPORTED_MODULE_0__.filter,
  remove: dom7__WEBPACK_IMPORTED_MODULE_0__.remove
};
Object.keys(Methods).forEach(methodName => {
  Object.defineProperty(dom7__WEBPACK_IMPORTED_MODULE_0__.$.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dom7__WEBPACK_IMPORTED_MODULE_0__.$);

/***/ }),

/***/ "./node_modules/swiper/shared/effect-init.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/shared/effect-init.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ effectInit)
/* harmony export */ });
function effectInit(params) {
  const {
    effect,
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams,
    perspective,
    recreateShadows,
    getEffectParams
  } = params;
  on('beforeInit', () => {
    if (swiper.params.effect !== effect) return;
    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);

    if (perspective && perspective()) {
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
    }

    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on('setTranslate', () => {
    if (swiper.params.effect !== effect) return;
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    if (swiper.params.effect !== effect) return;
    setTransition(duration);
  });
  on('transitionEnd', () => {
    if (swiper.params.effect !== effect) return;

    if (recreateShadows) {
      if (!getEffectParams || !getEffectParams().slideShadows) return; // remove shadows

      swiper.slides.each(slideEl => {
        const $slideEl = swiper.$(slideEl);
        $slideEl.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').remove();
      }); // create new one

      recreateShadows();
    }
  });
  let requireUpdateOnVirtual;
  on('virtualUpdate', () => {
    if (swiper.params.effect !== effect) return;

    if (!swiper.slides.length) {
      requireUpdateOnVirtual = true;
    }

    requestAnimationFrame(() => {
      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
        setTranslate();
        requireUpdateOnVirtual = false;
      }
    });
  });
}

/***/ }),

/***/ "./node_modules/swiper/shared/effect-target.js":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/shared/effect-target.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ effectTarget)
/* harmony export */ });
function effectTarget(effectParams, $slideEl) {
  if (effectParams.transformEl) {
    return $slideEl.find(effectParams.transformEl).css({
      'backface-visibility': 'hidden',
      '-webkit-backface-visibility': 'hidden'
    });
  }

  return $slideEl;
}

/***/ }),

/***/ "./node_modules/swiper/shared/effect-virtual-transition-end.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swiper/shared/effect-virtual-transition-end.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ effectVirtualTransitionEnd)
/* harmony export */ });
function effectVirtualTransitionEnd({
  swiper,
  duration,
  transformEl,
  allSlides
}) {
  const {
    slides,
    activeIndex,
    $wrapperEl
  } = swiper;

  if (swiper.params.virtualTranslate && duration !== 0) {
    let eventTriggered = false;
    let $transitionEndTarget;

    if (allSlides) {
      $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
    } else {
      $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
    }

    $transitionEndTarget.transitionEnd(() => {
      if (eventTriggered) return;
      if (!swiper || swiper.destroyed) return;
      eventTriggered = true;
      swiper.animating = false;
      const triggerEvents = ['webkitTransitionEnd', 'transitionend'];

      for (let i = 0; i < triggerEvents.length; i += 1) {
        $wrapperEl.trigger(triggerEvents[i]);
      }
    });
  }
}

/***/ }),

/***/ "./node_modules/swiper/shared/get-browser.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/shared/get-browser.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getBrowser": () => (/* binding */ getBrowser)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

let browser;

function calcBrowser() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();

  function isSafari() {
    const ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }

  return {
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
  };
}

function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }

  return browser;
}



/***/ }),

/***/ "./node_modules/swiper/shared/get-device.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/shared/get-device.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDevice": () => (/* binding */ getDevice)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");
/* harmony import */ var _get_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-support.js */ "./node_modules/swiper/shared/get-support.js");


let deviceCached;

function calcDevice({
  userAgent
} = {}) {
  const support = (0,_get_support_js__WEBPACK_IMPORTED_MODULE_1__.getSupport)();
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel'; // iPadOs 13 fix

  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  } // Android


  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }

  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  } // Export object


  return device;
}

function getDevice(overrides = {}) {
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }

  return deviceCached;
}



/***/ }),

/***/ "./node_modules/swiper/shared/get-support.js":
/*!***************************************************!*\
  !*** ./node_modules/swiper/shared/get-support.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSupport": () => (/* binding */ getSupport)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");

let support;

function calcSupport() {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const document = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
  return {
    smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    passiveListener: function checkPassiveListener() {
      let supportsPassive = false;

      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          }

        });
        window.addEventListener('testPassiveListener', null, opts);
      } catch (e) {// No support
      }

      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return 'ongesturestart' in window;
    }()
  };
}

function getSupport() {
  if (!support) {
    support = calcSupport();
  }

  return support;
}



/***/ }),

/***/ "./node_modules/swiper/shared/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/swiper/shared/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "animateCSSModeScroll": () => (/* binding */ animateCSSModeScroll),
/* harmony export */   "deleteProps": () => (/* binding */ deleteProps),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "getComputedStyle": () => (/* binding */ getComputedStyle),
/* harmony export */   "getTranslate": () => (/* binding */ getTranslate),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "setCSSProperty": () => (/* binding */ setCSSProperty)
/* harmony export */ });
/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/ssr-window.esm.js");


function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {// no getter for object
    }

    try {
      delete object[key];
    } catch (e) {// something got wrong
    }
  });
}

function nextTick(callback, delay = 0) {
  return setTimeout(callback, delay);
}

function now() {
  return Date.now();
}

function getComputedStyle(el) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let style;

  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }

  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }

  if (!style) {
    style = el.style;
  }

  return style;
}

function getTranslate(el, axis = 'x') {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle(el, null);

  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;

    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    } // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case


    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }

  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }

  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }

  return curTransform || 0;
}

function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}

function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }

  return node && (node.nodeType === 1 || node.nodeType === 11);
}

function extend(...args) {
  const to = Object(args[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];

  for (let i = 1; i < args.length; i += 1) {
    const nextSource = args[i];

    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);

      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};

            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }

  return to;
}

function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}

function animateCSSModeScroll({
  swiper,
  targetPosition,
  side
}) {
  const window = (0,ssr_window__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';

  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };

  const animate = () => {
    time = new Date().getTime();

    if (startTime === null) {
      startTime = time;
    }

    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);

    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }

    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });

    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }

    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
  };

  animate();
}



/***/ }),

/***/ "./node_modules/swiper/swiper-bundle.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/swiper/swiper-bundle.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Swiper": () => (/* reexport safe */ _core_core_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (/* reexport safe */ _core_core_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _core_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/core.js */ "./node_modules/swiper/core/core.js");
/* harmony import */ var _modules_virtual_virtual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/virtual/virtual.js */ "./node_modules/swiper/modules/virtual/virtual.js");
/* harmony import */ var _modules_keyboard_keyboard_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/keyboard/keyboard.js */ "./node_modules/swiper/modules/keyboard/keyboard.js");
/* harmony import */ var _modules_mousewheel_mousewheel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/mousewheel/mousewheel.js */ "./node_modules/swiper/modules/mousewheel/mousewheel.js");
/* harmony import */ var _modules_navigation_navigation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/navigation/navigation.js */ "./node_modules/swiper/modules/navigation/navigation.js");
/* harmony import */ var _modules_pagination_pagination_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/pagination/pagination.js */ "./node_modules/swiper/modules/pagination/pagination.js");
/* harmony import */ var _modules_scrollbar_scrollbar_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/scrollbar/scrollbar.js */ "./node_modules/swiper/modules/scrollbar/scrollbar.js");
/* harmony import */ var _modules_parallax_parallax_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/parallax/parallax.js */ "./node_modules/swiper/modules/parallax/parallax.js");
/* harmony import */ var _modules_zoom_zoom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/zoom/zoom.js */ "./node_modules/swiper/modules/zoom/zoom.js");
/* harmony import */ var _modules_lazy_lazy_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/lazy/lazy.js */ "./node_modules/swiper/modules/lazy/lazy.js");
/* harmony import */ var _modules_controller_controller_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/controller/controller.js */ "./node_modules/swiper/modules/controller/controller.js");
/* harmony import */ var _modules_a11y_a11y_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/a11y/a11y.js */ "./node_modules/swiper/modules/a11y/a11y.js");
/* harmony import */ var _modules_history_history_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/history/history.js */ "./node_modules/swiper/modules/history/history.js");
/* harmony import */ var _modules_hash_navigation_hash_navigation_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/hash-navigation/hash-navigation.js */ "./node_modules/swiper/modules/hash-navigation/hash-navigation.js");
/* harmony import */ var _modules_autoplay_autoplay_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/autoplay/autoplay.js */ "./node_modules/swiper/modules/autoplay/autoplay.js");
/* harmony import */ var _modules_thumbs_thumbs_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/thumbs/thumbs.js */ "./node_modules/swiper/modules/thumbs/thumbs.js");
/* harmony import */ var _modules_free_mode_free_mode_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modules/free-mode/free-mode.js */ "./node_modules/swiper/modules/free-mode/free-mode.js");
/* harmony import */ var _modules_grid_grid_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./modules/grid/grid.js */ "./node_modules/swiper/modules/grid/grid.js");
/* harmony import */ var _modules_manipulation_manipulation_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./modules/manipulation/manipulation.js */ "./node_modules/swiper/modules/manipulation/manipulation.js");
/* harmony import */ var _modules_effect_fade_effect_fade_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./modules/effect-fade/effect-fade.js */ "./node_modules/swiper/modules/effect-fade/effect-fade.js");
/* harmony import */ var _modules_effect_cube_effect_cube_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./modules/effect-cube/effect-cube.js */ "./node_modules/swiper/modules/effect-cube/effect-cube.js");
/* harmony import */ var _modules_effect_flip_effect_flip_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./modules/effect-flip/effect-flip.js */ "./node_modules/swiper/modules/effect-flip/effect-flip.js");
/* harmony import */ var _modules_effect_coverflow_effect_coverflow_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./modules/effect-coverflow/effect-coverflow.js */ "./node_modules/swiper/modules/effect-coverflow/effect-coverflow.js");
/* harmony import */ var _modules_effect_creative_effect_creative_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./modules/effect-creative/effect-creative.js */ "./node_modules/swiper/modules/effect-creative/effect-creative.js");
/* harmony import */ var _modules_effect_cards_effect_cards_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./modules/effect-cards/effect-cards.js */ "./node_modules/swiper/modules/effect-cards/effect-cards.js");
/**
 * Swiper 8.4.5
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: November 21, 2022
 */




























// Swiper Class
const modules = [_modules_virtual_virtual_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modules_keyboard_keyboard_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modules_mousewheel_mousewheel_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modules_navigation_navigation_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modules_pagination_pagination_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modules_scrollbar_scrollbar_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modules_parallax_parallax_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modules_zoom_zoom_js__WEBPACK_IMPORTED_MODULE_8__["default"], _modules_lazy_lazy_js__WEBPACK_IMPORTED_MODULE_9__["default"], _modules_controller_controller_js__WEBPACK_IMPORTED_MODULE_10__["default"], _modules_a11y_a11y_js__WEBPACK_IMPORTED_MODULE_11__["default"], _modules_history_history_js__WEBPACK_IMPORTED_MODULE_12__["default"], _modules_hash_navigation_hash_navigation_js__WEBPACK_IMPORTED_MODULE_13__["default"], _modules_autoplay_autoplay_js__WEBPACK_IMPORTED_MODULE_14__["default"], _modules_thumbs_thumbs_js__WEBPACK_IMPORTED_MODULE_15__["default"], _modules_free_mode_free_mode_js__WEBPACK_IMPORTED_MODULE_16__["default"], _modules_grid_grid_js__WEBPACK_IMPORTED_MODULE_17__["default"], _modules_manipulation_manipulation_js__WEBPACK_IMPORTED_MODULE_18__["default"], _modules_effect_fade_effect_fade_js__WEBPACK_IMPORTED_MODULE_19__["default"], _modules_effect_cube_effect_cube_js__WEBPACK_IMPORTED_MODULE_20__["default"], _modules_effect_flip_effect_flip_js__WEBPACK_IMPORTED_MODULE_21__["default"], _modules_effect_coverflow_effect_coverflow_js__WEBPACK_IMPORTED_MODULE_22__["default"], _modules_effect_creative_effect_creative_js__WEBPACK_IMPORTED_MODULE_23__["default"], _modules_effect_cards_effect_cards_js__WEBPACK_IMPORTED_MODULE_24__["default"]];
_core_core_js__WEBPACK_IMPORTED_MODULE_0__["default"].use(modules);


/***/ }),

/***/ "./node_modules/swiper/swiper.esm.js":
/*!*******************************************!*\
  !*** ./node_modules/swiper/swiper.esm.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A11y": () => (/* reexport safe */ _modules_a11y_a11y_js__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "Autoplay": () => (/* reexport safe */ _modules_autoplay_autoplay_js__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   "Controller": () => (/* reexport safe */ _modules_controller_controller_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "EffectCards": () => (/* reexport safe */ _modules_effect_cards_effect_cards_js__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   "EffectCoverflow": () => (/* reexport safe */ _modules_effect_coverflow_effect_coverflow_js__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   "EffectCreative": () => (/* reexport safe */ _modules_effect_creative_effect_creative_js__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   "EffectCube": () => (/* reexport safe */ _modules_effect_cube_effect_cube_js__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   "EffectFade": () => (/* reexport safe */ _modules_effect_fade_effect_fade_js__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   "EffectFlip": () => (/* reexport safe */ _modules_effect_flip_effect_flip_js__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   "FreeMode": () => (/* reexport safe */ _modules_free_mode_free_mode_js__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   "Grid": () => (/* reexport safe */ _modules_grid_grid_js__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   "HashNavigation": () => (/* reexport safe */ _modules_hash_navigation_hash_navigation_js__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "History": () => (/* reexport safe */ _modules_history_history_js__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "Keyboard": () => (/* reexport safe */ _modules_keyboard_keyboard_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "Lazy": () => (/* reexport safe */ _modules_lazy_lazy_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "Manipulation": () => (/* reexport safe */ _modules_manipulation_manipulation_js__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   "Mousewheel": () => (/* reexport safe */ _modules_mousewheel_mousewheel_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "Navigation": () => (/* reexport safe */ _modules_navigation_navigation_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "Pagination": () => (/* reexport safe */ _modules_pagination_pagination_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "Parallax": () => (/* reexport safe */ _modules_parallax_parallax_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "Scrollbar": () => (/* reexport safe */ _modules_scrollbar_scrollbar_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "Swiper": () => (/* reexport safe */ _core_core_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "Thumbs": () => (/* reexport safe */ _modules_thumbs_thumbs_js__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   "Virtual": () => (/* reexport safe */ _modules_virtual_virtual_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "Zoom": () => (/* reexport safe */ _modules_zoom_zoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "default": () => (/* reexport safe */ _core_core_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _core_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/core.js */ "./node_modules/swiper/core/core.js");
/* harmony import */ var _modules_virtual_virtual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/virtual/virtual.js */ "./node_modules/swiper/modules/virtual/virtual.js");
/* harmony import */ var _modules_keyboard_keyboard_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/keyboard/keyboard.js */ "./node_modules/swiper/modules/keyboard/keyboard.js");
/* harmony import */ var _modules_mousewheel_mousewheel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/mousewheel/mousewheel.js */ "./node_modules/swiper/modules/mousewheel/mousewheel.js");
/* harmony import */ var _modules_navigation_navigation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/navigation/navigation.js */ "./node_modules/swiper/modules/navigation/navigation.js");
/* harmony import */ var _modules_pagination_pagination_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/pagination/pagination.js */ "./node_modules/swiper/modules/pagination/pagination.js");
/* harmony import */ var _modules_scrollbar_scrollbar_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/scrollbar/scrollbar.js */ "./node_modules/swiper/modules/scrollbar/scrollbar.js");
/* harmony import */ var _modules_parallax_parallax_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/parallax/parallax.js */ "./node_modules/swiper/modules/parallax/parallax.js");
/* harmony import */ var _modules_zoom_zoom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/zoom/zoom.js */ "./node_modules/swiper/modules/zoom/zoom.js");
/* harmony import */ var _modules_lazy_lazy_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/lazy/lazy.js */ "./node_modules/swiper/modules/lazy/lazy.js");
/* harmony import */ var _modules_controller_controller_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/controller/controller.js */ "./node_modules/swiper/modules/controller/controller.js");
/* harmony import */ var _modules_a11y_a11y_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/a11y/a11y.js */ "./node_modules/swiper/modules/a11y/a11y.js");
/* harmony import */ var _modules_history_history_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/history/history.js */ "./node_modules/swiper/modules/history/history.js");
/* harmony import */ var _modules_hash_navigation_hash_navigation_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/hash-navigation/hash-navigation.js */ "./node_modules/swiper/modules/hash-navigation/hash-navigation.js");
/* harmony import */ var _modules_autoplay_autoplay_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/autoplay/autoplay.js */ "./node_modules/swiper/modules/autoplay/autoplay.js");
/* harmony import */ var _modules_thumbs_thumbs_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/thumbs/thumbs.js */ "./node_modules/swiper/modules/thumbs/thumbs.js");
/* harmony import */ var _modules_free_mode_free_mode_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modules/free-mode/free-mode.js */ "./node_modules/swiper/modules/free-mode/free-mode.js");
/* harmony import */ var _modules_grid_grid_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./modules/grid/grid.js */ "./node_modules/swiper/modules/grid/grid.js");
/* harmony import */ var _modules_manipulation_manipulation_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./modules/manipulation/manipulation.js */ "./node_modules/swiper/modules/manipulation/manipulation.js");
/* harmony import */ var _modules_effect_fade_effect_fade_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./modules/effect-fade/effect-fade.js */ "./node_modules/swiper/modules/effect-fade/effect-fade.js");
/* harmony import */ var _modules_effect_cube_effect_cube_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./modules/effect-cube/effect-cube.js */ "./node_modules/swiper/modules/effect-cube/effect-cube.js");
/* harmony import */ var _modules_effect_flip_effect_flip_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./modules/effect-flip/effect-flip.js */ "./node_modules/swiper/modules/effect-flip/effect-flip.js");
/* harmony import */ var _modules_effect_coverflow_effect_coverflow_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./modules/effect-coverflow/effect-coverflow.js */ "./node_modules/swiper/modules/effect-coverflow/effect-coverflow.js");
/* harmony import */ var _modules_effect_creative_effect_creative_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./modules/effect-creative/effect-creative.js */ "./node_modules/swiper/modules/effect-creative/effect-creative.js");
/* harmony import */ var _modules_effect_cards_effect_cards_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./modules/effect-cards/effect-cards.js */ "./node_modules/swiper/modules/effect-cards/effect-cards.js");
/**
 * Swiper 8.4.5
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: November 21, 2022
 */



























/***/ }),

/***/ "./node_modules/swiper/vue/context.js":
/*!********************************************!*\
  !*** ./node_modules/swiper/vue/context.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useSwiper": () => (/* binding */ useSwiper),
/* harmony export */   "useSwiperSlide": () => (/* binding */ useSwiperSlide)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

const useSwiperSlide = () => {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)('swiperSlide');
};
const useSwiper = () => {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)('swiper');
};

/***/ }),

/***/ "./node_modules/swiper/vue/get-children.js":
/*!*************************************************!*\
  !*** ./node_modules/swiper/vue/get-children.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getChildren": () => (/* binding */ getChildren)
/* harmony export */ });
function getChildren(originalSlots, slidesRef, oldSlidesRef) {
  if (originalSlots === void 0) {
    originalSlots = {};
  }

  const slides = [];
  const slots = {
    'container-start': [],
    'container-end': [],
    'wrapper-start': [],
    'wrapper-end': []
  };

  const getSlidesFromElements = (els, slotName) => {
    if (!Array.isArray(els)) {
      return;
    }

    els.forEach(vnode => {
      const isFragment = typeof vnode.type === 'symbol';
      if (slotName === 'default') slotName = 'container-end';

      if (isFragment && vnode.children) {
        getSlidesFromElements(vnode.children, 'default');
      } else if (vnode.type && (vnode.type.name === 'SwiperSlide' || vnode.type.name === 'AsyncComponentWrapper')) {
        slides.push(vnode);
      } else if (slots[slotName]) {
        slots[slotName].push(vnode);
      }
    });
  };

  Object.keys(originalSlots).forEach(slotName => {
    if (typeof originalSlots[slotName] !== 'function') return;
    const els = originalSlots[slotName]();
    getSlidesFromElements(els, slotName);
  });
  oldSlidesRef.value = slidesRef.value;
  slidesRef.value = slides;
  return {
    slides,
    slots
  };
}



/***/ }),

/***/ "./node_modules/swiper/vue/loop.js":
/*!*****************************************!*\
  !*** ./node_modules/swiper/vue/loop.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calcLoopedSlides": () => (/* reexport safe */ _shared_calc_looped_slides_js__WEBPACK_IMPORTED_MODULE_0__.calcLoopedSlides),
/* harmony export */   "renderLoop": () => (/* binding */ renderLoop)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _shared_calc_looped_slides_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/calc-looped-slides.js */ "./node_modules/swiper/shared/calc-looped-slides.js");



function renderLoop(swiperRef, slides, swiperParams) {
  const modifiedSlides = slides.map((child, index) => {
    if (!child.props) child.props = {};
    child.props.swiperRef = swiperRef;
    child.props['data-swiper-slide-index'] = index;
    return child;
  });

  function duplicateSlide(child, index, position) {
    if (!child.props) child.props = {};
    return (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)(child.type, { ...child.props,
      key: `${child.key}-duplicate-${index}-${position}`,
      class: `${child.props.className || ''} ${swiperParams.slideDuplicateClass} ${child.props.class || ''}`
    }, child.children);
  }

  if (swiperParams.loopFillGroupWithBlank) {
    const blankSlidesNum = swiperParams.slidesPerGroup - modifiedSlides.length % swiperParams.slidesPerGroup;

    if (blankSlidesNum !== swiperParams.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankSlide = (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('div', {
          class: `${swiperParams.slideClass} ${swiperParams.slideBlankClass}`
        });
        modifiedSlides.push(blankSlide);
      }
    }
  }

  if (swiperParams.slidesPerView === 'auto' && !swiperParams.loopedSlides) {
    swiperParams.loopedSlides = modifiedSlides.length;
  }

  const loopedSlides = (0,_shared_calc_looped_slides_js__WEBPACK_IMPORTED_MODULE_0__.calcLoopedSlides)(modifiedSlides, swiperParams);
  const prependSlides = [];
  const appendSlides = [];

  for (let i = 0; i < loopedSlides; i += 1) {
    const index = i - Math.floor(i / modifiedSlides.length) * modifiedSlides.length;
    appendSlides.push(duplicateSlide(modifiedSlides[index], i, 'append'));
    prependSlides.unshift(duplicateSlide(modifiedSlides[modifiedSlides.length - index - 1], i, 'prepend'));
  }

  if (swiperRef.value) {
    swiperRef.value.loopedSlides = loopedSlides;
  }

  return [...prependSlides, ...modifiedSlides, ...appendSlides];
}



/***/ }),

/***/ "./node_modules/swiper/vue/swiper-slide.js":
/*!*************************************************!*\
  !*** ./node_modules/swiper/vue/swiper-slide.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SwiperSlide": () => (/* binding */ SwiperSlide)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _components_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components-shared/utils.js */ "./node_modules/swiper/components-shared/utils.js");


const SwiperSlide = {
  name: 'SwiperSlide',
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    swiperRef: {
      type: Object,
      required: false
    },
    zoom: {
      type: Boolean,
      default: undefined
    },
    virtualIndex: {
      type: [String, Number],
      default: undefined
    }
  },

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    let eventAttached = false;
    const {
      swiperRef
    } = props;
    const slideElRef = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);
    const slideClasses = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)('swiper-slide');

    function updateClasses(swiper, el, classNames) {
      if (el === slideElRef.value) {
        slideClasses.value = classNames;
      }
    }

    (0,vue__WEBPACK_IMPORTED_MODULE_1__.onMounted)(() => {
      if (!swiperRef || !swiperRef.value) return;
      swiperRef.value.on('_slideClass', updateClasses);
      eventAttached = true;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_1__.onBeforeUpdate)(() => {
      if (eventAttached || !swiperRef || !swiperRef.value) return;
      swiperRef.value.on('_slideClass', updateClasses);
      eventAttached = true;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_1__.onUpdated)(() => {
      if (!slideElRef.value || !swiperRef || !swiperRef.value) return;

      if (swiperRef.value.destroyed) {
        if (slideClasses.value !== 'swiper-slide') {
          slideClasses.value = 'swiper-slide';
        }
      }
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_1__.onBeforeUnmount)(() => {
      if (!swiperRef || !swiperRef.value) return;
      swiperRef.value.off('_slideClass', updateClasses);
    });
    const slideData = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => ({
      isActive: slideClasses.value.indexOf('swiper-slide-active') >= 0 || slideClasses.value.indexOf('swiper-slide-duplicate-active') >= 0,
      isVisible: slideClasses.value.indexOf('swiper-slide-visible') >= 0,
      isDuplicate: slideClasses.value.indexOf('swiper-slide-duplicate') >= 0,
      isPrev: slideClasses.value.indexOf('swiper-slide-prev') >= 0 || slideClasses.value.indexOf('swiper-slide-duplicate-prev') >= 0,
      isNext: slideClasses.value.indexOf('swiper-slide-next') >= 0 || slideClasses.value.indexOf('swiper-slide-duplicate-next') >= 0
    }));
    (0,vue__WEBPACK_IMPORTED_MODULE_1__.provide)('swiperSlide', slideData);
    return () => {
      return (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)(props.tag, {
        class: (0,_components_shared_utils_js__WEBPACK_IMPORTED_MODULE_0__.uniqueClasses)(`${slideClasses.value}`),
        ref: slideElRef,
        'data-swiper-slide-index': props.virtualIndex
      }, props.zoom ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('div', {
        class: 'swiper-zoom-container',
        'data-swiper-zoom': typeof props.zoom === 'number' ? props.zoom : undefined
      }, slots.default && slots.default(slideData.value)) : slots.default && slots.default(slideData.value));
    };
  }

};


/***/ }),

/***/ "./node_modules/swiper/vue/swiper-vue.js":
/*!***********************************************!*\
  !*** ./node_modules/swiper/vue/swiper-vue.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Swiper": () => (/* reexport safe */ _swiper_js__WEBPACK_IMPORTED_MODULE_0__.Swiper),
/* harmony export */   "SwiperSlide": () => (/* reexport safe */ _swiper_slide_js__WEBPACK_IMPORTED_MODULE_1__.SwiperSlide),
/* harmony export */   "useSwiper": () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.useSwiper),
/* harmony export */   "useSwiperSlide": () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.useSwiperSlide)
/* harmony export */ });
/* harmony import */ var _swiper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./swiper.js */ "./node_modules/swiper/vue/swiper.js");
/* harmony import */ var _swiper_slide_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./swiper-slide.js */ "./node_modules/swiper/vue/swiper-slide.js");
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context.js */ "./node_modules/swiper/vue/context.js");
/**
 * Swiper Vue 8.4.5
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: November 21, 2022
 */






/***/ }),

/***/ "./node_modules/swiper/vue/swiper.js":
/*!*******************************************!*\
  !*** ./node_modules/swiper/vue/swiper.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Swiper": () => (/* binding */ Swiper)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ "./node_modules/swiper/swiper.esm.js");
/* harmony import */ var _components_shared_get_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components-shared/get-params.js */ "./node_modules/swiper/components-shared/get-params.js");
/* harmony import */ var _components_shared_mount_swiper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components-shared/mount-swiper.js */ "./node_modules/swiper/components-shared/mount-swiper.js");
/* harmony import */ var _components_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components-shared/utils.js */ "./node_modules/swiper/components-shared/utils.js");
/* harmony import */ var _loop_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loop.js */ "./node_modules/swiper/vue/loop.js");
/* harmony import */ var _components_shared_get_changed_params_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components-shared/get-changed-params.js */ "./node_modules/swiper/components-shared/get-changed-params.js");
/* harmony import */ var _get_children_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-children.js */ "./node_modules/swiper/vue/get-children.js");
/* harmony import */ var _components_shared_update_swiper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components-shared/update-swiper.js */ "./node_modules/swiper/components-shared/update-swiper.js");
/* harmony import */ var _virtual_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./virtual.js */ "./node_modules/swiper/vue/virtual.js");
/* harmony import */ var _components_shared_update_on_virtual_data_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components-shared/update-on-virtual-data.js */ "./node_modules/swiper/components-shared/update-on-virtual-data.js");











const Swiper = {
  name: 'Swiper',
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    wrapperTag: {
      type: String,
      default: 'div'
    },
    modules: {
      type: Array,
      default: undefined
    },
    init: {
      type: Boolean,
      default: undefined
    },
    direction: {
      type: String,
      default: undefined
    },
    touchEventsTarget: {
      type: String,
      default: undefined
    },
    initialSlide: {
      type: Number,
      default: undefined
    },
    speed: {
      type: Number,
      default: undefined
    },
    cssMode: {
      type: Boolean,
      default: undefined
    },
    updateOnWindowResize: {
      type: Boolean,
      default: undefined
    },
    resizeObserver: {
      type: Boolean,
      default: undefined
    },
    nested: {
      type: Boolean,
      default: undefined
    },
    focusableElements: {
      type: String,
      default: undefined
    },
    width: {
      type: Number,
      default: undefined
    },
    height: {
      type: Number,
      default: undefined
    },
    preventInteractionOnTransition: {
      type: Boolean,
      default: undefined
    },
    userAgent: {
      type: String,
      default: undefined
    },
    url: {
      type: String,
      default: undefined
    },
    edgeSwipeDetection: {
      type: [Boolean, String],
      default: undefined
    },
    edgeSwipeThreshold: {
      type: Number,
      default: undefined
    },
    autoHeight: {
      type: Boolean,
      default: undefined
    },
    setWrapperSize: {
      type: Boolean,
      default: undefined
    },
    virtualTranslate: {
      type: Boolean,
      default: undefined
    },
    effect: {
      type: String,
      default: undefined
    },
    breakpoints: {
      type: Object,
      default: undefined
    },
    spaceBetween: {
      type: Number,
      default: undefined
    },
    slidesPerView: {
      type: [Number, String],
      default: undefined
    },
    maxBackfaceHiddenSlides: {
      type: Number,
      default: undefined
    },
    slidesPerGroup: {
      type: Number,
      default: undefined
    },
    slidesPerGroupSkip: {
      type: Number,
      default: undefined
    },
    slidesPerGroupAuto: {
      type: Boolean,
      default: undefined
    },
    centeredSlides: {
      type: Boolean,
      default: undefined
    },
    centeredSlidesBounds: {
      type: Boolean,
      default: undefined
    },
    slidesOffsetBefore: {
      type: Number,
      default: undefined
    },
    slidesOffsetAfter: {
      type: Number,
      default: undefined
    },
    normalizeSlideIndex: {
      type: Boolean,
      default: undefined
    },
    centerInsufficientSlides: {
      type: Boolean,
      default: undefined
    },
    watchOverflow: {
      type: Boolean,
      default: undefined
    },
    roundLengths: {
      type: Boolean,
      default: undefined
    },
    touchRatio: {
      type: Number,
      default: undefined
    },
    touchAngle: {
      type: Number,
      default: undefined
    },
    simulateTouch: {
      type: Boolean,
      default: undefined
    },
    shortSwipes: {
      type: Boolean,
      default: undefined
    },
    longSwipes: {
      type: Boolean,
      default: undefined
    },
    longSwipesRatio: {
      type: Number,
      default: undefined
    },
    longSwipesMs: {
      type: Number,
      default: undefined
    },
    followFinger: {
      type: Boolean,
      default: undefined
    },
    allowTouchMove: {
      type: Boolean,
      default: undefined
    },
    threshold: {
      type: Number,
      default: undefined
    },
    touchMoveStopPropagation: {
      type: Boolean,
      default: undefined
    },
    touchStartPreventDefault: {
      type: Boolean,
      default: undefined
    },
    touchStartForcePreventDefault: {
      type: Boolean,
      default: undefined
    },
    touchReleaseOnEdges: {
      type: Boolean,
      default: undefined
    },
    uniqueNavElements: {
      type: Boolean,
      default: undefined
    },
    resistance: {
      type: Boolean,
      default: undefined
    },
    resistanceRatio: {
      type: Number,
      default: undefined
    },
    watchSlidesProgress: {
      type: Boolean,
      default: undefined
    },
    grabCursor: {
      type: Boolean,
      default: undefined
    },
    preventClicks: {
      type: Boolean,
      default: undefined
    },
    preventClicksPropagation: {
      type: Boolean,
      default: undefined
    },
    slideToClickedSlide: {
      type: Boolean,
      default: undefined
    },
    preloadImages: {
      type: Boolean,
      default: undefined
    },
    updateOnImagesReady: {
      type: Boolean,
      default: undefined
    },
    loop: {
      type: Boolean,
      default: undefined
    },
    loopAdditionalSlides: {
      type: Number,
      default: undefined
    },
    loopedSlides: {
      type: Number,
      default: undefined
    },
    loopedSlidesLimit: {
      type: Boolean,
      default: true
    },
    loopFillGroupWithBlank: {
      type: Boolean,
      default: undefined
    },
    loopPreventsSlide: {
      type: Boolean,
      default: undefined
    },
    rewind: {
      type: Boolean,
      default: undefined
    },
    allowSlidePrev: {
      type: Boolean,
      default: undefined
    },
    allowSlideNext: {
      type: Boolean,
      default: undefined
    },
    swipeHandler: {
      type: Boolean,
      default: undefined
    },
    noSwiping: {
      type: Boolean,
      default: undefined
    },
    noSwipingClass: {
      type: String,
      default: undefined
    },
    noSwipingSelector: {
      type: String,
      default: undefined
    },
    passiveListeners: {
      type: Boolean,
      default: undefined
    },
    containerModifierClass: {
      type: String,
      default: undefined
    },
    slideClass: {
      type: String,
      default: undefined
    },
    slideBlankClass: {
      type: String,
      default: undefined
    },
    slideActiveClass: {
      type: String,
      default: undefined
    },
    slideDuplicateActiveClass: {
      type: String,
      default: undefined
    },
    slideVisibleClass: {
      type: String,
      default: undefined
    },
    slideDuplicateClass: {
      type: String,
      default: undefined
    },
    slideNextClass: {
      type: String,
      default: undefined
    },
    slideDuplicateNextClass: {
      type: String,
      default: undefined
    },
    slidePrevClass: {
      type: String,
      default: undefined
    },
    slideDuplicatePrevClass: {
      type: String,
      default: undefined
    },
    wrapperClass: {
      type: String,
      default: undefined
    },
    runCallbacksOnInit: {
      type: Boolean,
      default: undefined
    },
    observer: {
      type: Boolean,
      default: undefined
    },
    observeParents: {
      type: Boolean,
      default: undefined
    },
    observeSlideChildren: {
      type: Boolean,
      default: undefined
    },
    a11y: {
      type: [Boolean, Object],
      default: undefined
    },
    autoplay: {
      type: [Boolean, Object],
      default: undefined
    },
    controller: {
      type: Object,
      default: undefined
    },
    coverflowEffect: {
      type: Object,
      default: undefined
    },
    cubeEffect: {
      type: Object,
      default: undefined
    },
    fadeEffect: {
      type: Object,
      default: undefined
    },
    flipEffect: {
      type: Object,
      default: undefined
    },
    creativeEffect: {
      type: Object,
      default: undefined
    },
    cardsEffect: {
      type: Object,
      default: undefined
    },
    hashNavigation: {
      type: [Boolean, Object],
      default: undefined
    },
    history: {
      type: [Boolean, Object],
      default: undefined
    },
    keyboard: {
      type: [Boolean, Object],
      default: undefined
    },
    lazy: {
      type: [Boolean, Object],
      default: undefined
    },
    mousewheel: {
      type: [Boolean, Object],
      default: undefined
    },
    navigation: {
      type: [Boolean, Object],
      default: undefined
    },
    pagination: {
      type: [Boolean, Object],
      default: undefined
    },
    parallax: {
      type: [Boolean, Object],
      default: undefined
    },
    scrollbar: {
      type: [Boolean, Object],
      default: undefined
    },
    thumbs: {
      type: Object,
      default: undefined
    },
    virtual: {
      type: [Boolean, Object],
      default: undefined
    },
    zoom: {
      type: [Boolean, Object],
      default: undefined
    },
    grid: {
      type: [Object],
      default: undefined
    },
    freeMode: {
      type: [Boolean, Object],
      default: undefined
    },
    enabled: {
      type: Boolean,
      default: undefined
    }
  },
  emits: ['_beforeBreakpoint', '_containerClasses', '_slideClass', '_slideClasses', '_swiper', '_freeModeNoMomentumRelease', 'activeIndexChange', 'afterInit', 'autoplay', 'autoplayStart', 'autoplayStop', 'autoplayPause', 'autoplayResume', 'beforeDestroy', 'beforeInit', 'beforeLoopFix', 'beforeResize', 'beforeSlideChangeStart', 'beforeTransitionStart', 'breakpoint', 'changeDirection', 'click', 'disable', 'doubleTap', 'doubleClick', 'destroy', 'enable', 'fromEdge', 'hashChange', 'hashSet', 'imagesReady', 'init', 'keyPress', 'lazyImageLoad', 'lazyImageReady', 'lock', 'loopFix', 'momentumBounce', 'navigationHide', 'navigationShow', 'navigationPrev', 'navigationNext', 'observerUpdate', 'orientationchange', 'paginationHide', 'paginationRender', 'paginationShow', 'paginationUpdate', 'progress', 'reachBeginning', 'reachEnd', 'realIndexChange', 'resize', 'scroll', 'scrollbarDragEnd', 'scrollbarDragMove', 'scrollbarDragStart', 'setTransition', 'setTranslate', 'slideChange', 'slideChangeTransitionEnd', 'slideChangeTransitionStart', 'slideNextTransitionEnd', 'slideNextTransitionStart', 'slidePrevTransitionEnd', 'slidePrevTransitionStart', 'slideResetTransitionStart', 'slideResetTransitionEnd', 'sliderMove', 'sliderFirstMove', 'slidesLengthChange', 'slidesGridLengthChange', 'snapGridLengthChange', 'snapIndexChange', 'swiper', 'tap', 'toEdge', 'touchEnd', 'touchMove', 'touchMoveOpposite', 'touchStart', 'transitionEnd', 'transitionStart', 'unlock', 'update', 'virtualUpdate', 'zoomChange'],

  setup(props, _ref) {
    let {
      slots: originalSlots,
      emit
    } = _ref;
    const {
      tag: Tag,
      wrapperTag: WrapperTag
    } = props;
    const containerClasses = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)('swiper');
    const virtualData = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(null);
    const breakpointChanged = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(false);
    const initializedRef = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(false);
    const swiperElRef = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(null);
    const swiperRef = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(null);
    const oldPassedParamsRef = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(null);
    const slidesRef = {
      value: []
    };
    const oldSlidesRef = {
      value: []
    };
    const nextElRef = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(null);
    const prevElRef = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(null);
    const paginationElRef = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(null);
    const scrollbarElRef = (0,vue__WEBPACK_IMPORTED_MODULE_10__.ref)(null);
    const {
      params: swiperParams,
      passedParams
    } = (0,_components_shared_get_params_js__WEBPACK_IMPORTED_MODULE_1__.getParams)(props, false);
    (0,_get_children_js__WEBPACK_IMPORTED_MODULE_6__.getChildren)(originalSlots, slidesRef, oldSlidesRef);
    oldPassedParamsRef.value = passedParams;
    oldSlidesRef.value = slidesRef.value;

    const onBeforeBreakpoint = () => {
      (0,_get_children_js__WEBPACK_IMPORTED_MODULE_6__.getChildren)(originalSlots, slidesRef, oldSlidesRef);
      breakpointChanged.value = true;
    };

    swiperParams.onAny = function (event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      emit(event, ...args);
    };

    Object.assign(swiperParams.on, {
      _beforeBreakpoint: onBeforeBreakpoint,

      _containerClasses(swiper, classes) {
        containerClasses.value = classes;
      }

    }); // init Swiper

    swiperRef.value = new swiper__WEBPACK_IMPORTED_MODULE_0__["default"](swiperParams);

    swiperRef.value.loopCreate = () => {};

    swiperRef.value.loopDestroy = () => {};

    if (swiperParams.loop) {
      swiperRef.value.loopedSlides = (0,_loop_js__WEBPACK_IMPORTED_MODULE_4__.calcLoopedSlides)(slidesRef.value, swiperParams);
    }

    if (swiperRef.value.virtual && swiperRef.value.params.virtual.enabled) {
      swiperRef.value.virtual.slides = slidesRef.value;
      const extendWith = {
        cache: false,
        slides: slidesRef.value,
        renderExternal: data => {
          virtualData.value = data;
        },
        renderExternalUpdate: false
      };
      (0,_components_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(swiperRef.value.params.virtual, extendWith);
      (0,_components_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.extend)(swiperRef.value.originalParams.virtual, extendWith);
    }

    (0,vue__WEBPACK_IMPORTED_MODULE_10__.onUpdated)(() => {
      // set initialized flag
      if (!initializedRef.value && swiperRef.value) {
        swiperRef.value.emitSlidesClasses();
        initializedRef.value = true;
      } // watch for params change


      const {
        passedParams: newPassedParams
      } = (0,_components_shared_get_params_js__WEBPACK_IMPORTED_MODULE_1__.getParams)(props, false);
      const changedParams = (0,_components_shared_get_changed_params_js__WEBPACK_IMPORTED_MODULE_5__.getChangedParams)(newPassedParams, oldPassedParamsRef.value, slidesRef.value, oldSlidesRef.value, c => c.props && c.props.key);
      oldPassedParamsRef.value = newPassedParams;

      if ((changedParams.length || breakpointChanged.value) && swiperRef.value && !swiperRef.value.destroyed) {
        (0,_components_shared_update_swiper_js__WEBPACK_IMPORTED_MODULE_7__.updateSwiper)({
          swiper: swiperRef.value,
          slides: slidesRef.value,
          passedParams: newPassedParams,
          changedParams,
          nextEl: nextElRef.value,
          prevEl: prevElRef.value,
          scrollbarEl: scrollbarElRef.value,
          paginationEl: paginationElRef.value
        });
      }

      breakpointChanged.value = false;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_10__.provide)('swiper', swiperRef); // update on virtual update

    (0,vue__WEBPACK_IMPORTED_MODULE_10__.watch)(virtualData, () => {
      (0,vue__WEBPACK_IMPORTED_MODULE_10__.nextTick)(() => {
        (0,_components_shared_update_on_virtual_data_js__WEBPACK_IMPORTED_MODULE_9__.updateOnVirtualData)(swiperRef.value);
      });
    }); // mount swiper

    (0,vue__WEBPACK_IMPORTED_MODULE_10__.onMounted)(() => {
      if (!swiperElRef.value) return;
      (0,_components_shared_mount_swiper_js__WEBPACK_IMPORTED_MODULE_2__.mountSwiper)({
        el: swiperElRef.value,
        nextEl: nextElRef.value,
        prevEl: prevElRef.value,
        paginationEl: paginationElRef.value,
        scrollbarEl: scrollbarElRef.value,
        swiper: swiperRef.value
      }, swiperParams);
      emit('swiper', swiperRef.value);
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_10__.onBeforeUnmount)(() => {
      if (swiperRef.value && !swiperRef.value.destroyed) {
        swiperRef.value.destroy(true, false);
      }
    }); // bypass swiper instance to slides

    function renderSlides(slides) {
      if (swiperParams.virtual) {
        return (0,_virtual_js__WEBPACK_IMPORTED_MODULE_8__.renderVirtual)(swiperRef, slides, virtualData.value);
      }

      if (!swiperParams.loop || swiperRef.value && swiperRef.value.destroyed) {
        slides.forEach(slide => {
          if (!slide.props) slide.props = {};
          slide.props.swiperRef = swiperRef;
        });
        return slides;
      }

      return (0,_loop_js__WEBPACK_IMPORTED_MODULE_4__.renderLoop)(swiperRef, slides, swiperParams);
    }

    return () => {
      const {
        slides,
        slots
      } = (0,_get_children_js__WEBPACK_IMPORTED_MODULE_6__.getChildren)(originalSlots, slidesRef, oldSlidesRef);
      return (0,vue__WEBPACK_IMPORTED_MODULE_10__.h)(Tag, {
        ref: swiperElRef,
        class: (0,_components_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.uniqueClasses)(containerClasses.value)
      }, [slots['container-start'], (0,vue__WEBPACK_IMPORTED_MODULE_10__.h)(WrapperTag, {
        class: 'swiper-wrapper'
      }, [slots['wrapper-start'], renderSlides(slides), slots['wrapper-end']]), (0,_components_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.needsNavigation)(props) && [(0,vue__WEBPACK_IMPORTED_MODULE_10__.h)('div', {
        ref: prevElRef,
        class: 'swiper-button-prev'
      }), (0,vue__WEBPACK_IMPORTED_MODULE_10__.h)('div', {
        ref: nextElRef,
        class: 'swiper-button-next'
      })], (0,_components_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.needsScrollbar)(props) && (0,vue__WEBPACK_IMPORTED_MODULE_10__.h)('div', {
        ref: scrollbarElRef,
        class: 'swiper-scrollbar'
      }), (0,_components_shared_utils_js__WEBPACK_IMPORTED_MODULE_3__.needsPagination)(props) && (0,vue__WEBPACK_IMPORTED_MODULE_10__.h)('div', {
        ref: paginationElRef,
        class: 'swiper-pagination'
      }), slots['container-end']]);
    };
  }

};


/***/ }),

/***/ "./node_modules/swiper/vue/virtual.js":
/*!********************************************!*\
  !*** ./node_modules/swiper/vue/virtual.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "renderVirtual": () => (/* binding */ renderVirtual)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");


function renderVirtual(swiperRef, slides, virtualData) {
  if (!virtualData) return null;
  const style = swiperRef.value.isHorizontal() ? {
    [swiperRef.value.rtlTranslate ? 'right' : 'left']: `${virtualData.offset}px`
  } : {
    top: `${virtualData.offset}px`
  };
  return slides.filter((slide, index) => index >= virtualData.from && index <= virtualData.to).map(slide => {
    if (!slide.props) slide.props = {};
    if (!slide.props.style) slide.props.style = {};
    slide.props.swiperRef = swiperRef;
    slide.props.style = style;
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(slide.type, { ...slide.props
    }, slide.children);
  });
}



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;